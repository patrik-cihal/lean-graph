[{"references":
  ["NontriviallyNormedField",
   "NontriviallyNormedField.mk",
   "DenselyNormedField",
   "DenselyNormedField.toNormedField",
   "DenselyNormedField.toNontriviallyNormedField.proof_1"],
  "name": "DenselyNormedField.toNontriviallyNormedField",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : DenselyNormedField Œ±] ‚Üí NontriviallyNormedField Œ±",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Ord.compare",
   "Ordering",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LinearOrderedRing.decidableEq",
   "compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "Eq"],
  "name": "LinearOrderedRing.compare_eq_compareOfLessAndEq",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a b : Œ±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{Œ± : Type u_9} ‚Üí [self : CompleteLattice Œ±] ‚Üí CompleteSemilatticeInf Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1375",
   "SubNegMonoid.toSub",
   "MetricSpace",
   "Norm",
   "PseudoMetricSpace.toDist",
   "AddGroup",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedAddGroup",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "Dist.dist",
   "Eq"],
  "name": "NormedAddGroup.mk",
  "constType":
  "{E : Type u_9} ‚Üí\n  [toNorm : Norm E] ‚Üí\n    [toAddGroup : AddGroup E] ‚Üí\n      [toMetricSpace : MetricSpace E] ‚Üí autoParam (‚àÄ (x y : E), dist x y = ‚Äñx - y‚Äñ) _auto‚úù ‚Üí NormedAddGroup E",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Set",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_4",
  "constType": "‚àÄ {Œ± : Type u_1} (a : Set Œ±), ‚ä• ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "Nontrivial"],
  "name": "StrictOrderedSemiring.toNontrivial",
  "constType": "‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±], Nontrivial Œ±",
  "constCategory": "Definition"},
 {"references": ["Norm", "NonUnitalNormedRing"],
  "name": "NonUnitalNormedRing.toNorm",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NonUnitalNormedRing Œ±] ‚Üí Norm Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "‚àÄ {p : Prop}, ¬¨p ‚Üí p = False",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Int"],
  "name": "Ring.zsmul",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí ‚Ñ§ ‚Üí R ‚Üí R",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Real.instLinearOrderedFieldReal",
   "Real.instLinearOrderedRingReal",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "CauSeq.IsComplete.mk",
   "Real",
   "CauSeq.IsComplete",
   "Real.instSupReal",
   "Real.instRingReal",
   "Abs.abs",
   "Real.cauSeq_converges",
   "Real.instNegReal"],
  "name":
  "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
  "constType": "CauSeq.IsComplete ‚Ñù abs",
  "constCategory": "Definition"},
 {"references":
  ["SecondCountableTopologyEither",
   "SecondCountableTopology",
   "Or",
   "TopologicalSpace"],
  "name": "SecondCountableTopologyEither.mk",
  "constType":
  "‚àÄ {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤],\n  SecondCountableTopology Œ± ‚à® SecondCountableTopology Œ≤ ‚Üí SecondCountableTopologyEither Œ± Œ≤",
  "constCategory": "Other"},
 {"references":
  ["MeasurableSpace.instLEMeasurableSpace",
   "OpensMeasurableSpace",
   "borel",
   "TopologicalSpace",
   "LE.le",
   "MeasurableSpace"],
  "name": "OpensMeasurableSpace.mk",
  "constType":
  "‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [h : MeasurableSpace Œ±], borel Œ± ‚â§ h ‚Üí OpensMeasurableSpace Œ±",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LinearOrderedRing.toMin",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.min_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a b : Œ±), min a b = if a ‚â§ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "Set.univ",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_univ",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤}, f '' Set.univ = Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Submodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "AddCommMonoid.toAddMonoid",
   "Lattice.mk",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Inf.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "Set.inter_subset_right",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "Semiring",
   "Submodule.instInfSetSubmodule.proof_2",
   "SemilatticeSup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "Set.subset_inter",
   "Set.iInter",
   "And.intro",
   "Set.inter_subset_left",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice.proof_8",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)), 0 ‚àà ‚ãÇ i ‚àà fun x_1 => ‚àÄ b ‚àà x, b ‚â§ x_1, ‚Üëi",
  "constCategory": "Theorem"},
 {"references":
  ["DistribMulActionHom",
   "AddCommSemigroup.toAddCommMagma",
   "Module.toDistribMulAction",
   "Semiring",
   "AddHom.mk",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.mk",
   "LinearMap.id.proof_2",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "DistribMulActionHom.id",
   "RingHom.id",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "MulActionHom.toFun",
   "LinearMap.id.proof_1",
   "DistribSMul.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "Module",
   "LinearMap",
   "DistribMulActionHom.toMulActionHom",
   "AddCommMonoid.toAddCommSemigroup",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid"],
  "name": "LinearMap.id",
  "constType":
  "{R : Type u_1} ‚Üí {M : Type u_9} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí M ‚Üí‚Çó[R] M",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHomClass.toNonUnitalRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "algebraMap",
   "CommSemiring",
   "Algebra",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul"],
  "name": "Algebra.cast",
  "constType":
  "{R : Type u_1} ‚Üí {A : Type u_2} ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : Semiring A] ‚Üí [inst : Algebra R A] ‚Üí R ‚Üí A",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "HMul.hMul",
   "HasDistribNeg",
   "Neg.neg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : Mul Œ±] ‚Üí\n    [toInvolutiveNeg : InvolutiveNeg Œ±] ‚Üí\n      (‚àÄ (x y : Œ±), -x * y = -(x * y)) ‚Üí (‚àÄ (x y : Œ±), x * -y = -(x * y)) ‚Üí HasDistribNeg Œ±",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT", "LT.lt", "le_of_lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LT.lt.le",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Continuous.tendsto.match_1",
   "Exists",
   "Filter.HasBasis.tendsto_iff",
   "Set.preimage",
   "nhds",
   "Set",
   "Exists.intro",
   "Set.Subset.rfl",
   "Iff.mpr",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "And",
   "Continuous",
   "TopologicalSpace",
   "Filter.Tendsto",
   "And.intro",
   "IsOpen.preimage",
   "IsOpen"],
  "name": "Continuous.tendsto",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí ‚àÄ (x : Œ±), Filter.Tendsto f (nhds x) (nhds (f x))",
  "constCategory": "Theorem"},
 {"references":
  ["MulAction.one_smul",
   "DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "inferInstance",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "Module",
   "MulAction",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero.proof_1",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (b : M), 1 ‚Ä¢ b = b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u ‚Üí Type v ‚Üí outParam (Type w) ‚Üí Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.inv_zero",
  "constType": "‚àÄ {K : Type u} [self : DivisionRing K], 0‚Åª¬π = 0",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} ‚Üí [self : AddRightCancelMonoid M] ‚Üí AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup",
   "OfNat.ofNat",
   "NontriviallyNormedField.toNormedField",
   "Real.instLEReal",
   "Real.instMulReal",
   "AddCommGroup.toAddCommMonoid",
   "Asymptotics.IsLittleO",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "tendsto_const_nhds",
   "Iff.mp",
   "HasFDerivAtFilter",
   "HasFDerivAt",
   "NormedAddCommGroup.toNorm",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "Filter.Tendsto.prod_mk_nhds",
   "instHSub",
   "setOf",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "PseudoMetricSpace.toUniformSpace",
   "Filter.Eventually",
   "Prod.fst",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "HasStrictFDerivAt",
   "instHMul",
   "ContinuousLinearMap",
   "propext",
   "LT.lt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Norm.norm",
   "NormedSpace.toModule",
   "Asymptotics.isLittleO_iff",
   "NormedAddCommGroup.toAddCommGroup",
   "Filter.tendsto_id",
   "Real",
   "Eq.refl",
   "NormedSpace",
   "RingHom.id",
   "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAtFilter._eq_1",
   "NormedField.toField",
   "Zero.toOfNat0",
   "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAt._eq_1",
   "NormedAddGroup.toAddGroup",
   "UniformSpace.toTopologicalSpace",
   "id",
   "NontriviallyNormedField",
   "Real.instLTReal",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HSub.hSub",
   "Field.toSemifield",
   "FunLike.coe",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Prod.mk",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NormedAddCommGroup.toNormedAddGroup",
   "Prod",
   "ContinuousMapClass.toFunLike"],
  "name": "HasStrictFDerivAt.hasFDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  {f' : E ‚ÜíL[ùïú] F} {x : E}, HasStrictFDerivAt f f' x ‚Üí HasFDerivAt f f' x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass",
   "Neg",
   "Eq"],
  "name": "NegZeroClass.mk",
  "constType":
  "{G : Type u_2} ‚Üí [toZero : Zero G] ‚Üí [toNeg : Neg G] ‚Üí -0 = 0 ‚Üí NegZeroClass G",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.npow",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "Nat",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.npow_succ",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (n : ‚Ñï) (x : Œ±),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = x * CanonicallyOrderedCommSemiring.npow n x",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Exists",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "Exists.intro",
   "UniformSpace.toTopologicalSpace",
   "Exists.casesOn",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace.match_1",
  "constType":
  "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (motive : (‚àÉ m, UniformSpace.toTopologicalSpace = inst) ‚Üí Prop)\n  (x : ‚àÉ m, UniformSpace.toTopologicalSpace = inst),\n  (‚àÄ (m : MetricSpace X) (hm : UniformSpace.toTopologicalSpace = inst),\n      motive (_ : ‚àÉ m, UniformSpace.toTopologicalSpace = inst)) ‚Üí\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toCompleteLattice : CompleteLattice Œ±] ‚Üí\n    (‚àÄ {Œπ : Type u} {Œ∫ : Œπ ‚Üí Type u} (f : (a : Œπ) ‚Üí Œ∫ a ‚Üí Œ±), ‚®Ö a, ‚®Ü b, f a b = ‚®Ü g, ‚®Ö a, f a (g a)) ‚Üí\n      CompletelyDistribLattice Œ±",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} ‚Üí (‚Ñï ‚Üí R) ‚Üí NatCast R",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Neg.toHasAbs",
   "SemilatticeSup.toSup",
   "LinearOrder",
   "instDistribLattice",
   "LinearOrder.toMax",
   "Max.max",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "rfl",
   "Abs.abs",
   "Neg",
   "Eq"],
  "name": "abs_eq_max_neg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Neg Œ±] [inst_1 : LinearOrder Œ±] {a : Œ±}, |a| = max a (-a)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "OrderClosedTopology",
  "constType":
  "(Œ± : Type u_1) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : Preorder Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "‚àÄ {p : Prop} [inst : Decidable p], decide p = true ‚Üí p",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocRing Œ±] ‚Üí NonUnitalNonAssocSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a = b ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Ring"],
  "name": "DivisionRing.toRing",
  "constType": "{K : Type u} ‚Üí [self : DivisionRing K] ‚Üí Ring K",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Module",
   "Set.inter_subset_right",
   "Submodule.setLike",
   "Set.instInterSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_5",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), ‚Üëx ‚à© ‚Üëx_1 ‚äÜ ‚Üëx_1",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1571"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
  "constType": "‚Ñù ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommGroup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribMulAction.toMulAction",
   "MulOneClass.toMul",
   "Module.toDistribMulAction",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "MulAction.mul_smul",
   "Monoid.toMulOneClass",
   "Eq",
   "inferInstance",
   "instHMul",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "Module",
   "MulAction",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero.proof_2",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x y : R) (b : M),\n  (x * y) ‚Ä¢ b = x ‚Ä¢ y ‚Ä¢ b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "setOf",
   "Preorder.toLT",
   "Set",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Set.Ioc",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Semiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mk",
  "constType":
  "{Œ± : Type u_4} ‚Üí\n  [toSemiring : Semiring Œ±] ‚Üí\n    [toInv : Inv Œ±] ‚Üí\n      [toDiv : Div Œ±] ‚Üí\n        autoParam (‚àÄ (a b : Œ±), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí Œ± ‚Üí Œ±) ‚Üí\n            autoParam (‚àÄ (a : Œ±), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  [toNontrivial : Nontrivial Œ±] ‚Üí 0‚Åª¬π = 0 ‚Üí (‚àÄ (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí DivisionSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyLinearOrderedSemifield",
   "Real.instLinearOrderedFieldReal",
   "Real",
   "Nonneg.canonicallyLinearOrderedSemifield",
   "NNReal"],
  "name": "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
  "constType": "CanonicallyLinearOrderedSemifield NNReal",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedRing",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±], 0 ‚â§ 1",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Trans.mk", "Eq"],
  "name": "instTransEq_1",
  "constType":
  "{Œ± : Sort u_1} ‚Üí {Œ≤ : Sort u_2} ‚Üí (r : Œ± ‚Üí Œ≤ ‚Üí Sort u) ‚Üí Trans r Eq r",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "AddMonoidHom.id",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_4",
  "constType":
  "‚àÄ (f : ‚Ñù), (AddMonoidHom.id ‚Ñù) ((algebraMap ‚Ñù ‚Ñù) f) = (AddMonoidHom.id ‚Ñù) ((algebraMap ‚Ñù ‚Ñù) f)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí (Œ± ‚Üí Œ≤ ‚Üí Œ≥) ‚Üí HAdd Œ± Œ≤ Œ≥",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrderedAddCommGroup.decidableLE",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.min_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a b : Œ±), min a b = if a ‚â§ b then a else b",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Eq.symm", "Eq"],
  "name": "eq_comm",
  "constType": "‚àÄ {Œ± : Sort u_1} {a b : Œ±}, a = b ‚Üî b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) ‚Üí Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "SemilatticeSup.toSup",
   "sup_eq_maxDefault",
   "IsTotal",
   "Max.max",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun‚ÇÇ",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_3",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : Lattice Œ±] [inst_1 : DecidableRel fun x x_1 => x ‚â§ x_1]\n  [inst_2 : IsTotal Œ± fun x x_1 => x ‚â§ x_1] (a b : Œ±), max a b = if a ‚â§ b then b else a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "LinearOrderedRing.toStrictOrderedRing",
   "instNatCastInt",
   "LinearOrderedRing",
   "Int.negSucc",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (n : ‚Ñï) (a : Œ±),\n  Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (‚Üë(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionSemiring.toSemiring",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing",
   "Module.Finite",
   "AddCommGroup.toAddCommMonoid",
   "Module",
   "AddCommGroup"],
  "name": "FiniteDimensional",
  "constType":
  "(K : Type u_1) ‚Üí (V : Type u_2) ‚Üí [inst : DivisionRing K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst : Module K V] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLT",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Real.linearOrderedCommRing",
   "Real",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring"],
  "name": "Real.instLinearOrderedSemiringReal",
  "constType": "LinearOrderedSemiring ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["SecondCountableTopologyEither",
   "SecondCountableTopology",
   "Or",
   "TopologicalSpace"],
  "name": "SecondCountableTopologyEither.out",
  "constType":
  "‚àÄ {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [self : SecondCountableTopologyEither Œ± Œ≤], SecondCountableTopology Œ± ‚à® SecondCountableTopology Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "nhds",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAtFilter",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "HasFDerivAt",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup F] ‚Üí [inst_4 : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí (E ‚ÜíL[ùïú] F) ‚Üí E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "Div"],
  "name": "CommGroupWithZero.toDiv",
  "constType": "{G‚ÇÄ : Type u_4} ‚Üí [self : CommGroupWithZero G‚ÇÄ] ‚Üí Div G‚ÇÄ",
  "constCategory": "Definition"},
 {"references": ["Ring", "Neg"],
  "name": "Ring.toNeg",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí Neg R",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "SeminormedCommRing"],
  "name": "SeminormedCommRing.toSeminormedRing",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : SeminormedCommRing Œ±] ‚Üí SeminormedRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHom.id.proof_1",
  "constType":
  "‚àÄ (M : Type u_1) [inst : AddZeroClass M], (fun x => x) 0 = (fun x => x) 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingEquiv.map_add'",
   "RingEquiv.map_mul'",
   "Equiv.toFun",
   "Equiv.invFun",
   "RingEquivClass",
   "RingEquiv.instRingEquivClassRingEquiv.proof_2",
   "RingEquiv",
   "Add",
   "Mul",
   "MulEquivClass.mk",
   "RingEquivClass.mk",
   "RingEquiv.instRingEquivClassRingEquiv.proof_3",
   "RingEquiv.toEquiv",
   "EquivLike.mk",
   "RingEquiv.instRingEquivClassRingEquiv.proof_1"],
  "name": "RingEquiv.instRingEquivClassRingEquiv",
  "constType":
  "{R : Type u_4} ‚Üí\n  {S : Type u_5} ‚Üí\n    [inst : Mul R] ‚Üí [inst_1 : Mul S] ‚Üí [inst_2 : Add R] ‚Üí [inst_3 : Add S] ‚Üí RingEquivClass (R ‚âÉ+* S) R S",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.4539"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.lt",
  "constType": "‚Ñù ‚Üí ‚Ñù ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{Œ± : Type u} ‚Üí [self : Preorder Œ±] ‚Üí LE Œ±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Eq.rec",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "max_comm",
   "LE.le",
   "Preorder.toLE",
   "max_eq_left",
   "Eq"],
  "name": "max_eq_right",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí max a b = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MulZeroOneClass M‚ÇÄ] ‚Üí MulOneClass M‚ÇÄ",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.mk",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí (Œ± ‚Üí Œ≤ ‚Üí Œ≥) ‚Üí HSMul Œ± Œ≤ Œ≥",
  "constCategory": "Other"},
 {"references":
  ["two_ne_zero",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "two_mul",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "Semifield.toCommGroupWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "Eq",
   "Semiring.toNatCast",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "CommGroupWithZero.toDiv",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "mul_div_cancel_left",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "instHDiv",
   "CommGroupWithZero.toGroupWithZero",
   "LinearOrderedSemifield",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "div_add_div_same",
   "NonUnitalNonAssocSemiring.toDistrib",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "ZeroLEOneClass.neZero.two",
   "NonAssocSemiring.toNatCast",
   "instNatAtLeastTwo",
   "HMul.hMul",
   "Semifield.toDivisionSemiring"],
  "name": "add_halves",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] (a : Œ±), a / 2 + a / 2 = a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "Subtype.val",
   "MeasureTheory.StronglyMeasurable.isSeparable_range",
   "Set",
   "BorelSpace.opensMeasurable",
   "Set.range",
   "Iff",
   "MeasureTheory.StronglyMeasurable",
   "Set.Elem",
   "TopologicalSpace.PseudoMetrizableSpace.subtype",
   "TopologicalSpace",
   "Measurable",
   "Set.rangeFactorization",
   "TopologicalSpace.PseudoMetrizableSpace",
   "Set.mem_range_self",
   "Subtype",
   "Membership.mem",
   "BorelSpace",
   "continuous_subtype_val",
   "Subtype.instMeasurableSpace",
   "stronglyMeasurable_iff_measurable_separable.match_1",
   "Measurable.stronglyMeasurable",
   "Measurable.subtype_mk",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "TopologicalSpace.IsSeparable.secondCountableTopology",
   "SecondCountableTopology",
   "Subtype.opensMeasurableSpace",
   "instTopologicalSpaceSubtype",
   "And.intro",
   "MeasureTheory.StronglyMeasurable.measurable",
   "MeasurableSpace",
   "Subtype.mk",
   "Continuous.comp_stronglyMeasurable"],
  "name": "stronglyMeasurable_iff_measurable_separable",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {m : MeasurableSpace Œ±} [inst : TopologicalSpace Œ≤]\n  [inst_1 : TopologicalSpace.PseudoMetrizableSpace Œ≤] [inst_2 : MeasurableSpace Œ≤] [inst_3 : BorelSpace Œ≤],\n  MeasureTheory.StronglyMeasurable f ‚Üî Measurable f ‚àß TopologicalSpace.IsSeparable (Set.range f)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalNonAssocSemiring",
   "TopologicalSemiring",
   "TopologicalSpace",
   "ContinuousAdd",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "TopologicalSemiring.toContinuousAdd",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ±] [self : TopologicalSemiring Œ±],\n  ContinuousAdd Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "True",
   "Preorder.toLE",
   "max_def",
   "Eq",
   "ite",
   "if_pos",
   "Eq.mpr",
   "of_eq_true",
   "Max.max",
   "LinearOrder.toMax",
   "Decidable",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_max_left",
  "constType": "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a b : Œ±), a ‚â§ max a b",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.MetrizableSpace.exists_metric",
   "MetricSpace",
   "Exists",
   "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace.match_1",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "Exists.intro",
   "TopologicalSpace.PseudoMetrizableSpace.mk",
   "TopologicalSpace.PseudoMetrizableSpace",
   "TopologicalSpace.MetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace",
  "constType":
  "‚àÄ {X : Type u_2} [inst : TopologicalSpace X] [h : TopologicalSpace.MetrizableSpace X],\n  TopologicalSpace.PseudoMetrizableSpace X",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Set", "MeasurableSet", "LE", "MeasurableSpace"],
  "name": "MeasurableSpace.instLEMeasurableSpace",
  "constType": "{Œ± : Type u_1} ‚Üí LE (MeasurableSpace Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Filter.mem_iInf_of_mem",
   "HAdd.hAdd",
   "Set",
   "Filter.mem_of_superset",
   "compRel",
   "AddCommMonoid.toAddMonoid",
   "Filter.mem_lift'",
   "Iff.mpr",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Filter",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Filter.mem_principal_self",
   "setOf",
   "Prod.snd",
   "instHAdd",
   "Prod.fst",
   "AddCommMagma.toAdd",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le.trans_lt",
   "UniformSpace.ofFun.match_2",
   "Set.instMembershipSet",
   "GT.gt",
   "le_iInf‚ÇÇ",
   "And",
   "Filter.le_principal_iff",
   "iInf",
   "CompleteLattice.toInfSet",
   "Prod.mk",
   "LT.lt",
   "Filter.instPartialOrderFilter",
   "UniformSpace.ofFun.match_1",
   "Filter.lift'",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "UniformSpace.ofFun.match_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofFun.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : OrderedAddCommMonoid Œ≤] (d : Œ± ‚Üí Œ± ‚Üí Œ≤),\n  (‚àÄ (x y z : Œ±), d x z ‚â§ d x y + d y z) ‚Üí\n    (‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x < Œ¥, ‚àÄ y < Œ¥, x + y < Œµ) ‚Üí\n      (Filter.lift' (‚®Ö r, ‚®Ö (_ : r > 0), Filter.principal {x | d x.1 x.2 < r}) fun s => compRel s s) ‚â§\n        ‚®Ö i, ‚®Ö (_ : i > 0), Filter.principal {x | d x.1 x.2 < i}",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Eq.rec",
   "AddMonoidHom.toZeroHom",
   "Eq.symm",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.casesOn",
   "FunLike.coe_injective'"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_1",
  "constType":
  "‚àÄ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f g : M ‚Üí+ N),\n  (fun f => f.toFun) f = (fun f => f.toFun) g ‚Üí f = g",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : ConditionallyCompleteLattice Œ±] ‚Üí InfSet Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "CommRing.toNonUnitalCommRing.proof_7",
  "constType":
  "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a b c : Œ±), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "instNontrivial",
   "Real.instRingReal",
   "Nontrivial"],
  "name": "Real.nontrivial",
  "constType": "Nontrivial ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MonoidWithZero.toZero",
   "MulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.mk",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí\n    [inst : MonoidWithZero R] ‚Üí\n      [inst_1 : Zero M] ‚Üí\n        [toMulAction : MulAction R M] ‚Üí (‚àÄ (r : R), r ‚Ä¢ 0 = 0) ‚Üí (‚àÄ (m : M), 0 ‚Ä¢ m = 0) ‚Üí MulActionWithZero R M",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "PartialOrder.toPreorder",
   "Max.max",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid.toMax",
   "LinearOrderedCancelAddCommMonoid",
   "ite",
   "Eq"],
  "name": "LinearOrderedCancelAddCommMonoid.max_def",
  "constType":
  "‚àÄ {Œ± : Type u_3} [self : LinearOrderedCancelAddCommMonoid Œ±] (a b : Œ±), max a b = if a ‚â§ b then b else a",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "‚àÄ {G : Type u} [inst : Add G], (‚àÄ (a b c : G), a + b = a + c ‚Üí b = c) ‚Üí IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} ‚Üí [self : AddLeftCancelMonoid M] ‚Üí AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.equiv",
   "Setoid.r",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "Real.casesOn",
   "CauSeq.Completion.Cauchy",
   "Quot.induction_on",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ind_mk",
  "constType":
  "‚àÄ {C : ‚Ñù ‚Üí Prop} (x : ‚Ñù), (‚àÄ (y : CauSeq ‚Ñö abs), C (Real.mk y)) ‚Üí C x",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : CanonicallyOrderedAddCommMonoid Œ±] ‚Üí OrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references": ["UniformSpace", "TopologicalSpace"],
  "name": "UniformSpace.toTopologicalSpace",
  "constType": "{Œ± : Type u} ‚Üí [self : UniformSpace Œ±] ‚Üí TopologicalSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "instHAdd",
   "Real",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Set",
   "LE.le",
   "Bornology.ofDist.proof_1",
   "Eq",
   "Set.instMembershipSet",
   "Bornology.ofDist.proof_2",
   "Bornology.ofDist.proof_4",
   "Bornology.ofBounded",
   "Bornology.ofDist.proof_3",
   "Bornology"],
  "name": "Bornology.ofDist",
  "constType":
  "{Œ± : Type u_3} ‚Üí\n  (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) ‚Üí\n    (‚àÄ (x y : Œ±), dist x y = dist y x) ‚Üí (‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) ‚Üí Bornology Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "wrapped._@.Mathlib.MeasureTheory.Measure.Haar.OfBasis._hyg.2506",
   "NormedAddCommGroup",
   "BorelSpace",
   "Basis",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "PseudoMetricSpace.toUniformSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "MeasureTheory.Measure",
   "Fintype",
   "Real.semiring",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "UniformSpace.toTopologicalSpace",
   "NormedSpace.toModule",
   "MeasurableSpace"],
  "name": "Basis.addHaar",
  "constType":
  "{Œπ : Type u_5} ‚Üí\n  {E : Type u_6} ‚Üí\n    [inst : Fintype Œπ] ‚Üí\n      [inst : NormedAddCommGroup E] ‚Üí\n        [inst_1 : NormedSpace ‚Ñù E] ‚Üí\n          [inst_2 : MeasurableSpace E] ‚Üí [inst_3 : BorelSpace E] ‚Üí Basis Œπ ‚Ñù E ‚Üí MeasureTheory.Measure E",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : CompleteLattice Œ±] ‚Üí ConditionallyCompleteLattice Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MetricSpace",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "‚àÄ (p : Prop), (p ‚Üî p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["BorelSpace", "borel", "TopologicalSpace", "MeasurableSpace", "Eq"],
  "name": "BorelSpace.measurable_eq",
  "constType":
  "‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [self : BorelSpace Œ±], inst_1 = borel Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OpensMeasurableSpace",
   "BorelSpace",
   "borel",
   "PartialOrder.toPreorder",
   "TopologicalSpace",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "ge_of_eq",
   "OpensMeasurableSpace.mk",
   "MeasurableSpace",
   "BorelSpace.measurable_eq"],
  "name": "BorelSpace.opensMeasurable",
  "constType":
  "‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±],\n  OpensMeasurableSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderedAddCommGroup.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toAddCommGroup : AddCommGroup Œ±] ‚Üí\n    [toPartialOrder : PartialOrder Œ±] ‚Üí (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b) ‚Üí OrderedAddCommGroup Œ±",
  "constCategory": "Other"},
 {"references":
  ["RingHom.id.proof_1",
   "RingHom",
   "RingHom.id.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "OneHom.mk",
   "MonoidHom.mk",
   "RingHom.id.proof_4",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "RingHom.id.proof_2",
   "NonAssocSemiring",
   "id"],
  "name": "RingHom.id",
  "constType": "(Œ± : Type u_5) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí Œ± ‚Üí+* Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield",
   "Semifield.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mul_inv_cancel",
  "constType":
  "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv",
  "constType": "Type u ‚Üí Type v ‚Üí outParam (Type w) ‚Üí Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "Function.swap",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "add_ne_add_left",
   "IsRightCancelAdd",
   "CovariantClass",
   "Add",
   "CovariantClass.mk"],
  "name": "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
  "constType":
  "‚àÄ (N : Type u_2) [inst : Add N] [inst_1 : IsRightCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{Œ± : Sort u} ‚Üí {p : Œ± ‚Üí Prop} ‚Üí Subtype p ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalSemiring.mul_assoc",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalSemiring Œ±] (a b c : Œ±), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocRing",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Semiring.mk",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.npow",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "zero_le",
   "OrderedAddCommMonoid.toPartialOrder",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedCommSemiring Œ±], 0 ‚â§ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "Field",
   "CommRing.toRing",
   "One.toOfNat1",
   "Field.zpow",
   "Ring.toSemiring",
   "Int",
   "Eq"],
  "name": "Field.zpow_zero'",
  "constType": "‚àÄ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_left",
  "constType": "‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] {a b : Œ±}, a ‚äì b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "Sub",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddGroupWithOne",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Neg",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "AddGroupWithOne.mk",
  "constType":
  "{R : Type u} ‚Üí\n  [toIntCast : IntCast R] ‚Üí\n    [toAddMonoidWithOne : AddMonoidWithOne R] ‚Üí\n      [toNeg : Neg R] ‚Üí\n        [toSub : Sub R] ‚Üí\n          autoParam (‚àÄ (a b : R), a - b = a + -b) _auto‚úù ‚Üí\n            (zsmul : ‚Ñ§ ‚Üí R ‚Üí R) ‚Üí\n              autoParam (‚àÄ (a : R), zsmul 0 a = 0) _auto‚úù¬π ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                  autoParam (‚àÄ (n : ‚Ñï) (a : R), zsmul (Int.negSucc n) a = -zsmul (‚Üë(Nat.succ n)) a) _auto‚úù¬≥ ‚Üí\n                    (‚àÄ (a : R), -a + a = 0) ‚Üí\n                      autoParam (‚àÄ (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën) _auto‚úù‚Å¥ ‚Üí\n                        autoParam (‚àÄ (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)) _auto‚úù‚Åµ ‚Üí AddGroupWithOne R",
  "constCategory": "Other"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{Œ± : Type u} ‚Üí [self : Inv Œ±] ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne.toSub",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "Eq"],
  "name": "AddGroupWithOne.sub_eq_add_neg",
  "constType":
  "‚àÄ {R : Type u} [self : AddGroupWithOne R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace",
   "ContinuousWithinAt",
   "Set.instMembershipSet"],
  "name": "ContinuousOn",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PosMulMono",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toPosMulMono",
  "constType": "‚àÄ {Œ± : Type u} [inst : OrderedSemiring Œ±], PosMulMono Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} ‚Üí [toAddSemigroup : AddSemigroup G] ‚Üí (‚àÄ (a b : G), a + b = b + a) ‚Üí AddCommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "RingHom",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "Semiring",
   "ContinuousLinearMap.mk",
   "Zero.mk",
   "TopologicalSpace",
   "Module",
   "LinearMap",
   "ContinuousLinearMap.zero.proof_1",
   "LinearMap.instZeroLinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.zero",
  "constType":
  "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí Zero (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mul_comm",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedCommRing Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["Field", "Div"],
  "name": "Field.toDiv",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí Div K",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "CommRing.toNonUnitalCommRing",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "hasFDerivAt_iff_hasDerivAt",
   "Iff.mp",
   "HasFDerivAt",
   "NormedField.toNormedSpace",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "One.toOfNat1",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousMapClass.toFunLike"],
  "name": "HasFDerivAt.hasDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {x : ùïú} {f' : ùïú ‚ÜíL[ùïú] F}, HasFDerivAt f f' x ‚Üí HasDerivAt f (f' 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "eq_comm",
   "LE.le.le_iff_eq",
   "le_top",
   "OrderTop",
   "Iff.trans",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "top_le_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, ‚ä§ ‚â§ a ‚Üî a = ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["NormedCommRing.toSeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "NormedAddCommGroup",
   "NontriviallyNormedField",
   "nhds",
   "NontriviallyNormedField.toNormedField",
   "PseudoMetricSpace.toUniformSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "SeminormedRing.toPseudoMetricSpace",
   "HasDerivAtFilter",
   "NormedField.toNormedCommRing",
   "UniformSpace.toTopologicalSpace",
   "NormedSpace"],
  "name": "HasDerivAt",
  "constType":
  "{ùïú : Type u} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {F : Type v} ‚Üí [inst_1 : NormedAddCommGroup F] ‚Üí [inst : NormedSpace ùïú F] ‚Üí (ùïú ‚Üí F) ‚Üí F ‚Üí ùïú ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : LinearOrderedCommSemiring Œ±] ‚Üí StrictOrderedCommSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat"],
  "name": "EuclideanSpace.proof_1",
  "constType": "Nat.AtLeastTwo (0 + 2)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Set",
   "Set.instSupSetSet",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} (s : Set (Set Œ±)) (t : Set Œ±), (‚àÄ b ‚àà s, b ‚â§ t) ‚Üí ‚àÄ a ‚àà sSup s, a ‚àà t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Submodule",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "SetLike.instMembership",
   "SMulZeroClass.toSMul",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "AddMonoid.toZero",
   "Submodule.smul_mem'",
   "HSMul.hSMul",
   "Module",
   "MonoidWithZero.toZero",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Submodule.smul_mem",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : Module R M} (p : Submodule R M)\n  {x : M} (r : R), x ‚àà p ‚Üí r ‚Ä¢ x ‚àà p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.OuterMeasure.coe_fn_injective",
   "MeasureTheory.OuterMeasure.instAdd",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Set",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_4",
   "AddMonoid.toNatSMul",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "Pi.addCommMonoid",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.OuterMeasure.instSMul",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_3",
   "Function.Injective.addCommMonoid",
   "MeasureTheory.OuterMeasure.instZero",
   "Nat",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_1",
   "MeasureTheory.OuterMeasure",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_2",
   "AddCommMonoid"],
  "name": "MeasureTheory.OuterMeasure.addCommMonoid",
  "constType": "{Œ± : Type u_1} ‚Üí AddCommMonoid (MeasureTheory.OuterMeasure Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1771",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Dist.dist",
   "Norm",
   "MetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "AddCommGroup"],
  "name": "NormedAddCommGroup.mk",
  "constType":
  "{E : Type u_9} ‚Üí\n  [toNorm : Norm E] ‚Üí\n    [toAddCommGroup : AddCommGroup E] ‚Üí\n      [toMetricSpace : MetricSpace E] ‚Üí autoParam (‚àÄ (x y : E), dist x y = ‚Äñx - y‚Äñ) _auto‚úù ‚Üí NormedAddCommGroup E",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "Zero.mk",
   "instZeroAddMonoidHom.proof_1",
   "instZeroAddMonoidHom.proof_2",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom"],
  "name": "instZeroAddMonoidHom",
  "constType":
  "{M : Type u_3} ‚Üí {N : Type u_4} ‚Üí [inst : AddZeroClass M] ‚Üí [inst_1 : AddZeroClass N] ‚Üí Zero (M ‚Üí+ N)",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HPow Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HSMul Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "Real.strictOrderedCommSemiring",
   "Real",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring"],
  "name": "Real.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Inter.inter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  (sets : Set (Set Œ±)) ‚Üí\n    Set.univ ‚àà sets ‚Üí\n      (‚àÄ {x y : Set Œ±}, x ‚àà sets ‚Üí x ‚äÜ y ‚Üí y ‚àà sets) ‚Üí (‚àÄ {x y : Set Œ±}, x ‚àà sets ‚Üí y ‚àà sets ‚Üí x ‚à© y ‚àà sets) ‚Üí Filter Œ±",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderHom",
   "Nat",
   "Preorder",
   "Nat.strictOrderedSemiring"],
  "name": "OmegaCompletePartialOrder.Chain",
  "constType": "(Œ± : Type u) ‚Üí [inst : Preorder Œ±] ‚Üí Type u",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} ‚Üí [self : SubNegMonoid G] ‚Üí Sub G",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "LinearOrderedSemiring.toMin",
   "Eq"],
  "name": "LinearOrderedSemiring.min_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a b : Œ±), min a b = if a ‚â§ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "left_distrib",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocRing Œ±] (a b : Œ±), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Real", "Real.toNNReal", "ENNReal.ofNNReal"],
  "name": "ENNReal.ofReal",
  "constType": "‚Ñù ‚Üí ENNReal",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toMin",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid",
   "ite",
   "Eq"],
  "name": "LinearOrderedCancelAddCommMonoid.min_def",
  "constType":
  "‚àÄ {Œ± : Type u_3} [self : LinearOrderedCancelAddCommMonoid Œ±] (a b : Œ±), min a b = if a ‚â§ b then a else b",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.6260", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.sup",
  "constType": "‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Set",
   "Real",
   "Real.measurableSpace",
   "StieltjesFunction.measure",
   "Real.volume_eq_stieltjes_id",
   "MeasureTheory.MeasureSpace.volume",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "Real.measureSpace",
   "StieltjesFunction.id",
   "MeasureTheory.OuterMeasure",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Real.volume_val",
  "constType":
  "‚àÄ (s : Set ‚Ñù), ‚Üë‚ÜëMeasureTheory.volume s = ‚Üë‚Üë(StieltjesFunction.measure StieltjesFunction.id) s",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike", "Function.Injective", "FunLike.coe", "FunLike.coe_injective'"],
  "name": "FunLike.coe_injective",
  "constType":
  "‚àÄ {F : Sort u_1} {Œ± : Sort u_2} {Œ≤ : Œ± ‚Üí Sort u_3} [i : FunLike F Œ± Œ≤], Function.Injective fun f => ‚áëf",
  "constCategory": "Theorem"},
 {"references": ["Field", "Inv"],
  "name": "Field.toInv",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí Inv K",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.add_le_add_left",
  "constType":
  "‚àÄ {Œ± : Type u_3} [self : OrderedAddCommMonoid Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "eq_max",
   "le_refl",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "max_eq_left",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b : Œ±}, b ‚â§ a ‚Üí max a b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{Œ± : Sort u} ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedCommSemiring",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mk",
  "constType":
  "{Œ± : Type u_2} ‚Üí\n  [toLinearOrderedCommSemiring : LinearOrderedCommSemiring Œ±] ‚Üí\n    [toInv : Inv Œ±] ‚Üí\n      [toDiv : Div Œ±] ‚Üí\n        autoParam (‚àÄ (a b : Œ±), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí Œ± ‚Üí Œ±) ‚Üí\n            autoParam (‚àÄ (a : Œ±), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  0‚Åª¬π = 0 ‚Üí (‚àÄ (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí LinearOrderedSemifield Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_11",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a b c : Œ±), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a b : Œ±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "Module",
   "AddCommMonoid"],
  "name": "SemilinearMapClass",
  "constType":
  "Type u_17 ‚Üí\n  {R : outParam (Type u_18)} ‚Üí\n    {S : outParam (Type u_19)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          outParam (R ‚Üí+* S) ‚Üí\n            (M : outParam (Type u_20)) ‚Üí\n              (M‚ÇÇ : outParam (Type u_21)) ‚Üí\n                [inst_2 : AddCommMonoid M] ‚Üí\n                  [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                    [inst : Module R M] ‚Üí [inst : Module S M‚ÇÇ] ‚Üí Type (max (max u_17 u_20) u_21)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "NormedAddCommGroup",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "SeminormedCommRing.toSeminormedRing",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "NormedSpace.boundedSMul",
   "AddMonoid.toZero",
   "NormedField.toNormedSpace",
   "HasFDerivAt",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "MulActionWithZero.toMulAction",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "Module.toMulActionWithZero",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "EuclideanDomain.toCommRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "HasDerivAt",
   "SMulZeroClass.toSMul",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "NormedSpace.toModule",
   "BoundedSMul.continuousSMul",
   "NegZeroClass.toZero",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAt.hasFDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {x : ùïú} {f' : F},\n  HasDerivAt f f' x ‚Üí HasFDerivAt f (ContinuousLinearMap.smulRight 1 f') x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "compl_compl",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Set.compl_univ",
   "BooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Set.compl_inter",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Filter.mk",
   "Filter",
   "Eq.symm",
   "Set.compl_subset_compl",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "setOf",
   "Union.union",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.univ",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Filter.le_cofinite_iff_compl_singleton_mem",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "propext",
   "Filter.cofinite",
   "Filter.instPartialOrderFilter",
   "Eq.mp",
   "Singleton.singleton",
   "congrArg",
   "Set.instUnionSet",
   "congrFun",
   "Set.instInterSet"],
  "name": "Bornology.ofBounded.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} (B : Set (Set Œ±)) (empty_mem : ‚àÖ ‚àà B) (subset_mem : ‚àÄ s‚ÇÅ ‚àà B, ‚àÄ s‚ÇÇ ‚äÜ s‚ÇÅ, s‚ÇÇ ‚àà B)\n  (union_mem : ‚àÄ s‚ÇÅ ‚àà B, ‚àÄ s‚ÇÇ ‚àà B, s‚ÇÅ ‚à™ s‚ÇÇ ‚àà B),\n  (‚àÄ (x : Œ±), {x} ‚àà B) ‚Üí\n    { sets := {s | s·∂ú ‚àà B}, univ_sets := (_ : Set.univ·∂ú ‚àà B),\n        sets_of_superset := (_ : ‚àÄ {x y : Set Œ±}, x ‚àà {s | s·∂ú ‚àà B} ‚Üí x ‚äÜ y ‚Üí y·∂ú ‚àà B),\n        inter_sets := (_ : ‚àÄ {x y : Set Œ±}, x ‚àà {s | s·∂ú ‚àà B} ‚Üí y ‚àà {s | s·∂ú ‚àà B} ‚Üí x ‚à© y ‚àà {s | s·∂ú ‚àà B}) } ‚â§\n      Filter.cofinite",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "AddCancelCommMonoid",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : OrderedCancelAddCommMonoid Œ±] ‚Üí AddCancelCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Exists",
   "Filter.EventuallyEq",
   "MeasureTheory.StronglyMeasurable",
   "TopologicalSpace",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace"],
  "name": "MeasureTheory.AEStronglyMeasurable",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí {x : MeasurableSpace Œ±} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí MeasureTheory.Measure Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "MeasureTheory.Integrable",
   "Set",
   "MeasureTheory.Measure.restrict",
   "_auto._@.Mathlib.MeasureTheory.Integral.IntegrableOn._hyg.689",
   "autoParam",
   "MeasurableSpace"],
  "name": "MeasureTheory.IntegrableOn",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {E : Type u_3} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí (Œ± ‚Üí E) ‚Üí Set Œ± ‚Üí autoParam (MeasureTheory.Measure Œ±) _auto‚úù ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommGroupWithZero",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Add",
   "AddSubsemigroup",
   "Set.instMembershipSet"],
  "name": "AddSubsemigroup.mk",
  "constType":
  "{M : Type u_4} ‚Üí\n  [inst : Add M] ‚Üí (carrier : Set M) ‚Üí (‚àÄ {a b : M}, a ‚àà carrier ‚Üí b ‚àà carrier ‚Üí a + b ‚àà carrier) ‚Üí AddSubsemigroup M",
  "constCategory": "Other"},
 {"references": ["CanonicallyOrderedCommSemiring", "Mul"],
  "name": "CanonicallyOrderedCommSemiring.toMul",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : CanonicallyOrderedCommSemiring Œ±] ‚Üí Mul Œ±",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.toLinearMap",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {M : Type u_3} ‚Üí\n            [inst_2 : TopologicalSpace M] ‚Üí\n              [inst_3 : AddCommMonoid M] ‚Üí\n                {M‚ÇÇ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R M] ‚Üí [inst_7 : Module S M‚ÇÇ] ‚Üí (M ‚ÜíSL[œÉ] M‚ÇÇ) ‚Üí M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toNormedDivisionRing.proof_7",
   "DivisionRing.mk",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "NormedField.toNormedDivisionRing.proof_5",
   "NormedField.norm_mul'",
   "Field.toInv",
   "Field.zpow",
   "NormedField.toNormedDivisionRing.proof_8",
   "NormedField.toNorm",
   "NormedField.toNormedDivisionRing.proof_2",
   "Field.toRatCast",
   "NormedField.toNormedDivisionRing.proof_9",
   "Field.toCommRing",
   "NormedField.toField",
   "NormedField.toNormedDivisionRing.proof_1",
   "NormedField.toNormedDivisionRing.proof_6",
   "NormedField.toNormedDivisionRing.proof_3",
   "CommRing.toRing",
   "Field.toDiv",
   "NormedDivisionRing",
   "Field.qsmul",
   "NormedField.toNormedDivisionRing.proof_4",
   "NormedDivisionRing.mk"],
  "name": "NormedField.toNormedDivisionRing",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : NormedField Œ±] ‚Üí NormedDivisionRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "CommMonoidWithZero.toZero",
   "instHDiv",
   "OfNat.ofNat",
   "Ne.isUnit",
   "CommGroupWithZero.toGroupWithZero",
   "CommGroupWithZero",
   "IsUnit.mul_div_cancel'",
   "CommGroupWithZero.toCommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "CommGroupWithZero.toDiv",
   "HMul.hMul",
   "HDiv.hDiv",
   "CommGroupWithZero.toDivisionCommMonoid"],
  "name": "mul_div_cancel'",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : CommGroupWithZero G‚ÇÄ] {b : G‚ÇÄ} (a : G‚ÇÄ), b ‚â† 0 ‚Üí b * (a / b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddLeftCancelMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} ‚Üí\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] ‚Üí\n    [toZero : Zero M] ‚Üí\n      (‚àÄ (a : M), 0 + a = a) ‚Üí\n        (‚àÄ (a : M), a + 0 = a) ‚Üí\n          (nsmul : ‚Ñï ‚Üí M ‚Üí M) ‚Üí\n            autoParam (‚àÄ (x : M), nsmul 0 x = 0) _auto‚úù ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto‚úù¬π ‚Üí AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["ENNReal",
   "Semiring",
   "WithLp",
   "AddCommGroup.toAddCommMonoid",
   "WithLp.instAddCommGroup",
   "Module",
   "AddCommGroup"],
  "name": "WithLp.instModule",
  "constType":
  "(p : ENNReal) ‚Üí\n  (K : Type uK) ‚Üí\n    (V : Type uV) ‚Üí [inst : Semiring K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí Module K (WithLp p V)",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "Eq.symm", "rfl", "Eq"],
  "name": "forall_eq",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÄ (a : Œ±), a = a' ‚Üí p a) ‚Üî p a'",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nat.cast_add",
   "instDecidableEqNat",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.symm",
   "instOfNat",
   "Nat.cast_one",
   "id"],
  "name": "one_add_one_eq_two",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{Œ± : Type u_1} ‚Üí Membership Œ± (Set Œ±)",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "CompleteAtomicBooleanAlgebra"],
  "name": "CompleteAtomicBooleanAlgebra.toHasCompl",
  "constType":
  "{Œ± : Type u} ‚Üí [self : CompleteAtomicBooleanAlgebra Œ±] ‚Üí HasCompl Œ±",
  "constCategory": "Definition"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : ‚Ñï) ‚Üí Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "instHSub",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "Ring.toNeg",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a b : Œ±), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Module.add_smul",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "MonoidWithZero.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "add_smul",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (r s : R) (x : M),\n  (r + s) ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x",
  "constCategory": "Theorem"},
 {"references": ["Top", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.mk",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [toTop : Top Œ±] ‚Üí (‚àÄ (a : Œ±), a ‚â§ ‚ä§) ‚Üí OrderTop Œ±",
  "constCategory": "Other"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "Eq.refl",
   "One.toOfNat1",
   "OneHom.mk",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "id"],
  "name": "RingHom.id.proof_2",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : NonAssocSemiring Œ±] (x y : Œ±),\n  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n    OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "instHMul",
   "ContinuousMul",
   "Continuous.mul",
   "Continuous",
   "continuous_const",
   "HMul.hMul",
   "TopologicalSpace",
   "Mul"],
  "name": "continuous_mul_left",
  "constType":
  "‚àÄ {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Mul M] [inst_2 : ContinuousMul M] (a : M),\n  Continuous fun b => a * b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHom.toMonoidHom",
  "constType":
  "{Œ± : Type u_5} ‚Üí {Œ≤ : Type u_6} ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí [inst_1 : NonAssocSemiring Œ≤] ‚Üí (Œ± ‚Üí+* Œ≤) ‚Üí Œ± ‚Üí* Œ≤",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddLeftCancelMonoid.mk",
   "Eq.symm",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_6",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = c + b ‚Üí a = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "RatCast",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "Semiring.npow",
   "Semiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Semiring.npow_zero",
  "constType":
  "‚àÄ {Œ± : Type u} [self : Semiring Œ±] (x : Œ±), Semiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid.proof_1",
   "AddCommMonoid.mk",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid.proof_2",
   "SubNegMonoid.toAddMonoid",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "AddCommGroup.toAddGroup",
   "OrderedAddCommGroup.add_le_add_left",
   "AddGroup.toSubNegMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : OrderedAddCommGroup Œ±] ‚Üí OrderedCancelAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references": ["CommSemiring", "Semifield"],
  "name": "Semifield.toCommSemiring",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Semifield Œ±] ‚Üí CommSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "And",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "DenselyNormedField",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "NormedField",
   "Norm.norm",
   "LE.le",
   "NormedField.toNorm"],
  "name": "DenselyNormedField.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toNormedField : NormedField Œ±] ‚Üí (‚àÄ (x y : ‚Ñù), 0 ‚â§ x ‚Üí x < y ‚Üí ‚àÉ a, x < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < y) ‚Üí DenselyNormedField Œ±",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{Œ± : Type u_2} ‚Üí\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring Œ±] ‚Üí\n    [toMin : Min Œ±] ‚Üí\n      [toMax : Max Œ±] ‚Üí\n        [toOrd : Ord Œ±] ‚Üí\n          (‚àÄ (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a) ‚Üí\n            (decidableLE : DecidableRel fun x x_1 => x ‚â§ x_1) ‚Üí\n              (decidableEq : DecidableEq Œ±) ‚Üí\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) ‚Üí\n                  autoParam (‚àÄ (a b : Œ±), min a b = if a ‚â§ b then a else b) _auto‚úù ‚Üí\n                    autoParam (‚àÄ (a b : Œ±), max a b = if a ‚â§ b then b else a) _auto‚úù¬π ‚Üí\n                      autoParam (‚àÄ (a b : Œ±), compare a b = compareOfLessAndEq a b) _auto‚úù¬≤ ‚Üí\n                        LinearOrderedCommSemiring Œ±",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "PartialOrder"],
  "name": "OrderedAddCommGroup.toPartialOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : OrderedAddCommGroup Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHSMul",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddCommMagma.toAdd",
   "DistribMulAction",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "MonoidWithZero.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "Module.mk",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí\n        [toDistribMulAction : DistribMulAction R M] ‚Üí\n          (‚àÄ (r s : R) (x : M), (r + s) ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) ‚Üí (‚àÄ (x : M), 0 ‚Ä¢ x = 0) ‚Üí Module R M",
  "constCategory": "Other"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{Œ± : Type u_1} ‚Üí Inter (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.toInv",
   "Field.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.div_eq_mul_inv",
  "constType": "‚àÄ {K : Type u} [self : Field K] (a b : K), a / b = a * b‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_zero'",
  "constType":
  "‚àÄ {G : Type u} [self : SubNegMonoid G] (a : G), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "Filter.NeBot",
   "LE.le",
   "ClusterPt",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "IsCompact",
  "constType": "{X : Type u} ‚Üí [inst : TopologicalSpace X] ‚Üí Set X ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{Œ± : Type u} ‚Üí [self : Sup Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing",
   "Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "NormedRing.toRing",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (n : ‚Ñï) (a : Œ±), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (‚Üë(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedRing.toNorm",
   "NormedCommRing.toSeminormedCommRing.proof_2",
   "NormedCommRing",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "NormedRing.toMetricSpace",
   "SeminormedCommRing",
   "NormedCommRing.mul_comm",
   "NormedCommRing.toSeminormedCommRing.proof_1",
   "SeminormedRing.mk",
   "NormedRing.toRing",
   "SeminormedCommRing.mk"],
  "name": "NormedCommRing.toSeminormedCommRing",
  "constType": "{Œ± : Type u_1} ‚Üí [Œ≤ : NormedCommRing Œ±] ‚Üí SeminormedCommRing Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedRing",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.instHasSubsetSet",
   "setOf",
   "Bornology.ofDist.match_1",
   "Real.instLEReal",
   "Set",
   "Real",
   "HasSubset.Subset",
   "Exists.intro",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù),\n  ‚àÄ s ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C},\n    ‚àÄ t ‚äÜ s, t ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C}",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "‚àÄ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} ‚Üí [self : Monoid M] ‚Üí MulOneClass M",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{Œ± : Type u} ‚Üí [self : LE Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "Set.Icc",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup"],
  "name": "Set.uIcc",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Lattice Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{Œ± : Type u} ‚Üí [self : Top Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Real", "LT", "LT.mk", "_private.Mathlib.Data.Real.Basic.0.Real.lt"],
  "name": "Real.instLTReal",
  "constType": "LT ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Real.linearOrderedCommRing",
   "Real"],
  "name": "Real.instLinearOrderedRingReal",
  "constType": "LinearOrderedRing ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure", "TopologicalSpace", "MeasurableSpace"],
  "name": "MeasureTheory.IsLocallyFiniteMeasure",
  "constType":
  "{Œ± : Type u_1} ‚Üí {m0 : MeasurableSpace Œ±} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí MeasureTheory.Measure Œ± ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NormedAddCommGroup",
   "CompleteSpace",
   "OfNat.ofNat",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "Classical.propDecidable",
   "MeasureTheory.Integrable",
   "PseudoMetricSpace.toUniformSpace",
   "dite",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NormedSpace",
   "MeasureTheory.Integrable.toL1",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "MeasureTheory.L1.integral",
   "Not",
   "NegZeroClass.toZero",
   "MeasurableSpace",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name":
  "MeasureTheory.definition._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {G : Type u_5} ‚Üí\n    [inst : NormedAddCommGroup G] ‚Üí\n      [inst : NormedSpace ‚Ñù G] ‚Üí {x : MeasurableSpace Œ±} ‚Üí MeasureTheory.Measure Œ± ‚Üí (Œ± ‚Üí G) ‚Üí G",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{Œ± : Type u} ‚Üí [self : Lattice Œ±] ‚Üí SemilatticeSup Œ±",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "‚àÄ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["wrapped._@.Mathlib.LinearAlgebra.Dimension._hyg.100",
   "Semiring",
   "Cardinal",
   "Module",
   "AddCommMonoid"],
  "name": "Module.rank",
  "constType":
  "(K : Type u_2) ‚Üí\n  (V : Type u_3) ‚Üí [inst : Semiring K] ‚Üí [inst_1 : AddCommMonoid V] ‚Üí [inst : Module K V] ‚Üí Cardinal.{u_3}",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "TopologicalSpace.PseudoMetrizableSpace",
  "constType": "(X : Type u_5) ‚Üí [t : TopologicalSpace X] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "Continuous.add",
   "instHAdd",
   "HAdd.hAdd",
   "Continuous",
   "continuous_const",
   "TopologicalSpace",
   "ContinuousAdd",
   "Add",
   "id"],
  "name": "continuous_add_right",
  "constType":
  "‚àÄ {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Add M] [inst_2 : ContinuousAdd M] (a : M),\n  Continuous fun b => b + a",
  "constCategory": "Theorem"},
 {"references":
  ["CauchySeq",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "Real",
   "GE.ge",
   "PseudoMetricSpace.toUniformSpace",
   "Prod.fst",
   "Preorder.toLE",
   "Nonempty",
   "Filter.HasBasis.cauchySeq_iff'",
   "GT.gt",
   "Dist.dist",
   "SemilatticeSup",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "PseudoMetricSpace.toDist",
   "Iff",
   "LT.lt",
   "Prod",
   "Metric.uniformity_basis_dist",
   "SemilatticeSup.toPartialOrder",
   "PseudoMetricSpace"],
  "name": "Metric.cauchySeq_iff'",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±},\n  CauchySeq u ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, dist (u n) (u N) < Œµ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí OrderedCancelAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "Function.leftLim",
   "StieltjesFunction.measure_Ioo",
   "Set.Ioo",
   "Real.measurableSpace",
   "Real",
   "Real.instSubReal",
   "PseudoMetricSpace.toUniformSpace",
   "ENNReal.ofReal",
   "HSub.hSub",
   "StieltjesFunction.measure",
   "Real.pseudoMetricSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Real.volume_val",
   "True",
   "Eq",
   "Real.linearOrder",
   "ENNReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "StieltjesFunction.toFun",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "StieltjesFunction.id_leftLim",
   "Real.instPreorderReal",
   "Real.measureSpace",
   "StieltjesFunction.id",
   "UniformSpace.toTopologicalSpace",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Real.volume_Ioo",
  "constType":
  "‚àÄ {a b : ‚Ñù}, ‚Üë‚ÜëMeasureTheory.volume (Set.Ioo a b) = ENNReal.ofReal (b - a)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemifield", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedSemifield.toLinearOrderedCommSemiring",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : LinearOrderedSemifield Œ±] ‚Üí LinearOrderedCommSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "Nontrivial"],
  "name": "StrictOrderedRing.toNontrivial",
  "constType": "‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±], Nontrivial Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.instAdd",
   "MeasureTheory.Measure.toOuterMeasure",
   "instHAdd",
   "HAdd.hAdd",
   "MeasureTheory.Measure.instAdd",
   "MeasureTheory.OuterMeasure",
   "rfl",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.Measure.add_toOuterMeasure",
  "constType":
  "‚àÄ {Œ± : Type u_1} {_m : MeasurableSpace Œ±} (Œº‚ÇÅ Œº‚ÇÇ : MeasureTheory.Measure Œ±), ‚Üë(Œº‚ÇÅ + Œº‚ÇÇ) = ‚ÜëŒº‚ÇÅ + ‚ÜëŒº‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "BorelSpace",
   "Basis",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "PseudoMetricSpace.toUniformSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "Eq",
   "MeasureTheory.Measure",
   "Fintype",
   "Real.semiring",
   "definition._@.Mathlib.MeasureTheory.Measure.Haar.OfBasis._hyg.2506",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "UniformSpace.toTopologicalSpace",
   "NormedSpace.toModule",
   "MeasurableSpace",
   "Subtype"],
  "name": "wrapped._@.Mathlib.MeasureTheory.Measure.Haar.OfBasis._hyg.2506",
  "constType": "Subtype (Eq @definition‚úù)",
  "constCategory": "Other"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} ‚Üí [self : AddMonoid M] ‚Üí ‚Ñï ‚Üí M ‚Üí M",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.Regular",
   "MeasureTheory.Measure",
   "TopologicalSpace",
   "MeasureTheory.IsFiniteMeasureOnCompacts",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.Regular.toIsFiniteMeasureOnCompacts",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] [inst_1 : TopologicalSpace Œ±] {Œº : MeasureTheory.Measure Œ±}\n  [self : MeasureTheory.Measure.Regular Œº], MeasureTheory.IsFiniteMeasureOnCompacts Œº",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, f = g ‚Üí ‚àÄ (a : Œ±), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.univ",
   "Set.instMembershipSet"],
  "name": "Set.subset_univ",
  "constType": "‚àÄ {Œ± : Type u} (s : Set Œ±), s ‚äÜ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MonoidWithZero M‚ÇÄ] ‚Üí Zero M‚ÇÄ",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
  "constCategory": "Other"},
 {"references":
  ["Nat.gcd.proof_1",
   "measure",
   "WellFoundedRelation.rel",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF",
   "Nat",
   "WellFounded.fix",
   "id"],
  "name": "Nat.gcd",
  "constType": "‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["Norm", "Real"],
  "name": "Norm.norm",
  "constType": "{E : Type u_9} ‚Üí [self : Norm E] ‚Üí E ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring.proof_2",
   "StrictOrderedSemiring.toOrderedSemiring.proof_1",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : StrictOrderedSemiring Œ±] ‚Üí OrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["Prod.mk", "Prod.rec", "Prod"],
  "name": "Prod.casesOn",
  "constType":
  "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí {motive : Œ± √ó Œ≤ ‚Üí Sort u_1} ‚Üí (t : Œ± √ó Œ≤) ‚Üí ((fst : Œ±) ‚Üí (snd : Œ≤) ‚Üí motive (fst, snd)) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "ContinuousLinearMap.toLinearMap",
   "AddHom.toFun",
   "Semiring",
   "continuous_const",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "RingHom.id",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "Continuous.smul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Continuous",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "ContinuousSMul",
   "Module",
   "MonoidWithZero.toZero",
   "ContinuousLinearMap.cont",
   "LinearMap.toAddHom",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.smulRight.proof_2",
  "constType":
  "‚àÄ {M‚ÇÅ : Type u_2} [inst : TopologicalSpace M‚ÇÅ] [inst_1 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1}\n  [inst_2 : TopologicalSpace M‚ÇÇ] [inst_3 : AddCommMonoid M‚ÇÇ] {R : Type u_4} {S : Type u_3} [inst_4 : Semiring R]\n  [inst_5 : Semiring S] [inst_6 : Module R M‚ÇÅ] [inst_7 : Module R S] [inst_8 : Module S M‚ÇÇ]\n  [inst_9 : TopologicalSpace S] [inst_10 : ContinuousSMul S M‚ÇÇ] (c : M‚ÇÅ ‚ÜíL[R] S) (f : M‚ÇÇ),\n  Continuous fun x => AddHom.toFun c.toAddHom x ‚Ä¢ f",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_6",
  "constType":
  "‚àÄ {Œ± : Type u_1} (x y z : Set Œ±), (x ‚äî y) ‚äì (x ‚äî z) ‚â§ x ‚äî y ‚äì z",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "Continuous",
   "ContinuousMapClass",
   "TopologicalSpace",
   "FunLike.coe"],
  "name": "ContinuousMapClass.mk",
  "constType":
  "{F : Type u_1} ‚Üí\n  {Œ± : outParam (Type u_2)} ‚Üí\n    {Œ≤ : outParam (Type u_3)} ‚Üí\n      [inst : TopologicalSpace Œ±] ‚Üí\n        [inst_1 : TopologicalSpace Œ≤] ‚Üí\n          [toFunLike : FunLike F Œ± fun x => Œ≤] ‚Üí (‚àÄ (f : F), Continuous ‚áëf) ‚Üí ContinuousMapClass F Œ± Œ≤",
  "constCategory": "Other"},
 {"references": ["nhds", "TopologicalSpace", "Filter.Tendsto"],
  "name": "ContinuousAt",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MulActionWithZero.toMulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.smul_zero",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (r : R),\n  r ‚Ä¢ 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "CommRing",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "Nat.cast",
   "Field",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "CommRing.toRing",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int.natAbs",
   "Inv.inv"],
  "name": "Field.mk",
  "constType":
  "{K : Type u} ‚Üí\n  [toCommRing : CommRing K] ‚Üí\n    [toInv : Inv K] ‚Üí\n      [toDiv : Div K] ‚Üí\n        autoParam (‚àÄ (a b : K), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí K ‚Üí K) ‚Üí\n            autoParam (‚àÄ (a : K), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : K), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : K), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  [toNontrivial : Nontrivial K] ‚Üí\n                    [toRatCast : RatCast K] ‚Üí\n                      (‚àÄ (a : K), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí\n                        0‚Åª¬π = 0 ‚Üí\n                          autoParam\n                              (‚àÄ (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                                ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π)\n                              _auto‚úù‚Å¥ ‚Üí\n                            (qsmul : ‚Ñö ‚Üí K ‚Üí K) ‚Üí autoParam (‚àÄ (a : ‚Ñö) (x : K), qsmul a x = ‚Üëa * x) _auto‚úù‚Åµ ‚Üí Field K",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Inf.inf",
   "Set",
   "Filter.generate",
   "Inter.inter",
   "Preorder.le_trans",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.inter_mem",
   "Preorder.toLT",
   "Eq.rec",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.match_1",
   "Filter.sets",
   "Membership.mem",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "Preorder.le_refl",
   "SemilatticeSup.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "OrderDual.completeLattice",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup.sup_le",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "Filter.giGenerate",
   "Preorder.lt_iff_le_not_le",
   "Set.instInterSet"],
  "name": "Filter.instCompleteLatticeFilter.proof_8",
  "constType":
  "‚àÄ {Œ± : Type u_1} (x x_1 x_2 : Filter Œ±), x ‚â§ x_1 ‚Üí x ‚â§ x_2 ‚Üí ‚àÄ _s ‚àà x_1 ‚äì x_2, _s ‚àà x",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "SubtractionCommMonoid.toAddCommMonoid",
   "SubtractionCommMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "True",
   "Eq",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "NegZeroClass.toNeg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun"],
  "name": "neg_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionCommMonoid Œ±] (a b : Œ±), -(a + b) = -a + -b",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "‚àÄ {M : Type u_1} {N : Type u_2} {Œº : M ‚Üí N ‚Üí N} {r : N ‚Üí N ‚Üí Prop}, Covariant M N Œº r ‚Üí CovariantClass M N Œº r",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "instZeroAddMonoidHom.proof_1",
  "constType":
  "‚àÄ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N], (fun x => 0) 0 = (fun x => 0) 0",
  "constCategory": "Theorem"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["Div"],
  "name": "Div.div",
  "constType": "{Œ± : Type u} ‚Üí [self : Div Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulHomClass",
   "HMul.hMul",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MulHomClass.map_mul",
   "Mul",
   "Eq"],
  "name": "map_mul",
  "constType":
  "‚àÄ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Mul M] [inst_1 : Mul N] [inst_2 : MulHomClass F M N] (f : F)\n  (x y : M), f (x * y) = f x * f y",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "abs_of_nonneg",
   "True",
   "Abs.abs",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Iff",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "LinearOrderedAddCommGroup",
   "Neg.toHasAbs",
   "Or",
   "instDistribLattice",
   "eq_or_eq_neg_of_abs_eq",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Or.casesOn",
   "LE.le",
   "Iff.intro",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "of_eq_true",
   "abs_neg",
   "congrArg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "congrFun",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_eq",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {a b : Œ±}, 0 ‚â§ b ‚Üí (|a| = b ‚Üî a = b ‚à® a = -b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "‚àÄ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.instSupSetSet", "iSup"],
  "name": "Set.iUnion",
  "constType": "{Œ≤ : Type u_2} ‚Üí {Œπ : Sort u_4} ‚Üí (Œπ ‚Üí Set Œ≤) ‚Üí Set Œ≤",
  "constCategory": "Definition"},
 {"references": [],
  "name": "BooleanAlgebra",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Semiring",
   "ContinuousLinearMap.ext_ring_iff",
   "One.toOfNat1",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "RingHom.id",
   "Eq",
   "Semiring.toOne",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "TopologicalSpace",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "Semiring.toModule",
   "AddCommMonoid",
   "ContinuousMapClass.toFunLike",
   "ContinuousSemilinearMapClass.toContinuousMapClass"],
  "name": "Mathlib.Topology.Algebra.Module.Basic._auxLemma.20",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_1} [inst : Semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [inst_1 : TopologicalSpace M‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ]\n  [inst_3 : Module R‚ÇÅ M‚ÇÅ] [inst_4 : TopologicalSpace R‚ÇÅ] {f g : R‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ}, (f = g) = (f 1 = g 1)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Preorder.le_trans",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a b c : MeasurableSpace Œ±), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references": ["Set.range", "SupSet", "SupSet.sSup"],
  "name": "iSup",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : SupSet Œ±] ‚Üí {Œπ : Sort u_9} ‚Üí (Œπ ‚Üí Œ±) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Eq.ge", "GE.ge", "Preorder", "Preorder.toLE", "Eq"],
  "name": "ge_of_eq",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a = b ‚Üí a ‚â• b",
  "constCategory": "Theorem"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.sInf",
  "constType": "{Œ± : Type u_9} ‚Üí [self : InfSet Œ±] ‚Üí Set Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {Œ≥ : Sort u_3} ‚Üí\n      {r : Œ± ‚Üí Œ≤ ‚Üí Sort u} ‚Üí\n        {s : Œ≤ ‚Üí Œ≥ ‚Üí Sort v} ‚Üí\n          {t : outParam (Œ± ‚Üí Œ≥ ‚Üí Sort w)} ‚Üí [self : Trans r s t] ‚Üí {a : Œ±} ‚Üí {b : Œ≤} ‚Üí {c : Œ≥} ‚Üí r a b ‚Üí s b c ‚Üí t a c",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "instTransEq",
   "add_lt_add_left",
   "add_zero",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "lt_add_of_pos_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : Œ±) {b : Œ±}, 0 < b ‚Üí a < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["starMulOfComm",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "starRingOfComm.proof_2",
   "starRingOfComm.proof_1",
   "StarMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "StarRing.mk",
   "StarMul.toInvolutiveStar",
   "StarMul.mk"],
  "name": "starRingOfComm",
  "constType": "{R : Type u_1} ‚Üí [inst : CommSemiring R] ‚Üí StarRing R",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "Neg.neg", "Neg", "Eq"],
  "name": "InvolutiveNeg.mk",
  "constType":
  "{A : Type u_2} ‚Üí [toNeg : Neg A] ‚Üí (‚àÄ (x : A), - -x = x) ‚Üí InvolutiveNeg A",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "zero_add",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "instZeroAddMonoidHom.proof_2",
  "constType":
  "‚àÄ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass N], M ‚Üí M ‚Üí 0 = 0 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "NormedField.toField",
   "SeminormedCommRing.toSeminormedRing",
   "SMulWithZero.toSMulZeroClass",
   "NormedSpace.boundedSMul",
   "AddMonoid.toZero",
   "ContinuousSMul",
   "UniformSpace.toTopologicalSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "Module.toMulActionWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SMulZeroClass.toSMul",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "MulActionWithZero.toSMulWithZero",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "BoundedSMul.continuousSMul"],
  "name": "HasStrictDerivAt.proof_2",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F], ContinuousSMul ùïú F",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "instHMul",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_succ'",
  "constType":
  "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±] (n : ‚Ñï) (a : Œ±),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLE",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí DecidableRel fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references": ["MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.toMeasurableSpace",
  "constType":
  "{Œ± : Type u_6} ‚Üí [self : MeasureTheory.MeasureSpace Œ±] ‚Üí MeasurableSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LinearOrderedCancelAddCommMonoid.decidableEq",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "compareOfLessAndEq",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLT",
   "Eq"],
  "name": "LinearOrderedCancelAddCommMonoid.compare_eq_compareOfLessAndEq",
  "constType":
  "‚àÄ {Œ± : Type u_3} [self : LinearOrderedCancelAddCommMonoid Œ±] (a b : Œ±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Continuous", "ContinuousAt", "TopologicalSpace", "Continuous.tendsto"],
  "name": "Continuous.continuousAt",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±},\n  Continuous f ‚Üí ContinuousAt f x",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "‚àÄ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b ‚Üí a = c",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "AddGroupWithOne.zsmul",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_neg'",
  "constType":
  "‚àÄ {R : Type u} [self : AddGroupWithOne R] (n : ‚Ñï) (a : R),\n  AddGroupWithOne.zsmul (Int.negSucc n) a = -AddGroupWithOne.zsmul (‚Üë(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ConditionallyCompleteLattice",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "Field.toSemifield",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Norm.norm",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule"],
  "name": "NormedSpace.norm_smul_le",
  "constType":
  "‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_6} [inst : NormedField Œ±] [inst_1 : SeminormedAddCommGroup Œ≤] [self : NormedSpace Œ± Œ≤]\n  (a : Œ±) (b : Œ≤), ‚Äña ‚Ä¢ b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HSub Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toMin",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí Min Œ±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.cofinite",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Bornology",
   "Preorder.toLE"],
  "name": "Bornology.mk",
  "constType":
  "{Œ± : Type u_4} ‚Üí (cobounded' : Filter Œ±) ‚Üí cobounded' ‚â§ Filter.cofinite ‚Üí Bornology Œ±",
  "constCategory": "Other"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MulZeroClass M‚ÇÄ] ‚Üí Zero M‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddZeroClass.toZero",
   "of_eq_true",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "congrFun"],
  "name": "Real.isROrC.proof_12",
  "constType": "‚Ñù ‚Üí 0 * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "nhds",
   "TopologicalSpace",
   "Filter.Tendsto",
   "MeasureTheory.SimpleFunc",
   "Nat",
   "Filter.atTop",
   "MeasurableSpace",
   "MeasureTheory.SimpleFunc.toFun",
   "Nat.strictOrderedSemiring"],
  "name": "MeasureTheory.StronglyMeasurable",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí [inst : MeasurableSpace Œ±] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "‚àÄ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{Œ± : Type u} ‚Üí [self : Lattice Œ±] ‚Üí Inf Œ±",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.neg", "Real", "Neg", "Neg.mk"],
  "name": "Real.instNegReal",
  "constType": "Neg ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Classical.choose_spec",
   "Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "Classical.choose",
   "PartialOrder.toPreorder",
   "not_lt",
   "le_iInf",
   "not_le_of_lt",
   "GE.ge",
   "dite",
   "CompleteLinearOrder",
   "iSup",
   "le_iSup",
   "Mathlib.Init.Order.Defs._auxLemma.2",
   "Exists.casesOn",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.5",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Eq.mpr",
   "Iff.mp",
   "forall_congr",
   "Preorder.toLT",
   "lt_irrefl",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.3",
   "le_trans",
   "lt_of_not_le",
   "le_of_lt",
   "iInf_le",
   "And.casesOn",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.2",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "id",
   "lt_iSup_iff",
   "Or",
   "le_of_not_lt",
   "False",
   "CompleteLinearOrder.toLinearOrder",
   "lt_of_lt_of_le",
   "Classical.propDecidable",
   "LE.le",
   "Or.resolve_left",
   "And",
   "iInf",
   "CompleteLinearOrder.toCompletelyDistribLattice.match_1",
   "CompleteLattice.toInfSet",
   "LT.lt",
   "Eq.mp",
   "CompleteLinearOrder.toCompleteLattice",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "le_iInf_iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "le_antisymm"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : CompleteLinearOrder Œ±] {Œ±_1 : Type u_1} {Œ≤ : Œ±_1 ‚Üí Type u_1} (g : (a : Œ±_1) ‚Üí Œ≤ a ‚Üí Œ±),\n  ‚®Ö a, ‚®Ü b, g a b = ‚®Ü g_1, ‚®Ö a, g a (g_1 a)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u} ‚Üí [self : OrderedSemiring Œ±] ‚Üí OrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Abs.abs",
   "neg_le_abs_self",
   "le_total",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "Or.elim",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "le_abs_self",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "LinearOrder.toPartialOrder",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] (a : Œ±), 0 ‚â§ |a|",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "inferInstance",
   "Real",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Real.orderedSemiring"],
  "name": "Real.orderedAddCommMonoid",
  "constType": "OrderedAddCommMonoid ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.mul_one",
  "constType": "‚àÄ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "Eq",
   "Iff.of_eq",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "OrderTopology",
   "Filter",
   "Metric.ball",
   "Eq.trans",
   "PseudoMetricSpace",
   "iInf_congr_Prop",
   "instHSub",
   "setOf",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "DistribLattice.toLattice",
   "orderTopology_of_nhds_abs",
   "of_eq_true",
   "iInf",
   "LT.lt",
   "Real.instAddGroupReal",
   "congrArg",
   "abs_sub_comm",
   "OrderedAddCommGroup.toAddCommGroup",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real",
   "Set",
   "Eq.refl",
   "Filter.HasBasis.eq_biInf",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Metric.nhds_basis_ball",
   "Abs.abs",
   "True",
   "Zero.toOfNat0",
   "Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddCommGroup.toAddGroup",
   "UniformSpace.toTopologicalSpace",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Filter.instCompleteLatticeFilter",
   "Neg.toHasAbs",
   "eq_self",
   "funext",
   "Real.instLTReal",
   "nhds",
   "HSub.hSub",
   "Real.pseudoMetricSpace",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "ConditionallyCompleteLattice.toInfSet",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "CompleteLattice.toInfSet",
   "Real.instPreorderReal",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name":
  "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
  "constType": "OrderTopology ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "‚àÄ {a b : Prop} {motive : a ‚à® b ‚Üí Prop} (t : a ‚à® b),\n  (‚àÄ (h : a), motive (_ : a ‚à® b)) ‚Üí (‚àÄ (h : b), motive (_ : a ‚à® b)) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Real.instLTReal",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "Real.partialOrder.proof_4",
   "Real.partialOrder.proof_2",
   "LT.mk",
   "Real.partialOrder.proof_1",
   "LE.le",
   "PartialOrder",
   "Real.partialOrder.proof_3",
   "Preorder.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Prop) ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["setOf",
   "Set",
   "MeasurableSpace.generateFrom",
   "TopologicalSpace",
   "MeasurableSpace",
   "IsOpen"],
  "name": "borel",
  "constType": "(Œ± : Type u) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí MeasurableSpace Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMagma",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["UniformSpace",
   "UniformSpace.Core.toTopologicalSpace",
   "UniformSpace.ofCore.proof_1",
   "UniformSpace.mk",
   "UniformSpace.Core"],
  "name": "UniformSpace.ofCore",
  "constType": "{Œ± : Type u} ‚Üí UniformSpace.Core Œ± ‚Üí UniformSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "NormedRing",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a : Œ±), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{Œ± Œ≤ : Sort u} ‚Üí Œ± = Œ≤ ‚Üí Œ≤ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HSub.hSub",
   "zero_sub",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "neg_neg",
   "SubtractionMonoid",
   "SubNegMonoid.sub_eq_add_neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegMonoid.zsmul_succ'",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "congr",
   "Eq.symm",
   "congrArg",
   "neg_sub",
   "Eq.trans",
   "SubNegMonoid.zsmul_zero'",
   "id"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : SubtractionMonoid Œ±], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NormedCommRing",
   "NormedCommRing.toNormedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mul_comm",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NormedCommRing Œ±] (x y : Œ±), x * y = y * x",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mul_smul",
  "constType":
  "‚àÄ {Œ± : Type u_10} {Œ≤ : Type u_11} [inst : Monoid Œ±] [self : MulAction Œ± Œ≤] (x y : Œ±) (b : Œ≤), (x * y) ‚Ä¢ b = x ‚Ä¢ y ‚Ä¢ b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_11",
  "constType":
  "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a b c : Œ±), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module",
   "DistribMulAction",
   "AddCommMonoid"],
  "name": "Module.toDistribMulAction",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [self : Module R M] ‚Üí DistribMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "‚àÄ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "inferInstance",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Real",
   "Real.strictOrderedRing"],
  "name": "Real.orderedAddCommGroup",
  "constType": "OrderedAddCommGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["ENNReal", "WithTop.some", "NNReal"],
  "name": "ENNReal.ofNNReal",
  "constType": "NNReal ‚Üí ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.1166",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1166",
  "constType": "Subtype (Eq Real.definition‚úù)",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "PartialOrder.toPreorder",
   "Submodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "HAdd.hAdd",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "AddCommMonoid.toAddMonoid",
   "Lattice.mk",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Preorder.toLE",
   "Inf.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "Set.inter_subset_right",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "instHAdd",
   "Semiring",
   "SemilatticeSup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "Submodule.instInfSetSubmodule.proof_1",
   "And",
   "Set.subset_inter",
   "Set.iInter",
   "And.intro",
   "Set.inter_subset_left",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice.proof_7",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)) (a a_1 : M),\n  a ‚àà ‚ãÇ i ‚àà fun x_1 => ‚àÄ b ‚àà x, b ‚â§ x_1, ‚Üëi ‚Üí\n    a_1 ‚àà ‚ãÇ i ‚àà fun x_1 => ‚àÄ b ‚àà x, b ‚â§ x_1, ‚Üëi ‚Üí a + a_1 ‚àà ‚ãÇ i ‚àà fun x_1 => ‚àÄ b ‚àà x, b ‚â§ x_1, ‚Üëi",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_6",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a : Œ±), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{Œ± : Type u_1} ‚Üí HasSubset (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "TopologicalSpace.generateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Set",
   "Function.comp",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "GaloisCoinsertion.liftCompleteLattice",
   "Equiv.instFunLikeEquiv",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "OrderDual.completeLattice",
   "TopologicalSpace",
   "OrderDual",
   "TopologicalSpace.gciGenerateFrom",
   "IsOpen"],
  "name": "TopologicalSpace.instCompleteLatticeTopologicalSpace",
  "constType": "{Œ± : Type u} ‚Üí CompleteLattice (TopologicalSpace Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring Œ±] ‚Üí\n    [toOne : One Œ±] ‚Üí\n      (‚àÄ (a : Œ±), 1 * a = a) ‚Üí\n        (‚àÄ (a : Œ±), a * 1 = a) ‚Üí\n          [toNatCast : NatCast Œ±] ‚Üí\n            autoParam (NatCast.natCast 0 = 0) _auto‚úù ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto‚úù¬π ‚Üí NonAssocSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Semifield.toInv",
   "Semifield.zpow",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.zpow_neg'",
  "constType":
  "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±] (n : ‚Ñï) (a : Œ±),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) ‚Üí [inst : Add G] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_left",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : Œ±}, b < c ‚Üí ‚àÄ (a : Œ±), a + b < a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PseudoMetricSpace.toUniformSpace",
   "TopologicalSpace",
   "TopologicalSpace.PseudoMetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "Eq"],
  "name": "TopologicalSpace.PseudoMetrizableSpace.mk",
  "constType":
  "‚àÄ {X : Type u_5} [t : TopologicalSpace X],\n  (‚àÉ m, UniformSpace.toTopologicalSpace = t) ‚Üí TopologicalSpace.PseudoMetrizableSpace X",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : One Œ±] ‚Üí OfNat Œ± 1",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Nontrivial"],
  "name": "DivisionRing.toNontrivial",
  "constType": "‚àÄ {K : Type u} [self : DivisionRing K], Nontrivial K",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.zpow_neg'",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "AddHom",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "LinearMap.toAddHom",
  "constType":
  "{R : Type u_17} ‚Üí\n  {S : Type u_18} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {M : Type u_19} ‚Üí\n            {M‚ÇÇ : Type u_20} ‚Üí\n              [inst_2 : AddCommMonoid M] ‚Üí\n                [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                  [inst_4 : Module R M] ‚Üí [inst_5 : Module S M‚ÇÇ] ‚Üí (M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí AddHom M M‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "Monoid",
   "CommMonoid",
   "HMul.hMul",
   "Eq"],
  "name": "CommMonoid.mk",
  "constType":
  "{M : Type u} ‚Üí [toMonoid : Monoid M] ‚Üí (‚àÄ (a b : M), a * b = b * a) ‚Üí CommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "DenselyOrdered", "LT.lt", "LT"],
  "name": "DenselyOrdered.dense",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LT Œ±] [self : DenselyOrdered Œ±] (a‚ÇÅ a‚ÇÇ : Œ±), a‚ÇÅ < a‚ÇÇ ‚Üí ‚àÉ a, a‚ÇÅ < a ‚àß a < a‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) ‚Üí [inst : AddCancelCommMonoid M] ‚Üí AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddGroupWithOne",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Homeomorph.symm",
   "HAdd.hAdd",
   "Set.Nonempty",
   "AddGroup.toSubtractionMonoid",
   "Homeomorph.instEquivLikeHomeomorph",
   "Inter.inter",
   "TopologicalSpace.exists_dense_seq",
   "Exists.casesOn",
   "Iff.mpr",
   "Eq",
   "Set.iUnion",
   "Homeomorph",
   "EquivLike.toEmbeddingLike",
   "Homeomorph.addLeft",
   "Filter",
   "Nat",
   "And.casesOn",
   "TopologicalAddGroup.toContinuousAdd",
   "Dense.inter_nhds_nonempty",
   "Homeomorph.apply_symm_apply",
   "Homeomorph.addRight",
   "Homeomorph.isCompact_preimage",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "And",
   "Classical.indefiniteDescription",
   "DenseRange",
   "Eq.mp",
   "And.intro",
   "TopologicalSpace.denseSeq",
   "AddZeroClass.toAdd",
   "TopologicalSpace.denseRange_denseSeq",
   "Exists",
   "EmbeddingLike.toFunLike",
   "WeaklyLocallyCompactSpace.exists_compact_mem_nhds",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Zero.toOfNat0",
   "Set.range",
   "AddGroup",
   "TopologicalSpace",
   "TopologicalSpace.SeparableSpace",
   "Eq.symm",
   "SigmaCompactSpace.mk",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instMembershipSetFilter",
   "Membership.mem",
   "WeaklyLocallyCompactSpace",
   "Set.preimage",
   "instHAdd",
   "nhds",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.univ",
   "AddGroup.toSubNegMonoid",
   "Continuous.continuousAt",
   "Zero.nonempty",
   "Eq.ndrec",
   "SigmaCompactSpace",
   "Homeomorph.continuous",
   "SubNegMonoid.toAddMonoid",
   "IsCompact",
   "NegZeroClass.toZero",
   "TopologicalAddGroup",
   "Set.instInterSet"],
  "name": "SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace",
  "constType":
  "‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : TopologicalSpace.SeparableSpace G] [inst_4 : WeaklyLocallyCompactSpace G], SigmaCompactSpace G",
  "constCategory": "Definition"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{Œ± : Type u} ‚Üí [self : NonAssocSemiring Œ±] ‚Üí One Œ±",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "Neg"],
  "name": "InvolutiveNeg.toNeg",
  "constType": "{A : Type u_2} ‚Üí [self : InvolutiveNeg A] ‚Üí Neg A",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.FiniteAtFilter",
   "nhds",
   "TopologicalSpace",
   "MeasurableSpace",
   "MeasureTheory.IsLocallyFiniteMeasure"],
  "name": "MeasureTheory.IsLocallyFiniteMeasure.mk",
  "constType":
  "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} [inst : TopologicalSpace Œ±] {Œº : MeasureTheory.Measure Œ±},\n  (‚àÄ (x : Œ±), MeasureTheory.Measure.FiniteAtFilter Œº (nhds x)) ‚Üí MeasureTheory.IsLocallyFiniteMeasure Œº",
  "constCategory": "Other"},
 {"references": ["outParam", "SetLike", "Function.Injective", "Set"],
  "name": "SetLike.mk",
  "constType":
  "{A : Type u_1} ‚Üí {B : outParam (Type u_2)} ‚Üí (coe : A ‚Üí Set B) ‚Üí Function.Injective coe ‚Üí SetLike A B",
  "constCategory": "Other"},
 {"references":
  ["Nonempty.intro",
   "Or",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Classical.em",
   "Classical.propDecidable.match_1",
   "Nonempty"],
  "name": "Classical.propDecidable.proof_1",
  "constType": "‚àÄ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "LinearOrderedCommRing"],
  "name": "LinearOrderedField.toLinearOrderedCommRing",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí LinearOrderedCommRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} ‚Üí {N : Type u_4} ‚Üí [inst : Zero M] ‚Üí [inst_1 : Zero N] ‚Üí ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references":
  ["BorelSpace", "borel", "TopologicalSpace", "MeasurableSpace", "Eq"],
  "name": "BorelSpace.mk",
  "constType":
  "‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±], inst_1 = borel Œ± ‚Üí BorelSpace Œ±",
  "constCategory": "Other"},
 {"references": [],
  "name": "Exists",
  "constType": "{Œ± : Sort u} ‚Üí (Œ± ‚Üí Prop) ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Semifield.toCommSemiring",
   "Real",
   "Real.instLEReal",
   "Field.toSemifield",
   "Ring.toSemiring",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Norm.norm",
   "NormedAlgebra",
   "Algebra.toSMul"],
  "name": "NormedAlgebra.mk",
  "constType":
  "{ùïú : Type u_5} ‚Üí\n  {ùïú' : Type u_6} ‚Üí\n    [inst : NormedField ùïú] ‚Üí\n      [inst_1 : SeminormedRing ùïú'] ‚Üí\n        [toAlgebra : Algebra ùïú ùïú'] ‚Üí (‚àÄ (r : ùïú) (x : ùïú'), ‚Äñr ‚Ä¢ x‚Äñ ‚â§ ‚Äñr‚Äñ * ‚Äñx‚Äñ) ‚Üí NormedAlgebra ùïú ùïú'",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Left.neg_nonpos_iff",
   "LE",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_nonpos",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {a : Œ±}, -a ‚â§ 0 ‚Üî 0 ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["WithTop.instCompleteLinearOrderWithTop.proof_7",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "WithTop.le",
   "Inf.inf",
   "CompleteLattice.mk",
   "CompleteLinearOrder",
   "WithTop.instCompleteLinearOrderWithTop.proof_13",
   "OrderBot",
   "Lattice.mk",
   "Sup.mk",
   "WithTop.instCompleteLinearOrderWithTop.proof_11",
   "Preorder.toLE",
   "WithTop.instCompleteLinearOrderWithTop.proof_2",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "WithTop.orderBot",
   "ConditionallyCompleteLattice.toSupSet",
   "WithTop",
   "instLinearOrder",
   "WithTop.semilatticeSup",
   "LinearOrder.decidableEq",
   "Lattice.toSemilatticeSup",
   "ConditionallyCompleteLinearOrderBot",
   "WithTop.linearOrder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "CompleteLinearOrder.mk",
   "WithTop.instInfSet",
   "WithTop.instCompleteLinearOrderWithTop.proof_5",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "SemilatticeSup.mk",
   "WithTop.instCompleteLinearOrderWithTop.proof_12",
   "ConditionallyCompleteLattice.toInfSet",
   "WithTop.instCompleteLinearOrderWithTop.proof_8",
   "WithTop.orderTop",
   "WithTop.instCompleteLinearOrderWithTop.proof_9",
   "WithTop.instCompleteLinearOrderWithTop.proof_1",
   "WithTop.instCompleteLinearOrderWithTop.proof_6",
   "WithTop.instCompleteLinearOrderWithTop.proof_3",
   "ConditionallyCompleteLinearOrderBot.toOrderBot",
   "WithTop.lattice",
   "LinearOrder.decidableLT",
   "OrderBot.toBot",
   "OrderTop",
   "WithTop.instCompleteLinearOrderWithTop.proof_10",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "WithTop.instCompleteLinearOrderWithTop.proof_4",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "WithTop.instSupSet"],
  "name": "WithTop.instCompleteLinearOrderWithTop",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : ConditionallyCompleteLinearOrderBot Œ±] ‚Üí CompleteLinearOrder (WithTop Œ±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "DistribLattice.toLattice",
   "isOpen_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "continuous_const",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "TopologicalSpace",
   "OrderClosedTopology",
   "Set.Iio",
   "IsOpen"],
  "name": "isOpen_Iio",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±] {a : Œ±},\n  IsOpen (Set.Iio a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSMul",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.Measure.instSMul",
   "Module.toMulActionWithZero",
   "MeasureTheory.Measure.smul_toOuterMeasure",
   "IsScalarTower",
   "instENNRealZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "SMulZeroClass.toSMul",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.instSMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "HSMul.hSMul",
   "OrderedSemiring.toSemiring",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "Algebra.id",
   "Module",
   "MonoidWithZero.toZero",
   "MeasureTheory.OuterMeasure",
   "Algebra.toSMul",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.instModule.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {R : Type u_2} [inst : Semiring R] [inst_1 : Module R ENNReal]\n  [inst_2 : IsScalarTower R ENNReal ENNReal] [inst_3 : MeasurableSpace Œ±] (c : R) (Œº : MeasureTheory.Measure Œ±),\n  ‚Üë(c ‚Ä¢ Œº) = c ‚Ä¢ ‚ÜëŒº",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toLinearOrder.proof_4",
   "Lattice.toLinearOrder.proof_2",
   "Min.mk",
   "Lattice.toLinearOrder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "IsTotal",
   "LinearOrder.mk",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Lattice.toLinearOrder.proof_3",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder",
  "constType":
  "(Œ± : Type u) ‚Üí\n  [inst : Lattice Œ±] ‚Üí\n    [inst_1 : DecidableEq Œ±] ‚Üí\n      [inst_2 : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] ‚Üí [inst : IsTotal Œ± fun x x_1 => x ‚â§ x_1] ‚Üí LinearOrder Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Abs",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["tangentConeAt",
   "TopologicalSpace.t2Space_of_metrizableSpace",
   "NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Set",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "ContinuousLinearMap.ext_on",
   "Eq",
   "MetricSpace.toMetrizableSpace",
   "NormedAddCommGroup.toMetricSpace",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "UniqueDiffWithinAt",
   "Semifield.toDivisionSemiring",
   "HasFDerivWithinAt.unique_on",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "UniqueDiffWithinAt.dense_tangentCone",
   "HasFDerivWithinAt"],
  "name": "UniqueDiffWithinAt.eq",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  {f' f‚ÇÅ' : E ‚ÜíL[ùïú] F} {x : E} {s : Set E},\n  UniqueDiffWithinAt ùïú s x ‚Üí HasFDerivWithinAt f f' s x ‚Üí HasFDerivWithinAt f f‚ÇÅ' s x ‚Üí f' = f‚ÇÅ'",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "le_max_left",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "le_abs_self",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Neg Œ±] [inst_1 : LinearOrder Œ±] (a : Œ±), a ‚â§ |a|",
  "constCategory": "Theorem"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} ‚Üí [self : CommMagma G] ‚Üí Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Module.toDistribMulAction",
   "OfNat.ofNat",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "smul_zero",
   "Eq",
   "SMulZeroClass.toSMul",
   "Zero.toOfNat0",
   "DistribSMul.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero.proof_3",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (a : R), a ‚Ä¢ 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Inf", "SemilatticeInf"],
  "name": "SemilatticeInf.toInf",
  "constType": "{Œ± : Type u} ‚Üí [self : SemilatticeInf Œ±] ‚Üí Inf Œ±",
  "constCategory": "Definition"},
 {"references": ["MetricSpace", "NormedField"],
  "name": "NormedField.toMetricSpace",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedField Œ±] ‚Üí MetricSpace Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop ‚Üí Prop ‚Üí Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocRing", "AddCommGroup"],
  "name": "NonUnitalNonAssocRing.toAddCommGroup",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocRing Œ±] ‚Üí AddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.add_left_neg",
  "constType": "‚àÄ {R : Type u} [self : Ring R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NormedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí [toNormedRing : NormedRing Œ±] ‚Üí (‚àÄ (x y : Œ±), x * y = y * x) ‚Üí NormedCommRing Œ±",
  "constCategory": "Other"},
 {"references": ["NonUnitalSemiring", "NonUnitalCommSemiring"],
  "name": "NonUnitalCommSemiring.toNonUnitalSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalCommSemiring Œ±] ‚Üí NonUnitalSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "pow_two",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "sq",
  "constType": "‚àÄ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "HMul.hMul",
   "MonoidWithZero",
   "Eq"],
  "name": "MonoidWithZero.mk",
  "constType":
  "{M‚ÇÄ : Type u} ‚Üí\n  [toMonoid : Monoid M‚ÇÄ] ‚Üí [toZero : Zero M‚ÇÄ] ‚Üí (‚àÄ (a : M‚ÇÄ), 0 * a = 0) ‚Üí (‚àÄ (a : M‚ÇÄ), a * 0 = 0) ‚Üí MonoidWithZero M‚ÇÄ",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} ‚Üí [inst : NatCast R] ‚Üí ‚Ñï ‚Üí R",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MulZeroClass M‚ÇÄ] ‚Üí Mul M‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.mk",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±], 0 ‚â§ 1 ‚Üí ZeroLEOneClass Œ±",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "HasSubset.Subset",
   "Module",
   "Submodule.span",
   "Submodule.setLike",
   "SetLike.instMembership",
   "Iff.mpr",
   "Submodule.mem_span",
   "SetLike.coe",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name": "Submodule.subset_span",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {s : Set M},\n  s ‚äÜ ‚Üë(Submodule.span R s)",
  "constCategory": "Theorem"},
 {"references": ["NormedField", "DenselyNormedField"],
  "name": "DenselyNormedField.toNormedField",
  "constType": "{Œ± : Type u_5} ‚Üí [self : DenselyNormedField Œ±] ‚Üí NormedField Œ±",
  "constCategory": "Definition"},
 {"references":
  ["borel",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "MeasurableSpace"],
  "name": "Real.measurableSpace",
  "constType": "MeasurableSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String ‚Üí Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} ‚Üí [self : AddCommSemigroup G] ‚Üí AddCommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.Countable",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace"],
  "name": "TopologicalSpace.IsSeparable",
  "constType": "{Œ± : Type u} ‚Üí [t : TopologicalSpace Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a b c : Œ±), a + b ‚â§ a + c ‚Üí b ‚â§ c",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "One",
   "ContinuousLinearMap",
   "Semiring",
   "ContinuousLinearMap.id",
   "One.mk",
   "TopologicalSpace",
   "Module",
   "RingHom.id",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.one",
  "constType":
  "{R‚ÇÅ : Type u_1} ‚Üí\n  [inst : Semiring R‚ÇÅ] ‚Üí\n    {M‚ÇÅ : Type u_4} ‚Üí\n      [inst_1 : TopologicalSpace M‚ÇÅ] ‚Üí [inst_2 : AddCommMonoid M‚ÇÅ] ‚Üí [inst_3 : Module R‚ÇÅ M‚ÇÅ] ‚Üí One (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ)",
  "constCategory": "Definition"},
 {"references":
  ["definition._@.Mathlib.Analysis.InnerProductSpace.PiL2._hyg.13914",
   "NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "Fin.fintype",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "OrthonormalBasis",
   "Eq",
   "NormedField.toField",
   "InnerProductSpace.toNormedSpace",
   "DivisionSemiring.toSemiring",
   "FiniteDimensional.finrank",
   "InnerProductSpace",
   "NormedDivisionRing.toDivisionRing",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NormedField.toNormedDivisionRing",
   "Subtype",
   "FiniteDimensional",
   "Fin"],
  "name": "wrapped._@.Mathlib.Analysis.InnerProductSpace.PiL2._hyg.13914",
  "constType": "Subtype (Eq definition‚úù)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "RatCast"],
  "name": "LinearOrderedField.toRatCast",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí RatCast Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.Subset.trans",
  "constType": "‚àÄ {Œ± : Type u} {a b c : Set Œ±}, a ‚äÜ b ‚Üí b ‚äÜ c ‚Üí a ‚äÜ c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "Ring.toSemiring",
   "LinearOrderedRing.max_def",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "LinearOrderedSemiring",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : LinearOrderedRing Œ±] ‚Üí LinearOrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zero_le_one",
  "constType": "‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±], 0 ‚â§ 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.div_eq_mul_inv",
  "constType":
  "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±] (a b : Œ±), a / b = a * b‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{Œ± : Type u} ‚Üí Array Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "LatticeOrderedGroup.neg_eq_zero_iff",
   "NormedLatticeAddCommGroup.toLattice",
   "AddGroup.toSubtractionMonoid",
   "IsClosed.preimage",
   "Eq.refl",
   "NormedLatticeAddCommGroup",
   "T3Space.t25Space",
   "continuous_neg'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedLatticeAddCommGroup.toOrderedAddCommGroup",
   "NormedLatticeAddCommGroup.toNormedAddCommGroup",
   "NegPart.neg",
   "True",
   "Preorder.toLE",
   "iff_self",
   "isClosed_singleton",
   "Eq",
   "Mathlib.Analysis.Normed.Order.Lattice._auxLemma.3",
   "Set.ext",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Iff",
   "NormedAddGroup.toAddGroup",
   "T2Space.t1Space",
   "UniformSpace.toTopologicalSpace",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "separated_t3",
   "T25Space.t2Space",
   "setOf",
   "Lattice.toSemilatticeInf",
   "Set.preimage",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Analysis.Normed.Order.Lattice._auxLemma.4",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Set.instMembershipSet",
   "NormedAddCommGroup.toMetricSpace",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "LatticeOrderedGroup.hasZeroLatticeHasNegPart",
   "NormedAddCommGroup.toNormedAddGroup",
   "Singleton.singleton",
   "IsClosed",
   "congrArg",
   "NegZeroClass.toZero",
   "MetricSpace.to_separated"],
  "name": "isClosed_nonneg",
  "constType":
  "‚àÄ {E : Type u_2} [inst : NormedLatticeAddCommGroup E], IsClosed {x | 0 ‚â§ x}",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHSMul",
   "SMulWithZero",
   "HSMul.hSMul",
   "SMulZeroClass",
   "SMulZeroClass.toSMul",
   "Eq"],
  "name": "SMulWithZero.mk",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí\n    [inst : Zero R] ‚Üí\n      [inst_1 : Zero M] ‚Üí [toSMulZeroClass : SMulZeroClass R M] ‚Üí (‚àÄ (m : M), 0 ‚Ä¢ m = 0) ‚Üí SMulWithZero R M",
  "constCategory": "Other"},
 {"references":
  ["Norm",
   "Filter",
   "Subtype",
   "Asymptotics.definition._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
   "Eq"],
  "name":
  "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
  "constType": "Subtype (Eq @Asymptotics.definition‚úù)",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
  "constType":
  "‚àÄ {Œ± : Type u_3} [self : OrderedCancelAddCommMonoid Œ±] (a b c : Œ±), a + b ‚â§ a + c ‚Üí b ‚â§ c",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "NormedAddCommGroup",
   "Real.measurableSpace",
   "Real",
   "Real.instPreorderReal",
   "Set.Ioc",
   "MeasureTheory.IntegrableOn"],
  "name": "IntervalIntegrable",
  "constType":
  "{E : Type u_3} ‚Üí [inst : NormedAddCommGroup E] ‚Üí (‚Ñù ‚Üí E) ‚Üí MeasureTheory.Measure ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "propext",
   "Bool.true",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "Nat.cast_one",
   "id"],
  "name": "NeZero.charZero_one",
  "constType":
  "‚àÄ {M : Type u_1} [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.mk",
   "CompleteLinearOrder.toCompleteLattice",
   "CompletelyDistribLattice",
   "CompleteLinearOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice.proof_1"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : CompleteLinearOrder Œ±] ‚Üí CompletelyDistribLattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "Algebra.commutes'",
   "NormedField",
   "Semifield.toCommSemiring",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Algebra.id"],
  "name": "NormedAlgebra.id.proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NormedField ùïú] (r x : ùïú), Algebra.toRingHom r * x = x * Algebra.toRingHom r",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} ‚Üí [self : AddCommGroup G] ‚Üí AddGroup G",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Filter.map.proof_2",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "Filter.map.proof_1",
   "Filter",
   "Filter.univ_mem"],
  "name": "Filter.map",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Filter Œ± ‚Üí Filter Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ‚Ñï), ‚Üë(Nat.succ n) = ‚Üën + 1",
  "constCategory": "Theorem"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} ‚Üí [dp : Decidable p] ‚Üí Decidable ¬¨p",
  "constCategory": "Definition"},
 {"references": ["CanonicallyLinearOrderedSemifield", "Nontrivial"],
  "name": "CanonicallyLinearOrderedSemifield.toNontrivial",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyLinearOrderedSemifield Œ±], Nontrivial Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_zero",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Field.toInv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Field.mul_inv_cancel",
  "constType": "‚àÄ {K : Type u} [self : Field K] (a : K), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass",
  "constType":
  "Type u_1 ‚Üí\n  {R : outParam (Type u_2)} ‚Üí\n    {S : outParam (Type u_3)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          outParam (R ‚Üí+* S) ‚Üí\n            (M : outParam (Type u_4)) ‚Üí\n              [inst_2 : TopologicalSpace M] ‚Üí\n                [inst_3 : AddCommMonoid M] ‚Üí\n                  (M‚ÇÇ : outParam (Type u_5)) ‚Üí\n                    [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst : Module R M] ‚Üí [inst : Module S M‚ÇÇ] ‚Üí Type (max (max u_1 u_4) u_5)",
  "constCategory": "Other"},
 {"references": ["Prod", "Filter", "UniformSpace.Core"],
  "name": "UniformSpace.Core.uniformity",
  "constType": "{Œ± : Type u} ‚Üí UniformSpace.Core Œ± ‚Üí Filter (Œ± √ó Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NormedRing",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (n : ‚Ñï) (a : Œ±),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddGroup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "SMul",
   "instHSMul",
   "HSMul.hSMul",
   "SMulZeroClass",
   "Eq"],
  "name": "SMulZeroClass.mk",
  "constType":
  "{M : Type u_10} ‚Üí {A : Type u_11} ‚Üí [inst : Zero A] ‚Üí [toSMul : SMul M A] ‚Üí (‚àÄ (a : M), a ‚Ä¢ 0 = 0) ‚Üí SMulZeroClass M A",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace"],
  "name": "MeasureTheory.MeasureSpace.volume",
  "constType":
  "{Œ± : Type u_6} ‚Üí [self : MeasureTheory.MeasureSpace Œ±] ‚Üí MeasureTheory.Measure Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "‚àÄ {Œ± : Type u} [self : Semiring Œ±] (a : Œ±), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_8",
  "constType": "‚àÄ {Œ± : Type u_1} (x : Set Œ±), ‚ä§ ‚â§ x ‚äî x·∂ú",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "BorelSpace",
   "IsROrC.toDenselyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "MeasureTheory.MeasureSpace.mk",
   "Real.isROrC",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "Fin.fintype",
   "DenselyNormedField.toNormedField",
   "NormedField.toField",
   "Real.instDivisionRingReal",
   "DivisionSemiring.toSemiring",
   "InnerProductSpace.toNormedSpace",
   "stdOrthonormalBasis",
   "FiniteDimensional.finrank",
   "InnerProductSpace",
   "MeasureTheory.MeasureSpace",
   "OrthonormalBasis.toBasis",
   "Basis.addHaar",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "MeasurableSpace",
   "Fin",
   "FiniteDimensional"],
  "name": "measureSpaceOfInnerProductSpace",
  "constType":
  "{E : Type u_3} ‚Üí\n  [inst : NormedAddCommGroup E] ‚Üí\n    [inst_1 : InnerProductSpace ‚Ñù E] ‚Üí\n      [inst_2 : FiniteDimensional ‚Ñù E] ‚Üí\n        [inst_3 : MeasurableSpace E] ‚Üí [inst : BorelSpace E] ‚Üí MeasureTheory.MeasureSpace E",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.restrict‚Çó",
   "Set",
   "LinearMap.instFunLike",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.Measure.restrict.proof_1",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasurableSpace",
   "LinearMap",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.restrict",
  "constType":
  "{Œ± : Type u_2} ‚Üí {_m0 : MeasurableSpace Œ±} ‚Üí MeasureTheory.Measure Œ± ‚Üí Set Œ± ‚Üí MeasureTheory.Measure Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.insert",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ndinsert.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.ndinsert",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : DecidableEq Œ±] ‚Üí Œ± ‚Üí Multiset Œ± ‚Üí Multiset Œ±",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "PseudoMetricSpace"],
  "name": "SeminormedRing.toPseudoMetricSpace",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : SeminormedRing Œ±] ‚Üí PseudoMetricSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instNNRealSemiring",
   "NNReal",
   "AddCommMonoidWithOne",
   "WithTop.addCommMonoidWithOne"],
  "name": "instENNRealAddCommMonoidWithOne",
  "constType": "AddCommMonoidWithOne ENNReal",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : OrderedAddCommMonoid Œ±] ‚Üí AddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalSemiring Œ±] ‚Üí NonUnitalNonAssocSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "neg_neg",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "neg_sub",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionMonoid Œ±] (a b : Œ±), -(a - b) = b - a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "Finset.instSingletonFinset"],
  "name": "Finset.coe_singleton",
  "constType": "‚àÄ {Œ± : Type u_1} (a : Œ±), ‚Üë{a} = {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "‚Ñï ‚Üí ‚Ñ§",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "RingHom.instRingHomClass",
   "RingHom",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "IsROrC.toStarRing",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "map_mul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.trans",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "EuclideanDomain.toCommRing",
   "MulZeroOneClass.toMulZeroClass",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "of_eq_true",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "congrArg",
   "congrFun"],
  "name": "IsROrC.innerProductSpace.proof_4",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] (x y z : ùïú),\n  (starRingEnd ùïú) (z * x) * y = (starRingEnd ùïú) z * ((starRingEnd ùïú) x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MulZeroOneClass M‚ÇÄ] ‚Üí MulZeroClass M‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "MeasureTheory.SimpleFunc.tendsto_approxOn",
   "PartialOrder.toPreorder",
   "Nontrivial.to_nonempty",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "MeasureTheory.SimpleFunc",
   "MeasureTheory.SimpleFunc.toFun",
   "Eq",
   "PseudoEMetricSpace.toUniformSpace",
   "Eq.mpr",
   "MeasureTheory.StronglyMeasurable",
   "Subsingleton",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Measurable",
   "TopologicalSpace.PseudoMetrizableSpace",
   "Nat",
   "UniformSpace.toTopologicalSpace",
   "Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim",
   "separableSpace_univ",
   "id",
   "Nat.strictOrderedSemiring",
   "PseudoMetricSpace.toPseudoEMetricSpace",
   "Membership.mem",
   "OpensMeasurableSpace",
   "Lean.Elab.Tactic.nonempty_to_inhabited",
   "nhds",
   "MeasureTheory.SimpleFunc.approxOn",
   "TopologicalSpace.pseudoMetrizableSpacePseudoMetric",
   "Set.univ",
   "TopologicalSpace.SecondCountableTopology.to_separableSpace",
   "Inhabited.default",
   "Set.instMembershipSet",
   "SecondCountableTopology",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "StrictOrderedSemiring.toPartialOrder",
   "Nontrivial",
   "Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic._auxLemma.2",
   "Filter.atTop",
   "MeasurableSpace",
   "Set.mem_univ",
   "closure_univ"],
  "name": "Measurable.stronglyMeasurable",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {mŒ± : MeasurableSpace Œ±} [inst : MeasurableSpace Œ≤]\n  [inst_1 : TopologicalSpace Œ≤] [inst_2 : TopologicalSpace.PseudoMetrizableSpace Œ≤] [inst_3 : SecondCountableTopology Œ≤]\n  [inst_4 : OpensMeasurableSpace Œ≤], Measurable f ‚Üí MeasureTheory.StronglyMeasurable f",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "OfNat.ofNat",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MulZeroOneClass.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Zero.toOfNat0",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass.toMonoidWithZeroHomClass",
   "map_zero",
   "MonoidWithZeroHomClass.toZeroHomClass"],
  "name": "RingHom.map_zero",
  "constType":
  "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), f 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí Œ± √ó Œ≤ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemifield",
  "constType": "Type u_2 ‚Üí Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instSubReal",
   "Real",
   "Real.instMulReal",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Real.instAddCommGroupReal",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "sub_zero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.isROrC.proof_6",
  "constType": "‚àÄ (z w : ‚Ñù), z * w = z * w - 0 * 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "‚àÄ {n : ‚Ñï}, n ‚â• 2 ‚Üí Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedField.toField",
   "Real",
   "Field"],
  "name": "Real.field",
  "constType": "Field ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "NonUnitalSeminormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "Real",
   "HSub.hSub",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalSeminormedRing.toPseudoMetricSpace",
   "Dist.dist",
   "Eq"],
  "name": "NonUnitalSeminormedRing.dist_eq",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NonUnitalSeminormedRing Œ±] (x y : Œ±), dist x y = ‚Äñx - y‚Äñ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬¨False) = True",
  "constCategory": "Theorem"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} ‚Üí {motive : a ‚àß b ‚Üí Sort u} ‚Üí (t : a ‚àß b) ‚Üí ((left : a) ‚Üí (right : b) ‚Üí motive (_ : a ‚àß b)) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "Max"],
  "name": "LinearOrderedRing.toMax",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí Max Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NegZeroClass",
  "constType": "Type u_2 ‚Üí Type u_2",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semifield.toCommSemiring",
   "Real",
   "DenselyNormedField.toNormedField",
   "NonUnitalRingHomClass.toMulHomClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "Eq.trans",
   "Real.denselyNormedField",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "Neg.neg",
   "RingHom.map_zero",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroOneClass.toZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.isROrC.proof_10",
  "constType": "(starRingEnd ‚Ñù) 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "sub_self",
   "DivisionRing.toRing",
   "AddGroup.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "AddGroupWithOne.toAddGroup",
   "True",
   "MulZeroClass.toMul",
   "mul_div_cancel",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddMonoid.toZero",
   "Field",
   "Ring.toSub",
   "HDiv.hDiv",
   "not_false_eq_true",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Ne",
   "instHDiv",
   "False",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "HSub.hSub",
   "Field.toSemifield",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "of_eq_true",
   "congr",
   "CommRing.toRing",
   "HMul.hMul",
   "Not",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "and_self",
   "congrFun"],
  "name": "Field.toEuclideanDomain.proof_4",
  "constType":
  "‚àÄ {K : Type u_1} [inst : Field K] (a b : K), b ‚â† 0 ‚Üí a - a * b / b = 0 ‚àß ¬¨b = 0",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí a ‚Üí b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{Œ± : Type u} ‚Üí [self : Semiring Œ±] ‚Üí NonAssocSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.map_mono",
   "PartialOrder.toPreorder",
   "Filter.map",
   "LE.le.trans",
   "Filter.instPartialOrderFilter",
   "Filter.Tendsto",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto.mono_left",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {x y : Filter Œ±} {z : Filter Œ≤},\n  Filter.Tendsto f x z ‚Üí y ‚â§ x ‚Üí Filter.Tendsto f y z",
  "constCategory": "Theorem"},
 {"references":
  ["RingHomInvPair",
   "RingHom",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "LinearEquiv",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "LinearIsometryEquiv",
   "Module"],
  "name": "LinearIsometryEquiv.toLinearEquiv",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                {E : Type u_11} ‚Üí\n                  {E‚ÇÇ : Type u_12} ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["Bot", "CompleteLattice"],
  "name": "CompleteLattice.toBot",
  "constType": "{Œ± : Type u_9} ‚Üí [self : CompleteLattice Œ±] ‚Üí Bot Œ±",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(Œ± : Type u) ‚Üí [inst : LE Œ±] ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : StrictOrderedCommSemiring Œ±] ‚Üí StrictOrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.finRange.proof_1",
   "List.Nodup",
   "LT.lt",
   "List.finRange",
   "List.Pairwise.pmap",
   "Fin.ne_of_vne",
   "List.nodup_range",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.nodup_finRange",
  "constType": "‚àÄ (n : ‚Ñï), List.Nodup (List.finRange n)",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "IsROrC",
  "constType": "semiOutParam (Type u_1) ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_coe",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.6",
  "constType": "‚àÄ {Œ± : Type u_1} {a : Œ±} {s : Finset Œ±}, (a ‚àà ‚Üës) = (a ‚àà s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "AddHom.toFun",
   "Semiring",
   "Continuous",
   "_auto._@.Mathlib.Topology.Algebra.Module.Basic._hyg.2648",
   "TopologicalSpace",
   "Module",
   "AddCommMagma.toAdd",
   "autoParam",
   "LinearMap.toAddHom",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.mk",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {M : Type u_3} ‚Üí\n            [inst_2 : TopologicalSpace M] ‚Üí\n              [inst_3 : AddCommMonoid M] ‚Üí\n                {M‚ÇÇ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R M] ‚Üí\n                        [inst_7 : Module S M‚ÇÇ] ‚Üí\n                          (toLinearMap : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí autoParam (Continuous toLinearMap.toFun) _auto‚úù ‚Üí M ‚ÜíSL[œÉ] M‚ÇÇ",
  "constCategory": "Other"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HAdd Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "lt_add_of_pos_right",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "NeZero.one",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddZeroClass.toZero",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "one_pos",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "StrictOrderedSemiring.toPartialOrder",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NoMaxOrder.mk",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "NoMaxOrder"],
  "name": "StrictOrderedSemiring.toNoMaxOrder",
  "constType": "‚àÄ {Œ± : Type u} [inst : StrictOrderedSemiring Œ±], NoMaxOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["Abs"],
  "name": "Abs.mk",
  "constType": "{Œ± : Type u_1} ‚Üí (Œ± ‚Üí Œ±) ‚Üí Abs Œ±",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "Div"],
  "name": "GroupWithZero.toDiv",
  "constType": "{G‚ÇÄ : Type u} ‚Üí [self : GroupWithZero G‚ÇÄ] ‚Üí Div G‚ÇÄ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G‚ÇÄ : Type u} ‚Üí [self : GroupWithZero G‚ÇÄ] ‚Üí MonoidWithZero G‚ÇÄ",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{Œ± : Sort u} ‚Üí Œ± ‚Üí Inhabited Œ±",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toNormedCommRing.proof_2",
   "NormedField.toField",
   "Field.toCommRing",
   "NormedCommRing",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "CommRing.toRing",
   "NormedRing.mk",
   "NormedCommRing.mk",
   "NormedField.toNormedCommRing.proof_1",
   "NormedField.toNorm"],
  "name": "NormedField.toNormedCommRing",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : NormedField Œ±] ‚Üí NormedCommRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_2",
   "Mathlib.Order.OmegaCompletePartialOrder._auxLemma.14",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "RelHomClass.toFunLike",
   "OrderHom.mk",
   "Eq.mpr",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : CompleteLattice Œ±] (x : OmegaCompletePartialOrder.Chain Œ±) (s : Œ±),\n  (‚àÄ (i : ‚Ñï), x i ‚â§ s) ‚Üí (fun c => ‚®Ü i, c i) x ‚â§ s",
  "constCategory": "Theorem"},
 {"references":
  ["Algebra.toRingHom",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "algebraMap",
  "constType":
  "(R : Type u) ‚Üí (A : Type v) ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí R ‚Üí+* A",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyLinearOrderedAddCommMonoid.decidableLE",
   "OrderedAddCommMonoid.add_le_add_left",
   "CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyLinearOrderedAddCommMonoid.max_def",
   "CanonicallyLinearOrderedAddCommMonoid.le_total",
   "CanonicallyLinearOrderedAddCommMonoid.min_def",
   "CanonicallyLinearOrderedAddCommMonoid.toMin",
   "CanonicallyLinearOrderedAddCommMonoid.toOrd",
   "CanonicallyLinearOrderedAddCommMonoid.decidableLT",
   "CanonicallyLinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq",
   "CanonicallyLinearOrderedAddCommMonoid.toMax",
   "LinearOrder.mk",
   "CanonicallyLinearOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyLinearOrderedAddCommMonoid.decidableEq",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : CanonicallyLinearOrderedAddCommMonoid Œ±] ‚Üí LinearOrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "lt_add_of_pos_right",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder",
   "AddZeroClass.toZero",
   "NeZero",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "zero_lt_one",
   "AddZeroClass"],
  "name": "lt_add_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : One Œ±] [inst_1 : AddZeroClass Œ±] [inst_2 : PartialOrder Œ±] [inst_3 : ZeroLEOneClass Œ±]\n  [inst_4 : NeZero 1] [inst_5 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : Œ±), a < a + 1",
  "constCategory": "Theorem"},
 {"references":
  ["OpensMeasurableSpace",
   "CompactIccSpace.isCompact_Icc",
   "NormedAddCommGroup",
   "Set.Icc",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "ContinuousOn.integrableOn_compact",
   "PseudoMetricSpace.toUniformSpace",
   "CompactIccSpace",
   "MeasureTheory.IntegrableOn",
   "Preorder",
   "MeasureTheory.IsFiniteMeasureOnCompacts",
   "MeasureTheory.Measure",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "TopologicalSpace",
   "T2Space",
   "UniformSpace.toTopologicalSpace",
   "ContinuousOn",
   "MeasurableSpace"],
  "name": "ContinuousOn.integrableOn_Icc",
  "constType":
  "‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X ‚Üí E} {Œº : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X] {a b : X}\n  [inst_4 : MeasureTheory.IsFiniteMeasureOnCompacts Œº] [inst_5 : Preorder X] [inst_6 : CompactIccSpace X]\n  [inst_7 : T2Space X], ContinuousOn f (Set.Icc a b) ‚Üí MeasureTheory.IntegrableOn f (Set.Icc a b)",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "ContinuousAt",
   "continuous_snd",
   "TopologicalSpace",
   "Prod",
   "Continuous.continuousAt"],
  "name": "continuousAt_snd",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {p : Œ± √ó Œ≤},\n  ContinuousAt Prod.snd p",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Function.Injective",
   "Nat"],
  "name": "CharZero.mk",
  "constType":
  "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R], Function.Injective Nat.cast ‚Üí CharZero R",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "outParam",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHomClass.mk",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : AddZeroClass M] ‚Üí\n        [inst_1 : AddZeroClass N] ‚Üí [toAddHomClass : AddHomClass F M N] ‚Üí (‚àÄ (f : F), f 0 = 0) ‚Üí AddMonoidHomClass F M N",
  "constCategory": "Other"},
 {"references": ["OfNat.ofNat", "One", "One.toOfNat1", "OneHom", "Eq"],
  "name": "OneHom.mk",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : One M] ‚Üí [inst_1 : One N] ‚Üí (toFun : M ‚Üí N) ‚Üí toFun 1 = 1 ‚Üí OneHom M N",
  "constCategory": "Other"},
 {"references": [],
  "name": "OmegaCompletePartialOrder",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references": ["Set", "MeasurableSpace.MeasurableSet'", "MeasurableSpace"],
  "name": "MeasurableSet",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_3",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.mk",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLE",
   "Ring.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_6",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Ring.toSub",
   "LinearOrderedAddCommGroup.mk",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_4",
   "AddCommGroup.mk",
   "LinearOrderedAddCommGroup",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_1",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_7",
   "AddGroup.mk",
   "LinearOrderedRing.decidableEq",
   "Ring.toSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_2",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.min_def",
   "SubNegMonoid.mk",
   "Ring.zsmul",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_5",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : LinearOrderedRing Œ±] ‚Üí LinearOrderedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OrderHom",
   "inferInstanceAs",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Nat",
   "Preorder",
   "Preorder.toLE",
   "OrderHomClass",
   "Nat.strictOrderedSemiring"],
  "name":
  "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí OrderHomClass (OmegaCompletePartialOrder.Chain Œ±) ‚Ñï Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "‚àÄ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "NatCast.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Nat.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "Nat",
   "CauSeq.instNatCast",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instNatCastCauchy",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : LinearOrderedField Œ±] ‚Üí\n    {Œ≤ : Type u_2} ‚Üí\n      [inst_1 : Ring Œ≤] ‚Üí {abv : Œ≤ ‚Üí Œ±} ‚Üí [inst_2 : IsAbsoluteValue abv] ‚Üí NatCast (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Prod.pseudoMetricSpaceMax",
   "PseudoMetricSpace.toDist",
   "Prod.casesOn",
   "Real.instLTReal",
   "Prod.mk",
   "LT.lt",
   "Real",
   "Prod",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "BoundedSMul.continuousSMul.match_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] (a : Œ±) (b : Œ≤) (Œ¥ : ‚Ñù)\n  (motive : (x : Œ± √ó Œ≤) ‚Üí dist x (a, b) < Œ¥ ‚Üí Prop) (x : Œ± √ó Œ≤) (hab' : dist x (a, b) < Œ¥),\n  (‚àÄ (a' : Œ±) (b' : Œ≤) (hab' : dist (a', b') (a, b) < Œ¥), motive (a', b') hab') ‚Üí motive x hab'",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Exists",
   "OfNat.ofNat",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "Classical.choose",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Classical.propDecidable",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "dite",
   "NormedSpace",
   "RingHom.id",
   "Zero.toOfNat0",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Not",
   "Semifield.toDivisionSemiring",
   "ContinuousLinearMap.zero",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "definition._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : NormedAddCommGroup F] ‚Üí [inst_4 : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí E ‚Üí E ‚ÜíL[ùïú] F",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toInv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.inv_zero",
  "constType": "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±], 0‚Åª¬π = 0",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{Œ± : Type u} ‚Üí Œ± ‚Üí Top Œ±",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "DivisionRing",
   "DivisionRing.mk",
   "Field.zpow_zero'",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Field.div_eq_mul_inv"],
  "name": "Field.toDivisionRing",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí DivisionRing K",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "Continuous.isOpen_preimage",
   "TopologicalSpace",
   "IsOpen"],
  "name": "IsOpen.preimage",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí ‚àÄ {s : Set Œ≤}, IsOpen s ‚Üí IsOpen (f ‚Åª¬π' s)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "‚àÄ {n : ‚Ñï}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup.toAddCommGroup",
   "SeminormedAddCommGroup.mk",
   "NormedAddCommGroup",
   "SeminormedAddCommGroup",
   "MetricSpace.toPseudoMetricSpace",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm"],
  "name": "NormedAddCommGroup.toSeminormedAddCommGroup",
  "constType":
  "{E : Type u_6} ‚Üí [inst : NormedAddCommGroup E] ‚Üí SeminormedAddCommGroup E",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toMulPosMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : StrictOrderedSemiring Œ±] (x x_1 x_2 : Œ±), x ‚â§ x_1 ‚Üí 0 ‚â§ x_2 ‚Üí x * x_2 ‚â§ x_1 * x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Real.instLEReal",
   "Set",
   "Real",
   "Exists.intro",
   "Exists.casesOn",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.match_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (s : Set Œ±)\n  (motive : s ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C} ‚Üí Prop)\n  (x : s ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C}),\n  (‚àÄ (c : ‚Ñù) (hc : ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ c),\n      motive (_ : ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C)) ‚Üí\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHomClass.toMonoidHomClass",
  "constType":
  "{F : Type u_5} ‚Üí\n  {Œ± : outParam (Type u_6)} ‚Üí\n    {Œ≤ : outParam (Type u_7)} ‚Üí\n      [inst : NonAssocSemiring Œ±] ‚Üí [inst_1 : NonAssocSemiring Œ≤] ‚Üí [self : RingHomClass F Œ± Œ≤] ‚Üí MonoidHomClass F Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "Classical.choose_spec",
   "instHasEquiv",
   "CauSeq.lim",
   "CauSeq.IsComplete",
   "CauSeq.complete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.equiv_lim",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {Œ≤ : Type u_2} [inst_1 : Ring Œ≤] {abv : Œ≤ ‚Üí Œ±}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete Œ≤ abv] (s : CauSeq Œ≤ abv),\n  s ‚âà CauSeq.const abv (CauSeq.lim s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop ‚Üí Prop ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Lattice._auxLemma.27",
   "Set",
   "Set.univ",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "iff_self",
   "Iff",
   "Set.iUnion",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion_eq_univ_iff",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} {f : Œπ ‚Üí Set Œ±}, ‚ãÉ i, f i = Set.univ ‚Üî ‚àÄ (x : Œ±), ‚àÉ i, x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Zero", "SMul", "SMulZeroClass"],
  "name": "SMulZeroClass.toSMul",
  "constType":
  "{M : Type u_10} ‚Üí {A : Type u_11} ‚Üí [inst : Zero A] ‚Üí [self : SMulZeroClass M A] ‚Üí SMul M A",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) ‚Üí (N : Type u_10) ‚Üí [inst : Zero M] ‚Üí [inst : Zero N] ‚Üí Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.re",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "IsROrC.I",
   "NormedField.toField",
   "Field.toCommRing",
   "IsROrC.re_add_im_ax",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "EuclideanDomain.toCommRing",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "IsROrC.ofReal",
   "instHMul",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.im"],
  "name": "IsROrC.re_add_im",
  "constType":
  "‚àÄ {K : Type u_1} [inst : IsROrC K] (z : K), ‚Üë(IsROrC.re z) + ‚Üë(IsROrC.im z) * IsROrC.I = z",
  "constCategory": "Theorem"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} ‚Üí [self : MulOneClass M] ‚Üí One M",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1166"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.neg",
  "constType": "‚Ñù ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "NormedRing",
   "instHMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedRing.norm_mul",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NormedRing Œ±] (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Subtype",
  "constType": "{Œ± : Sort u} ‚Üí (Œ± ‚Üí Prop) ‚Üí Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{Œ± : Type u_4} ‚Üí Finset Œ± ‚Üí Multiset Œ±",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "HasDistribNeg", "Mul"],
  "name": "HasDistribNeg.toInvolutiveNeg",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : Mul Œ±] ‚Üí [self : HasDistribNeg Œ±] ‚Üí InvolutiveNeg Œ±",
  "constCategory": "Definition"},
 {"references": ["Div"],
  "name": "Div.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Div Œ±",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "NormedRing",
   "PseudoMetricSpace.toDist",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedRing.dist_eq",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NormedRing Œ±] (x y : Œ±), dist x y = ‚Äñx - y‚Äñ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds",
  "constType": "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí Set Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddMonoidHom.map_zero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "congrArg",
   "Eq.trans",
   "AddMonoidHom",
   "AddMonoidHom.id",
   "congrFun"],
  "name": "Real.isROrC.proof_1",
  "constType": "(AddMonoidHom.id ‚Ñù) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Lattice.toLinearOrder",
   "Preorder.toLT",
   "Real.lattice",
   "LT.lt",
   "Classical.propDecidable",
   "Real",
   "SemilatticeInf.toPartialOrder",
   "Real.instIsTotalRealLeInstLEReal",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Real.linearOrder",
  "constType": "LinearOrder ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Real.linearOrder",
   "inferInstance",
   "instDecidableEq",
   "Real",
   "Decidable",
   "Eq"],
  "name": "Real.decidableEq",
  "constType": "(a b : ‚Ñù) ‚Üí Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["Ne", "Preorder.toLT", "LT.lt", "ne_of_lt", "Preorder"],
  "name": "LT.lt.ne",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí a ‚â† b",
  "constCategory": "Theorem"},
 {"references":
  ["One", "Real", "One.mk", "_private.Mathlib.Data.Real.Basic.0.Real.one"],
  "name": "Real.instOneReal",
  "constType": "One ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_7",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a b c : (Filter Œ±)·µí·µà·µí·µà), a ‚â§ c ‚Üí b ‚â§ c ‚Üí a ‚äî b ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule",
   "Submodule.FG",
   "Top.top",
   "Semiring",
   "Module.Finite",
   "Module",
   "Submodule.instTopSubmodule",
   "AddCommMonoid"],
  "name": "Module.Finite.mk",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Submodule.FG ‚ä§ ‚Üí Module.Finite R M",
  "constCategory": "Other"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{Œ± : Type u} ‚Üí (x : ‚Ñï) ‚Üí [self : OfNat Œ± x] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "Real",
   "Real.instAddMonoidReal",
   "CommRing.toRing",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "semiOutParam",
   "AddMonoidHom"],
  "name": "IsROrC.re",
  "constType": "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K ‚Üí+ ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} ‚Üí [self : NegZeroClass G] ‚Üí Zero G",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Eq",
   "Dist.dist",
   "instHMul",
   "Norm",
   "MetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NonUnitalNormedRing",
   "HMul.hMul",
   "NonUnitalRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNormedRing.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toNorm : Norm Œ±] ‚Üí\n    [toNonUnitalRing : NonUnitalRing Œ±] ‚Üí\n      [toMetricSpace : MetricSpace Œ±] ‚Üí\n        (‚àÄ (x y : Œ±), dist x y = ‚Äñx - y‚Äñ) ‚Üí (‚àÄ (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ) ‚Üí NonUnitalNormedRing Œ±",
  "constCategory": "Other"},
 {"references": ["UniformSpace", "UniformSpace.Core"],
  "name": "UniformSpace.toCore",
  "constType": "{Œ± : Type u} ‚Üí [self : UniformSpace Œ±] ‚Üí UniformSpace.Core Œ±",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{Œ± : Type u} ‚Üí [self : NonAssocSemiring Œ±] ‚Üí NatCast Œ±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.lift.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "Preorder",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift",
  "constType":
  "{Œ± : Type u_3} ‚Üí {Œ≤ : Type u_4} ‚Üí [inst : PartialOrder Œ≤] ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí Function.Injective f ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(Œ± : Type u) ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{Œ± : Type u} ‚Üí [self : Max Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] (a : Œ±), a ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Submodule",
   "instHSMul",
   "Semiring",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "AddSubsemigroup.carrier",
   "AddCommMonoid"],
  "name": "Submodule.mk",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí\n        [inst_2 : Module R M] ‚Üí\n          (toAddSubmonoid : AddSubmonoid M) ‚Üí\n            (‚àÄ (c : R) {x : M}, x ‚àà toAddSubmonoid.carrier ‚Üí c ‚Ä¢ x ‚àà toAddSubmonoid.carrier) ‚Üí Submodule R M",
  "constCategory": "Other"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "Membership.mem",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "setOf",
   "Submodule",
   "PartialOrder.toPreorder",
   "Semiring",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "Inf.mk",
   "And",
   "Set.subset_inter",
   "And.intro",
   "Set.inter_subset_left",
   "Module",
   "Lattice.toSemilatticeSup",
   "Set.inter_subset_right",
   "Submodule.setLike",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_10",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)), ‚àÄ x_1 ‚àà x, x_1 ‚â§ sInf fun x_2 => ‚àÄ b ‚àà x, b ‚â§ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_one",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{Œ± : Type u} ‚Üí [self : Semiring Œ±] ‚Üí One Œ±",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.toNormedAlgebra",
   "NormedField.toField",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "NormedAlgebra.toAlgebra",
   "IsROrC.toDenselyNormedField",
   "Real.instCommSemiringReal",
   "Real.normedField",
   "Real",
   "Algebra.cast",
   "Field.toSemifield",
   "DenselyNormedField.toNormedField",
   "Semifield.toDivisionSemiring",
   "IsROrC",
   "NormedField.toNormedCommRing"],
  "name": "IsROrC.ofReal",
  "constType": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí ‚Ñù ‚Üí K",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{Œ± : Type u} ‚Üí [inst : LT Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "max_eq_right",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_of_nonpos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {a : Œ±}, a ‚â§ 0 ‚Üí |a| = -a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "HasDerivAtFilter.proof_2",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "NormedField.toNormedSpace",
   "HasFDerivAt.differentiableAt",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "HasDerivAtFilter.proof_1",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DifferentiableAt",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAt.differentiableAt",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú}, HasDerivAt f f' x ‚Üí DifferentiableAt ùïú f x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "BooleanAlgebra.toHasCompl",
   "Set.Set.completeAtomicBooleanAlgebra.proof_8",
   "BooleanAlgebra.toBot",
   "Set.Set.completeAtomicBooleanAlgebra.proof_12",
   "Preorder.toLE",
   "BooleanAlgebra",
   "CompletelyDistribLattice.mk",
   "CompleteAtomicBooleanAlgebra.mk",
   "BooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra",
   "Set.Set.completeAtomicBooleanAlgebra.proof_10",
   "Set.Set.completeAtomicBooleanAlgebra.proof_3",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Set.Set.completeAtomicBooleanAlgebra.proof_7",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra.proof_5",
   "Set.Set.completeAtomicBooleanAlgebra.proof_11",
   "Set.Set.completeAtomicBooleanAlgebra.proof_2",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.proof_6",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.instBooleanAlgebraSet",
   "Set.Set.completeAtomicBooleanAlgebra.proof_1",
   "Set.Set.completeAtomicBooleanAlgebra.proof_9",
   "Set.Set.completeAtomicBooleanAlgebra.proof_4",
   "Set.instInfSetSet",
   "BooleanAlgebra.toSDiff"],
  "name": "Set.Set.completeAtomicBooleanAlgebra",
  "constType": "{Œ± : Type u_1} ‚Üí CompleteAtomicBooleanAlgebra (Set Œ±)",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.preimage",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Set Œ≤ ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SMul",
   "Module.toDistribMulAction",
   "instHSMul",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "DistribMulAction",
   "SMulWithZero.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "Function.Injective.distribMulAction",
   "HSMul.hSMul",
   "Module",
   "Function.Injective.module.proof_1",
   "AddCommMonoid",
   "DistribMulAction.toMulAction",
   "DistribMulAction.mk",
   "AddHomClass.toFunLike",
   "Semiring",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "SMulZeroClass.toSMul",
   "Function.Injective.module.proof_3",
   "MulActionWithZero.toSMulWithZero",
   "Function.Injective",
   "Function.Injective.module.proof_4",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "MonoidWithZero.toZero",
   "Function.Injective.module.proof_2",
   "AddMonoidHom",
   "Module.mk"],
  "name": "Function.Injective.module",
  "constType":
  "(R : Type u_2) ‚Üí\n  {M : Type u_5} ‚Üí\n    {M‚ÇÇ : Type u_6} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí\n          [inst_2 : Module R M] ‚Üí\n            [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n              [inst_4 : SMul R M‚ÇÇ] ‚Üí\n                (f : M‚ÇÇ ‚Üí+ M) ‚Üí Function.Injective ‚áëf ‚Üí (‚àÄ (c : R) (x : M‚ÇÇ), f (c ‚Ä¢ x) = c ‚Ä¢ f x) ‚Üí Module R M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.mk",
  "constType": "{K : Type u} ‚Üí (‚Ñö ‚Üí K) ‚Üí RatCast K",
  "constCategory": "Other"},
 {"references":
  ["Quot.liftOn", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSMul",
  "constType": "Type u ‚Üí Type v ‚Üí outParam (Type w) ‚Üí Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedRing"],
  "name": "Real.strictOrderedRing",
  "constType": "StrictOrderedRing ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["SMul", "TopologicalSpace"],
  "name": "ContinuousSMul",
  "constType":
  "(M : Type u_1) ‚Üí (X : Type u_2) ‚Üí [inst : SMul M X] ‚Üí [inst : TopologicalSpace M] ‚Üí [inst : TopologicalSpace X] ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["DecidableEq", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.decidableEq",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí DecidableEq Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.instAdd.proof_1",
   "MeasureTheory.OuterMeasure.instAdd",
   "MeasureTheory.Measure.toOuterMeasure",
   "instHAdd",
   "HAdd.hAdd",
   "MeasureTheory.Measure.mk",
   "Add",
   "MeasureTheory.Measure.instAdd.proof_2",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "Add.mk"],
  "name": "MeasureTheory.Measure.instAdd",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Add (MeasureTheory.Measure Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} ‚Üí [self : AddCancelMonoid M] ‚Üí AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{Œ± : Type u} ‚Üí [self : Preorder Œ±] ‚Üí LT Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "add_right_neg",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["starRingAut",
   "Distrib.toAdd",
   "RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "RingAut",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "RingHomClass.toRingHom",
   "NonUnitalNonAssocSemiring.toMul",
   "RingEquivClass.toRingHomClass",
   "RingEquiv.instRingEquivClassRingEquiv",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "starRingEnd",
  "constType":
  "(R : Type u) ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : StarRing R] ‚Üí R ‚Üí+* R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "Set.subset_univ",
   "Set.instMembershipSet"],
  "name": "Filter.principal",
  "constType": "{Œ± : Type u} ‚Üí Set Œ± ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inner",
  "constType": "Type u_4 ‚Üí Type u_5 ‚Üí Type (max u_4 u_5)",
  "constCategory": "Other"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Zero Œ±] ‚Üí OfNat Œ± 0",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedCommSemiring Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.cons",
   "Singleton",
   "Singleton.mk"],
  "name": "Multiset.instSingletonMultiset",
  "constType": "{Œ± : Type u_1} ‚Üí Singleton Œ± (Multiset Œ±)",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "or_true", "iff_of_eq", "True"],
  "name": "or_true_iff",
  "constType": "‚àÄ (p : Prop), p ‚à® True ‚Üî True",
  "constCategory": "Theorem"},
 {"references":
  ["Function.swap",
   "add_lt_add_of_lt_of_lt",
   "Preorder.toLT",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "Add"],
  "name": "add_lt_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c d : Œ±},\n  a < b ‚Üí c < d ‚Üí a + c < b + d",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.decidableEq",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí DecidableEq Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Preorder.le_trans",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a b c : (Filter Œ±)·µí·µà·µí·µà), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "Left.mul_nonneg",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul"],
  "name": "mul_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} {a b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulMono Œ±],\n  0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a * b",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommGroup", "AddCommGroup"],
  "name": "OrderedAddCommGroup.toAddCommGroup",
  "constType": "{Œ± : Type u} ‚Üí [self : OrderedAddCommGroup Œ±] ‚Üí AddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "Real",
   "Real.instAddMonoidReal",
   "CommRing.toRing",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "semiOutParam",
   "AddMonoidHom"],
  "name": "IsROrC.im",
  "constType": "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K ‚Üí+ ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast"],
  "name": "IntCast.intCast",
  "constType": "{R : Type u} ‚Üí [self : IntCast R] ‚Üí ‚Ñ§ ‚Üí R",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "SMul",
   "instHSMul",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul"],
  "name": "Algebra.mk",
  "constType":
  "{R : Type u} ‚Üí\n  {A : Type v} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : Semiring A] ‚Üí\n        [toSMul : SMul R A] ‚Üí\n          (toRingHom : R ‚Üí+* A) ‚Üí\n            (‚àÄ (r : R) (x : A), toRingHom r * x = x * toRingHom r) ‚Üí\n              (‚àÄ (r : R) (x : A), r ‚Ä¢ x = toRingHom r * x) ‚Üí Algebra R A",
  "constCategory": "Other"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "SetLike.instPartialOrder",
   "And",
   "setOf",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "InfSet.sInf",
   "And.intro",
   "Module",
   "LE.le",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_3",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 x_2 : Submodule R M), x ‚â§ x_2 ‚Üí x_1 ‚â§ x_2 ‚Üí sInf {x_3 | x ‚â§ x_3 ‚àß x_1 ‚â§ x_3} ‚â§ x_2",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MulOneClass.toOne", "MonoidHom", "OneHom"],
  "name": "MonoidHom.toOneHom",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : MulOneClass M] ‚Üí [inst_1 : MulOneClass N] ‚Üí (M ‚Üí* N) ‚Üí OneHom M N",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Mul Œ±] ‚Üí HMul Œ± Œ± Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "OrderedAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "Continuous.sub",
   "IsClosed.preimage",
   "Eq.refl",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Eq",
   "Set.ext",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "ContinuousSub",
   "continuous_snd",
   "TopologicalSpace",
   "AddCommGroup.toAddGroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "instHSub",
   "funext",
   "setOf",
   "Prod.snd",
   "Set.preimage",
   "instTopologicalSpaceProd",
   "HSub.hSub",
   "Prod.fst",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Mathlib.Analysis.Normed.Order.Lattice._auxLemma.5",
   "Set.instMembershipSet",
   "continuous_fst",
   "Eq.ndrec",
   "of_eq_true",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "Prod",
   "IsClosed",
   "congrArg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "isClosed_le_of_isClosed_nonneg",
  "constType":
  "‚àÄ {G : Type u_2} [inst : OrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousSub G],\n  IsClosed {x | 0 ‚â§ x} ‚Üí IsClosed {p | p.1 ‚â§ p.2}",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üí b) ‚Üí (b ‚Üí a) ‚Üí (a ‚Üî b)",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "Eq"],
  "name": "SubNegMonoid.sub_eq_add_neg",
  "constType":
  "‚àÄ {G : Type u} [self : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Definition"},
 {"references": ["Real", "Dist"],
  "name": "Dist.mk",
  "constType": "{Œ± : Type u_3} ‚Üí (Œ± ‚Üí Œ± ‚Üí ‚Ñù) ‚Üí Dist Œ±",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommSemiring",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring",
   "Real.instStrictOrderedCommRingReal",
   "Real"],
  "name": "Real.strictOrderedCommSemiring",
  "constType": "StrictOrderedCommSemiring ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "inferInstanceAs",
   "OrderDual",
   "OrderDual.instPartialOrder.proof_3",
   "OrderDual.instPartialOrder.proof_1",
   "Preorder",
   "le_antisymm",
   "LE.le",
   "OrderDual.instPartialOrder.proof_2",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(Œ± : Type u_3) ‚Üí [inst : PartialOrder Œ±] ‚Üí PartialOrder Œ±·µí·µà",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.inv'", "Real", "Inv", "Inv.mk"],
  "name": "Real.instInvReal",
  "constType": "Inv ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "instHSub",
   "OfNat.ofNat",
   "neg_zero",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegZeroMonoid",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegZeroMonoid.toSubNegMonoid",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "sub_zero",
  "constType":
  "‚àÄ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedAddCommGroup", "Min"],
  "name": "LinearOrderedAddCommGroup.toMin",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí Min Œ±",
  "constCategory": "Definition"},
 {"references": ["WithTop", "NNReal"],
  "name": "ENNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{Œ± : Type u_9} ‚Üí [self : CompleteLattice Œ±] ‚Üí Lattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "max_eq_left",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "neg_nonpos"],
  "name": "abs_of_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {a : Œ±}, 0 ‚â§ a ‚Üí |a| = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "semiOutParam",
  "constType": "Sort u ‚Üí Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Filter.join.proof_2",
   "Membership.mem",
   "setOf",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.join.proof_3",
   "Filter.join.proof_1",
   "instMembershipSetFilter"],
  "name": "Filter.join",
  "constType": "{Œ± : Type u} ‚Üí Filter (Filter Œ±) ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": ["Bot", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toBot",
  "constType": "{Œ± : Type u} ‚Üí [self : BooleanAlgebra Œ±] ‚Üí Bot Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Membership.mem",
   "Submodule",
   "setOf",
   "PartialOrder.toPreorder",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_2",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), x_1 ‚â§ sInf {x_2 | x ‚â§ x_2 ‚àß x_1 ‚â§ x_2}",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegMonoid.sub_eq_add_neg",
   "Eq"],
  "name": "sub_eq_add_neg",
  "constType":
  "‚àÄ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "True",
   "Abs.abs",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instNonempty",
   "instHSub",
   "Neg.toHasAbs",
   "eq_self",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_1",
  "constType": "‚àÄ (a : ‚Ñù), |a - a| = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Neg.neg",
   "Sub",
   "Real.instNegReal",
   "Sub.mk"],
  "name": "Real.instSubReal",
  "constType": "Sub ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "LT.lt.trans_le",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "one_le_two",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "zero_lt_one",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "zero_lt_two",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "NormedAlgebra.toAlgebra",
   "NormedAlgebra.toNormedSpace.proof_2",
   "Algebra.toModule",
   "NormedSpace.mk",
   "NormedField",
   "Semifield.toCommSemiring",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "NormedSpace",
   "NormedAlgebra.norm_smul_le",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "SeminormedRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Semiring.toNonAssocSemiring",
   "SeminormedRing.toRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDivisionSemiring",
   "NormedAlgebra.toNormedSpace.proof_1",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedAlgebra",
   "Module",
   "SeminormedRing.toNonUnitalSeminormedRing",
   "Module.mk"],
  "name": "NormedAlgebra.toNormedSpace",
  "constType":
  "{ùïú : Type u_5} ‚Üí\n  (ùïú' : Type u_6) ‚Üí\n    [inst : NormedField ùïú] ‚Üí [inst_1 : SeminormedRing ùïú'] ‚Üí [inst_2 : NormedAlgebra ùïú ùïú'] ‚Üí NormedSpace ùïú ùïú'",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Add",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Nonempty.elim", "Iff", "Nonempty"],
  "name": "forall_const",
  "constType": "‚àÄ {b : Prop} (Œ± : Sort u_1) [i : Nonempty Œ±], Œ± ‚Üí b ‚Üî b",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Ring",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_neg'",
  "constType":
  "‚àÄ {R : Type u} [self : Ring R] (n : ‚Ñï) (a : R), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (‚Üë(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mul_comm",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocCommRing Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{Œ± : Type u_1} ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{Œ± : Type u} ‚Üí Œ± ‚Üí One Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "‚àÄ {Œ± : Type u} [self : Semiring Œ±] (a : Œ±), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "‚àÄ {a b : Prop}, b ‚Üí a ‚à® b",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.const",
   "instHasEquiv",
   "Classical.choose",
   "CauSeq.IsComplete",
   "CauSeq.complete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.lim",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : LinearOrderedField Œ±] ‚Üí\n    {Œ≤ : Type u_2} ‚Üí\n      [inst_1 : Ring Œ≤] ‚Üí\n        {abv : Œ≤ ‚Üí Œ±} ‚Üí [inst_2 : IsAbsoluteValue abv] ‚Üí [inst_3 : CauSeq.IsComplete Œ≤ abv] ‚Üí CauSeq Œ≤ abv ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "Mul"],
  "name": "NonUnitalNonAssocRing.toMul",
  "constType": "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocRing Œ±] ‚Üí Mul Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "tangentConeAt",
   "closure",
   "Mathlib.Topology.Basic._auxLemma.26",
   "NormedAddCommGroup",
   "Submodule",
   "NontriviallyNormedField.toNormedField",
   "Set",
   "uniqueDiffWithinAt_iff",
   "AddCommGroup.toAddCommMonoid",
   "Eq.refl",
   "Dense",
   "NormedSpace",
   "Submodule.span",
   "True",
   "Submodule.instTopSubmodule",
   "Eq",
   "NormedField.toField",
   "Eq.mpr",
   "UniqueDiffWithinAt",
   "UniformSpace.toTopologicalSpace",
   "Submodule.span_univ",
   "Eq.trans",
   "id",
   "Membership.mem",
   "NontriviallyNormedField",
   "Top.top",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "tangentCone_univ",
   "Set.univ",
   "Set.instMembershipSet",
   "And",
   "DivisionSemiring.toSemiring",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "congr",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "congrArg",
   "and_self",
   "Submodule.setLike",
   "closure_univ",
   "SetLike.coe"],
  "name": "uniqueDiffWithinAt_univ",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {x : E}, UniqueDiffWithinAt ùïú Set.univ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedAddCommMonoid",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_7",
  "constType": "‚àÄ {Œ± : Type u_1} (x : Set Œ±), x ‚äì x·∂ú ‚â§ ‚ä•",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toDistribLattice",
  "constType": "{Œ± : Type u} ‚Üí [self : BooleanAlgebra Œ±] ‚Üí DistribLattice Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop ‚Üí Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "CommRing.toNonUnitalCommRing",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "HasFDerivAt",
   "NormedField.toNormedSpace",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "NontriviallyNormedField",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "One.toOfNat1",
   "FunLike.coe",
   "hasFDerivAtFilter_iff_hasDerivAtFilter",
   "NormedField.toNormedCommRing",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousMapClass.toFunLike"],
  "name": "hasFDerivAt_iff_hasDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {x : ùïú} {f' : ùïú ‚ÜíL[ùïú] F}, HasFDerivAt f f' x ‚Üî HasDerivAt f (f' 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "And",
   "OfNat.ofNat",
   "Field",
   "Field.toSemifield",
   "And.intro",
   "Semifield.toCommGroupWithZero",
   "And.casesOn",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "Field.toEuclideanDomain.match_1",
  "constType":
  "‚àÄ {K : Type u_1} [inst : Field K] (b c : K) (motive : c = 0 ‚àß b ‚â† 0 ‚Üí Prop) (x : c = 0 ‚àß b ‚â† 0),\n  (‚àÄ (left : c = 0) (hnb : b ‚â† 0), motive (_ : c = 0 ‚àß b ‚â† 0)) ‚Üí motive x",
  "constCategory": "Definition"},
 {"references": ["SeminormedAddCommGroup", "AddCommGroup"],
  "name": "SeminormedAddCommGroup.toAddCommGroup",
  "constType":
  "{E : Type u_9} ‚Üí [self : SeminormedAddCommGroup E] ‚Üí AddCommGroup E",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (self : Subtype p), p ‚Üëself",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Field",
   "Field.toInv",
   "Field.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "Field.zpow_neg'",
  "constType":
  "‚àÄ {K : Type u} [self : Field K] (n : ‚Ñï) (a : K), Field.zpow (Int.negSucc n) a = (Field.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["continuous_fst",
   "instTopologicalSpaceProd",
   "ContinuousAt",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "Continuous.continuousAt"],
  "name": "continuousAt_fst",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {p : Œ± √ó Œ≤},\n  ContinuousAt Prod.fst p",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_eq_of_add",
  "constType":
  "‚àÄ {G : Type u} [self : SubtractionMonoid G] (a b : G), a + b = 0 ‚Üí -a = b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{Œ± : Type u_9} ‚Üí\n  [toLattice : Lattice Œ±] ‚Üí\n    [toSupSet : SupSet Œ±] ‚Üí\n      (‚àÄ (s : Set Œ±), ‚àÄ a ‚àà s, a ‚â§ sSup s) ‚Üí\n        (‚àÄ (s : Set Œ±) (a : Œ±), (‚àÄ b ‚àà s, b ‚â§ a) ‚Üí sSup s ‚â§ a) ‚Üí\n          [toInfSet : InfSet Œ±] ‚Üí\n            (‚àÄ (s : Set Œ±), ‚àÄ a ‚àà s, sInf s ‚â§ a) ‚Üí\n              (‚àÄ (s : Set Œ±) (a : Œ±), (‚àÄ b ‚àà s, a ‚â§ b) ‚Üí a ‚â§ sInf s) ‚Üí\n                [toTop : Top Œ±] ‚Üí [toBot : Bot Œ±] ‚Üí (‚àÄ (x : Œ±), x ‚â§ ‚ä§) ‚Üí (‚àÄ (x : Œ±), ‚ä• ‚â§ x) ‚Üí CompleteLattice Œ±",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Exists",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "HSub.hSub",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GT.gt",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "instLENat",
   "Preorder.toLT",
   "LT.lt",
   "Ring.toSub",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat"],
  "name": "IsCauSeq",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : LinearOrderedField Œ±] ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : Ring Œ≤] ‚Üí (Œ≤ ‚Üí Œ±) ‚Üí (‚Ñï ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.instPartialOrderFilter",
   "le_refl",
   "Filter.Tendsto",
   "Filter",
   "id"],
  "name": "Filter.tendsto_id",
  "constType": "‚àÄ {Œ± : Type u} {x : Filter Œ±}, Filter.Tendsto id x x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Submodule",
  "constType":
  "(R : Type u) ‚Üí (M : Type v) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst : Module R M] ‚Üí Type v",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "SeminormedAddCommGroup.to_uniformAddGroup",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "UniformAddGroup.to_topologicalAddGroup",
   "PseudoMetricSpace.toUniformSpace",
   "SeminormedAddCommGroup",
   "UniformSpace.toTopologicalSpace",
   "SeminormedAddCommGroup.toSeminormedAddGroup",
   "SeminormedAddGroup.toAddGroup",
   "TopologicalAddGroup"],
  "name": "SeminormedAddCommGroup.toTopologicalAddGroup",
  "constType":
  "‚àÄ {E : Type u_6} [inst : SeminormedAddCommGroup E], TopologicalAddGroup E",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedCancelAddCommMonoid", "Ord"],
  "name": "LinearOrderedCancelAddCommMonoid.toOrd",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí Ord Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} ‚Üí {B : outParam (Type u_2)} ‚Üí [self : SetLike A B] ‚Üí A ‚Üí Set B",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "‚Ñï ‚Üí Type",
  "constCategory": "Other"},
 {"references":
  ["max_le",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_max_left",
   "eq_max",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "le_max_right",
   "Preorder.toLE",
   "Eq"],
  "name": "max_comm",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a b : Œ±), max a b = max b a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "Nat.succ",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_8",
  "constType":
  "‚àÄ (n : ‚Ñï) (a : ‚Ñù), zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "NormedField",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "SeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Module",
   "NormedSpace"],
  "name": "NormedSpace.toModule",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  {Œ≤ : Type u_6} ‚Üí [inst : NormedField Œ±] ‚Üí [inst_1 : SeminormedAddCommGroup Œ≤] ‚Üí [self : NormedSpace Œ± Œ≤] ‚Üí Module Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Field",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Field.toInv",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.inv_zero",
  "constType": "‚àÄ {K : Type u} [self : Field K], 0‚Åª¬π = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.intro",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.subset_inter",
  "constType": "‚àÄ {Œ± : Type u} {s t r : Set Œ±}, r ‚äÜ s ‚Üí r ‚äÜ t ‚Üí r ‚äÜ s ‚à© t",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "StrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.add_le_add_left",
  "constType":
  "‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{Œ± : Type u} ‚Üí [self : LT Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} ‚Üí [self : AddMonoidWithOne R] ‚Üí One R",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "IsROrC", "semiOutParam"],
  "name": "IsROrC.toDecidableEq",
  "constType":
  "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí DecidableEq K",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "HasStrictFDerivAt.hasFDerivAt",
   "NormedField.toNormedSpace",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "HasStrictDerivAt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "HasStrictDerivAt.proof_1",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "HasStrictDerivAt.proof_2",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasStrictDerivAt.hasDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú}, HasStrictDerivAt f f' x ‚Üí HasDerivAt f f' x",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M‚ÇÄ : Type u} ‚Üí [self : MonoidWithZero M‚ÇÄ] ‚Üí MulZeroOneClass M‚ÇÄ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedRing",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references": ["MetricSpace", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toMetricSpace",
  "constType": "{E : Type u_9} ‚Üí [self : NormedAddCommGroup E] ‚Üí MetricSpace E",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "DecidableEq"],
  "name": "LinearOrderedAddCommGroup.decidableEq",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí DecidableEq Œ±",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "InvolutiveNeg.mk"],
  "name": "SubtractionMonoid.toInvolutiveNeg",
  "constType": "{G : Type u} ‚Üí [self : SubtractionMonoid G] ‚Üí InvolutiveNeg G",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "‚àÄ {Œ± : Type u} [self : Lattice Œ±] (a b : Œ±), a ‚äì b ‚â§ a",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mul_pos",
  "constType":
  "‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{Œ± : Sort u} ‚Üí {Œ≤ : Sort v} ‚Üí {Œ¥ : Sort w} ‚Üí (Œ≤ ‚Üí Œ¥) ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Œ± ‚Üí Œ¥",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "BoundedSMul.dist_smul_pair'",
   "LE.le",
   "Dist.dist",
   "Zero.toOfNat0",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "HSMul.hSMul",
   "HMul.hMul",
   "PseudoMetricSpace",
   "BoundedSMul"],
  "name": "dist_smul_pair",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : Zero Œ±]\n  [inst_3 : Zero Œ≤] [inst_4 : SMul Œ± Œ≤] [inst_5 : BoundedSMul Œ± Œ≤] (x : Œ±) (y‚ÇÅ y‚ÇÇ : Œ≤),\n  dist (x ‚Ä¢ y‚ÇÅ) (x ‚Ä¢ y‚ÇÇ) ‚â§ dist x 0 * dist y‚ÇÅ y‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "And",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "Filter",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace",
   "instMembershipSetFilter"],
  "name": "MeasureTheory.Measure.FiniteAtFilter",
  "constType":
  "{Œ± : Type u_1} ‚Üí {_m0 : MeasurableSpace Œ±} ‚Üí MeasureTheory.Measure Œ± ‚Üí Filter Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} ‚Üí\n  [toNatCast : NatCast R] ‚Üí\n    [toAddMonoid : AddMonoid R] ‚Üí\n      [toOne : One R] ‚Üí\n        autoParam (NatCast.natCast 0 = 0) _auto‚úù ‚Üí\n          autoParam (‚àÄ (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto‚úù¬π ‚Üí AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references": ["Monoid"],
  "name": "MulAction",
  "constType":
  "(Œ± : Type u_10) ‚Üí Type u_11 ‚Üí [inst : Monoid Œ±] ‚Üí Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : LinearOrderedCommMonoidWithZero Œ±] ‚Üí Zero Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.liftLinear.proof_3",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "LinearMap.instFunLike",
   "RingHom.id",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.Measure.instModule",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "Semiring.toModule",
   "MeasureTheory.Measure.liftLinear.proof_1",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "IsScalarTower.right",
   "AddHom.mk",
   "LinearMap.mk",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddCommMagma.toAdd",
   "MeasureTheory.Measure.liftLinear.proof_2",
   "LE.le",
   "MeasurableSpace.instLEMeasurableSpace",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.toMeasure",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasureTheory.OuterMeasure.instModule",
   "Algebra.id",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.caratheodory"],
  "name": "MeasureTheory.Measure.liftLinear",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ≤] ‚Üí\n      {m0 : MeasurableSpace Œ±} ‚Üí\n        (f : MeasureTheory.OuterMeasure Œ± ‚Üí‚Çó[ENNReal] MeasureTheory.OuterMeasure Œ≤) ‚Üí\n          (‚àÄ (Œº : MeasureTheory.Measure Œ±), inst ‚â§ MeasureTheory.OuterMeasure.caratheodory (f ‚ÜëŒº)) ‚Üí\n            MeasureTheory.Measure Œ± ‚Üí‚Çó[ENNReal] MeasureTheory.Measure Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "ContinuousMul",
   "Prod.mk",
   "Continuous",
   "Continuous.prod_mk",
   "HMul.hMul",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "continuous_mul",
   "Mul",
   "Continuous.comp"],
  "name": "Continuous.mul",
  "constType":
  "‚àÄ {M : Type u_3} {X : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace M] [inst_2 : Mul M]\n  [inst_3 : ContinuousMul M] {f g : X ‚Üí M}, Continuous f ‚Üí Continuous g ‚Üí Continuous fun x => f x * g x",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Set", "MeasureTheory.OuterMeasure"],
  "name": "MeasureTheory.OuterMeasure.measureOf",
  "constType":
  "{Œ± : Type u_1} ‚Üí MeasureTheory.OuterMeasure Œ± ‚Üí Set Œ± ‚Üí ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["continuous_add",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Continuous",
   "Continuous.prod_mk",
   "TopologicalSpace",
   "Prod",
   "ContinuousAdd",
   "Prod.fst",
   "Add",
   "Continuous.comp"],
  "name": "Continuous.add",
  "constType":
  "‚àÄ {M : Type u_3} {X : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace M] [inst_2 : Add M]\n  [inst_3 : ContinuousAdd M] {f g : X ‚Üí M}, Continuous f ‚Üí Continuous g ‚Üí Continuous fun x => f x + g x",
  "constCategory": "Theorem"},
 {"references":
  ["add_lt_iff_neg_left",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "propext",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "AddZeroClass",
   "ContravariantClass",
   "Eq"],
  "name": "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.27",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : Œ±}, (a + b < a) = (b < 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Real",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "AddMonoid.toAddSemigroup",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instZeroAddMonoidHom",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Ring.toSemiring",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "congrFun"],
  "name": "Real.isROrC.proof_3",
  "constType": "‚àÄ (z : ‚Ñù), z + 0 z * 0 = z",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "TopologicalSpace.MetrizableSpace",
  "constType": "(X : Type u_5) ‚Üí [t : TopologicalSpace X] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "CovariantClass.elim"],
  "name": "add_le_add_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : LE Œ±]\n  [i : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {b c : Œ±},\n  b ‚â§ c ‚Üí ‚àÄ (a : Œ±), b + a ‚â§ c + a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "Semifield.toCommSemiring",
   "NormedField",
   "Algebra",
   "Field.toSemifield",
   "NormedAlgebra",
   "Ring.toSemiring"],
  "name": "NormedAlgebra.toAlgebra",
  "constType":
  "{ùïú : Type u_5} ‚Üí\n  {ùïú' : Type u_6} ‚Üí [inst : NormedField ùïú] ‚Üí [inst_1 : SeminormedRing ùïú'] ‚Üí [self : NormedAlgebra ùïú ùïú'] ‚Üí Algebra ùïú ùïú'",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "‚àÄ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.const.proof_1",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "IsCauSeq",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Nat",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Subtype.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.const",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : LinearOrderedField Œ±] ‚Üí\n      [inst_1 : Ring Œ≤] ‚Üí (abv : Œ≤ ‚Üí Œ±) ‚Üí [inst_2 : IsAbsoluteValue abv] ‚Üí Œ≤ ‚Üí CauSeq Œ≤ abv",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsOpen",
   "Iff.mpr",
   "continuous_def",
   "id"],
  "name": "continuous_id",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±], Continuous id",
  "constCategory": "Theorem"},
 {"references": ["Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.natAbs",
  "constType": "‚Ñ§ ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "SubNegMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "add_sub_assoc",
  "constType":
  "‚àÄ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + b - c = a + (b - c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MeasureTheory.OuterMeasure",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "setOf",
   "Set",
   "Union.union",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Bornology.ofBounded.proof_1",
   "Set.instMembershipSet",
   "Bornology.ofBounded.proof_2",
   "Bornology.ofBounded.proof_4",
   "Set.instHasSubsetSet",
   "Set.instSingletonSet",
   "Filter.mk",
   "Singleton.singleton",
   "Bornology.ofBounded.proof_3",
   "Bornology",
   "Set.instUnionSet",
   "Bornology.mk"],
  "name": "Bornology.ofBounded",
  "constType":
  "{Œ± : Type u_4} ‚Üí\n  (B : Set (Set Œ±)) ‚Üí\n    ‚àÖ ‚àà B ‚Üí (‚àÄ s‚ÇÅ ‚àà B, ‚àÄ s‚ÇÇ ‚äÜ s‚ÇÅ, s‚ÇÇ ‚àà B) ‚Üí (‚àÄ s‚ÇÅ ‚àà B, ‚àÄ s‚ÇÇ ‚àà B, s‚ÇÅ ‚à™ s‚ÇÇ ‚àà B) ‚Üí (‚àÄ (x : Œ±), {x} ‚àà B) ‚Üí Bornology Œ±",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "Max"],
  "name": "LinearOrderedAddCommGroup.toMax",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí Max Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.instSingletonSet",
   "forall_eq",
   "Real.instLEReal",
   "Set",
   "Real",
   "Real.instPreorderReal",
   "Singleton.singleton",
   "le_rfl",
   "Exists.intro",
   "LE.le",
   "Iff.mpr",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (z : Œ±), ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà {z} ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà {z} ‚Üí dist x y ‚â§ C",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "StrictOrderedRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.zero_le_one",
  "constType": "‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±], 0 ‚â§ 1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.MeasureTheory.Integral.IntegrableOn._hyg.83",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Order.Frame.inf_sSup_le_iSup_inf",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "Set.instMembershipSet",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_11",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a : Set Œ±) (s : Set (Set Œ±)), a ‚äì sSup s ‚â§ ‚®Ü b ‚àà s, a ‚äì b",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZeroHom.toZeroHom",
   "MulOneClass.toMul",
   "ZeroHom.toFun",
   "MulZeroOneClass.toMulOneClass",
   "MonoidWithZeroHomClass",
   "FunLike.mk",
   "MonoidWithZeroHom.map_one'",
   "MonoidWithZeroHom.monoidWithZeroHomClass.proof_2",
   "MonoidWithZeroHom.map_mul'",
   "MulZeroOneClass.toZero",
   "MonoidWithZeroHom",
   "MonoidWithZeroHomClass.mk",
   "MonoidWithZeroHom.monoidWithZeroHomClass.proof_1",
   "MulHomClass.mk",
   "MonoidHomClass.mk",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHom.monoidWithZeroHomClass",
  "constType":
  "{M : Type u_3} ‚Üí\n  {N : Type u_4} ‚Üí [inst : MulZeroOneClass M] ‚Üí [inst_1 : MulZeroOneClass N] ‚Üí MonoidWithZeroHomClass (M ‚Üí*‚ÇÄ N) M N",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.toZero",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.zpow_neg'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.inv_zero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommGroupWithZero.toNontrivial",
   "CommGroupWithZero.zpow_succ'",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommMonoidWithZero.zero_mul",
   "MonoidWithZero.mk",
   "CommGroupWithZero.toDiv",
   "GroupWithZero",
   "GroupWithZero.mk",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.zpow_zero'"],
  "name": "CommGroupWithZero.toGroupWithZero",
  "constType":
  "{G‚ÇÄ : Type u_4} ‚Üí [self : CommGroupWithZero G‚ÇÄ] ‚Üí GroupWithZero G‚ÇÄ",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≥ : Type v} ‚Üí [self : Membership Œ± Œ≥] ‚Üí Œ± ‚Üí Œ≥ ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.add_le_add_left",
   "LinearOrderedCancelAddCommMonoid.toOrd",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toMax",
   "LinearOrderedCancelAddCommMonoid.decidableLT",
   "LinearOrderedCancelAddCommMonoid.compare_eq_compareOfLessAndEq",
   "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrder.mk",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableEq",
   "LinearOrderedCancelAddCommMonoid.toMin",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedCancelAddCommMonoid.le_total",
   "LinearOrderedCancelAddCommMonoid.min_def",
   "LinearOrderedCancelAddCommMonoid.max_def",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí LinearOrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "Eq",
   "NormedRing",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_5",
  "constType": "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a : Œ±), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Real.borelSpace",
   "NormedAddCommGroup",
   "CompleteSpace",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real.measurableSpace",
   "Real",
   "Real.normedField",
   "intervalIntegral.integral_hasStrictDerivAt_right",
   "HasStrictDerivAt",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Real.locallyFinite_volume",
   "Continuous.continuousAt",
   "MetricSpace.toMetrizableSpace",
   "BorelSpace.opensMeasurable",
   "NormedAddCommGroup.toMetricSpace",
   "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace",
   "Continuous.stronglyMeasurableAtFilter",
   "Continuous",
   "Continuous.intervalIntegrable",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.measureSpace",
   "instSecondCountableTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpace",
   "secondCountableTopologyEither_of_left",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "Real.denselyNormedField",
   "DenselyNormedField.toNontriviallyNormedField"],
  "name": "Continuous.integral_hasStrictDerivAt",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ‚Ñù E] {f : ‚Ñù ‚Üí E},\n  Continuous f ‚Üí ‚àÄ (a b : ‚Ñù), HasStrictDerivAt (fun u => ‚à´ (x : ‚Ñù) in a..u, f x) (f b) b",
  "constCategory": "Theorem"},
 {"references": ["Acc"],
  "name": "Acc.intro",
  "constType":
  "‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} (x : Œ±), (‚àÄ (y : Œ±), r y x ‚Üí Acc r y) ‚Üí Acc r x",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_10",
  "constType": "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a : Œ±), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE",
   "Eq"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a b : MeasurableSpace Œ±), a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} ‚Üí [self : AddMonoid M] ‚Üí Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "_auto._@.Std.Data.Rat.Basic._hyg.33",
   "Rat",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "Int",
   "_auto._@.Std.Data.Rat.Basic._hyg.4",
   "Int.natAbs"],
  "name": "Rat.mk'",
  "constType":
  "(num : ‚Ñ§) ‚Üí (den : ‚Ñï) ‚Üí autoParam (den ‚â† 0) _auto‚úù ‚Üí autoParam (Nat.Coprime (Int.natAbs num) den) _auto‚úù¬π ‚Üí ‚Ñö",
  "constCategory": "Other"},
 {"references": ["SubtractionCommMonoid", "SubtractionMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} ‚Üí [self : SubtractionCommMonoid G] ‚Üí SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Min.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "inf_eq_minDefault",
   "Lattice.toInf",
   "IsTotal",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun‚ÇÇ",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_2",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : Lattice Œ±] [inst_1 : DecidableRel fun x x_1 => x ‚â§ x_1]\n  [inst_2 : IsTotal Œ± fun x x_1 => x ‚â§ x_1] (a b : Œ±), min a b = if a ‚â§ b then a else b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedLatticeAddCommGroup",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toLattice",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "inf_le_of_right_le",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inf_le_of_left_le",
   "Lattice.mk",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "instDistribLattice.match_1",
   "LE.le",
   "Preorder.toLE",
   "le_total",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "le_inf",
   "le_refl",
   "sup_le_sup_left",
   "inferInstanceAs",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "instDistribLattice.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (x b c : Œ±), (x ‚äî b) ‚äì (x ‚äî c) ‚â§ x ‚äî b ‚äì c",
  "constCategory": "Theorem"},
 {"references":
  ["nhds",
   "Eq.rec",
   "Continuous",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Continuous.tendsto",
   "Eq"],
  "name": "Continuous.tendsto'",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí ‚àÄ (x : Œ±) (y : Œ≤), f x = y ‚Üí Filter.Tendsto f (nhds x) (nhds y)",
  "constCategory": "Theorem"},
 {"references": ["SMul", "instHSMul", "HSMul.hSMul", "IsScalarTower", "Eq"],
  "name": "IsScalarTower.mk",
  "constType":
  "‚àÄ {M : Type u_10} {N : Type u_11} {Œ± : Type u_12} [inst : SMul M N] [inst_1 : SMul N Œ±] [inst_2 : SMul M Œ±],\n  (‚àÄ (x : M) (y : N) (z : Œ±), (x ‚Ä¢ y) ‚Ä¢ z = x ‚Ä¢ y ‚Ä¢ z) ‚Üí IsScalarTower M N Œ±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure",
   "And",
   "Exists",
   "Set",
   "TopologicalSpace",
   "MeasureTheory.Measure.restrict",
   "Filter",
   "_auto._@.Mathlib.MeasureTheory.Integral.IntegrableOn._hyg.83",
   "autoParam",
   "MeasurableSpace",
   "MeasureTheory.AEStronglyMeasurable",
   "instMembershipSetFilter"],
  "name": "StronglyMeasurableAtFilter",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí\n      [inst_1 : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Filter Œ± ‚Üí autoParam (MeasureTheory.Measure Œ±) _auto‚úù ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SMul",
  "constType": "Type u ‚Üí Type v ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Prod.snd",
   "PseudoEMetricSpace.toPseudoMetricSpaceOfDist",
   "Real",
   "PseudoMetricSpace.replaceBornology",
   "Real.instSupReal",
   "Prod.fst",
   "PseudoMetricSpace.toBornology",
   "Dist.dist",
   "PseudoMetricSpace.toDist",
   "Prod.pseudoEMetricSpaceMax",
   "Prod.pseudoMetricSpaceMax.proof_3",
   "Prod",
   "Sup.sup",
   "Prod.pseudoMetricSpaceMax.proof_1",
   "Prod.instBornology",
   "Prod.pseudoMetricSpaceMax.proof_2",
   "PseudoMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name": "Prod.pseudoMetricSpaceMax",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : PseudoMetricSpace Œ±] ‚Üí [inst : PseudoMetricSpace Œ≤] ‚Üí PseudoMetricSpace (Œ± √ó Œ≤)",
  "constCategory": "Definition"},
 {"references":
  ["Trans",
   "lt_of_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Trans.mk",
   "Preorder.toLE"],
  "name": "instTransLeToLELtToLT",
  "constType": "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí Trans LE.le LT.lt LT.lt",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "True",
   "max_def",
   "Eq",
   "ite",
   "le_of_not_le",
   "Eq.mpr",
   "if_pos",
   "of_eq_true",
   "Max.max",
   "LinearOrder.toMax",
   "Decidable",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_max_right",
  "constType": "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a b : Œ±), b ‚â§ max a b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "ContinuousLinearMap.toLinearMap",
   "instHSMul",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalRingHomClass.toMulHomClass",
   "RingHom.id",
   "LinearMap.smulRight",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid",
   "LinearMap.map_smul'",
   "AddHom.toFun",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "IsScalarTower",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero"],
  "name": "ContinuousLinearMap.smulRight.proof_1",
  "constType":
  "‚àÄ {M‚ÇÅ : Type u_2} [inst : TopologicalSpace M‚ÇÅ] [inst_1 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1} [inst_2 : AddCommMonoid M‚ÇÇ]\n  {R : Type u_3} {S : Type u_4} [inst_3 : Semiring R] [inst_4 : Semiring S] [inst_5 : Module R M‚ÇÅ]\n  [inst_6 : Module R M‚ÇÇ] [inst_7 : Module R S] [inst_8 : Module S M‚ÇÇ] [inst_9 : IsScalarTower R S M‚ÇÇ]\n  [inst_10 : TopologicalSpace S] (c : M‚ÇÅ ‚ÜíL[R] S) (f : M‚ÇÇ) (r : R) (x : M‚ÇÅ),\n  AddHom.toFun (LinearMap.smulRight (‚Üëc) f).toAddHom (r ‚Ä¢ x) =\n    (RingHom.id R) r ‚Ä¢ AddHom.toFun (LinearMap.smulRight (‚Üëc) f).toAddHom x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "setOf",
   "Set",
   "InfSet",
   "Set.instMembershipSet"],
  "name": "Set.instInfSetSet",
  "constType": "{Œ± : Type u_1} ‚Üí InfSet (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.mk",
   "CauSeq",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.mk",
  "constType": "CauSeq ‚Ñö abs ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "‚àÄ {Œ± : Sort u} (a : Œ±), HEq a a",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubNegZeroMonoid"],
  "name": "SubNegZeroMonoid.toSubNegMonoid",
  "constType": "{G : Type u_2} ‚Üí [self : SubNegZeroMonoid G] ‚Üí SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S‚ÇÄ : Type u} ‚Üí [self : SemigroupWithZero S‚ÇÄ] ‚Üí Semigroup S‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "add_le_add",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "Iff.mpr",
   "neg_le_abs_self",
   "Eq",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "Eq.rec",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "neg_add",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "instHAdd",
   "instDistribLattice",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "LE.le",
   "le_abs_self",
   "abs_le",
   "DistribLattice.toLattice",
   "neg_le",
   "And",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "And.intro",
   "NegZeroClass.toNeg",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] (a b : Œ±), |a + b| ‚â§ |a| + |b|",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "NonUnitalNonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : NonAssocRing Œ±] ‚Üí NonUnitalNonAssocRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "AddCommGroup.toAddCommMonoid",
   "Dist.dist",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "SMulWithZero.toSMulZeroClass",
   "DistribSMul.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "sub_zero",
   "Eq.trans",
   "BoundedSMul.mk",
   "SeminormedRing.toNonUnitalSeminormedRing",
   "DistribMulAction.toDistribSMul",
   "instHSub",
   "SeminormedAddGroup.toPseudoMetricSpace",
   "Module.toMulActionWithZero",
   "SMulZeroClass.toSMul",
   "instHMul",
   "SubNegZeroMonoid.toSubNegMonoid",
   "MulActionWithZero.toSMulWithZero",
   "Eq.mp",
   "congr",
   "Norm.norm",
   "MonoidWithZero.toZero",
   "SeminormedAddCommGroup.toSeminormedAddGroup",
   "congrArg",
   "BoundedSMul",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "SeminormedAddCommGroup",
   "SeminormedAddGroup.toNorm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SeminormedAddGroup.toAddGroup",
   "Zero.toOfNat0",
   "SeminormedAddCommGroup.toAddCommGroup",
   "SeminormedRing.toNorm",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "Ring.toSub",
   "AddGroup.toAddCancelMonoid",
   "SeminormedAddCommGroup.toNorm",
   "AddCommGroup.toAddGroup",
   "Module",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "AddRightCancelMonoid.toZero",
   "HSub.hSub",
   "SubNegZeroMonoid.toNegZeroClass",
   "dist_eq_norm",
   "sub_smul",
   "Ring.toSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "SeminormedRing",
   "PseudoMetricSpace.toDist",
   "SeminormedRing.toRing",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "smul_sub",
   "NegZeroClass.toZero"],
  "name": "BoundedSMul.of_norm_smul_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SeminormedRing Œ±] [inst_1 : SeminormedAddCommGroup Œ≤] [inst_2 : Module Œ± Œ≤],\n  (‚àÄ (r : Œ±) (x : Œ≤), ‚Äñr ‚Ä¢ x‚Äñ ‚â§ ‚Äñr‚Äñ * ‚Äñx‚Äñ) ‚Üí BoundedSMul Œ± Œ≤",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Not",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a b : (Filter Œ±)·µí·µà·µí·µà), a < b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_7",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a : Œ±), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["OmegaCompletePartialOrder.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
   "iSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "CompleteLattice",
   "instLENat",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "(Œ± : Type u) ‚Üí [inst : CompleteLattice Œ±] ‚Üí OmegaCompletePartialOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompletelyDistribLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{Œ± : Type u} ‚Üí [self : CompletelyDistribLattice Œ±] ‚Üí CompleteLattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.decidableLT",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Filter",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.univ_mem'",
  "constType":
  "‚àÄ {Œ± : Type u} {f : Filter Œ±} {s : Set Œ±}, (‚àÄ (a : Œ±), a ‚àà s) ‚Üí s ‚àà f",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "CommGroupWithZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommMonoidWithZero",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "Int",
   "Inv.inv"],
  "name": "CommGroupWithZero.mk",
  "constType":
  "{G‚ÇÄ : Type u_4} ‚Üí\n  [toCommMonoidWithZero : CommMonoidWithZero G‚ÇÄ] ‚Üí\n    [toInv : Inv G‚ÇÄ] ‚Üí\n      [toDiv : Div G‚ÇÄ] ‚Üí\n        autoParam (‚àÄ (a b : G‚ÇÄ), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí G‚ÇÄ ‚Üí G‚ÇÄ) ‚Üí\n            autoParam (‚àÄ (a : G‚ÇÄ), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : G‚ÇÄ), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : G‚ÇÄ), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  [toNontrivial : Nontrivial G‚ÇÄ] ‚Üí 0‚Åª¬π = 0 ‚Üí (‚àÄ (a : G‚ÇÄ), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí CommGroupWithZero G‚ÇÄ",
  "constCategory": "Other"},
 {"references":
  ["Metric.closedBall",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "ProperSpace",
   "UniformSpace.toTopologicalSpace",
   "IsCompact",
   "PseudoMetricSpace"],
  "name": "ProperSpace.mk",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±], (‚àÄ (x : Œ±) (r : ‚Ñù), IsCompact (Metric.closedBall x r)) ‚Üí ProperSpace Œ±",
  "constCategory": "Other"},
 {"references": ["SemilatticeSup", "PartialOrder"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : SemilatticeSup Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["MulZeroOneClass"],
  "name": "MonoidWithZeroHom",
  "constType":
  "(M : Type u_9) ‚Üí (N : Type u_10) ‚Üí [inst : MulZeroOneClass M] ‚Üí [inst : MulZeroOneClass N] ‚Üí Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{Œ± : Type u} ‚Üí [self : Sub Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["continuous_id",
   "DistribLattice.toLattice",
   "isOpen_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "continuous_const",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "TopologicalSpace",
   "OrderClosedTopology",
   "Set.Ioi",
   "IsOpen"],
  "name": "isOpen_Ioi",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±] {a : Œ±},\n  IsOpen (Set.Ioi a)",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "DivisionSemiring.toSemiring",
   "NormedSpace.mk",
   "NormedField",
   "NormedField.toNormedSpace.proof_1",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "Semifield.toDivisionSemiring",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "Semiring.toModule",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup"],
  "name": "NormedField.toNormedSpace",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : NormedField Œ±] ‚Üí NormedSpace Œ± Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Pi.partialOrder.proof_2",
   "Pi.partialOrder.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Pi.partialOrder.proof_3",
   "Preorder.toLT",
   "Pi.preorder",
   "Pi.partialOrder.proof_1",
   "Preorder",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder",
  "constType":
  "{Œπ : Type u_1} ‚Üí {œÄ : Œπ ‚Üí Type u_2} ‚Üí [inst : (i : Œπ) ‚Üí PartialOrder (œÄ i)] ‚Üí PartialOrder ((i : Œπ) ‚Üí œÄ i)",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MonoidWithZero M‚ÇÄ] ‚Üí Monoid M‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Preorder.le_refl",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} (a : MeasurableSpace Œ±), a ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "Semiring.toModule.proof_1",
  "constType": "‚àÄ {R : Type u_1} [inst : Semiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "inferInstance",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Submodule",
   "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "Semiring",
   "OrderBot.toBot",
   "OrderBot.bot_le",
   "OrderBot",
   "Module",
   "LE.le",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_13",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (a : Submodule R M), ‚ä• ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instSubReal",
   "Real",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Filter",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Neg.toHasAbs",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "UniformSpace.ofDist",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "uniformity",
   "of_eq_true",
   "Real.instAddGroupReal",
   "Prod",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_4",
  "constType": "uniformity ‚Ñù = uniformity ‚Ñù",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Real.instLTReal",
   "Subtype.val",
   "Real",
   "Subtype.ext",
   "Eq.refl",
   "Asymptotics.IsBigOWith",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
   "Asymptotics.IsLittleO",
   "rfl",
   "Eq",
   "Asymptotics.definition._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
   "Subtype.property",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Norm",
   "Eq.mpr",
   "Eq.ndrec",
   "LT.lt",
   "Filter",
   "Eq.symm",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "Asymptotics.IsLittleO_def",
  "constType":
  "‚àÄ {Œ± : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (l : Filter Œ±) (f : Œ± ‚Üí E)\n  (g : Œ± ‚Üí F), f =o[l] g = ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí Asymptotics.IsBigOWith c l f g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedAddGroup",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "sub_add_cancel",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id",
   "add_sub_assoc"],
  "name": "sub_add_sub_cancel",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - b + (b - c) = a - c",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "AddGroup.toSubtractionMonoid.proof_1",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid.proof_2",
   "SubtractionMonoid.mk"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} ‚Üí [inst : AddGroup G] ‚Üí SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "SMulZeroClass",
  "constType":
  "Type u_10 ‚Üí (A : Type u_11) ‚Üí [inst : Zero A] ‚Üí Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "PseudoMetricSpace.toDist",
   "dist_triangle",
   "dist_comm",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instLEReal",
   "Real",
   "dist_self",
   "LE.le",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "dist_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±}, 0 ‚â§ dist x y",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.mem_top",
   "Membership.mem",
   "Iff.mp",
   "Filter.instTopFilter",
   "Top.top",
   "Eq.rec",
   "Set",
   "Filter",
   "Eq.symm",
   "Set.univ",
   "Top.mk",
   "Filter.univ_mem",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instCompleteLatticeFilter.proof_11",
  "constType": "‚àÄ {Œ± : Type u_1} (x : Filter Œ±), ‚àÄ _s ‚àà ‚ä§, _s ‚àà x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_10",
  "constType":
  "‚àÄ {Œ± : Type u_1} (s : Set (Filter Œ±)·µí·µà·µí·µà) (a : (Filter Œ±)·µí·µà·µí·µà), (‚àÄ b ‚àà s, a ‚â§ b) ‚Üí a ‚â§ sInf s",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} ‚Üí [self : MulOneClass M] ‚Üí Mul M",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "‚Ñï ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_insert_iff",
   "Membership.mem",
   "Or",
   "propext",
   "Set",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.63",
  "constType":
  "‚àÄ {Œ± : Type u} {x a : Œ±} {s : Set Œ±}, (x ‚àà insert a s) = (x = a ‚à® x ‚àà s)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.dist_eq",
   "NormedAddCommGroup",
   "NormedAddCommGroup.mk",
   "NonUnitalNormedRing.toNorm",
   "NonUnitalNormedRing",
   "NonUnitalNormedRing.toMetricSpace",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNormedRing.toNormedAddCommGroup",
  "constType":
  "{Œ± : Type u_1} ‚Üí [Œ≤ : NonUnitalNormedRing Œ±] ‚Üí NormedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "Monoid.mk",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Semiring.npow_succ",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "HDiv.hDiv",
   "Real.strictOrderedRing",
   "Semigroup.mk",
   "StrictOrderedRing.toPartialOrder",
   "instHDiv",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "DivInvMonoid.div'",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_6",
  "constType": "‚àÄ (a b : ‚Ñù), a / b = a / b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "Real.normedField",
   "Real",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedSpace",
   "MeasurableSpace",
   "MeasureTheory.definition._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
   "Subtype",
   "Eq"],
  "name":
  "MeasureTheory.wrapped._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
  "constType": "Subtype (Eq @MeasureTheory.definition‚úù)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.zero_le_one",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [self : ZeroLEOneClass Œ±], 0 ‚â§ 1",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "SigmaCompactSpace",
  "constType": "(X : Type u_4) ‚Üí [inst : TopologicalSpace X] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Set.instBooleanAlgebraSet.proof_5",
   "Prop.booleanAlgebra",
   "EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "Set",
   "Inter.inter",
   "Set.instBooleanAlgebraSet.proof_17",
   "Lattice.mk",
   "LT.mk",
   "HasCompl.mk",
   "Sup.mk",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "inferInstance",
   "Inf.mk",
   "BooleanAlgebra.toHImp",
   "SDiff.mk",
   "Set.instBooleanAlgebraSet.proof_9",
   "Set.instBooleanAlgebraSet.proof_1",
   "Set.instBooleanAlgebraSet.proof_8",
   "Set.instBooleanAlgebraSet.proof_13",
   "Set.instBooleanAlgebraSet.proof_6",
   "Membership.mem",
   "Set.instBooleanAlgebraSet.proof_16",
   "setOf",
   "Union.union",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.instBooleanAlgebraSet.proof_4",
   "Set.univ",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "Set.instBooleanAlgebraSet.proof_7",
   "And",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet.proof_3",
   "Set.instBooleanAlgebraSet.proof_14",
   "Set.instBooleanAlgebraSet.proof_10",
   "Pi.booleanAlgebra",
   "Bot.mk",
   "Set.instBooleanAlgebraSet.proof_11",
   "Set.instBooleanAlgebraSet.proof_2",
   "Not",
   "Set.instBooleanAlgebraSet.proof_12",
   "Top.mk",
   "Set.instUnionSet",
   "Set.instBooleanAlgebraSet.proof_15",
   "Set.instInterSet"],
  "name": "Set.instBooleanAlgebraSet",
  "constType": "{Œ± : Type u} ‚Üí BooleanAlgebra (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.commRing",
   "Eq",
   "Real.instOneReal",
   "Eq.mpr",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "Eq.trans",
   "Ne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.ofCauchy.injEq",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "CommMagma.toMul",
   "CauSeq.Completion.inv_mul_cancel",
   "CauSeq.Completion.instZeroCauchy",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Mathlib.Data.Real.Basic._auxLemma.18",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Not",
   "LinearOrderedCommRing.mul_comm",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "congrFun",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "Abs.abs",
   "Inv.mk",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "mul_comm",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "CauSeq.Completion.instMulCauchy",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "Real.instZeroReal",
   "Eq.ndrec",
   "Mathlib.Data.Real.Basic._auxLemma.3",
   "Rat.divisionRing",
   "LinearOrderedCommRing.mk",
   "Real.linearOrderedCommRing",
   "Real.casesOn",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Real.instLinearOrderedFieldReal.proof_10",
  "constType": "‚àÄ (a : ‚Ñù), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toNatCast",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Rat.cast",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "LinearOrderedField.toRatCast",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Int.natAbs"],
  "name": "LinearOrderedField.ratCast_mk",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["Real.field",
   "inferInstance",
   "DivisionRing",
   "Real",
   "Field.toDivisionRing"],
  "name": "Real.instDivisionRingReal",
  "constType": "DivisionRing ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "NormedRing.dist_eq",
   "NormedCommRing",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedCommRing Œ±] (x y : Œ±), dist x y = ‚Äñx - y‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_2",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Or",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedRing.le_total",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{Œ± : Type u} ‚Üí [self : Neg Œ±] ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_9",
  "constType": "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a : Œ±), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.Icc",
   "IntervalIntegrable",
   "Real.lattice",
   "Real",
   "Real.measurableSpace",
   "HasSubset.Subset.trans",
   "Set",
   "Set.uIcc",
   "MeasureTheory.IntegrableOn",
   "Set.Icc_subset_uIcc",
   "MeasureTheory.Measure",
   "Set.instHasSubsetSet",
   "Set.Icc_subset_uIcc'",
   "Real.instPreorderReal",
   "Set.Ioc_subset_Icc_self",
   "And.intro",
   "Set.Ioc",
   "MeasureTheory.IntegrableOn.mono_set"],
  "name": "MeasureTheory.IntegrableOn.intervalIntegrable",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  MeasureTheory.IntegrableOn f (Set.uIcc a b) ‚Üí IntervalIntegrable f Œº a b",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul_neg'",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.mk",
   "SubtractionMonoid",
   "SubNegMonoid.mk",
   "SubNegMonoid.zsmul_zero'",
   "SubtractionMonoid.toSubNegZeroMonoid.proof_1"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : SubtractionMonoid Œ±] ‚Üí SubNegZeroMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "IsROrC.innerProductSpace",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "PiLp.seminormedAddCommGroup",
   "DenselyNormedField.toNormedField",
   "OrthonormalBasis",
   "IsROrC",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "ENNReal",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Semiring.toNonAssocSemiring",
   "Fintype",
   "LinearIsometryEquiv",
   "fact_one_le_two_ennreal",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "RingHomInvPair.ids",
   "IsROrC.toDenselyNormedField",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "EuclideanSpace.proof_1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "InnerProductSpace.toNormedSpace",
   "EuclideanSpace",
   "Field.toEuclideanDomain",
   "InnerProductSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "WithLp.instModule",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "Pi.module",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "OrthonormalBasis.repr",
  "constType":
  "{Œπ : Type u_1} ‚Üí\n  {ùïú : Type u_3} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      {E : Type u_4} ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst_2 : InnerProductSpace ùïú E] ‚Üí [inst_3 : Fintype Œπ] ‚Üí OrthonormalBasis Œπ ùïú E ‚Üí E ‚âÉ‚Çó·µ¢[ùïú] EuclideanSpace ùïú Œπ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction.mul_smul",
   "Eq.symm",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "smul_smul",
  "constType":
  "‚àÄ {M : Type u_1} {Œ± : Type u_6} [inst : Monoid M] [inst_1 : MulAction M Œ±] (a‚ÇÅ a‚ÇÇ : M) (b : Œ±),\n  a‚ÇÅ ‚Ä¢ a‚ÇÇ ‚Ä¢ b = (a‚ÇÅ * a‚ÇÇ) ‚Ä¢ b",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí StrictOrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup.toAddCancelMonoid.proof_3",
   "AddMonoid.nsmul",
   "AddGroup.toAddCancelMonoid.proof_1",
   "AddGroup.toAddCancelMonoid.proof_6",
   "AddGroup",
   "AddGroup.toAddCancelMonoid.proof_5",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid.proof_2",
   "AddGroup.toSubNegMonoid",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toAddCancelMonoid.proof_4"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} ‚Üí [inst : AddGroup G] ‚Üí AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_exists_eq_and", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.33",
  "constType":
  "‚àÄ {Œ± : Sort u_3} {Œ≤ : Sort u_2} {f : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Prop}, (‚àÉ b, (‚àÉ a, f a = b) ‚àß p b) = ‚àÉ a, p (f a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["And", "and_iff_left_of_imp", "Iff"],
  "name": "and_iff_left",
  "constType": "‚àÄ {b a : Prop}, b ‚Üí (a ‚àß b ‚Üî a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "SMul",
   "Monoid",
   "Monoid.toOne",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "One.toOfNat1",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mk",
  "constType":
  "{Œ± : Type u_10} ‚Üí\n  {Œ≤ : Type u_11} ‚Üí\n    [inst : Monoid Œ±] ‚Üí\n      [toSMul : SMul Œ± Œ≤] ‚Üí (‚àÄ (b : Œ≤), 1 ‚Ä¢ b = b) ‚Üí (‚àÄ (x y : Œ±) (b : Œ≤), (x * y) ‚Ä¢ b = x ‚Ä¢ y ‚Ä¢ b) ‚Üí MulAction Œ± Œ≤",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "nhds",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Eq.refl",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAtFilter",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAt._eq_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\n  (f' : E ‚ÜíL[ùïú] F) (x : E), HasFDerivAt f f' x = HasFDerivAtFilter f f' x (nhds x)",
  "constCategory": "Theorem"},
 {"references": ["Field", "NormedField"],
  "name": "NormedField.toField",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedField Œ±] ‚Üí Field Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "setOf",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "Set.compl_subset_compl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Bornology.ofBounded.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} (B : Set (Set Œ±)), (‚àÄ s‚ÇÅ ‚àà B, ‚àÄ s‚ÇÇ ‚äÜ s‚ÇÅ, s‚ÇÇ ‚àà B) ‚Üí ‚àÄ {x y : Set Œ±}, x ‚àà {s | s·∂ú ‚àà B} ‚Üí x ‚äÜ y ‚Üí y·∂ú ‚àà B",
  "constCategory": "Theorem"},
 {"references": ["Max", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toMax",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí Max Œ±",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Int"],
  "name": "DivisionRing.zpow",
  "constType": "{K : Type u} ‚Üí [self : DivisionRing K] ‚Üí ‚Ñ§ ‚Üí K ‚Üí K",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "‚àÄ {Œ± : Sort u} {a : Œ±}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{Œ± : Type u} ‚Üí [self : NonAssocSemiring Œ±] ‚Üí MulZeroOneClass Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulZeroOneClass.toMulOneClass",
   "MonoidWithZeroHomClass",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHomClass.toMonoidHomClass",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : MulZeroOneClass M] ‚Üí\n        [inst_1 : MulZeroOneClass N] ‚Üí [self : MonoidWithZeroHomClass F M N] ‚Üí MonoidHomClass F M N",
  "constCategory": "Definition"},
 {"references": ["CanonicallyOrderedCommSemiring", "Nat"],
  "name": "CanonicallyOrderedCommSemiring.npow",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : CanonicallyOrderedCommSemiring Œ±] ‚Üí ‚Ñï ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNatInt",
  "constType": "{n : ‚Ñï} ‚Üí OfNat ‚Ñ§ n",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Eq.refl",
   "congrArg‚ÇÇ",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "Eq",
   "Eq.mpr",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "Eq.trans",
   "id",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "one_add_one_eq_two",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "instNatAtLeastTwo",
   "HMul.hMul"],
  "name": "two_mul",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : NonAssocSemiring Œ±] (n : Œ±), 2 * n = n + n",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_3",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_1",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_2",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_6",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_5",
   "AddCommMonoid.mk",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalCommSemiring.mk",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_4",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [s : NonUnitalCommRing Œ±] ‚Üí NonUnitalCommSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.add_comm",
   "SubtractionCommMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddGroup",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "AddCommGroup",
   "SubtractionCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "SubtractionMonoid.mk"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType":
  "{G : Type u_1} ‚Üí [inst : AddCommGroup G] ‚Üí SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1375",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IntCast",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "MeasurableSpace",
  "constType": "Type u_7 ‚Üí Type u_7",
  "constCategory": "Other"},
 {"references":
  ["StrictMono.compares",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Function.Injective",
   "Ordering.Compares",
   "Preorder.toLT",
   "Ordering.eq",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Eq"],
  "name": "StrictMono.injective",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {f : Œ± ‚Üí Œ≤},\n  StrictMono f ‚Üí Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "instHAdd",
   "HAdd.hAdd",
   "Function.Injective.addMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddCommSemigroup.add_comm",
   "AddMonoid.mk",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "Eq",
   "Zero.toOfNat0",
   "Function.Injective.addCommSemigroup",
   "AddMonoid.nsmul_zero",
   "AddCommMonoid.mk",
   "Function.Injective",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "AddCommSemigroup",
   "HSMul.hSMul",
   "AddMonoid.zero_add",
   "AddCommSemigroup.toAddSemigroup",
   "Add",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "Function.Injective.addCommMonoid",
  "constType":
  "{M‚ÇÅ : Type u_1} ‚Üí\n  {M‚ÇÇ : Type u_2} ‚Üí\n    [inst : Add M‚ÇÅ] ‚Üí\n      [inst_1 : Zero M‚ÇÅ] ‚Üí\n        [inst_2 : SMul ‚Ñï M‚ÇÅ] ‚Üí\n          [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n            (f : M‚ÇÅ ‚Üí M‚ÇÇ) ‚Üí\n              Function.Injective f ‚Üí\n                f 0 = 0 ‚Üí\n                  (‚àÄ (x y : M‚ÇÅ), f (x + y) = f x + f y) ‚Üí (‚àÄ (x : M‚ÇÅ) (n : ‚Ñï), f (n ‚Ä¢ x) = n ‚Ä¢ f x) ‚Üí AddCommMonoid M‚ÇÅ",
  "constCategory": "Definition"},
 {"references": ["One", "OneHom"],
  "name": "OneHom.toFun",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : One M] ‚Üí [inst_1 : One N] ‚Üí OneHom M N ‚Üí M ‚Üí N",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "CompactIccSpace.isCompact_Icc",
   "Set.Icc",
   "Metric.closedBall",
   "instHAdd",
   "Set",
   "Real",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "PseudoMetricSpace.toUniformSpace",
   "HSub.hSub",
   "Eq.refl",
   "Real.pseudoMetricSpace",
   "ConditionallyCompleteLinearOrder.toCompactIccSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.instConditionallyCompleteLinearOrderReal",
   "Real.instPreorderReal",
   "ProperSpace",
   "UniformSpace.toTopologicalSpace",
   "IsCompact",
   "Real.closedBall_eq_Icc",
   "ProperSpace.mk",
   "id"],
  "name": "instProperSpaceRealPseudoMetricSpace",
  "constType": "ProperSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "SetLike.instPartialOrder",
   "inferInstance",
   "PartialOrder.toPreorder",
   "Submodule",
   "Top.top",
   "Semiring",
   "OrderTop.le_top",
   "OrderTop",
   "Module",
   "LE.le",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_12",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (a : Submodule R M), a ‚â§ ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.toReal",
   "Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instSubReal",
   "Real.instLEReal",
   "Real",
   "ENNReal.ofReal",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "ENNReal.coe_nnreal_eq",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Neg.toHasAbs",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "Subtype.mk",
   "ENNReal.ofNNReal",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_3",
  "constType":
  "‚àÄ (x y : ‚Ñù),\n  ‚Üë{ val := |x - y|, property := (_ : 0 ‚â§ |x - y|) } = ENNReal.ofReal ‚Üë{ val := |x - y|, property := (_ : 0 ‚â§ |x - y|) }",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "Or",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedAddCommGroup.le_total",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "not_congr",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "Nat.cast_ne_zero",
  "constType":
  "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ‚Ñï}, ‚Üën ‚â† 0 ‚Üî n ‚â† 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí [toLattice : Lattice Œ±] ‚Üí (‚àÄ (x y z : Œ±), (x ‚äî y) ‚äì (x ‚äî z) ‚â§ x ‚äî y ‚äì z) ‚Üí DistribLattice Œ±",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd", "AddSubmonoid", "AddZeroClass", "AddSubsemigroup"],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_4} ‚Üí [inst : AddZeroClass M] ‚Üí AddSubmonoid M ‚Üí AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "NatCast.natCast",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.natCast_succ",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "instHMul",
   "AddZeroClass.toZero",
   "MonoidHom.toOneHom",
   "HMul.hMul",
   "OneHom.mk",
   "MonoidHom.mk",
   "id"],
  "name": "RingHom.id.proof_3",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : NonAssocSemiring Œ±],\n  OneHom.toFun\n      (‚Üë{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ‚àÄ (x y : Œ±),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      0 =\n    OneHom.toFun\n      (‚Üë{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ‚àÄ (x y : Œ±),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "Eq",
   "NormedRing",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a b : Œ±), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "OrderedSemiring.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "OrderedCommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "OrderedCommSemiring",
   "StrictOrderedCommSemiring.mul_comm",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : StrictOrderedCommSemiring Œ±] ‚Üí OrderedCommSemiring Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "lt_add_of_pos_right",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "ENNReal.ofReal",
   "Real.instAddMonoidReal",
   "NormedLatticeAddCommGroup.orderClosedTopology",
   "AddGroup.toSubtractionMonoid",
   "Real.instOneReal",
   "AddZeroClass.toZero",
   "ENNReal",
   "Real.linearOrder",
   "MeasureTheory.OuterMeasure.measureOf",
   "Real.measureSpace",
   "Filter",
   "Eq.trans",
   "instHSub",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.Ioo",
   "Real.partialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "sub_lt_self",
   "OrderedSemiring.zeroLEOneClass",
   "PseudoMetricSpace.toUniformSpace",
   "Real.orderedSemiring",
   "And",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "Real.instAddGroupReal",
   "And.intro",
   "congrArg",
   "Real.normedLatticeAddCommGroup",
   "congrFun",
   "AddZeroClass.toAdd",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Real",
   "Set",
   "IsOpen.mem_nhds",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "MeasureTheory.MeasureSpace.volume",
   "True",
   "Real.volume_Ioo",
   "MeasureTheory.IsLocallyFiniteMeasure.mk",
   "Preorder.toLT",
   "AddGroup.toAddCancelMonoid",
   "zero_lt_one",
   "isOpen_Ioo",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "UniformSpace.toTopologicalSpace",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "MeasureTheory.IsLocallyFiniteMeasure",
   "instMembershipSetFilter",
   "Membership.mem",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Top.top",
   "nhds",
   "instHAdd",
   "HSub.hSub",
   "Real.pseudoMetricSpace",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Real.instPreorderReal",
   "CompleteLattice.toTop",
   "SubNegMonoid.toAddMonoid",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.1",
   "NegZeroClass.toZero"],
  "name": "Real.locallyFinite_volume",
  "constType": "MeasureTheory.IsLocallyFiniteMeasure MeasureTheory.volume",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalAddGroup.to_continuousSub",
   "SeminormedAddCommGroup.toTopologicalAddGroup",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "OrderClosedTopology.mk",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NormedLatticeAddCommGroup",
   "OrderClosedTopology",
   "NormedLatticeAddCommGroup.toOrderedAddCommGroup",
   "NormedLatticeAddCommGroup.toNormedAddCommGroup",
   "isClosed_nonneg",
   "isClosed_le_of_isClosed_nonneg",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedAddCommGroup.toNormedAddGroup",
   "UniformSpace.toTopologicalSpace"],
  "name": "NormedLatticeAddCommGroup.orderClosedTopology",
  "constType":
  "‚àÄ {E : Type u_2} [inst : NormedLatticeAddCommGroup E], OrderClosedTopology E",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "LE.le.trans",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mul_le_mul_of_nonneg_right",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulPosMono",
   "MulZeroClass.toMul"],
  "name": "mul_le_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} {a b c d : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulMono Œ±]\n  [inst_3 : MulPosMono Œ±], a ‚â§ b ‚Üí c ‚â§ d ‚Üí 0 ‚â§ c ‚Üí 0 ‚â§ b ‚Üí a * c ‚â§ b * d",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "NormedField.toField",
   "SeminormedCommRing.toSeminormedRing",
   "SMulWithZero.toSMulZeroClass",
   "NormedSpace.boundedSMul",
   "AddMonoid.toZero",
   "ContinuousSMul",
   "UniformSpace.toTopologicalSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "Module.toMulActionWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SMulZeroClass.toSMul",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "MulActionWithZero.toSMulWithZero",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "BoundedSMul.continuousSMul"],
  "name": "HasDerivAtFilter.proof_2",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F], ContinuousSMul ùïú F",
  "constCategory": "Theorem"},
 {"references": ["Zero", "ZeroHom"],
  "name": "ZeroHom.toFun",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : Zero M] ‚Üí [inst_1 : Zero N] ‚Üí ZeroHom M N ‚Üí M ‚Üí N",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.mul_one",
  "constType": "‚àÄ {Œ± : Type u} [self : NonAssocSemiring Œ±] (a : Œ±), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Preorder.le_refl",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} (a : (Filter Œ±)·µí·µà·µí·µà), a ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Field.mk",
   "LinearOrderedField.qsmul",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedRing.toNontrivial",
   "LinearOrderedField.inv_zero",
   "CommRing.mk",
   "LinearOrderedField.toDiv",
   "LinearOrderedField.ratCast_mk",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "Field",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedField.toRatCast",
   "LinearOrderedField.qsmul_eq_mul'",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "LinearOrderedField.zpow_neg'"],
  "name": "LinearOrderedField.toField",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí Field Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "Left.nonneg_neg_iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "LE",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {a : Œ±}, 0 ‚â§ -a ‚Üî a ‚â§ 0",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "AddHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.mk",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : Add M] ‚Üí\n        [inst_1 : Add N] ‚Üí\n          [toFunLike : FunLike F M fun x => N] ‚Üí (‚àÄ (f : F) (x y : M), f (x + y) = f x + f y) ‚Üí AddHomClass F M N",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} ‚Üí [self : AddGroup A] ‚Üí SubNegMonoid A",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Real.instDistribLatticeReal.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Inf.inf",
   "Real",
   "Real.instLEReal",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "Real.instInfReal",
   "Real.instSupReal",
   "Lattice.mk",
   "Real.instDistribLatticeReal.proof_5",
   "Real.instDistribLatticeReal.proof_6",
   "Sup.mk",
   "LE.le",
   "PartialOrder",
   "Preorder.mk",
   "Inf.mk",
   "DistribLattice",
   "Real.instDistribLatticeReal.proof_8",
   "Real.instDistribLatticeReal.proof_2",
   "Real.instDistribLatticeReal.proof_10",
   "Real.instDistribLatticeReal.proof_9",
   "Preorder.toLT",
   "Real.instDistribLatticeReal.proof_1",
   "Real.instDistribLatticeReal.proof_3",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.instDistribLatticeReal.proof_7"],
  "name": "Real.instDistribLatticeReal",
  "constType": "DistribLattice ‚Ñù",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["wrapped._@.Mathlib.Topology.Basic._hyg.10659",
   "TopologicalSpace",
   "Filter"],
  "name": "nhds",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Œ± ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "StrictOrderedRing.toNontrivial",
   "Nontrivial"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±], Nontrivial Œ±",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "SecondCountableTopologyEither",
  "constType":
  "(Œ± : Type u_6) ‚Üí (Œ≤ : Type u_7) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace", "MeasurableSpace"],
  "name": "OpensMeasurableSpace",
  "constType":
  "(Œ± : Type u_6) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [h : MeasurableSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNormedRing.toMetricSpace",
   "NonUnitalNormedRing.toNonUnitalRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq",
   "Dist.dist",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NonUnitalNormedRing.toNorm",
   "NonUnitalNormedRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNormedRing.dist_eq",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NonUnitalNormedRing Œ±] (x y : Œ±), dist x y = ‚Äñx - y‚Äñ",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Div"],
  "name": "DivisionRing.toDiv",
  "constType": "{K : Type u} ‚Üí [self : DivisionRing K] ‚Üí Div K",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} ‚Üí [self : AddCommMonoid M] ‚Üí AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí Min Œ±",
  "constCategory": "Definition"},
 {"references": ["Ring", "Sub"],
  "name": "Ring.toSub",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí Sub R",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring"],
  "name": "StarRing",
  "constType": "(R : Type u) ‚Üí [inst : NonUnitalNonAssocSemiring R] ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "Real.commRing",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "AddMonoid.toAddZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "AddMonoidHom.id",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField",
   "eq_self",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Ring.toSemiring",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_7",
  "constType":
  "‚àÄ (z w : ‚Ñù), 0 = (AddMonoidHom.id ‚Ñù) z * 0 + 0 * (AddMonoidHom.id ‚Ñù) w",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "zero_lt_two",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "two_pos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u ‚Üí Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Other"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{Œ± : Type u_1} ‚Üí {Œπ : Sort u_4} ‚Üí (Œπ ‚Üí Œ±) ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) ‚Üí Type v ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "RingHom",
   "MulOneClass.toMul",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "MonoidHom.map_mul'",
   "HMul.hMul",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.instRingHomClass.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (x_2 y : Œ±),\n  OneHom.toFun (‚Üë‚Üëf) (x_2 * y) = OneHom.toFun (‚Üë‚Üëf) x_2 * OneHom.toFun (‚Üë‚Üëf) y",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule",
   "Semiring",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Module",
   "AddSubmonoid",
   "AddCommMonoid"],
  "name": "Submodule.toAddSubmonoid",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Submodule R M ‚Üí AddSubmonoid M",
  "constCategory": "Definition"},
 {"references":
  ["BorelSpace",
   "BorelSpace.mk",
   "Real.measurableSpace",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "MeasurableSpace",
   "rfl"],
  "name": "Real.borelSpace",
  "constType": "BorelSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) ‚Üí Type v ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "‚àÄ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["SecondCountableTopologyEither",
   "inferInstance",
   "SecondCountableTopology",
   "Or.inl",
   "TopologicalSpace",
   "SecondCountableTopologyEither.mk"],
  "name": "secondCountableTopologyEither_of_left",
  "constType":
  "‚àÄ (Œ± : Type u_6) (Œ≤ : Type u_7) [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : SecondCountableTopology Œ±], SecondCountableTopologyEither Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "StrictOrderedRing.toNontrivial",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "HMul.hMul",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_1",
  "constType": "‚àÄ (a b c : ‚Ñù), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{Œ± : Type u} ‚Üí Œ± ‚Üí Zero Œ±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "mem_interior_iff_mem_nhds",
   "WeaklyLocallyCompactSpace",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "Exists.intro",
   "Set.univ",
   "isOpen_univ",
   "Set.instMembershipSet",
   "LocallyCompactSpace",
   "And",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "exists_compact_subset",
   "WeaklyLocallyCompactSpace.mk",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "IsCompact",
   "Set.mem_univ",
   "instWeaklyLocallyCompactSpace_1.match_1",
   "interior",
   "instMembershipSetFilter"],
  "name": "instWeaklyLocallyCompactSpace_1",
  "constType":
  "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X], WeaklyLocallyCompactSpace X",
  "constCategory": "Definition"},
 {"references": ["SMul", "Monoid", "MulAction"],
  "name": "MulAction.toSMul",
  "constType":
  "{Œ± : Type u_10} ‚Üí {Œ≤ : Type u_11} ‚Üí [inst : Monoid Œ±] ‚Üí [self : MulAction Œ± Œ≤] ‚Üí SMul Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "AddHomClass",
   "SemilinearMapClass",
   "Semiring",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "SemilinearMapClass.toAddHomClass",
  "constType":
  "{F : Type u_17} ‚Üí\n  {R : outParam (Type u_18)} ‚Üí\n    {S : outParam (Type u_19)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          {œÉ : outParam (R ‚Üí+* S)} ‚Üí\n            {M : outParam (Type u_20)} ‚Üí\n              {M‚ÇÇ : outParam (Type u_21)} ‚Üí\n                [inst_2 : AddCommMonoid M] ‚Üí\n                  [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                    [inst_4 : Module R M] ‚Üí\n                      [inst_5 : Module S M‚ÇÇ] ‚Üí [self : SemilinearMapClass F œÉ M M‚ÇÇ] ‚Üí AddHomClass F M M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{Œ± : Type u_1} ‚Üí [self : DistribLattice Œ±] ‚Üí Lattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "MulZeroClass.mk",
  "constType":
  "{M‚ÇÄ : Type u} ‚Üí\n  [toMul : Mul M‚ÇÄ] ‚Üí [toZero : Zero M‚ÇÄ] ‚Üí (‚àÄ (a : M‚ÇÄ), 0 * a = 0) ‚Üí (‚àÄ (a : M‚ÇÄ), a * 0 = 0) ‚Üí MulZeroClass M‚ÇÄ",
  "constCategory": "Other"},
 {"references": ["AddZeroClass"],
  "name": "AddSubmonoid",
  "constType": "(M : Type u_4) ‚Üí [inst : AddZeroClass M] ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references": ["SMul"],
  "name": "IsScalarTower",
  "constType":
  "(M : Type u_10) ‚Üí (N : Type u_11) ‚Üí (Œ± : Type u_12) ‚Üí [inst : SMul M N] ‚Üí [inst : SMul N Œ±] ‚Üí [inst : SMul M Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Filter", "instMembershipSetFilter"],
  "name": "Filter.Eventually",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Prop) ‚Üí Filter Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "Ring.toNeg",
   "instAddNat",
   "instHAdd",
   "Int.negSucc",
   "HAdd.hAdd",
   "Ring.toIntCast",
   "Ring",
   "instOfNatNat",
   "Neg.neg",
   "Nat",
   "Ring.toSemiring",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_negSucc",
  "constType":
  "‚àÄ {R : Type u} [self : Ring R] (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra.smul_def'",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def",
  "constType":
  "‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r ‚Ä¢ x = (algebraMap R A) r * x",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "TopologicalSpace.induced"],
  "name": "instTopologicalSpaceProd",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [t‚ÇÅ : TopologicalSpace Œ±] ‚Üí [t‚ÇÇ : TopologicalSpace Œ≤] ‚Üí TopologicalSpace (Œ± √ó Œ≤)",
  "constCategory": "Definition"},
 {"references":
  ["Real.instAddCommGroupReal",
   "NormedAddCommGroup",
   "NormedAddCommGroup.mk",
   "Real.metricSpace",
   "Real",
   "Real.normedAddCommGroup.proof_1",
   "Real.norm"],
  "name": "Real.normedAddCommGroup",
  "constType": "NormedAddCommGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : OrderedAddCommMonoid Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "Eq"],
  "name": "AddGroupWithOne.add_left_neg",
  "constType": "‚àÄ {R : Type u} [self : AddGroupWithOne R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.765",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_3",
  "constType": "‚àÄ {Œ± : Type u_1} (a : Set Œ±), a ‚â§ ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLE",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí DecidableRel fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalRing"],
  "name": "NonUnitalRing.toNonUnitalNonAssocRing",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : NonUnitalRing Œ±] ‚Üí NonUnitalNonAssocRing Œ±",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{Œ± : Type u} ‚Üí {x : ‚Ñï} ‚Üí Œ± ‚Üí OfNat Œ± x",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubNegZeroMonoid",
  "constType": "Type u_2 ‚Üí Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "HAdd.hAdd",
   "Set",
   "Set.inter_comm",
   "LinearMap.instFunLike",
   "Inter.inter",
   "RingHom.id",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Mathlib.MeasureTheory.Measure.Restrict._auxLemma.1",
   "MeasurableSet",
   "Eq.trans",
   "LinearMap",
   "Semiring.toModule",
   "id",
   "Mathlib.MeasureTheory.Measure.Restrict._auxLemma.2",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "IsScalarTower.right",
   "instHAdd",
   "MeasureTheory.le_toOuterMeasure_caratheodory",
   "Set.instSDiffSet",
   "MeasureTheory.OuterMeasure.restrict_apply",
   "SDiff.sdiff",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NonUnitalNonAssocSemiring.toDistrib",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "congr",
   "MeasureTheory.OuterMeasure.instModule",
   "Algebra.id",
   "congrArg",
   "MeasureTheory.OuterMeasure",
   "MeasureTheory.OuterMeasure.restrict",
   "MeasurableSpace",
   "Set.instInterSet"],
  "name": "MeasureTheory.Measure.restrict‚Çó.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} (s : Set Œ±) (Œº : MeasureTheory.Measure Œ±) (s' : Set Œ±),\n  MeasurableSet s' ‚Üí\n    ‚àÄ (t : Set Œ±),\n      ‚Üë((MeasureTheory.OuterMeasure.restrict s) ‚ÜëŒº) t =\n        ‚Üë((MeasureTheory.OuterMeasure.restrict s) ‚ÜëŒº) (t ‚à© s') + ‚Üë((MeasureTheory.OuterMeasure.restrict s) ‚ÜëŒº) (t \\ s')",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup",
   "CompleteSpace",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "deriv",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Eq",
   "HasDerivAt.deriv",
   "HasStrictDerivAt.hasDerivAt",
   "Continuous",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.measureSpace",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "Continuous.integral_hasStrictDerivAt",
   "DenselyNormedField.toNontriviallyNormedField",
   "Real.denselyNormedField"],
  "name": "Continuous.deriv_integral",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ‚Ñù E] (f : ‚Ñù ‚Üí E),\n  Continuous f ‚Üí ‚àÄ (a b : ‚Ñù), deriv (fun u => ‚à´ (x : ‚Ñù) in a..u, f x) b = f b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "‚àÄ {Œ± : Type u} [self : Semiring Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["NormedCommRing.toSeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "IsROrC.toDenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NormedField.toNormedCommRing",
   "NormedAlgebra",
   "semiOutParam"],
  "name": "IsROrC.toNormedAlgebra",
  "constType":
  "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí NormedAlgebra ‚Ñù K",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.mk",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.npow",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "OrderedCommMonoid.toCovariantClassLeft",
   "Zero.toOfNat0",
   "mul_le_mul_left'",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedCommSemiring Œ±] (a b c : Œ±), a ‚â§ b ‚Üí 0 ‚â§ c ‚Üí c * a ‚â§ c * b",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) ‚Üí [inst : Add G] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : AddZeroClass M] ‚Üí [inst_1 : AddZeroClass N] ‚Üí [self : AddMonoidHomClass F M N] ‚Üí AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Real",
   "Preorder"],
  "name": "Real.instPreorderReal",
  "constType": "Preorder ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Neg.toHasAbs",
   "instHSub",
   "Set",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "Eq.refl",
   "Bornology.cobounded",
   "Real.instSupReal",
   "abs_sub_le",
   "Real.instLinearOrderedAddCommGroupReal",
   "Abs.abs",
   "Eq",
   "Real.instNegReal",
   "Real.linearOrder",
   "Real.instAddGroupReal",
   "Bornology.ofDist",
   "abs_sub_comm"],
  "name": "Real.pseudoMetricSpace.proof_5",
  "constType": "(Bornology.cobounded ‚Ñù).sets = (Bornology.cobounded ‚Ñù).sets",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ± √ó Œ≤",
  "constCategory": "Other"},
 {"references": ["NormedAddCommGroup", "IsROrC"],
  "name": "InnerProductSpace",
  "constType":
  "(ùïú : Type u_4) ‚Üí (E : Type u_5) ‚Üí [inst : IsROrC ùïú] ‚Üí [inst : NormedAddCommGroup E] ‚Üí Type (max u_4 u_5)",
  "constCategory": "Other"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.6260",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.6260",
  "constType": "Subtype (Eq Real.definition‚úù)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "Module.toMulActionWithZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsScalarTower",
   "NormedSpace",
   "NormedField.toField",
   "Monoid.toMulAction",
   "DivisionSemiring.toSemiring",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NegZeroClass.toZero",
   "MulActionWithZero.toMulAction",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "HasStrictDerivAt.proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F], IsScalarTower ùïú ùïú F",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule",
   "Semiring",
   "Set.insert_eq",
   "Union.union",
   "Set",
   "Eq.refl",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.completeLattice",
   "Submodule.span",
   "Insert.insert",
   "Submodule.span_union",
   "Eq",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Sup.sup",
   "Singleton.singleton",
   "Module",
   "Lattice.toSemilatticeSup",
   "Set.instUnionSet",
   "id",
   "AddCommMonoid",
   "Set.instInsertSet"],
  "name": "Submodule.span_insert",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x : M)\n  (s : Set M), Submodule.span R (insert x s) = Submodule.span R {x} ‚äî Submodule.span R s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} ‚Üí [toZero : Zero M] ‚Üí [toAdd : Add M] ‚Üí (‚àÄ (a : M), 0 + a = a) ‚Üí (‚àÄ (a : M), a + 0 = a) ‚Üí AddZeroClass M",
  "constCategory": "Other"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : ConditionallyCompleteLattice Œ±] ‚Üí Lattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "LT.lt.not_le",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "GT.gt",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "le_of_not_gt",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "mul_neg_of_pos_of_neg",
   "MulZeroClass.toZero",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "MonoidWithZero.toZero"],
  "name": "nonneg_of_mul_nonneg_right",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrderedSemiring Œ±] {a b : Œ±}, 0 ‚â§ a * b ‚Üí 0 < a ‚Üí 0 ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí [inst : Add M] ‚Üí [inst_1 : Add N] ‚Üí [self : AddHomClass F M N] ‚Üí FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references":
  ["StronglyMeasurableAtFilter",
   "CompleteSpace",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Real.measurableSpace",
   "Real.normedField",
   "Real",
   "Inf.inf",
   "continuousAt_fst",
   "NormedSpace",
   "intervalIntegral.FTCFilter.nhds",
   "MeasureTheory.MeasureSpace.volume",
   "NormedRing.toNonUnitalNormedRing",
   "Filter.Tendsto",
   "Real.measureSpace",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "MeasureTheory.Measure.ae",
   "continuousAt_snd",
   "Real.denselyNormedField",
   "IntervalIntegrable",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HasStrictDerivAt",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "Prod.fst",
   "NormedField.toNormedCommRing",
   "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Prod.mk",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Filter.instInfFilter",
   "Prod",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "DenselyNormedField.toNontriviallyNormedField"],
  "name": "intervalIntegral.integral_hasStrictDerivAt_of_tendsto_ae_right",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ‚Ñù E] {f : ‚Ñù ‚Üí E} {c : E}\n  {a b : ‚Ñù},\n  IntervalIntegrable f MeasureTheory.volume a b ‚Üí\n    StronglyMeasurableAtFilter f (nhds b) ‚Üí\n      Filter.Tendsto f (nhds b ‚äì MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) ‚Üí\n        HasStrictDerivAt (fun u => ‚à´ (x : ‚Ñù) in a..u, f x) c b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "NormedField",
   "Semifield.toCommSemiring",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Algebra.smul_def'",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.id",
   "Algebra.toSMul"],
  "name": "NormedAlgebra.id.proof_2",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NormedField ùïú] (r x : ùïú), r ‚Ä¢ x = Algebra.toRingHom r * x",
  "constCategory": "Theorem"},
 {"references": ["DenselyNormedField", "IsROrC", "semiOutParam"],
  "name": "IsROrC.toDenselyNormedField",
  "constType":
  "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí DenselyNormedField K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Abs", "Abs.mk", "Sup", "Neg.neg", "Sup.sup", "Neg"],
  "name": "Neg.toHasAbs",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Neg Œ±] ‚Üí [inst : Sup Œ±] ‚Üí Abs Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} ‚Üí [toAddGroup : AddGroup G] ‚Üí (‚àÄ (a b : G), a + b = b + a) ‚Üí AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "Subtype"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instHSMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Submodule.subset_span",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "one_smul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "AddCommMonoid",
   "add_smul",
   "Submodule.smul_mem",
   "Semiring",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Set.instMembershipSet",
   "SMulZeroClass.toSMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Iff.intro",
   "instHMul",
   "MulActionWithZero.toSMulWithZero",
   "MulAction.toSMul",
   "of_eq_true",
   "HEq.refl",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Singleton.singleton",
   "MonoidWithZero.toZero",
   "congrArg",
   "Submodule.setLike",
   "congrFun",
   "zero_smul",
   "Exists",
   "HEq",
   "Submodule",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "Submodule.span",
   "True",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "AddMonoid.toZero",
   "Module",
   "smul_smul",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "Membership.mem",
   "eq_self",
   "instHAdd",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "Eq.ndrec",
   "Submodule.span_induction",
   "HMul.hMul",
   "Eq.casesOn"],
  "name": "Submodule.mem_span_singleton",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x y : M},\n  x ‚àà Submodule.span R {y} ‚Üî ‚àÉ a, a ‚Ä¢ y = x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHom.id.proof_2",
  "constType":
  "‚àÄ (M : Type u_1) [inst : AddZeroClass M] (x x_1 : M),\n  ZeroHom.toFun { toFun := fun x => x, map_zero' := (_ : (fun x => x) 0 = (fun x => x) 0) } (x + x_1) =\n    ZeroHom.toFun { toFun := fun x => x, map_zero' := (_ : (fun x => x) 0 = (fun x => x) 0) } (x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "mul_le_mul_of_nonneg_left",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toPosMulMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : StrictOrderedSemiring Œ±] (x x_1 x_2 : Œ±), x ‚â§ x_1 ‚Üí 0 ‚â§ x_2 ‚Üí x_2 * x ‚â§ x_2 * x_1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.sprod",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : SProd Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} ‚Üí [inst : Zero R] ‚Üí R ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "lt_add_one",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddMonoidWithOne",
   "Eq.mpr",
   "NeZero",
   "one_add_one_eq_two",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "LT.lt",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "id"],
  "name": "one_lt_two",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1], 1 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "False.elim",
   "EmptyCollection.emptyCollection",
   "Real.instLEReal",
   "Set",
   "Real",
   "Set.instEmptyCollectionSet",
   "Exists.intro",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù), ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà ‚àÖ ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà ‚àÖ ‚Üí dist x y ‚â§ C",
  "constCategory": "Theorem"},
 {"references":
  ["Real.borelSpace",
   "pure_le_nhds",
   "tendstoIocClassNhds",
   "PartialOrder.toPreorder",
   "nhds",
   "Real",
   "Real.measurableSpace",
   "intervalIntegral.FTCFilter.mk",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "le_rfl",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "BorelSpace.opensMeasurable",
   "outParam",
   "intervalIntegral.FTCFilter",
   "Real.instPreorderReal",
   "Filter.instPartialOrderFilter",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "nhds_isMeasurablyGenerated"],
  "name": "intervalIntegral.FTCFilter.nhds",
  "constType": "‚àÄ (a : ‚Ñù), intervalIntegral.FTCFilter a (nhds a) (nhds a)",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "Set.instHasSubsetSet",
   "setOf",
   "Submodule",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "HasSubset.Subset",
   "Module",
   "Submodule.setLike",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.span",
  "constType":
  "(R : Type u_1) ‚Üí\n  {M : Type u_4} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Set M ‚Üí Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} ‚Üí [self : AddMonoid M] ‚Üí AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "nhds",
   "Set",
   "ContinuousAt",
   "Set.univ",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Logic.Basic._auxLemma.43",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Continuous",
   "TopologicalSpace",
   "congr",
   "Filter",
   "Filter.Tendsto",
   "nhdsWithin",
   "ContinuousOn",
   "congrArg",
   "Eq.trans",
   "Mathlib.Topology.ContinuousOn._auxLemma.29",
   "nhdsWithin_univ",
   "congrFun"],
  "name": "continuous_iff_continuousOn_univ",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üî ContinuousOn f Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "InvolutiveNeg.neg_neg",
   "Neg.neg",
   "Eq"],
  "name": "neg_neg",
  "constType": "‚àÄ {G : Type u_1} [inst : InvolutiveNeg G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "And",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "DenselyNormedField",
   "DenselyNormedField.toNormedField",
   "Norm.norm",
   "LE.le",
   "NormedField.toNorm"],
  "name": "DenselyNormedField.lt_norm_lt",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : DenselyNormedField Œ±] (x y : ‚Ñù), 0 ‚â§ x ‚Üí x < y ‚Üí ‚àÉ a, x < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < y",
  "constCategory": "Definition"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{Œ± : Type u} ‚Üí Array Œ± ‚Üí Œ± ‚Üí Array Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "CommRing.toRing",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "CommRing",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "CommRing.toNonUnitalCommRing.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (n : ‚Ñï) (a : Œ±), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (‚Üë(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.zero_le_one",
  "constType": "‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±], 0 ‚â§ 1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "LinearOrder.decidableLE",
   "LinearOrder.max_def",
   "Field.toNontrivial",
   "Field.zpow_neg'",
   "Field.zpow",
   "Field.toRatCast",
   "Rat.instLinearOrderedFieldRat.proof_2",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Field.mul_inv_cancel",
   "Field",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Rat.linearOrder",
   "Field.ratCast_mk",
   "LinearOrder",
   "Semiring",
   "StrictOrderedRing.mk",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Field.toInv",
   "Rat.semiring",
   "Rat.field",
   "Rat.instLinearOrderedFieldRat.proof_1",
   "LinearOrder.toOrd",
   "Rat.instLinearOrderedFieldRat.proof_3",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "Field.inv_zero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "Field.qsmul",
   "LinearOrderedRing.mk",
   "Rat.instLinearOrderedFieldRat.proof_4",
   "Field.div_eq_mul_inv"],
  "name": "Rat.instLinearOrderedFieldRat",
  "constType": "LinearOrderedField ‚Ñö",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "LinearOrderedRing",
   "DecidableEq",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toStrictOrderedRing : StrictOrderedRing Œ±] ‚Üí\n    [toMin : Min Œ±] ‚Üí\n      [toMax : Max Œ±] ‚Üí\n        [toOrd : Ord Œ±] ‚Üí\n          (‚àÄ (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a) ‚Üí\n            (decidableLE : DecidableRel fun x x_1 => x ‚â§ x_1) ‚Üí\n              (decidableEq : DecidableEq Œ±) ‚Üí\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) ‚Üí\n                  autoParam (‚àÄ (a b : Œ±), min a b = if a ‚â§ b then a else b) _auto‚úù ‚Üí\n                    autoParam (‚àÄ (a b : Œ±), max a b = if a ‚â§ b then b else a) _auto‚úù¬π ‚Üí\n                      autoParam (‚àÄ (a b : Œ±), compare a b = compareOfLessAndEq a b) _auto‚úù¬≤ ‚Üí LinearOrderedRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.le_sup_right",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_6",
  "constType": "‚àÄ {Œ± : Type u_1} (a b : (Filter Œ±)·µí·µà·µí·µà), b ‚â§ a ‚äî b",
  "constCategory": "Theorem"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1339", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.mul",
  "constType": "‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Not",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a b : MeasurableSpace Œ±), a < b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.le_sSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "CompleteLattice.sInf_le",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "OrderTop.toTop",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "OrderDual.completeLattice.proof_4",
   "CompleteLattice.sSup_le",
   "OrderDual.completeLattice.proof_1",
   "Lattice.toSemilatticeSup",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "OrderDual.completeLattice.proof_2",
   "OrderDual.infSet",
   "InfSet",
   "OrderDual.completeLattice.proof_5",
   "SupSet.sSup",
   "OrderDual.instLEOrderDual",
   "OrderDual.supSet",
   "OrderDual.boundedOrder",
   "SupSet",
   "InfSet.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice.proof_3",
   "OrderBot.toBot",
   "OrderDual",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderDual.lattice"],
  "name": "OrderDual.completeLattice",
  "constType":
  "(Œ± : Type u_1) ‚Üí [inst : CompleteLattice Œ±] ‚Üí CompleteLattice Œ±·µí·µà",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup",
   "NontriviallyNormedField",
   "NontriviallyNormedField.toNormedField",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "HasDerivAt.differentiableAt",
   "deriv",
   "DifferentiableAt.hasDerivAt",
   "NormedSpace",
   "HasDerivAt",
   "Eq",
   "HasDerivAt.unique"],
  "name": "HasDerivAt.deriv",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {f' : F} {x : ùïú}, HasDerivAt f f' x ‚Üí deriv f x = f'",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "Real.measurableSpace",
   "Real",
   "StieltjesFunction",
   "StieltjesFunction.wrapped._@.Mathlib.MeasureTheory.Measure.Stieltjes._hyg.3510"],
  "name": "StieltjesFunction.measure",
  "constType": "StieltjesFunction ‚Üí MeasureTheory.Measure ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "SMulWithZero",
  "constType":
  "(R : Type u_1) ‚Üí (M : Type u_3) ‚Üí [inst : Zero R] ‚Üí [inst : Zero M] ‚Üí Type (max u_1 u_3)",
  "constCategory": "Other"},
 {"references": ["Filter", "Bornology"],
  "name": "Bornology.cobounded'",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Bornology Œ±] ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "EmptyCollection.emptyCollection",
   "false_or_iff",
   "Union.union",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.instUnionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.empty_union",
  "constType": "‚àÄ {Œ± : Type u} (a : Set Œ±), ‚àÖ ‚à™ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Bot.bot",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.bot_le",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toBot",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_12",
  "constType": "‚àÄ {Œ± : Type u_1} (x : (Filter Œ±)·µí·µà·µí·µà), ‚ä• ‚â§ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PseudoMetricSpace",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "ENNReal.covariantClass_add_le",
   "OrderedSemiring.zeroLEOneClass",
   "instENNRealAddCommMonoidWithOne",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "one_le_two",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "Preorder.toLE",
   "ENNReal.instCompleteLinearOrderENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Fact.mk",
   "OrderedCommSemiring.toOrderedSemiring",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Fact",
   "instOfNat"],
  "name": "fact_one_le_two_ennreal",
  "constType": "Fact (1 ‚â§ 2)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_assoc",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a b c : Œ±), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "SupSet.mk",
   "Set.instMembershipSet"],
  "name": "Set.instSupSetSet",
  "constType": "{Œ± : Type u_1} ‚Üí SupSet (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.re",
   "Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC.conj_re",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "IsROrC.ext",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "IsROrC.mul_re",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "congr",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Mathlib.Tactic.Ring.sub_pf",
   "Field.toCommRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "Monoid.toNatPow",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Ring.toAddGroupWithOne",
   "IsROrC.toDenselyNormedField",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "AddHomClass.toFunLike",
   "MonoidHomClass.toMulHomClass",
   "Mathlib.Tactic.Ring.mul_add",
   "Field.toSemifield",
   "Neg.neg",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidHom",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.instMulReal",
   "Real.instSubReal",
   "Semifield.toCommSemiring",
   "Real.instAddReal",
   "Real.commRing",
   "MulZeroClass.mul_zero",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "IsROrC.ofReal_re",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "IsROrC.conj_im",
   "MonoidWithZeroHom",
   "Nat",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.rawCast",
   "IsROrC.normSq",
   "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "EuclideanDomain.toCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "Field.toEuclideanDomain",
   "CommRing.toRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "IsROrC.im",
   "Int.ofNat",
   "IsROrC.ofReal_im",
   "RingHom",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "CommRing.toNonUnitalCommRing",
   "IsROrC.toStarRing",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoid.toAddMonoid",
   "IsROrC.ofReal_add",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "starRingEnd",
   "instHPow",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "instHAdd",
   "HSub.hSub",
   "map_add",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "IsROrC.ofReal_mul",
   "IsROrC.ofReal",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "AddMonoidHom.addMonoidHomClass",
   "IsROrC.mul_im"],
  "name": "IsROrC.mul_conj",
  "constType":
  "‚àÄ {K : Type u_1} [inst : IsROrC K] (z : K), z * (starRingEnd K) z = ‚Üë(IsROrC.normSq z)",
  "constCategory": "Theorem"},
 {"references": ["Field", "RatCast"],
  "name": "Field.toRatCast",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí RatCast K",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup",
   "AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.toSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroup.mk",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "SubNegMonoid.mk",
   "AddGroupWithOne.add_left_neg",
   "AddGroupWithOne.sub_eq_add_neg"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} ‚Üí [self : AddGroupWithOne R] ‚Üí AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí [toRing : Ring Œ±] ‚Üí (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí CommRing Œ±",
  "constCategory": "Other"},
 {"references": ["NormedAddCommGroup", "NormedLatticeAddCommGroup"],
  "name": "NormedLatticeAddCommGroup.toNormedAddCommGroup",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : NormedLatticeAddCommGroup Œ±] ‚Üí NormedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a b c : Œ±), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "CommGroupWithZero",
   "Semifield.toCommSemiring",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "Semifield.mul_inv_cancel",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semifield",
   "Semifield.toInv",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Semifield.toNontrivial",
   "CommMonoidWithZero.mk",
   "CommMonoid.mk",
   "Semigroup.mk",
   "CommGroupWithZero.mk",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.zpow",
   "Semifield.zpow_neg'",
   "Semiring.toOne",
   "Semifield.zpow_zero'",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield.inv_zero"],
  "name": "Semifield.toCommGroupWithZero",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Semifield Œ±] ‚Üí CommGroupWithZero Œ±",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±}, a ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "AddZeroClass.toAdd",
   "Submodule.completeLattice.proof_5",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "AddSubsemigroup.mk",
   "PartialOrder.toPreorder",
   "Submodule",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "SupSet.mk",
   "AddCommMonoid.toAddMonoid",
   "Submodule.completeLattice.proof_11",
   "Lattice.mk",
   "OrderBot",
   "Submodule.completeLattice.proof_2",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Submodule.completeLattice.proof_6",
   "Submodule.completeLattice.proof_13",
   "Preorder.toLE",
   "OrderTop.toTop",
   "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "inferInstance",
   "Inf.mk",
   "Submodule.completeLattice.proof_9",
   "Submodule.completeLattice.proof_1",
   "Submodule.completeLattice.proof_4",
   "AddSubmonoid.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "Semiring",
   "SemilatticeSup.mk",
   "Submodule.completeLattice.proof_8",
   "LE.le",
   "Submodule.completeLattice.proof_12",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "CompleteLattice",
   "Submodule.completeLattice.proof_10",
   "Submodule.completeLattice.proof_3",
   "OrderBot.toBot",
   "Submodule.mk",
   "Set.iInter",
   "OrderTop",
   "Submodule.completeLattice.proof_7",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí\n    [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí CompleteLattice (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Exists", "Set", "Set.instMembershipSet"],
  "name": "Set.Nonempty",
  "constType": "{Œ± : Type u_1} ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Decidable", "LinearOrder.decidableEq", "Eq"],
  "name": "instDecidableEq",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : LinearOrder Œ±] ‚Üí (a b : Œ±) ‚Üí Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "setOf",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Set.compl_subset_compl",
   "MeasurableSpace",
   "MeasureTheory.measure_mono_null"],
  "name": "MeasureTheory.Measure.ae.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) {x y : Set Œ±},\n  x ‚àà {s | ‚Üë‚ÜëŒº s·∂ú = 0} ‚Üí x ‚äÜ y ‚Üí ‚Üë‚ÜëŒº y·∂ú = 0",
  "constCategory": "Theorem"},
 {"references": ["UniformSpace"],
  "name": "CompleteSpace",
  "constType": "(Œ± : Type u) ‚Üí [inst : UniformSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonAssocSemiring Œ±] ‚Üí AddCommMonoidWithOne Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toNeg",
   "HasDistribNeg.mk",
   "HasDistribNeg",
   "AddCommGroup.toAddGroup",
   "Neg.neg",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
   "AddGroup.toSubNegMonoid",
   "InvolutiveNeg.mk",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : NonUnitalNonAssocRing Œ±] ‚Üí HasDistribNeg Œ±",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{Œ± : Type u} ‚Üí [self : Semiring Œ±] ‚Üí NonUnitalSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Set",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAtFilter",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "nhdsWithin",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "HasFDerivWithinAt",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup F] ‚Üí [inst_4 : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí (E ‚ÜíL[ùïú] F) ‚Üí Set E ‚Üí E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "Metric.closedBall",
   "Real.instLEReal",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSupReal",
   "abs_sub_le_iff",
   "Preorder.toLE",
   "Eq",
   "Dist.dist",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "instHSub",
   "instDistribLattice",
   "Set.mem_Icc",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "propext",
   "OrderedAddCommGroup.toAddCommGroup",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Set.Icc",
   "sub_le_iff_le_add'",
   "Real.dist_eq",
   "dist_comm",
   "Iff.rfl",
   "Real",
   "Set",
   "Eq.refl",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Metric.mem_closedBall",
   "Abs.abs",
   "Real.instNegReal",
   "Set.ext",
   "Real.instAddCommGroupReal",
   "sub_le_comm",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "Membership.mem",
   "instHAdd",
   "HSub.hSub",
   "Real.pseudoMetricSpace",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "PseudoMetricSpace.toDist",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg"],
  "name": "Real.closedBall_eq_Icc",
  "constType": "‚àÄ {x r : ‚Ñù}, Metric.closedBall x r = Set.Icc (x - r) (x + r)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.neg_add_rev",
   "Eq"],
  "name": "neg_add_rev",
  "constType":
  "‚àÄ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references": ["Finset", "Multiset", "Multiset.Nodup"],
  "name": "Finset.mk",
  "constType":
  "{Œ± : Type u_4} ‚Üí (val : Multiset Œ±) ‚Üí Multiset.Nodup val ‚Üí Finset Œ±",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.OuterMeasure.addCommMonoid",
   "MeasureTheory.Measure.zero_toOuterMeasure",
   "MeasureTheory.Measure.add_toOuterMeasure",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "MeasureTheory.Measure.instSMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MeasureTheory.Measure.instAddCommMonoid.proof_2",
   "AddMonoid.toNatSMul",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.instZero",
   "MeasureTheory.Measure.instAdd",
   "MeasureTheory.Measure.instAddCommMonoid.proof_1",
   "Function.Injective.addCommMonoid",
   "Nat",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "AddCommMonoid"],
  "name": "MeasureTheory.Measure.instAddCommMonoid",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí AddCommMonoid (MeasureTheory.Measure Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Submodule",
   "Semiring",
   "Finset.toSet",
   "Finset",
   "Module",
   "Submodule.span",
   "Eq",
   "AddCommMonoid"],
  "name": "Submodule.FG",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_2} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Submodule R M ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "Ord"],
  "name": "LinearOrderedAddCommGroup.toOrd",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí Ord Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing Œ±] ‚Üí (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí NonUnitalNonAssocCommRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "NormedField.toNormedSpace",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "HasStrictFDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "HasStrictDerivAt.proof_1",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "HasStrictDerivAt.proof_2",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasStrictDerivAt",
  "constType":
  "{ùïú : Type u} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {F : Type v} ‚Üí [inst_1 : NormedAddCommGroup F] ‚Üí [inst : NormedSpace ùïú F] ‚Üí (ùïú ‚Üí F) ‚Üí F ‚Üí ùïú ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{Œ± : Type u} ‚Üí [self : Union Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "‚àÄ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Norm", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNorm",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NonUnitalSeminormedRing Œ±] ‚Üí Norm Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup",
   "Real",
   "Real.normedField",
   "Real.measurableSpace",
   "HSub.hSub",
   "MeasureTheory.Measure.restrict",
   "NormedSpace",
   "AddGroup.toSubNegMonoid",
   "MeasureTheory.integral",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.instPreorderReal",
   "NormedAddCommGroup.toNormedAddGroup",
   "Set.Ioc"],
  "name": "intervalIntegral",
  "constType":
  "{E : Type u_3} ‚Üí\n  [inst : NormedAddCommGroup E] ‚Üí [inst : NormedSpace ‚Ñù E] ‚Üí (‚Ñù ‚Üí E) ‚Üí ‚Ñù ‚Üí ‚Ñù ‚Üí MeasureTheory.Measure ‚Ñù ‚Üí E",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ‚Ñï) ‚Üí OfNat ‚Ñï n",
  "constCategory": "Definition"},
 {"references": ["continuous_id", "Continuous", "TopologicalSpace"],
  "name": "continuous_id'",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±], Continuous fun x => x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "NormedField",
   "Real.instMulReal",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Dist.dist",
   "Field.toCommRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Field",
   "Ring.toSub",
   "CommRing.toRing",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedField.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toNorm : Norm Œ±] ‚Üí\n    [toField : Field Œ±] ‚Üí\n      [toMetricSpace : MetricSpace Œ±] ‚Üí\n        (‚àÄ (x y : Œ±), dist x y = ‚Äñx - y‚Äñ) ‚Üí (‚àÄ (a b : Œ±), ‚Äña * b‚Äñ = ‚Äña‚Äñ * ‚Äñb‚Äñ) ‚Üí NormedField Œ±",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "HasCompl",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "CompleteLattice.toBot",
   "iSup",
   "autoParam",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8834",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8800",
   "HasCompl.compl",
   "SDiff.sdiff",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "Sup.sup"],
  "name": "CompleteAtomicBooleanAlgebra.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toCompletelyDistribLattice : CompletelyDistribLattice Œ±] ‚Üí\n    (‚àÄ (x y z : Œ±), (x ‚äî y) ‚äì (x ‚äî z) ‚â§ x ‚äî y ‚äì z) ‚Üí\n      [toHasCompl : HasCompl Œ±] ‚Üí\n        [toSDiff : SDiff Œ±] ‚Üí\n          [toHImp : HImp Œ±] ‚Üí\n            (‚àÄ (x : Œ±), x ‚äì x·∂ú ‚â§ ‚ä•) ‚Üí\n              (‚àÄ (x : Œ±), ‚ä§ ‚â§ x ‚äî x·∂ú) ‚Üí\n                autoParam (‚àÄ (x y : Œ±), x \\ y = x ‚äì y·∂ú) _auto‚úù ‚Üí\n                  autoParam (‚àÄ (x y : Œ±), x ‚á® y = y ‚äî x·∂ú) _auto‚úù¬π ‚Üí\n                    (‚àÄ (a : Œ±) (s : Set Œ±), a ‚äì sSup s ‚â§ ‚®Ü b ‚àà s, a ‚äì b) ‚Üí\n                      (‚àÄ (a : Œ±) (s : Set Œ±), ‚®Ö b ‚àà s, a ‚äî b ‚â§ a ‚äî sInf s) ‚Üí CompleteAtomicBooleanAlgebra Œ±",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.mk",
  "constType":
  "{G : Type u} ‚Üí\n  [toSubNegMonoid : SubNegMonoid G] ‚Üí\n    (‚àÄ (x : G), - -x = x) ‚Üí (‚àÄ (a b : G), -(a + b) = -b + -a) ‚Üí (‚àÄ (a b : G), a + b = 0 ‚Üí -a = b) ‚Üí SubtractionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "Eq.refl",
   "NormedSpace",
   "Asymptotics.IsLittleO",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "NormedAddGroup.toAddGroup",
   "HasFDerivAtFilter",
   "Filter",
   "NormedAddCommGroup.toNorm",
   "UniformSpace.toTopologicalSpace",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "instHSub",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "HSub.hSub",
   "Field.toSemifield",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "AddGroup.toSubNegMonoid",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedAddCommGroup.toNormedAddGroup",
   "NormedSpace.toModule",
   "ContinuousMapClass.toFunLike"],
  "name":
  "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAtFilter._eq_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\n  (f' : E ‚ÜíL[ùïú] F) (x : E) (L : Filter E),\n  HasFDerivAtFilter f f' x L = (fun x' => f x' - f x - f' (x' - x)) =o[L] fun x' => x' - x",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} ‚Üí [toAddSemigroup : AddSemigroup G] ‚Üí (‚àÄ (a b c : G), a + b = a + c ‚Üí b = c) ‚Üí AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["And", "Exists", "DenselyOrdered", "LT.lt", "LT", "DenselyOrdered.dense"],
  "name": "exists_between",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : DenselyOrdered Œ±] {a‚ÇÅ a‚ÇÇ : Œ±}, a‚ÇÅ < a‚ÇÇ ‚Üí ‚àÉ a, a‚ÇÅ < a ‚àß a < a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "MeasureTheory.Measure",
   "OfNat.ofNat",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.instZero",
   "MeasureTheory.OuterMeasure.instZero",
   "MeasureTheory.OuterMeasure",
   "rfl",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.Measure.zero_toOuterMeasure",
  "constType": "‚àÄ {Œ± : Type u_1} {_m : MeasurableSpace Œ±}, ‚Üë0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "SetLike.instPartialOrder",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "Module",
   "LE.le",
   "Preorder.toLE",
   "Submodule.setLike",
   "Set.biInter_subset_of_mem",
   "Set.instMembershipSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name":
  "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {S : Set (Submodule R M)} {p : Submodule R M}, p ‚àà S ‚Üí sInf S ‚â§ p",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "Ring",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "DivisionRing",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int.natAbs",
   "Inv.inv"],
  "name": "DivisionRing.mk",
  "constType":
  "{K : Type u} ‚Üí\n  [toRing : Ring K] ‚Üí\n    [toInv : Inv K] ‚Üí\n      [toDiv : Div K] ‚Üí\n        autoParam (‚àÄ (a b : K), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí K ‚Üí K) ‚Üí\n            autoParam (‚àÄ (a : K), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : K), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : K), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  [toNontrivial : Nontrivial K] ‚Üí\n                    [toRatCast : RatCast K] ‚Üí\n                      (‚àÄ (a : K), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí\n                        0‚Åª¬π = 0 ‚Üí\n                          autoParam\n                              (‚àÄ (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                                ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π)\n                              _auto‚úù‚Å¥ ‚Üí\n                            (qsmul : ‚Ñö ‚Üí K ‚Üí K) ‚Üí\n                              autoParam (‚àÄ (a : ‚Ñö) (x : K), qsmul a x = ‚Üëa * x) _auto‚úù‚Åµ ‚Üí DivisionRing K",
  "constCategory": "Other"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Classical.choose",
   "Classical.indefiniteDescription"],
  "name": "Classical.choose_spec",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (h : ‚àÉ x, p x), p (Classical.choose h)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.Tendsto.eventually",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "dist_triangle",
   "mul_le_mul",
   "Real.instAddMonoidReal",
   "add_le_add_right",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "MulZeroClass.toMul",
   "Dist.dist",
   "Real.linearOrder",
   "Continuous.add",
   "Continuous.mul",
   "Real.strictOrderedSemiring",
   "HSMul.hSMul",
   "LinearOrderedField.toTopologicalDivisionRing",
   "LinearOrderedField.toLinearOrderedSemifield",
   "le_of_lt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Prod.snd",
   "TopologicalSemiring.toContinuousMul",
   "dist_smul_pair",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "And",
   "Prod.casesOn",
   "propext",
   "LT.lt",
   "congr",
   "LinearOrderedSemiField.toDenselyOrdered",
   "And.intro",
   "OrderedSemiring.toMulPosMono",
   "OrderedSemiring.toPosMulMono",
   "congrFun",
   "BoundedSMul.continuousSMul.match_1",
   "AddZeroClass.toAdd",
   "Exists",
   "Real",
   "Eq.refl",
   "dist_pair_smul",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "True",
   "zero_add",
   "continuous_add_right",
   "UniformSpace.toTopologicalSpace",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Metric.continuous_iff",
   "Real.instLTReal",
   "LE.le.trans",
   "instTransLeToLE",
   "LE.le",
   "Real.instDivisionRingReal",
   "Eq.ndrec",
   "Prod.mk",
   "Real.instPreorderReal",
   "TopologicalSemiring.toContinuousAdd",
   "Prod",
   "max_lt_iff",
   "Real.orderedAddCommGroup",
   "StrictOrderedSemiring.toNoMaxOrder",
   "Filter.Eventually.exists_gt",
   "instHSMul",
   "gt_mem_nhds",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real.commRing",
   "add_le_add",
   "dist_nonneg",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff.mp",
   "Continuous",
   "And.casesOn",
   "Eq.trans",
   "continuous_mul_left",
   "instTopologicalSpaceProd",
   "Lattice.toSemilatticeInf",
   "Prod.fst",
   "Real.orderedSemiring",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "DistribLattice.toLattice",
   "instHMul",
   "of_eq_true",
   "Real.orderedAddCommMonoid",
   "LinearOrder.toMax",
   "nhdsWithin_Ioi_self_neBot",
   "congrArg",
   "add_zero",
   "BoundedSMul",
   "instTransLeToLELtToLT",
   "Zero",
   "Real.instLinearOrderedFieldReal",
   "SMul",
   "Prod.pseudoMetricSpaceMax",
   "Continuous.tendsto'",
   "CommRing.toNonUnitalCommRing",
   "MulZeroClass.zero_mul",
   "Zero.toOfNat0",
   "Preorder.toLT",
   "TopologicalRing.toTopologicalSemiring",
   "MulZeroClass.toZero",
   "continuous_id'",
   "ContinuousSMul",
   "id",
   "eq_self",
   "LT.lt.le",
   "nhds",
   "instHAdd",
   "Real.pseudoMetricSpace",
   "SemilatticeInf.toPartialOrder",
   "ContinuousSMul.mk",
   "GT.gt",
   "Real.instZeroReal",
   "PseudoMetricSpace.toDist",
   "Max.max",
   "le_refl",
   "HMul.hMul",
   "TopologicalDivisionRing.toTopologicalRing"],
  "name": "BoundedSMul.continuousSMul",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : Zero Œ±]\n  [inst_3 : Zero Œ≤] [inst_4 : SMul Œ± Œ≤] [inst_5 : BoundedSMul Œ± Œ≤], ContinuousSMul Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["NormedLatticeAddCommGroup.mk",
   "instHasSolidNormRealNormedAddCommGroupLattice",
   "Real.normedLatticeAddCommGroup.proof_1",
   "Real.lattice",
   "Real",
   "NormedLatticeAddCommGroup",
   "Real.normedAddCommGroup"],
  "name": "Real.normedLatticeAddCommGroup",
  "constType": "NormedLatticeAddCommGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Ring.toAddGroupWithOne",
   "AddGroup",
   "Real",
   "Real.instRingReal",
   "AddGroupWithOne.toAddGroup"],
  "name": "Real.instAddGroupReal",
  "constType": "AddGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "‚àÄ {p : Prop}, p = True ‚Üí p",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "Membership.mem",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "AddSubmonoid.instTopAddSubmonoid",
   "OfNat.ofNat",
   "Top.top",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name": "Submodule.instTopSubmodule.proof_2",
  "constType": "‚àÄ {M : Type u_1} [inst : AddCommMonoid M], 0 ‚àà ‚ä§.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "Eq",
   "NormedRing.toNonUnitalNormedRing",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "SMulWithZero.toSMulZeroClass",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "MulActionWithZero.toMulAction",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace.toUniformSpace",
   "NormedCommRing.toNormedRing",
   "HasFDerivAt.unique",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Module.toMulActionWithZero",
   "EuclideanDomain.toCommRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "HasDerivAt",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "ContinuousLinearMap.smulRight_one_eq_iff",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "BoundedSMul.continuousSMul",
   "NormedAddCommGroup.toAddCommGroup",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommRing.toNonUnitalCommRing",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "HasDerivAt.hasFDerivAt",
   "IsScalarTower.left",
   "AddMonoid.toZero",
   "NormedSpace.boundedSMul",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "Semiring.toModule",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAt.unique",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {f‚ÇÄ' f‚ÇÅ' : F} {x : ùïú}, HasDerivAt f f‚ÇÄ' x ‚Üí HasDerivAt f f‚ÇÅ' x ‚Üí f‚ÇÄ' = f‚ÇÅ'",
  "constCategory": "Theorem"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{Œ± : Sort u} ‚Üí [self : Inhabited Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "Sub",
   "autoParam",
   "AddMonoid",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Int",
   "Neg"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} ‚Üí\n  [toAddMonoid : AddMonoid G] ‚Üí\n    [toNeg : Neg G] ‚Üí\n      [toSub : Sub G] ‚Üí\n        autoParam (‚àÄ (a b : G), a - b = a + -b) _auto‚úù ‚Üí\n          (zsmul : ‚Ñ§ ‚Üí G ‚Üí G) ‚Üí\n            autoParam (‚àÄ (a : G), zsmul 0 a = 0) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : G), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : G), zsmul (Int.negSucc n) a = -zsmul (‚Üë(Nat.succ n)) a) _auto‚úù¬≥ ‚Üí\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references": ["Zero", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toZero",
  "constType": "{M‚ÇÄ : Type u} ‚Üí [self : MulZeroOneClass M‚ÇÄ] ‚Üí Zero M‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "UniformSpace",
   "UniformSpace.ofDist.proof_1",
   "Real.orderedAddCommMonoid",
   "instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "UniformSpace.ofFun",
   "LE.le",
   "Eq"],
  "name": "UniformSpace.ofDist",
  "constType":
  "{Œ± : Type u} ‚Üí\n  (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) ‚Üí\n    (‚àÄ (x : Œ±), dist x x = 0) ‚Üí\n      (‚àÄ (x y : Œ±), dist x y = dist y x) ‚Üí (‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) ‚Üí UniformSpace Œ±",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{Œ± : Type u} ‚Üí [self : HasSubset Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.re",
   "Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "ZeroHom.mk",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "IsROrC.normSq.proof_1",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZeroHom",
   "IsROrC.toDenselyNormedField",
   "instHAdd",
   "AddHomClass.toFunLike",
   "Field.toSemifield",
   "FunLike.coe",
   "IsROrC.normSq.proof_3",
   "MulZeroOneClass.toZero",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Real.semiring",
   "HMul.hMul",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.normSq.proof_2",
   "IsROrC.im",
   "MonoidWithZeroHom.mk"],
  "name": "IsROrC.normSq",
  "constType": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí K ‚Üí*‚ÇÄ ‚Ñù",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u ‚Üí Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["RingEquiv", "Add", "Mul"],
  "name": "RingAut",
  "constType": "(R : Type u_1) ‚Üí [inst : Mul R] ‚Üí [inst : Add R] ‚Üí Type u_1",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Add Œ±",
  "constCategory": "Other"},
 {"references": ["NormedRing", "Ring"],
  "name": "NormedRing.toRing",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedRing Œ±] ‚Üí Ring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "propext",
   "Continuous",
   "Set",
   "Eq.mp",
   "Eq.refl",
   "TopologicalSpace",
   "continuous_iff_continuousOn_univ",
   "ContinuousOn.mono",
   "ContinuousOn",
   "Set.univ",
   "Set.subset_univ",
   "Eq"],
  "name": "Continuous.continuousOn",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±},\n  Continuous f ‚Üí ContinuousOn f s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R], ‚Üë1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "‚àÄ {Œ± : Sort u} {a b c : Œ±}, a = b ‚Üí b = c ‚Üí a = c",
  "constCategory": "Theorem"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} ‚Üí [self : AddCommSemigroup G] ‚Üí AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "SemilinearMapClass",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.toSemilinearMapClass",
  "constType":
  "{F : Type u_1} ‚Üí\n  {R : outParam (Type u_2)} ‚Üí\n    {S : outParam (Type u_3)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          {œÉ : outParam (R ‚Üí+* S)} ‚Üí\n            {M : outParam (Type u_4)} ‚Üí\n              [inst_2 : TopologicalSpace M] ‚Üí\n                [inst_3 : AddCommMonoid M] ‚Üí\n                  {M‚ÇÇ : outParam (Type u_5)} ‚Üí\n                    [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst_6 : Module R M] ‚Üí\n                          [inst_7 : Module S M‚ÇÇ] ‚Üí\n                            [self : ContinuousSemilinearMapClass F œÉ M M‚ÇÇ] ‚Üí SemilinearMapClass F œÉ M M‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toPartialOrder : PartialOrder Œ±] ‚Üí\n    [toMin : Min Œ±] ‚Üí\n      [toMax : Max Œ±] ‚Üí\n        [toOrd : Ord Œ±] ‚Üí\n          (‚àÄ (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a) ‚Üí\n            (decidableLE : DecidableRel fun x x_1 => x ‚â§ x_1) ‚Üí\n              (decidableEq : DecidableEq Œ±) ‚Üí\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) ‚Üí\n                  autoParam (‚àÄ (a b : Œ±), min a b = if a ‚â§ b then a else b) _auto‚úù ‚Üí\n                    autoParam (‚àÄ (a b : Œ±), max a b = if a ‚â§ b then b else a) _auto‚úù¬π ‚Üí\n                      autoParam (‚àÄ (a b : Œ±), compare a b = compareOfLessAndEq a b) _auto‚úù¬≤ ‚Üí LinearOrder Œ±",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "Exists.intro",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DifferentiableAt",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "HasFDerivAt.differentiableAt",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  {f' : E ‚ÜíL[ùïú] F} {x : E}, HasFDerivAt f f' x ‚Üí DifferentiableAt ùïú f x",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Real",
   "CommSemiring",
   "Real.commRing"],
  "name": "Real.instCommSemiringReal",
  "constType": "CommSemiring ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.5206",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.5206",
  "constType": "Subtype (Eq Real.definition‚úù)",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 ‚Üí outParam (Type u_2) ‚Üí Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Inf Œ±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.45",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Nonempty.rec", "Nonempty"],
  "name": "Nonempty.casesOn",
  "constType":
  "‚àÄ {Œ± : Sort u} {motive : Nonempty Œ± ‚Üí Prop} (t : Nonempty Œ±), (‚àÄ (val : Œ±), motive (_ : Nonempty Œ±)) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["Norm",
   "Filter",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427"],
  "name": "Asymptotics.IsLittleO",
  "constType":
  "{Œ± : Type u_17} ‚Üí\n  {E : Type u_18} ‚Üí {F : Type u_19} ‚Üí [inst : Norm E] ‚Üí [inst : Norm F] ‚Üí Filter Œ± ‚Üí (Œ± ‚Üí E) ‚Üí (Œ± ‚Üí F) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "Eq.refl",
   "div_eq_mul_one_div",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Eq.mpr",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "DivInvMonoid.toDiv",
   "id",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "One.toOfNat1",
   "CommGroupWithZero.toCommMonoidWithZero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "one_div_pos",
   "mul_lt_mul_of_pos_right",
   "HMul.hMul",
   "Semifield.toDivisionSemiring"],
  "name": "div_lt_div_of_lt",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] {a b c : Œ±}, 0 < c ‚Üí a < b ‚Üí a / c < b / c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.isROrC.proof_5",
   "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Real.decidableEq",
   "Field.toCommRing",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.isROrC.proof_3",
   "Real.isROrC.proof_1",
   "Real.isROrC.proof_9",
   "Real.isROrC.proof_7",
   "Real.isROrC.proof_12",
   "Real.isROrC.proof_10",
   "Real.isROrC.proof_11",
   "Real.isROrC.proof_2",
   "AddMonoidHom.id",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "Real.isROrC.proof_6",
   "Real.partialOrder",
   "Ring.toSemiring",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Real.isROrC.proof_4",
   "Real.instZeroReal",
   "Real.isROrC.proof_13",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC.mk",
   "Real.isROrC.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC",
  "constType": "IsROrC ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.5206", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.le",
  "constType": "‚Ñù ‚Üí ‚Ñù ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "NegZeroClass.neg_zero",
   "Eq"],
  "name": "neg_zero",
  "constType": "‚àÄ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references": ["HSMul", "HSMul.mk", "SMul", "SMul.smul"],
  "name": "instHSMul",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : SMul Œ± Œ≤] ‚Üí HSMul Œ± Œ≤ Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Iff.rfl",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Iff",
   "HasFDerivAtFilter",
   "HasFDerivAt",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "nhdsWithin",
   "id",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "Set.univ",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "congrArg",
   "HasFDerivWithinAt",
   "nhdsWithin_univ",
   "congrFun"],
  "name": "hasFDerivWithinAt_univ",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  {f' : E ‚ÜíL[ùïú] F} {x : E}, HasFDerivWithinAt f f' Set.univ x ‚Üî HasFDerivAt f f' x",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toNonUnitalSemiring : NonUnitalSemiring Œ±] ‚Üí\n    [toOne : One Œ±] ‚Üí\n      (‚àÄ (a : Œ±), 1 * a = a) ‚Üí\n        (‚àÄ (a : Œ±), a * 1 = a) ‚Üí\n          [toNatCast : NatCast Œ±] ‚Üí\n            autoParam (NatCast.natCast 0 = 0) _auto‚úù ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto‚úù¬π ‚Üí\n                (npow : ‚Ñï ‚Üí Œ± ‚Üí Œ±) ‚Üí\n                  autoParam (‚àÄ (x : Œ±), npow 0 x = 1) _auto‚úù¬≤ ‚Üí\n                    autoParam (‚àÄ (n : ‚Ñï) (x : Œ±), npow (n + 1) x = x * npow n x) _auto‚úù¬≥ ‚Üí Semiring Œ±",
  "constCategory": "Other"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(Œ± : Type u_2) ‚Üí [inst : Zero Œ±] ‚Üí [inst : One Œ±] ‚Üí [inst : LE Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["One",
   "zpowRec.match_1",
   "npowRec",
   "Nat",
   "Mul",
   "Nat.succ",
   "Int",
   "Inv",
   "Inv.inv"],
  "name": "zpowRec",
  "constType":
  "{M : Type u_2} ‚Üí [inst : One M] ‚Üí [inst : Mul M] ‚Üí [inst : Inv M] ‚Üí ‚Ñ§ ‚Üí M ‚Üí M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_zero",
  "constType":
  "‚àÄ {M : Type u_3} {N : Type u_4} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M ‚Üí+ N), f 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.dist_eq",
   "NonUnitalNormedRing.norm_mul",
   "NonUnitalNormedRing.toNorm",
   "NonUnitalNormedRing",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNormedRing.toMetricSpace",
   "NonUnitalSeminormedRing",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NonUnitalSeminormedRing.mk"],
  "name": "NonUnitalNormedRing.toNonUnitalSeminormedRing",
  "constType":
  "{Œ± : Type u_1} ‚Üí [Œ≤ : NonUnitalNormedRing Œ±] ‚Üí NonUnitalSeminormedRing Œ±",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{Œ± : Sort u} ‚Üí {p : Œ± ‚Üí Prop} ‚Üí (val : Œ±) ‚Üí p val ‚Üí Subtype p",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Std.Data.Rat.Basic._hyg.4",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {Œ≥ : Sort u_3} ‚Üí\n      {r : Œ± ‚Üí Œ≤ ‚Üí Sort u} ‚Üí\n        {s : Œ≤ ‚Üí Œ≥ ‚Üí Sort v} ‚Üí\n          {t : outParam (Œ± ‚Üí Œ≥ ‚Üí Sort w)} ‚Üí ({a : Œ±} ‚Üí {b : Œ≤} ‚Üí {c : Œ≥} ‚Üí r a b ‚Üí s b c ‚Üí t a c) ‚Üí Trans r s t",
  "constCategory": "Other"},
 {"references": ["NegZeroClass", "Neg"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} ‚Üí [self : NegZeroClass G] ‚Üí Neg G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Int.negSucc",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_9",
  "constType":
  "‚àÄ (n : ‚Ñï) (a : ‚Ñù), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semifield.zpow_zero'",
   "DivisionSemiring",
   "Semifield.toNontrivial",
   "Semifield.toCommSemiring",
   "DivisionSemiring.mk",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "Semifield.mul_inv_cancel",
   "Semifield.zpow_neg'",
   "Semifield.zpow",
   "Semifield.toDiv",
   "Semifield.toInv",
   "Semifield",
   "Semifield.inv_zero"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Semifield Œ±] ‚Üí DivisionSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "CommSemiring.mk",
   "Field.toSemifield.proof_1",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Ring.toSemiring",
   "Semifield",
   "Field.toCommRing",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Semifield.mk",
   "Field.toDiv",
   "Field.div_eq_mul_inv"],
  "name": "Field.toSemifield",
  "constType": "{K : Type u_3} ‚Üí [inst : Field K] ‚Üí Semifield K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionCommMonoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_succ'",
  "constType":
  "‚àÄ {R : Type u} [self : AddGroupWithOne R] (n : ‚Ñï) (a : R),\n  AddGroupWithOne.zsmul (Int.ofNat (Nat.succ n)) a = a + AddGroupWithOne.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedAddCommGroup",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Membership.mk",
   "Membership",
   "Set.instMembershipSet"],
  "name": "instMembershipSetFilter",
  "constType": "{Œ± : Type u_1} ‚Üí Membership (Set Œ±) (Filter Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["DenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.mk",
   "Real.denselyNormedField.proof_1"],
  "name": "Real.denselyNormedField",
  "constType": "DenselyNormedField ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.mk",
  "constType":
  "{M : Type u_9} ‚Üí\n  {N : Type u_10} ‚Üí\n    [inst : AddZeroClass M] ‚Üí\n      [inst_1 : AddZeroClass N] ‚Üí\n        (toZeroHom : ZeroHom M N) ‚Üí\n          (‚àÄ (x y : M), ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) ‚Üí\n            M ‚Üí+ N",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Int"],
  "name": "LinearOrderedField.zpow",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí ‚Ñ§ ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [inst_3 : ZeroLEOneClass Œ±]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "Semiring",
   "ContinuousLinearMap.mk",
   "Semiring.toMonoidWithZero",
   "LinearMap.mk",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "RingHom.id",
   "LinearMap.smulRight",
   "ContinuousLinearMap.smulRight.proof_2",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "TopologicalSpace",
   "ContinuousLinearMap.smulRight.proof_1",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "ContinuousSMul",
   "Module",
   "MonoidWithZero.toZero",
   "LinearMap.toAddHom",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.smulRight",
  "constType":
  "{M‚ÇÅ : Type u_4} ‚Üí\n  [inst : TopologicalSpace M‚ÇÅ] ‚Üí\n    [inst_1 : AddCommMonoid M‚ÇÅ] ‚Üí\n      {M‚ÇÇ : Type u_6} ‚Üí\n        [inst_2 : TopologicalSpace M‚ÇÇ] ‚Üí\n          [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n            {R : Type u_10} ‚Üí\n              {S : Type u_11} ‚Üí\n                [inst_4 : Semiring R] ‚Üí\n                  [inst_5 : Semiring S] ‚Üí\n                    [inst_6 : Module R M‚ÇÅ] ‚Üí\n                      [inst_7 : Module R M‚ÇÇ] ‚Üí\n                        [inst_8 : Module R S] ‚Üí\n                          [inst_9 : Module S M‚ÇÇ] ‚Üí\n                            [inst_10 : IsScalarTower R S M‚ÇÇ] ‚Üí\n                              [inst_11 : TopologicalSpace S] ‚Üí\n                                [inst_12 : ContinuousSMul S M‚ÇÇ] ‚Üí (M‚ÇÅ ‚ÜíL[R] S) ‚Üí M‚ÇÇ ‚Üí M‚ÇÅ ‚ÜíL[R] M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["Monoid", "Pow.mk", "Nat", "Pow", "Monoid.npow"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} ‚Üí [inst : Monoid M] ‚Üí Pow M ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.inter_subset_left",
   "Module",
   "Submodule.setLike",
   "Set.instInterSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_4",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), ‚Üëx ‚à© ‚Üëx_1 ‚äÜ ‚Üëx",
  "constCategory": "Theorem"},
 {"references": ["MeasurableSpace"],
  "name": "MeasureTheory.Measure",
  "constType": "(Œ± : Type u_6) ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Type u_6",
  "constCategory": "Other"},
 {"references":
  ["RingHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.mk",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass",
   "RingHomClass.map_add",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_zero",
   "NonAssocSemiring",
   "NonUnitalRingHomClass"],
  "name": "RingHomClass.toNonUnitalRingHomClass",
  "constType":
  "{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      {x : NonAssocSemiring Œ±} ‚Üí {x_1 : NonAssocSemiring Œ≤} ‚Üí [inst : RingHomClass F Œ± Œ≤] ‚Üí NonUnitalRingHomClass F Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedCancelAddCommMonoid",
   "DecidableRel"],
  "name": "LinearOrderedCancelAddCommMonoid.decidableLT",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "‚àÄ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Field", "Int"],
  "name": "Field.zpow",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí ‚Ñ§ ‚Üí K ‚Üí K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedCommSemiring",
  "constType": "Type u_2 ‚Üí Type u_2",
  "constCategory": "Other"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.mk",
  "constType": "{Œ± : Type u_9} ‚Üí (Set Œ± ‚Üí Œ±) ‚Üí SupSet Œ±",
  "constCategory": "Other"},
 {"references":
  ["OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.toOuterMeasure_injective.match_2",
   "Eq",
   "MeasureTheory.Measure",
   "BooleanAlgebra.toBiheytingAlgebra",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "ENNReal.instTopologicalSpaceENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.iUnion",
   "Pairwise",
   "Eq.rec",
   "MeasurableSet",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "MeasureTheory.Measure.toOuterMeasure_injective.match_1",
   "Nat",
   "Function.onFun",
   "CompletelyDistribLattice.toCompleteLattice",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Disjoint",
   "MeasureTheory.Measure.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "tsum",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Function.Injective",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim"],
  "name": "MeasureTheory.Measure.toOuterMeasure_injective",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±], Function.Injective MeasureTheory.Measure.toOuterMeasure",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_6",
  "constType": "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a b : Œ±), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} ‚Üí [self : AddZeroClass M] ‚Üí Add M",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "instHSub",
   "congr_arg",
   "LinearOrder",
   "Trans.trans",
   "SubNegMonoid.toNeg",
   "instDistribLattice",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "SubNegMonoid.toSub",
   "AddGroup",
   "SemilatticeSup.toSup",
   "SubtractionMonoid.toSubNegMonoid",
   "abs_neg",
   "instTransEq",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "neg_sub",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_sub_comm",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±] (a b : Œ±), |a - b| = |b - a|",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.zero_mul",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.sub_eq_add_neg",
  "constType": "‚àÄ {R : Type u} [self : Ring R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "instZeroAddMonoidHom",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "Iff.symm",
   "And",
   "Iff",
   "and_iff_left",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_13",
  "constType": "‚àÄ {z w : ‚Ñù}, z ‚â§ w ‚Üî z ‚â§ w ‚àß 0 z = 0 z",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.901"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.add",
  "constType": "‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "Eq.ndrec",
   "NonUnitalNonAssocRing.zero_mul",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocRing Œ±] (a b : Œ±), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.right_distrib",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a b c : Œ±), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "NormedCommRing"],
  "name": "NormedCommRing.toNormedRing",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedCommRing Œ±] ‚Üí NormedRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} ‚Üí [toSubNegMonoid : SubNegMonoid A] ‚Üí (‚àÄ (a : A), -a + a = 0) ‚Üí AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} ‚Üí [toSemiring : Semiring R] ‚Üí (‚àÄ (a b : R), a * b = b * a) ‚Üí CommSemiring R",
  "constCategory": "Other"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí Œ± √ó Œ≤ ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing.toNonUnitalNormedRing",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NormedRing",
   "inferInstance",
   "NormedRing.toSeminormedRing",
   "NormedField",
   "NormedAlgebra",
   "NormedSpace",
   "NormedAlgebra.toNormedSpace",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup"],
  "name": "NormedAlgebra.toNormedSpace'",
  "constType":
  "{ùïú : Type u_5} ‚Üí\n  [inst : NormedField ùïú] ‚Üí {ùïú' : Type u_7} ‚Üí [inst_1 : NormedRing ùïú'] ‚Üí [inst_2 : NormedAlgebra ùïú ùïú'] ‚Üí NormedSpace ùïú ùïú'",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "Semiring",
   "AddHomClass.toFunLike",
   "ContinuousSemilinearMapClass.map_continuous",
   "ContinuousMapClass",
   "ContinuousMapClass.mk",
   "AddCommMagma.toAdd",
   "outParam",
   "SemilinearMapClass.toAddHomClass",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "ContinuousSemilinearMapClass.toSemilinearMapClass",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.toContinuousMapClass",
  "constType":
  "{F : Type u_1} ‚Üí\n  {R : outParam (Type u_2)} ‚Üí\n    {S : outParam (Type u_3)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          (œÉ : outParam (R ‚Üí+* S)) ‚Üí\n            {M : outParam (Type u_4)} ‚Üí\n              [inst_2 : TopologicalSpace M] ‚Üí\n                [inst_3 : AddCommMonoid M] ‚Üí\n                  {M‚ÇÇ : outParam (Type u_5)} ‚Üí\n                    [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst_6 : Module R M] ‚Üí\n                          [inst_7 : Module S M‚ÇÇ] ‚Üí\n                            [self : ContinuousSemilinearMapClass F œÉ M M‚ÇÇ] ‚Üí ContinuousMapClass F M M‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "LE.le",
   "SemilatticeInf",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toInf : Inf Œ±] ‚Üí\n    [toPartialOrder : PartialOrder Œ±] ‚Üí\n      (‚àÄ (a b : Œ±), a ‚äì b ‚â§ a) ‚Üí\n        (‚àÄ (a b : Œ±), a ‚äì b ‚â§ b) ‚Üí (‚àÄ (a b c : Œ±), a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ b ‚äì c) ‚Üí SemilatticeInf Œ±",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : LinearOrderedCommSemiring Œ±] ‚Üí LinearOrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Union.union",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Eq",
   "Set.compl_inter",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "congrArg",
   "Set.instUnionSet",
   "Set.instInterSet",
   "id",
   "congrFun"],
  "name": "Bornology.ofBounded.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} (B : Set (Set Œ±)),\n  (‚àÄ s‚ÇÅ ‚àà B, ‚àÄ s‚ÇÇ ‚àà B, s‚ÇÅ ‚à™ s‚ÇÇ ‚àà B) ‚Üí ‚àÄ {x y : Set Œ±}, x ‚àà {s | s·∂ú ‚àà B} ‚Üí y ‚àà {s | s·∂ú ‚àà B} ‚Üí x ‚à© y ‚àà {s | s·∂ú ‚àà B}",
  "constCategory": "Theorem"},
 {"references":
  ["StieltjesFunction.id.proof_2",
   "Real",
   "StieltjesFunction",
   "StieltjesFunction.mk",
   "StieltjesFunction.id.proof_1",
   "id"],
  "name": "StieltjesFunction.id",
  "constType": "StieltjesFunction",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "MetricSpace.ofT0PseudoMetricSpace.proof_1",
   "PseudoMetricSpace.toUniformSpace",
   "T0Space",
   "UniformSpace.toTopologicalSpace",
   "MetricSpace.mk",
   "PseudoMetricSpace"],
  "name": "MetricSpace.ofT0PseudoMetricSpace",
  "constType":
  "(Œ± : Type u_3) ‚Üí [inst : PseudoMetricSpace Œ±] ‚Üí [inst : T0Space Œ±] ‚Üí MetricSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HSub.hSub",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "Asymptotics.IsLittleO",
   "NormedSpace",
   "AddGroup.toSubNegMonoid",
   "RingHom.id",
   "NormedField.toField",
   "SubNegMonoid.toSub",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedAddCommGroup.toNormedAddGroup",
   "Filter",
   "Semifield.toDivisionSemiring",
   "NormedAddCommGroup.toNorm",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "ContinuousMapClass.toFunLike"],
  "name": "HasFDerivAtFilter",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup F] ‚Üí [inst_4 : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí (E ‚ÜíL[ùïú] F) ‚Üí E ‚Üí Filter E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "NormedDivisionRing"],
  "name": "NormedDivisionRing.toDivisionRing",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : NormedDivisionRing Œ±] ‚Üí DivisionRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Membership.mem",
   "Submodule",
   "setOf",
   "PartialOrder.toPreorder",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_1",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), x ‚â§ sInf {x_2 | x ‚â§ x_2 ‚àß x_1 ‚â§ x_2}",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_7",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a b c : Œ±), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "starMulAut",
   "NonUnitalCommSemiring.toCommSemigroup",
   "MulAut",
   "CommSemiring.toNonUnitalCommSemiring",
   "Semiring.toNonAssocSemiring",
   "starRingAut.proof_3",
   "InvolutiveStar.toStar",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "AddEquiv.toEquiv",
   "StarRing",
   "starRingAut.proof_2",
   "StarRing.toStarMul",
   "starRingAut.proof_1",
   "RingAut",
   "Star.star",
   "AddSemigroup.toAdd",
   "RingEquiv.mk",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddEquiv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "starAddEquiv",
   "StarRing.toStarAddMonoid",
   "Equiv.invFun",
   "starRingAut.proof_4",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Equiv.mk",
   "StarAddMonoid.toInvolutiveStar"],
  "name": "starRingAut",
  "constType":
  "{R : Type u} ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : StarRing R] ‚Üí RingAut R",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocCommRing Œ±] ‚Üí NonUnitalNonAssocRing Œ±",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNormedRing", "NonUnitalRing"],
  "name": "NonUnitalNormedRing.toNonUnitalRing",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : NonUnitalNormedRing Œ±] ‚Üí NonUnitalRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "MulZeroClass.toMul",
   "DivInvMonoid.toInv",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "GroupWithZero",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "id",
   "Inv.inv"],
  "name": "div_zero",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a / 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "‚àÄ {n m : ‚Ñï}, n ‚â§ m ‚Üí Nat.succ n ‚â§ Nat.succ m",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Module.Finite",
  "constType":
  "(R : Type u_1) ‚Üí (M : Type u_4) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst : Module R M] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.add_zero",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_3",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Filter.Tendsto", "Filter", "Filter.Eventually"],
  "name": "Filter.Tendsto.eventually",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : Filter Œ≤} {p : Œ≤ ‚Üí Prop},\n  Filter.Tendsto f l‚ÇÅ l‚ÇÇ ‚Üí (‚àÄ·∂† (y : Œ≤) in l‚ÇÇ, p y) ‚Üí ‚àÄ·∂† (x : Œ±) in l‚ÇÅ, p (f x)",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} ‚Üí [self : Semigroup G] ‚Üí Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "And",
   "setOf",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Set",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "definition._@.Mathlib.Topology.Basic._hyg.10659",
  "constType": "{Œ± : Type u} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Œ± ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedRing"],
  "name": "LinearOrderedRing.toMin",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí Min Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "‚àÄ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "NonAssocRing",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Neg.neg",
   "One.toOfNat1",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "NonAssocRing.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing Œ±] ‚Üí\n    [toOne : One Œ±] ‚Üí\n      (‚àÄ (a : Œ±), 1 * a = a) ‚Üí\n        (‚àÄ (a : Œ±), a * 1 = a) ‚Üí\n          [toNatCast : NatCast Œ±] ‚Üí\n            autoParam (NatCast.natCast 0 = 0) _auto‚úù ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto‚úù¬π ‚Üí\n                [toIntCast : IntCast Œ±] ‚Üí\n                  autoParam (‚àÄ (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën) _auto‚úù¬≤ ‚Üí\n                    autoParam (‚àÄ (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)) _auto‚úù¬≥ ‚Üí NonAssocRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_8",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a b c : Œ±), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def'",
  "constType":
  "‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [self : Algebra R A] (r : R) (x : A),\n  r ‚Ä¢ x = Algebra.toRingHom r * x",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring Œ±] ‚Üí\n    (‚àÄ (a b c : Œ±), a * b * c = a * (b * c)) ‚Üí NonUnitalSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí [toLinearOrderedRing : LinearOrderedRing Œ±] ‚Üí (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí LinearOrderedCommRing Œ±",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubtractionMonoid"],
  "name": "SubtractionMonoid.toSubNegMonoid",
  "constType": "{G : Type u} ‚Üí [self : SubtractionMonoid G] ‚Üí SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsTotal",
   "SemilatticeInf.toPartialOrder",
   "total_of",
   "Lattice",
   "LE.le",
   "Preorder.toLE"],
  "name": "Lattice.toLinearOrder.proof_1",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : Lattice Œ±] [inst_1 : IsTotal Œ± fun x x_1 => x ‚â§ x_1] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderedCommSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["SProd", "SProd.mk", "Filter.prod", "Prod", "Filter"],
  "name": "Filter.instSProd",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí SProd (Filter Œ±) (Filter Œ≤) (Filter (Œ± √ó Œ≤))",
  "constCategory": "Definition"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.sSup",
  "constType": "{Œ± : Type u_9} ‚Üí [self : SupSet Œ±] ‚Üí Set Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLT",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "AddHom.toFun",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddHom",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Eq",
   "SMulZeroClass.toSMul",
   "RingHomClass.toNonUnitalRingHomClass",
   "MulActionWithZero.toSMulWithZero",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "LinearMap.mk",
  "constType":
  "{R : Type u_17} ‚Üí\n  {S : Type u_18} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {M : Type u_19} ‚Üí\n            {M‚ÇÇ : Type u_20} ‚Üí\n              [inst_2 : AddCommMonoid M] ‚Üí\n                [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                  [inst_4 : Module R M] ‚Üí\n                    [inst_5 : Module S M‚ÇÇ] ‚Üí\n                      (toAddHom : AddHom M M‚ÇÇ) ‚Üí\n                        (‚àÄ (r : R) (x : M), AddHom.toFun toAddHom (r ‚Ä¢ x) = œÉ r ‚Ä¢ AddHom.toFun toAddHom x) ‚Üí M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ",
  "constCategory": "Other"},
 {"references": ["AddGroupWithOne", "Neg"],
  "name": "AddGroupWithOne.toNeg",
  "constType": "{R : Type u} ‚Üí [self : AddGroupWithOne R] ‚Üí Neg R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Rat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "UniformSpace",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "UniformSpace.ofCore",
   "Filter",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "Filter.instCompleteLatticeFilter",
   "setOf",
   "Prod.snd",
   "instHAdd",
   "Prod.fst",
   "AddCommMagma.toAdd",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "GT.gt",
   "UniformSpace.ofFun.proof_3",
   "And",
   "UniformSpace.ofFun.proof_1",
   "iInf",
   "LT.lt",
   "Prod",
   "UniformSpace.ofFun.proof_2",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "UniformSpace.Core.mk"],
  "name": "UniformSpace.ofFun",
  "constType":
  "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [inst : OrderedAddCommMonoid Œ≤] ‚Üí\n      (d : Œ± ‚Üí Œ± ‚Üí Œ≤) ‚Üí\n        (‚àÄ (x : Œ±), d x x = 0) ‚Üí\n          (‚àÄ (x y : Œ±), d x y = d y x) ‚Üí\n            (‚àÄ (x y z : Œ±), d x z ‚â§ d x y + d y z) ‚Üí (‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x < Œ¥, ‚àÄ y < Œ¥, x + y < Œµ) ‚Üí UniformSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "AddHom.toFun",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Eq",
   "SMulZeroClass.toSMul",
   "RingHomClass.toNonUnitalRingHomClass",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "LinearMap.map_smul'",
  "constType":
  "‚àÄ {R : Type u_17} {S : Type u_18} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {M : Type u_19}\n  {M‚ÇÇ : Type u_20} [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module S M‚ÇÇ]\n  (self : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) (r : R) (x : M), AddHom.toFun self.toAddHom (r ‚Ä¢ x) = œÉ r ‚Ä¢ AddHom.toFun self.toAddHom x",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_5",
  "constType": "‚àÄ {Œ± : Type u_1} (a b : (Filter Œ±)·µí·µà·µí·µà), a ‚â§ a ‚äî b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.left_distrib",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a b c : Œ±), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toMulAction",
   "Monoid",
   "MulAction.toSMul",
   "IsScalarTower.mk",
   "MulAction.mul_smul",
   "IsScalarTower",
   "MulAction"],
  "name": "IsScalarTower.left",
  "constType":
  "‚àÄ (M : Type u_1) {Œ± : Type u_6} [inst : Monoid M] [inst_1 : MulAction M Œ±], IsScalarTower M M Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvolutiveNeg",
  "constType": "Type u_2 ‚Üí Type u_2",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "‚àÄ {a b : Prop} {motive : a ‚à® b ‚Üí Prop},\n  (‚àÄ (h : a), motive (_ : a ‚à® b)) ‚Üí (‚àÄ (h : b), motive (_ : a ‚à® b)) ‚Üí ‚àÄ (t : a ‚à® b), motive t",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "Semiring",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_2",
   "StrictOrderedRing.toNontrivial",
   "Ring.toSemiring",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_3",
   "StrictOrderedRing.zero_le_one",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_1"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : StrictOrderedRing Œ±] ‚Üí StrictOrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.left_distrib",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a b c : Œ±), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "setOf",
   "Submodule",
   "PartialOrder.toPreorder",
   "Semiring",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "Inf.mk",
   "And",
   "Set.subset_inter",
   "And.intro",
   "Set.inter_subset_left",
   "Module",
   "Lattice.toSemilatticeSup",
   "Set.inter_subset_right",
   "Submodule.setLike",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_11",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)) (x_1 : Submodule R M), (‚àÄ b ‚àà x, b ‚â§ x_1) ‚Üí (sInf fun x_2 => ‚àÄ b ‚àà x, b ‚â§ x_2) ‚â§ x_1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "forall_exists_index.match_1"],
  "name": "Exists.imp",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a ‚Üí q a) ‚Üí (‚àÉ a, p a) ‚Üí ‚àÉ a, q a",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "SMul.mk",
   "instHSMul",
   "MeasureTheory.Measure.mk",
   "MeasureTheory.Measure.instSMul.proof_1",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HSMul.hSMul",
   "Algebra.id",
   "Algebra.toSMul",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.Measure.instSMul.proof_2"],
  "name": "MeasureTheory.Measure.instSMul",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {R : Type u_6} ‚Üí\n    [inst : SMul R ENNReal] ‚Üí\n      [inst : IsScalarTower R ENNReal ENNReal] ‚Üí [inst : MeasurableSpace Œ±] ‚Üí SMul R (MeasureTheory.Measure Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.preimage",
   "nhds",
   "all_mem_nhds_filter",
   "Filter.map",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Filter",
   "Set.preimage_mono",
   "IsOpen",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "tendsto_nhds",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {a : Œ±},\n  Filter.Tendsto f l (nhds a) ‚Üî ‚àÄ (s : Set Œ±), IsOpen s ‚Üí a ‚àà s ‚Üí f ‚Åª¬π' s ‚àà l",
  "constCategory": "Theorem"},
 {"references": ["NonAssocSemiring"],
  "name": "RingHom",
  "constType":
  "(Œ± : Type u_5) ‚Üí (Œ≤ : Type u_6) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí [inst : NonAssocSemiring Œ≤] ‚Üí Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemiring", "Max"],
  "name": "LinearOrderedSemiring.toMax",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí Max Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Ring.zsmul_succ'",
  "constType":
  "‚àÄ {R : Type u} [self : Ring R] (n : ‚Ñï) (a : R), Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OneHom.toFun",
   "AddZeroClass.toZero",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "AddMonoidWithOne.toAddMonoid",
   "RingHom.toMonoidHom",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.map_zero'",
  "constType":
  "‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_6} [inst : NonAssocSemiring Œ±] [inst_1 : NonAssocSemiring Œ≤] (self : Œ± ‚Üí+* Œ≤),\n  OneHom.toFun (‚Üë‚Üëself) 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CommSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CommSemiring",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toCommSemiring",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : CanonicallyOrderedCommSemiring Œ±] ‚Üí CommSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.symm",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí (b ‚Üî a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "‚àÄ {Œ± : Type u} [self : Lattice Œ±] (a b : Œ±), a ‚äì b ‚â§ b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int"],
  "name": "Real.instLinearOrderedFieldReal.proof_7",
  "constType": "‚àÄ (a : ‚Ñù), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "HAdd.hAdd",
   "Eq.refl",
   "sub_add_sub_cancel",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "instHSub",
   "instHAdd",
   "instDistribLattice",
   "HSub.hSub",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "abs_add",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "instTransEq",
   "NegZeroClass.toNeg",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_sub_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] (a b c : Œ±), |a - c| ‚â§ |a - b| + |b - c|",
  "constCategory": "Theorem"},
 {"references": ["outParam", "TopologicalSpace"],
  "name": "ContinuousMapClass",
  "constType":
  "Type u_1 ‚Üí\n  (Œ± : outParam (Type u_2)) ‚Üí\n    (Œ≤ : outParam (Type u_3)) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí Type (max (max u_1 u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Real.measurableSpace",
   "Real.instAddMonoidReal",
   "ENNReal.ofReal",
   "AddCommGroup.toAddCommMonoid",
   "le_rfl",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.MeasureTheory.Measure.Stieltjes._auxLemma.16",
   "Real.linearOrder",
   "BooleanAlgebra.toBiheytingAlgebra",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "SubNegMonoid.toSub",
   "MeasureTheory.OuterMeasure.measureOf",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "instHSub",
   "Or",
   "add_comm",
   "Set.Ioo",
   "MeasurableSingletonClass.measurableSet_singleton",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "StieltjesFunction.measure",
   "instENNRealZero",
   "AddCommMagma.toAdd",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "LT.lt",
   "Real.instConditionallyCompleteLinearOrderReal",
   "GeneralizedCoheytingAlgebra.toLattice",
   "LinearOrder.toPartialOrder",
   "Int",
   "Mathlib.Data.Real.ENNReal._auxLemma.107",
   "congrFun",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.1",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Mathlib.MeasureTheory.Measure.Stieltjes._auxLemma.9",
   "Set.Ioo_eq_empty",
   "instOfNatInt",
   "Set",
   "Real",
   "StieltjesFunction.measure_singleton",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "True",
   "BorelSpace.opensMeasurable",
   "Real.instAddCommGroupReal",
   "MeasureTheory.Measure",
   "zero_add",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "StieltjesFunction.mono",
   "Mathlib.Tactic.Abel.unfold_sub",
   "UniformSpace.toTopologicalSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Disjoint",
   "ConditionallyCompleteLattice.toLattice",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Mathlib.Tactic.Abel.term_atomg",
   "ENNReal.ofReal_ne_top",
   "OrderTopology.t5Space",
   "StieltjesFunction.toFun",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "Set.instUnionSet",
   "ENNReal.add_right_inj",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "AddGroup.toHasOrderedSub",
   "neg_zero",
   "Real.instLEReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Mathlib.Algebra.Order.Sub.Defs._auxLemma.1",
   "AddGroup.toSubtractionMonoid",
   "Mathlib.Tactic.Abel.zero_termg",
   "Set.Icc_self",
   "MeasureTheory.measure_empty",
   "Preorder.toLE",
   "Eq",
   "StieltjesFunction.measure_Ioc",
   "Mathlib.Tactic.Abel.const_add_termg",
   "AddZeroClass.toZero",
   "ENNReal",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "ENNReal.ofReal_add",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "not_false_eq_true",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Function.leftLim",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lattice.toSemilatticeInf",
   "Real.partialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Mathlib.Tactic.Abel.termg",
   "Mathlib.Tactic.Abel.term_neg",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Set.instMembershipSet",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Order.Basic._auxLemma.2",
   "DistribLattice.toLattice",
   "Real.orderedAddCommMonoid",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.77",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Real.instAddGroupReal",
   "Not",
   "Singleton.singleton",
   "Monotone.leftLim_le",
   "Set.Ioc",
   "Mathlib.Tactic.Abel.term_add_constg",
   "add_zero",
   "congrArg",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "Int.ofNat",
   "Real.borelSpace",
   "Set.Icc",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Mathlib.Tactic.Abel.term_add_termg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Set.instSingletonSet",
   "and_false",
   "Preorder.toLT",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "Int.instNegInt",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Membership.mem",
   "le_or_lt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "instHAdd",
   "Union.union",
   "HSub.hSub",
   "MeasureTheory.measure_union",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "OpensMeasurableSpace.toMeasurableSingletonClass",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Monotone.le_leftLim",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "T5Space.toT1Space",
   "HeytingAlgebra.toOrderBot",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "SubtractionMonoid.toSubNegMonoid",
   "OrderedCommSemiring.toOrderedSemiring",
   "StieltjesFunction",
   "OrderedSemiring.toSemiring",
   "NegZeroClass.toZero",
   "Set.Ioo_union_Icc_eq_Ioc"],
  "name": "StieltjesFunction.measure_Ioo",
  "constType":
  "‚àÄ (f : StieltjesFunction) {a b : ‚Ñù},\n  ‚Üë‚Üë(StieltjesFunction.measure f) (Set.Ioo a b) = ENNReal.ofReal (Function.leftLim (‚Üëf) b - ‚Üëf a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Iff.intro",
   "NoZeroDivisors",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "Iff",
   "mul_eq_zero_of_left",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mul_eq_zero_of_right",
   "Or.elim",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero",
  "constType":
  "‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ] [inst_1 : NoZeroDivisors M‚ÇÄ] {a b : M‚ÇÄ}, a * b = 0 ‚Üî a = 0 ‚à® b = 0",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{Œ± : Sort u} ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Continuous.neg",
   "Eq.mpr",
   "AddGroup",
   "Continuous.add",
   "ContinuousSub",
   "Continuous",
   "continuous_snd",
   "TopologicalSpace",
   "id",
   "TopologicalAddGroup.toContinuousAdd",
   "instHSub",
   "funext",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "instHAdd",
   "HSub.hSub",
   "TopologicalAddGroup.toContinuousNeg",
   "Neg.neg",
   "Prod.fst",
   "AddGroup.toSubNegMonoid",
   "continuous_fst",
   "SubNegMonoid.toAddMonoid",
   "Prod",
   "ContinuousSub.mk",
   "congrArg",
   "TopologicalAddGroup"],
  "name": "TopologicalAddGroup.to_continuousSub",
  "constType":
  "‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G], ContinuousSub G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.IsOpen", "Set", "TopologicalSpace"],
  "name": "IsOpen",
  "constType": "{Œ± : Type u} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Div",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.re",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "Eq",
   "IsROrC.ofReal",
   "IsROrC.ofReal_re_ax",
   "Field.toCommRing",
   "NormedField.toField",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom"],
  "name": "IsROrC.ofReal_re",
  "constType": "‚àÄ {K : Type u_1} [inst : IsROrC K] (r : ‚Ñù), IsROrC.re ‚Üër = r",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_succ'",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sSup_le",
  "constType":
  "‚àÄ {Œ± : Type u_9} [self : CompleteLattice Œ±] (s : Set Œ±) (a : Œ±), (‚àÄ b ‚àà s, b ‚â§ a) ‚Üí sSup s ‚â§ a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí [toSeminormedRing : SeminormedRing Œ±] ‚Üí (‚àÄ (x y : Œ±), x * y = y * x) ‚Üí SeminormedCommRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Exists",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "Real.normedField",
   "Real.instLEReal",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "Real.instSupReal",
   "Exists.intro",
   "And.left",
   "exists_between",
   "abs_of_nonneg",
   "NormedField.toNorm",
   "Abs.abs",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "LT.lt.le",
   "Real.instLTReal",
   "instDistribLattice",
   "LE.le.trans",
   "Real.norm",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "And",
   "Real.norm_eq_abs",
   "Eq.ndrec",
   "Real.denselyNormedField.match_1",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "Norm.norm",
   "LinearOrderedSemiField.toDenselyOrdered",
   "NegZeroClass.toNeg"],
  "name": "Real.denselyNormedField.proof_1",
  "constType": "‚àÄ (x x_1 : ‚Ñù), 0 ‚â§ x ‚Üí x < x_1 ‚Üí ‚àÉ a, x < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < x_1",
  "constCategory": "Theorem"},
 {"references": ["Norm", "NormedField"],
  "name": "NormedField.toNorm",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedField Œ±] ‚Üí Norm Œ±",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "‚àÄ {p‚ÇÅ p‚ÇÇ : Sort u} {q‚ÇÅ q‚ÇÇ : Sort v}, p‚ÇÅ = p‚ÇÇ ‚Üí q‚ÇÅ = q‚ÇÇ ‚Üí (p‚ÇÅ ‚Üí q‚ÇÅ) = (p‚ÇÇ ‚Üí q‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "Real",
   "Real.toNNReal",
   "ENNReal.ofReal",
   "Eq.refl",
   "ENNReal.ofNNReal",
   "Eq"],
  "name": "_private.Mathlib.Data.Real.ENNReal.0.ENNReal.ofReal._eq_1",
  "constType": "‚àÄ (r : ‚Ñù), ENNReal.ofReal r = ‚Üë(Real.toNNReal r)",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{Œ± : Type u} ‚Üí [self : Inter Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.decidableLT",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a b : Œ±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "‚àÄ {Œ± : Type u_9} [self : CompleteLattice Œ±] (s : Set Œ±), ‚àÄ a ‚àà s, sInf s ‚â§ a",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "NormedSpace.norm_smul_le",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "AddCommMonoid.toAddMonoid",
   "NormedField.toNormedCommRing",
   "LE.le",
   "NormedField.toNorm",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "NormedSpace.toModule"],
  "name": "NormedAlgebra.id.proof_3",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NormedField ùïú] (a b : ùïú), ‚Äña ‚Ä¢ b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.mul_comm",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalCommRing Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.810",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Real.commRing.proof_25",
   "Semiring.mk",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "nsmulRec",
   "npowRec",
   "CommRing.mk",
   "Real.instOneReal",
   "Real.commRing.proof_24",
   "zsmulRec",
   "Real.commRing.proof_3",
   "Real.commRing.proof_1",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Real.commRing.proof_20",
   "Rat.instNegRat",
   "Sub.sub",
   "Real.commRing.proof_10",
   "Nat",
   "Real.commRing.proof_11",
   "Add.mk",
   "Real.commRing.proof_6",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.commRing.proof_4",
   "AddMonoid.mk",
   "instHMul",
   "IntCast.mk",
   "Real.commRing.proof_21",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Zero.mk",
   "Real.commRing.proof_13",
   "CauSeq.Completion.Cauchy",
   "Ring.mk",
   "Real.commRing.proof_8",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Neg.mk",
   "Mul.mk",
   "CauSeq.Completion.instIntCastCauchy",
   "Real.commRing.proof_15",
   "Real.commRing.proof_5",
   "DivisionRing.toRing",
   "Real",
   "CauSeq.Completion.instNatCastCauchy",
   "Real.commRing.proof_23",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Abs.abs",
   "Real.commRing.proof_17",
   "Rat.instSupRat",
   "Real.instNegReal",
   "Sub.mk",
   "Zero.toOfNat0",
   "Real.commRing.proof_9",
   "Real.commRing.proof_18",
   "Real.commRing.proof_7",
   "Real.commRing.proof_22",
   "Real.commRing.proof_12",
   "Real.commRing.proof_14",
   "Real.commRing.proof_2",
   "Real.commRing.proof_16",
   "Real.commRing.proof_19",
   "Neg.toHasAbs",
   "AddSemigroup.mk",
   "instHAdd",
   "One.mk",
   "Rat",
   "One.toOfNat1",
   "Neg.neg",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "HMul.hMul"],
  "name": "Real.commRing",
  "constType": "CommRing ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Real.field",
   "NormedAddCommGroup",
   "Field.zpow_zero'",
   "Real.instLinearOrderedRingReal",
   "NormedField",
   "Real",
   "Field.mk",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "NormedAddCommGroup.toMetricSpace",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "abs_mul",
   "Field",
   "NormedField.mk",
   "Field.inv_zero",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Real.normedAddCommGroup",
   "Field.div_eq_mul_inv"],
  "name": "Real.normedField",
  "constType": "NormedField ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Std.Data.Rat.Basic._hyg.33",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Set",
   "ENNReal.ofReal",
   "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.810",
   "Bornology.cobounded",
   "autoParam",
   "Dist",
   "Dist.dist",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "Filter.principal",
   "UniformSpace",
   "CompleteLattice.toConditionallyCompleteLattice",
   "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.765",
   "Filter",
   "PseudoMetricSpace",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Filter.sets",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "instHAdd",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Prod.fst",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "GT.gt",
   "Real.instZeroReal",
   "uniformity",
   "iInf",
   "LT.lt",
   "Prod",
   "Bornology"],
  "name": "PseudoMetricSpace.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toDist : Dist Œ±] ‚Üí\n    (‚àÄ (x : Œ±), dist x x = 0) ‚Üí\n      (‚àÄ (x y : Œ±), dist x y = dist y x) ‚Üí\n        (‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) ‚Üí\n          (edist : Œ± ‚Üí Œ± ‚Üí ENNReal) ‚Üí\n            (‚àÄ (x y : Œ±), edist x y = ENNReal.ofReal (dist x y)) ‚Üí\n              (toUniformSpace : UniformSpace Œ±) ‚Üí\n                autoParam (uniformity Œ± = ‚®Ö Œµ, ‚®Ö (_ : Œµ > 0), Filter.principal {p | dist p.1 p.2 < Œµ}) _auto‚úù ‚Üí\n                  (toBornology : Bornology Œ±) ‚Üí\n                    autoParam ((Bornology.cobounded Œ±).sets = {s | ‚àÉ C, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C}) _auto‚úù¬π ‚Üí\n                      PseudoMetricSpace Œ±",
  "constCategory": "Other"},
 {"references": ["Norm", "Real"],
  "name": "Norm.mk",
  "constType": "{E : Type u_9} ‚Üí (E ‚Üí ‚Ñù) ‚Üí Norm E",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Filter.map",
   "Set",
   "Filter",
   "Filter.mem_map",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Instances.Real._auxLemma.3",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : Filter Œ±} {m : Œ± ‚Üí Œ≤} {t : Set Œ≤}, (t ‚àà Filter.map m f) = (m ‚Åª¬π' t ‚àà f)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1573",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} ‚Üí\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] ‚Üí (‚àÄ (a b c : M), a + b = c + b ‚Üí a = c) ‚Üí AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "NeZero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "NeZero.mk",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "one_ne_zero",
   "One.toOfNat1",
   "Real.instRingReal",
   "NeZero.charZero_one",
   "Real.instOneReal"],
  "name": "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
  "constType": "NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "Ring.add_left_neg",
   "AddCommGroup.mk"],
  "name": "Ring.toAddCommGroup",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí AddCommGroup R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u ‚Üí Type v ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(Œ± : Sort u) ‚Üí [i : Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "Ne.symm",
   "NeZero.out"],
  "name": "NeZero.ne'",
  "constType": "‚àÄ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], 0 ‚â† n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "OfNat.ofNat",
   "MeasureTheory.Measure.instZero.proof_1",
   "MeasureTheory.Measure.mk",
   "Zero.mk",
   "MeasureTheory.OuterMeasure.instZero",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim_zero"],
  "name": "MeasureTheory.Measure.instZero",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Zero (MeasureTheory.Measure Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "DivisionRing",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionRing.mul_inv_cancel",
  "constType":
  "‚àÄ {K : Type u} [self : DivisionRing K] (a : K), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "outParam",
   "RingHomClass.toMonoidHomClass"],
  "name": "RingHomClass.map_add",
  "constType":
  "‚àÄ {F : Type u_5} {Œ± : outParam (Type u_6)} {Œ≤ : outParam (Type u_7)} [inst : NonAssocSemiring Œ±]\n  [inst_1 : NonAssocSemiring Œ≤] [self : RingHomClass F Œ± Œ≤] (f : F) (x y : Œ±), f (x + y) = f x + f y",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "instHMul",
   "MonoidHom.toOneHom",
   "HMul.hMul",
   "OneHom.mk",
   "MonoidHom.mk",
   "id"],
  "name": "RingHom.id.proof_4",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : NonAssocSemiring Œ±] (x y : Œ±),\n  OneHom.toFun\n      (‚Üë{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ‚àÄ (x y : Œ±),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      (x + y) =\n    OneHom.toFun\n      (‚Üë{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ‚àÄ (x y : Œ±),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      (x + y)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "AddZeroClass"],
  "name": "AddMonoidHomClass",
  "constType":
  "Type u_9 ‚Üí\n  (M : outParam (Type u_10)) ‚Üí\n    (N : outParam (Type u_11)) ‚Üí [inst : AddZeroClass M] ‚Üí [inst : AddZeroClass N] ‚Üí Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a b : Œ±), min a b = if a ‚â§ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_7",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.val",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "Subtype.ext",
   "Eq.refl",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.579",
   "Asymptotics.IsBigOWith",
   "Filter.Eventually",
   "rfl",
   "LE.le",
   "Eq",
   "Subtype.property",
   "Norm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Asymptotics.definition._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.579",
   "HMul.hMul",
   "Filter",
   "Norm.norm",
   "Eq.symm",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "Asymptotics.IsBigOWith_def",
  "constType":
  "‚àÄ {Œ± : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (c : ‚Ñù) (l : Filter Œ±) (f : Œ± ‚Üí E)\n  (g : Œ± ‚Üí F), Asymptotics.IsBigOWith c l f g = ‚àÄ·∂† (x : Œ±) in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "ContinuousAt",
   "Metric.tendsto_nhds_nhds",
   "continuous_iff_continuousAt",
   "GT.gt",
   "Dist.dist",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "PseudoMetricSpace.toDist",
   "Iff",
   "Continuous",
   "LT.lt",
   "Iff.trans",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "forall_congr'"],
  "name": "Metric.continuous_iff",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üî ‚àÄ (b : Œ±), ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ (a : Œ±), dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.mk",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≥ : Type v} ‚Üí (Œ± ‚Üí Œ≥ ‚Üí Œ≥) ‚Üí Insert Œ± Œ≥",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "DecidableEq",
   "propext",
   "Finset",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.62",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {a b : Œ±}, (a ‚àà insert b s) = (a = b ‚à® a ‚àà s)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.toNNReal_coe",
   "NNReal.toReal",
   "ENNReal",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.toNNReal",
   "ENNReal.ofReal",
   "Eq.refl",
   "_private.Mathlib.Data.Real.ENNReal.0.ENNReal.ofReal._eq_1",
   "NNReal",
   "id",
   "ENNReal.ofNNReal",
   "Eq"],
  "name": "ENNReal.coe_nnreal_eq",
  "constType": "‚àÄ (r : NNReal), ‚Üër = ENNReal.ofReal ‚Üër",
  "constCategory": "Theorem"},
 {"references": ["Nontrivial", "Semifield"],
  "name": "Semifield.toNontrivial",
  "constType": "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±], Nontrivial Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real.natCast",
   "Real",
   "One.toOfNat1",
   "DenselyNormedField.toNormedField",
   "Exists.intro",
   "Exists.casesOn",
   "NormedField.toNorm",
   "Real.instOneReal",
   "And",
   "DenselyNormedField",
   "LT.lt",
   "instNatAtLeastTwo",
   "Norm.norm",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "instOfNat"],
  "name": "DenselyNormedField.toNontriviallyNormedField.match_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : DenselyNormedField Œ±] (motive : (‚àÉ a, 1 < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < 2) ‚Üí Prop) (x : ‚àÉ a, 1 < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < 2),\n  (‚àÄ (a : Œ±) (h : 1 < ‚Äña‚Äñ) (right : ‚Äña‚Äñ < 2), motive (_ : ‚àÉ a, 1 < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < 2)) ‚Üí motive x",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "instHSMul",
   "PartialOrder.toPreorder",
   "Submodule.instInfSetSubmodule.proof_3",
   "Submodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "Set",
   "Inf.inf",
   "Semiring.toMonoidWithZero",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "AddCommMonoid.toAddMonoid",
   "Lattice.mk",
   "Sup.mk",
   "Preorder.toLE",
   "Inf.mk",
   "SMulWithZero.toSMulZeroClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Lattice.toSemilatticeSup",
   "Module",
   "Set.inter_subset_right",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "Semiring",
   "SemilatticeSup.mk",
   "Module.toMulActionWithZero",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "SMulZeroClass.toSMul",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "MulActionWithZero.toSMulWithZero",
   "Set.subset_inter",
   "Set.iInter",
   "And.intro",
   "MonoidWithZero.toZero",
   "Set.inter_subset_left",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice.proof_9",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)) (a : R),\n  ‚àÄ a_1 ‚àà ‚ãÇ i ‚àà fun x_1 => ‚àÄ b ‚àà x, b ‚â§ x_1, ‚Üëi, a ‚Ä¢ a_1 ‚àà ‚ãÇ i ‚àà fun x_1 => ‚àÄ b ‚àà x, b ‚â§ x_1, ‚Üëi",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "Algebra.toRingHom",
  "constType":
  "{R : Type u} ‚Üí {A : Type v} ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : Semiring A] ‚Üí [self : Algebra R A] ‚Üí R ‚Üí+* A",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "funext",
   "Iff",
   "propext",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.ext",
  "constType":
  "‚àÄ {Œ± : Type u_1} {a b : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà a ‚Üî x ‚àà b) ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_2",
  "constType":
  "‚àÄ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M ‚Üí+ N), ZeroHom.toFun (‚Üëf) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["MetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "TopologicalSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace.MetrizableSpace",
   "Exists.intro",
   "TopologicalSpace.MetrizableSpace.mk",
   "UniformSpace.toTopologicalSpace",
   "rfl",
   "Eq"],
  "name": "MetricSpace.toMetrizableSpace",
  "constType":
  "‚àÄ {X : Type u_5} [m : MetricSpace X], TopologicalSpace.MetrizableSpace X",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet", "Set", "HasSubset.Subset", "Set.Subset.refl"],
  "name": "Set.Subset.rfl",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, s ‚äÜ s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "MonoidHom.toOneHom"],
  "name": "RingHom.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  {Œ≤ : Type u_6} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : NonAssocSemiring Œ≤] ‚Üí\n        (toMonoidHom : Œ± ‚Üí* Œ≤) ‚Üí\n          OneHom.toFun (‚ÜëtoMonoidHom) 0 = 0 ‚Üí\n            (‚àÄ (x y : Œ±),\n                OneHom.toFun (‚ÜëtoMonoidHom) (x + y) = OneHom.toFun (‚ÜëtoMonoidHom) x + OneHom.toFun (‚ÜëtoMonoidHom) y) ‚Üí\n              Œ± ‚Üí+* Œ≤",
  "constCategory": "Other"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (w : Œ±), p w ‚Üí Exists p",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "Distrib.toAdd",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "Module.toDistribMulAction",
   "instHSMul",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.instFunLike",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "RingHom.id",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "SMulHomClass.map_smul",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "SemilinearMapClass.distribMulActionHomClass",
   "MonoidWithZero.toMonoid",
   "DistribSMul.toSMulZeroClass",
   "AddMonoid.toZero",
   "SMulHomClass.toFunLike",
   "HSMul.hSMul",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid",
   "id",
   "LinearMap.semilinearMapClass",
   "add_smul",
   "smul_assoc",
   "AddHom.toFun",
   "Semiring",
   "AddHom.mk",
   "instHAdd",
   "DistribMulActionHomClass.toSMulHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "Eq.ndrec",
   "LinearMap.map_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero"],
  "name": "LinearMap.smulRight.proof_2",
  "constType":
  "‚àÄ {R : Type u_4} {S : Type u_3} {M : Type u_1} {M‚ÇÅ : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid M‚ÇÅ] [inst_3 : Module R M] [inst_4 : Module R M‚ÇÅ] [inst_5 : Semiring S] [inst_6 : Module R S]\n  [inst_7 : Module S M] [inst_8 : IsScalarTower R S M] (f : M‚ÇÅ ‚Üí‚Çó[R] S) (x : M) (b : R) (y : M‚ÇÅ),\n  AddHom.toFun\n      { toFun := fun b => f b ‚Ä¢ x,\n        map_add' := (_ : ‚àÄ (x_1 y : M‚ÇÅ), (fun b => f b ‚Ä¢ x) (x_1 + y) = (fun b => f b ‚Ä¢ x) x_1 + (fun b => f b ‚Ä¢ x) y) }\n      (b ‚Ä¢ y) =\n    (RingHom.id R) b ‚Ä¢\n      AddHom.toFun\n        { toFun := fun b => f b ‚Ä¢ x,\n          map_add' :=\n            (_ : ‚àÄ (x_1 y : M‚ÇÅ), (fun b => f b ‚Ä¢ x) (x_1 + y) = (fun b => f b ‚Ä¢ x) x_1 + (fun b => f b ‚Ä¢ x) y) }\n        y",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "LE.le",
   "Dist.dist",
   "Zero.toOfNat0",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "HSMul.hSMul",
   "HMul.hMul",
   "BoundedSMul.dist_pair_smul'",
   "PseudoMetricSpace",
   "BoundedSMul"],
  "name": "dist_pair_smul",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : Zero Œ±]\n  [inst_3 : Zero Œ≤] [inst_4 : SMul Œ± Œ≤] [inst_5 : BoundedSMul Œ± Œ≤] (x‚ÇÅ x‚ÇÇ : Œ±) (y : Œ≤),\n  dist (x‚ÇÅ ‚Ä¢ y) (x‚ÇÇ ‚Ä¢ y) ‚â§ dist x‚ÇÅ x‚ÇÇ * dist y 0",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "OrderedCancelAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : OrderedCancelAddCommMonoid Œ±] ‚Üí OrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "two_mul",
   "Trans.trans",
   "Real.natCast",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "two_pos",
   "Real.strictOrderedSemiring",
   "instOfNatNat",
   "Nat",
   "NeZero.charZero_one",
   "Eq.symm",
   "Real.instLinearOrderedSemiringReal",
   "instOfNat",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Real.partialOrder",
   "instHAdd",
   "nonneg_of_mul_nonneg_right",
   "OrderedSemiring.zeroLEOneClass",
   "Real.instRingReal",
   "NonUnitalNonAssocSemiring.toMul",
   "Real.orderedSemiring",
   "LE.le",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.instZeroReal",
   "instTransEq_1",
   "instHMul",
   "Eq.ndrec",
   "StrictOrderedSemiring.to_charZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Real.semiring",
   "NonAssocSemiring.toNatCast",
   "instTransEq",
   "instNatAtLeastTwo",
   "HMul.hMul"],
  "name": "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
  "constType":
  "‚àÄ {Œ± : Sort u_3} {x y : Œ±} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù),\n  (‚àÄ (x : Œ±), dist x x = 0) ‚Üí\n    (‚àÄ (x y : Œ±), dist x y = dist y x) ‚Üí (‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) ‚Üí 0 ‚â§ dist x y",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí Ord Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionCommMonoid.mk",
  "constType":
  "{G : Type u} ‚Üí [toSubtractionMonoid : SubtractionMonoid G] ‚Üí (‚àÄ (a b : G), a + b = b + a) ‚Üí SubtractionCommMonoid G",
  "constCategory": "Other"},
 {"references": ["Zero", "ENNReal", "WithTop.zero", "instNNRealZero", "NNReal"],
  "name": "instENNRealZero",
  "constType": "Zero ENNReal",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "CommMonoidWithZero"],
  "name": "CommGroupWithZero.toCommMonoidWithZero",
  "constType":
  "{G‚ÇÄ : Type u_4} ‚Üí [self : CommGroupWithZero G‚ÇÄ] ‚Üí CommMonoidWithZero G‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["Module.zero_smul",
   "DistribMulAction.toMulAction",
   "Module.toMulActionWithZero.proof_2",
   "Module.toDistribMulAction",
   "Semiring",
   "MulActionWithZero.mk",
   "Semiring.toMonoidWithZero",
   "MulActionWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero.proof_3",
   "inferInstance",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "AddMonoid.toZero",
   "Module",
   "MulAction",
   "Module.toMulActionWithZero.proof_1",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero",
  "constType":
  "{R : Type u_2} ‚Üí\n  {M : Type u_5} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí MulActionWithZero R M",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{Œ± : Type u_3} ‚Üí [self : HasCompl Œ±] ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "hasFDerivWithinAt_univ",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Eq.refl",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "Set.univ",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "UniqueDiffWithinAt.eq",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "ContinuousLinearMap",
   "propext",
   "HasFDerivAt",
   "Eq.mp",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "Eq.symm",
   "HasFDerivWithinAt",
   "uniqueDiffWithinAt_univ"],
  "name": "HasFDerivAt.unique",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  {f‚ÇÄ' f‚ÇÅ' : E ‚ÜíL[ùïú] F} {x : E}, HasFDerivAt f f‚ÇÄ' x ‚Üí HasFDerivAt f f‚ÇÅ' x ‚Üí f‚ÇÄ' = f‚ÇÅ'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "CauSeq.instNegCauSeq",
   "Subtype.val",
   "instHAdd",
   "IsCauSeq",
   "HAdd.hAdd",
   "CauSeq.instSubCauSeq.proof_1",
   "HSub.hSub",
   "Neg.neg",
   "CauSeq",
   "Sub",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.instAddCauSeq",
   "Sub.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring.toSub",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "CauSeq.ofEq"],
  "name": "CauSeq.instSubCauSeq",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : LinearOrderedField Œ±] ‚Üí\n      [inst_1 : Ring Œ≤] ‚Üí {abv : Œ≤ ‚Üí Œ±} ‚Üí [inst_2 : IsAbsoluteValue abv] ‚Üí Sub (CauSeq Œ≤ abv)",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "Bot.mk",
   "OrderBot",
   "OrderBot.mk",
   "Module",
   "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.proof_1",
   "Submodule.instBotSubmodule",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name":
  "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí OrderBot (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Set", "Filter"],
  "name": "Filter.sets",
  "constType": "{Œ± : Type u_1} ‚Üí Filter Œ± ‚Üí Set (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "Left.neg_neg_iff",
   "AddGroup",
   "propext",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Algebra.Order.Group.Defs._auxLemma.12",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : Œ±}, (-a < 0) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "Module",
   "AddCommMonoid"],
  "name": "LinearMap",
  "constType":
  "{R : Type u_17} ‚Üí\n  {S : Type u_18} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        (R ‚Üí+* S) ‚Üí\n          (M : Type u_19) ‚Üí\n            (M‚ÇÇ : Type u_20) ‚Üí\n              [inst_2 : AddCommMonoid M] ‚Üí\n                [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí [inst : Module R M] ‚Üí [inst : Module S M‚ÇÇ] ‚Üí Type (max u_19 u_20)",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "CommRing.toNonUnitalCommRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "Real.instSupReal",
   "AddMonoid.toAddZeroClass",
   "True",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "MulZeroClass.toMul",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "LinearOrderedRing.toLinearOrder",
   "Mathlib.Data.IsROrC.Basic._auxLemma.26",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "sq",
   "instHPow",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Lattice.toSemilatticeSup",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Neg.toHasAbs",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "Real.instMonoidReal",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "abs_mul_self",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Monoid.toMulOneClass",
   "DistribLattice.toLattice",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "add_zero",
   "congrArg"],
  "name": "Real.isROrC.proof_11",
  "constType": "‚àÄ (z : ‚Ñù), |z| ^ 2 = z * z + 0 * 0",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.induced.proof_2",
   "TopologicalSpace.mk",
   "And",
   "Exists",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced.proof_3",
   "IsOpen",
   "TopologicalSpace.induced.proof_1",
   "Eq"],
  "name": "TopologicalSpace.induced",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí TopologicalSpace Œ≤ ‚Üí TopologicalSpace Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HDiv Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mk",
  "constType":
  "{M‚ÇÄ : Type u_4} ‚Üí\n  [toCommMonoid : CommMonoid M‚ÇÄ] ‚Üí\n    [toZero : Zero M‚ÇÄ] ‚Üí (‚àÄ (a : M‚ÇÄ), 0 * a = 0) ‚Üí (‚àÄ (a : M‚ÇÄ), a * 0 = 0) ‚Üí CommMonoidWithZero M‚ÇÄ",
  "constCategory": "Other"},
 {"references": [],
  "name": "Field",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí a ‚â† b ‚Üí a < b",
  "constCategory": "Theorem"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Top.top",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Submodule.instTopSubmodule.proof_1",
   "AddMonoid.toAddZeroClass",
   "Set.univ",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "trivial",
   "Top",
   "AddSubmonoid.instTopAddSubmonoid",
   "Submodule.instTopSubmodule.proof_2",
   "Submodule.mk",
   "AddSubmonoid.mk",
   "Module",
   "AddSubsemigroup.carrier",
   "Top.mk",
   "AddCommMonoid"],
  "name": "Submodule.instTopSubmodule",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Top (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_comm",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "OrderedSemiring",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toSemiring : Semiring Œ±] ‚Üí\n    [toPartialOrder : PartialOrder Œ±] ‚Üí\n      (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b) ‚Üí\n        0 ‚â§ 1 ‚Üí\n          (‚àÄ (a b c : Œ±), a ‚â§ b ‚Üí 0 ‚â§ c ‚Üí c * a ‚â§ c * b) ‚Üí\n            (‚àÄ (a b c : Œ±), a ‚â§ b ‚Üí 0 ‚â§ c ‚Üí a * c ‚â§ b * c) ‚Üí OrderedSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["inf_le_left",
   "StronglyMeasurableAtFilter",
   "CompleteSpace",
   "NormedAddCommGroup",
   "Real.measurableSpace",
   "Real.normedField",
   "Real",
   "Inf.inf",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Filter.Tendsto.mono_left",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Real.measureSpace",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "MeasureTheory.Measure.ae",
   "intervalIntegral",
   "Real.denselyNormedField",
   "Filter.instCompleteLatticeFilter",
   "IntervalIntegrable",
   "Lattice.toSemilatticeInf",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "intervalIntegral.integral_hasStrictDerivAt_of_tendsto_ae_right",
   "ContinuousAt",
   "PseudoMetricSpace.toUniformSpace",
   "HasStrictDerivAt",
   "Real.pseudoMetricSpace",
   "ConditionallyCompleteLattice.toLattice",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Filter.instInfFilter",
   "DenselyNormedField.toNontriviallyNormedField"],
  "name": "intervalIntegral.integral_hasStrictDerivAt_right",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ‚Ñù E] {f : ‚Ñù ‚Üí E}\n  {a b : ‚Ñù},\n  IntervalIntegrable f MeasureTheory.volume a b ‚Üí\n    StronglyMeasurableAtFilter f (nhds b) ‚Üí\n      ContinuousAt f b ‚Üí HasStrictDerivAt (fun u => ‚à´ (x : ‚Ñù) in a..u, f x) (f b) b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg.mul_neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "mul_neg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : HasDistribNeg Œ±] (a b : Œ±), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sSup",
  "constType":
  "‚àÄ {Œ± : Type u_9} [self : CompleteLattice Œ±] (s : Set Œ±), ‚àÄ a ‚àà s, a ‚â§ sSup s",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} ‚Üí [self : CommSemiring R] ‚Üí Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["UniformSpace", "Filter.map", "Preorder", "Filter.atTop", "Cauchy"],
  "name": "CauchySeq",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [uniformSpace : UniformSpace Œ±] ‚Üí [inst : Preorder Œ≤] ‚Üí (Œ≤ ‚Üí Œ±) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "AddZeroClass.toZero",
   "RingHomClass.toMonoidHomClass"],
  "name": "RingHomClass.map_zero",
  "constType":
  "‚àÄ {F : Type u_5} {Œ± : outParam (Type u_6)} {Œ≤ : outParam (Type u_7)} [inst : NonAssocSemiring Œ±]\n  [inst_1 : NonAssocSemiring Œ≤] [self : RingHomClass F Œ± Œ≤] (f : F), f 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "implies_congr",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_2",
  "constType": "‚àÄ (a b c : ‚Ñù), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (n : ‚Ñï) (a : Œ±),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≥ : Type v} ‚Üí (Œ± ‚Üí Œ≥ ‚Üí Prop) ‚Üí Membership Œ± Œ≥",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalSemiring Œ±] ‚Üí SemigroupWithZero Œ±",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemifield", "Div"],
  "name": "LinearOrderedSemifield.toDiv",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedSemifield Œ±] ‚Üí Div Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Real",
   "Real.instSupReal",
   "Norm.norm",
   "Real.norm",
   "rfl",
   "Abs.abs",
   "Real.instNegReal",
   "Eq"],
  "name": "Real.norm_eq_abs",
  "constType": "‚àÄ (r : ‚Ñù), ‚Äñr‚Äñ = |r|",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo ‚Üí Lean.SyntaxNodeKind ‚Üí Array Lean.Syntax ‚Üí Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["SMul",
   "Prod.snd",
   "instHSMul",
   "instTopologicalSpaceProd",
   "Continuous",
   "HSMul.hSMul",
   "TopologicalSpace",
   "Prod",
   "ContinuousSMul",
   "Prod.fst"],
  "name": "ContinuousSMul.mk",
  "constType":
  "‚àÄ {M : Type u_1} {X : Type u_2} [inst : SMul M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X],\n  (Continuous fun p => p.1 ‚Ä¢ p.2) ‚Üí ContinuousSMul M X",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddSubmonoid.instTopAddSubmonoid",
   "instHAdd",
   "Top.top",
   "HAdd.hAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddSubsemigroup.add_mem'",
   "AddMonoid.toAddZeroClass",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name": "Submodule.instTopSubmodule.proof_1",
  "constType":
  "‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {a b : M}, a ‚àà ‚ä§.carrier ‚Üí b ‚àà ‚ä§.carrier ‚Üí a + b ‚àà ‚ä§.carrier",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedRing"],
  "name": "LinearOrderedRing.decidableEq",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí DecidableEq Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "UniformSpace.toTopologicalSpace",
   "ProperSpace",
   "IsCompact",
   "PseudoMetricSpace"],
  "name": "ProperSpace.isCompact_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [self : ProperSpace Œ±] (x : Œ±) (r : ‚Ñù), IsCompact (Metric.closedBall x r)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "instHSub",
   "OfNat.ofNat",
   "Dist.mk",
   "Real.instLEReal",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "Real.instSupReal",
   "Real.pseudoMetricSpace.proof_1",
   "UniformSpace.ofDist",
   "abs_sub_le",
   "Real.pseudoMetricSpace.proof_3",
   "Real.instLinearOrderedAddCommGroupReal",
   "Real.pseudoMetricSpace.proof_4",
   "LE.le",
   "Abs.abs",
   "Real.instNegReal",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Real.pseudoMetricSpace.proof_5",
   "Real.instAddGroupReal",
   "Bornology.ofDist",
   "PseudoMetricSpace",
   "Subtype.mk",
   "PseudoMetricSpace.mk",
   "abs_sub_comm",
   "Real.pseudoMetricSpace.proof_2",
   "ENNReal.ofNNReal"],
  "name": "Real.pseudoMetricSpace",
  "constType": "PseudoMetricSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "setOf",
   "Union.union",
   "Set",
   "HasCompl.compl",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "Set.compl_inter",
   "ENNReal",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.measure_union_null",
   "congrArg",
   "MeasurableSpace",
   "Set.instUnionSet",
   "congrFun",
   "id",
   "Set.instInterSet"],
  "name": "MeasureTheory.Measure.ae.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) {x y : Set Œ±},\n  x ‚àà {s | ‚Üë‚ÜëŒº s·∂ú = 0} ‚Üí y ‚àà {s | ‚Üë‚ÜëŒº s·∂ú = 0} ‚Üí x ‚à© y ‚àà {s | ‚Üë‚ÜëŒº s·∂ú = 0}",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "Eq",
   "iff_self",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_5",
  "constType":
  "‚àÄ {Œ± Œπ : Type u_1} {Œ∫ : Œπ ‚Üí Type u_1} (f : (a : Œπ) ‚Üí Œ∫ a ‚Üí Set Œ±), ‚®Ö a, ‚®Ü b, f a b = ‚®Ü g, ‚®Ö a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Semiring.one_mul",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_2",
  "constType": "‚àÄ (a : ‚Ñù), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_left",
  "constType":
  "‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±] (a b c : Œ±), a ‚â§ b ‚Üí 0 ‚â§ c ‚Üí c * a ‚â§ c * b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.one_mul",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "instHSub",
   "NormedAddCommGroup.toMetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NormedAddCommGroup",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NormedAddCommGroup.toNorm",
   "AddGroup.toSubNegMonoid",
   "Dist.dist",
   "Eq"],
  "name": "NormedAddCommGroup.dist_eq",
  "constType":
  "‚àÄ {E : Type u_9} [self : NormedAddCommGroup E] (x y : E), dist x y = ‚Äñx - y‚Äñ",
  "constCategory": "Definition"},
 {"references":
  ["Real.linearOrder",
   "OrderTopology.to_orderClosedTopology",
   "Real.partialOrder",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "T0Space",
   "T1Space.t0Space",
   "T2Space.t1Space",
   "UniformSpace.toTopologicalSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "OrderClosedTopology.to_t2Space"],
  "name": "Real.metricSpace.proof_1",
  "constType": "T0Space ‚Ñù",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Top",
   "AddSubmonoid.instTopAddSubmonoid.proof_2",
   "AddSubsemigroup.mk",
   "AddSubmonoid.mk",
   "AddSubmonoid.instTopAddSubmonoid.proof_1",
   "Set.univ",
   "AddSubmonoid",
   "Top.mk",
   "AddZeroClass"],
  "name": "AddSubmonoid.instTopAddSubmonoid",
  "constType":
  "{M : Type u_1} ‚Üí [inst : AddZeroClass M] ‚Üí Top (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Sub Œ±",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Div"],
  "name": "LinearOrderedField.toDiv",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí Div Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semifield",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Sup Œ±",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "StarRing",
   "CommRing.toRing",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "semiOutParam"],
  "name": "IsROrC.toStarRing",
  "constType": "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí StarRing K",
  "constCategory": "Definition"},
 {"references":
  ["Set.Icc", "TopologicalSpace", "CompactIccSpace", "Preorder", "IsCompact"],
  "name": "CompactIccSpace.isCompact_Icc",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [self : CompactIccSpace Œ±] {a b : Œ±},\n  IsCompact (Set.Icc a b)",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "Ring"],
  "name": "StrictOrderedRing.toRing",
  "constType": "{Œ± : Type u} ‚Üí [self : StrictOrderedRing Œ±] ‚Üí Ring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "NonUnitalRing",
   "HMul.hMul",
   "Eq"],
  "name": "NonUnitalRing.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing Œ±] ‚Üí (‚àÄ (a b c : Œ±), a * b * c = a * (b * c)) ‚Üí NonUnitalRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a b : Œ±), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "zero_lt_two",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHDiv",
   "LinearOrderedSemifield",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CommGroupWithZero.toCommMonoidWithZero",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "div_pos",
   "LT.lt",
   "OrderedCommSemiring.toOrderedSemiring",
   "instNatAtLeastTwo"],
  "name": "half_pos",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] {a : Œ±}, 0 < a ‚Üí 0 < a / 2",
  "constCategory": "Theorem"},
 {"references":
  ["Asymptotics.IsBigOWith_def",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "Eq.refl",
   "Asymptotics.IsBigOWith",
   "Filter.Eventually",
   "Asymptotics.IsLittleO",
   "implies_congr",
   "Asymptotics.IsLittleO_def",
   "LE.le",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Norm",
   "instHMul",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "LT.lt",
   "HMul.hMul",
   "Filter",
   "Norm.norm",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Asymptotics.isLittleO_iff",
  "constType":
  "‚àÄ {Œ± : Type u_1} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {l : Filter Œ±},\n  f =o[l] g ‚Üî ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí ‚àÄ·∂† (x : Œ±) in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.instPartialOrderFilter.proof_3",
   "Membership.mem",
   "LE.mk",
   "And",
   "Filter.instPartialOrderFilter.proof_1",
   "PartialOrder.mk",
   "Set",
   "Not",
   "Filter",
   "LT.mk",
   "Filter.instPartialOrderFilter.proof_2",
   "Filter.instPartialOrderFilter.proof_4",
   "PartialOrder",
   "instMembershipSetFilter",
   "Preorder.mk"],
  "name": "Filter.instPartialOrderFilter",
  "constType": "{Œ± : Type u} ‚Üí PartialOrder (Filter Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Real",
   "Real.metricSpace.proof_1",
   "Real.pseudoMetricSpace",
   "MetricSpace.ofT0PseudoMetricSpace"],
  "name": "Real.metricSpace",
  "constType": "MetricSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "AbsoluteValue.abs",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "StrictOrderedSemiring.toOrderedSemiring",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name": "IsAbsoluteValue.abs_isAbsoluteValue",
  "constType":
  "‚àÄ {S : Type u_1} [inst : LinearOrderedRing S], IsAbsoluteValue abs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedCommRing",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Inhabited",
   "Real",
   "Inhabited.mk"],
  "name": "Real.instInhabitedReal",
  "constType": "Inhabited ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "AddCommMagma.mk",
  "constType":
  "{G : Type u} ‚Üí [toAdd : Add G] ‚Üí (‚àÄ (a b : G), a + b = b + a) ‚Üí AddCommMagma G",
  "constCategory": "Other"},
 {"references":
  ["OrderedSemiring",
   "inferInstance",
   "Real.strictOrderedCommSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "Real",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Real.orderedSemiring",
  "constType": "OrderedSemiring ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "PartialOrder"],
  "name": "StrictOrderedRing.toPartialOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : StrictOrderedRing Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["Top", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toTop",
  "constType": "{Œ± : Type u} ‚Üí [self : BooleanAlgebra Œ±] ‚Üí Top Œ±",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí DecidableEq Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Exists",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "Classical.choose",
   "Subtype.val",
   "NontriviallyNormedField.toNormedField",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "dite",
   "NormedSpace",
   "rfl",
   "RingHom.id",
   "Eq",
   "Subtype.property",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "HasFDerivAt",
   "UniformSpace.toTopologicalSpace",
   "Eq.symm",
   "Subtype",
   "id",
   "fderiv",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Classical.propDecidable",
   "PseudoMetricSpace.toUniformSpace",
   "Subtype.ext",
   "Field.toSemifield",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Not",
   "wrapped._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
   "NormedSpace.toModule",
   "ContinuousLinearMap.zero",
   "Subtype.mk",
   "definition._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944"],
  "name": "fderiv_def",
  "constType":
  "‚àÄ (ùïú : Type u_6) [inst : NontriviallyNormedField ùïú] {E : Type u_7} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_8} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F)\n  (x : E), fderiv ùïú f x = if h : ‚àÉ f', HasFDerivAt f f' x then Classical.choose h else 0",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OrderedAddCommGroup",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "StrictOrderedRing.toOrderedAddCommGroup",
  "constType":
  "{Œ± : Type u} ‚Üí [self : StrictOrderedRing Œ±] ‚Üí OrderedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Int.natAbs",
   "Inv.inv"],
  "name": "LinearOrderedField.mk",
  "constType":
  "{Œ± : Type u_2} ‚Üí\n  [toLinearOrderedCommRing : LinearOrderedCommRing Œ±] ‚Üí\n    [toInv : Inv Œ±] ‚Üí\n      [toDiv : Div Œ±] ‚Üí\n        autoParam (‚àÄ (a b : Œ±), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí Œ± ‚Üí Œ±) ‚Üí\n            autoParam (‚àÄ (a : Œ±), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  [toRatCast : RatCast Œ±] ‚Üí\n                    (‚àÄ (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí\n                      0‚Åª¬π = 0 ‚Üí\n                        autoParam\n                            (‚àÄ (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                              ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π)\n                            _auto‚úù‚Å¥ ‚Üí\n                          (qsmul : ‚Ñö ‚Üí Œ± ‚Üí Œ±) ‚Üí\n                            autoParam (‚àÄ (a : ‚Ñö) (x : Œ±), qsmul a x = ‚Üëa * x) _auto‚úù‚Åµ ‚Üí LinearOrderedField Œ±",
  "constCategory": "Other"},
 {"references": ["Zero", "SMulWithZero", "SMulZeroClass"],
  "name": "SMulWithZero.toSMulZeroClass",
  "constType":
  "{R : Type u_1} ‚Üí {M : Type u_3} ‚Üí [inst : Zero R] ‚Üí [inst_1 : Zero M] ‚Üí [self : SMulWithZero R M] ‚Üí SMulZeroClass R M",
  "constCategory": "Definition"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : LT Œ±]\n  [i : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : Œ±},\n  b < c ‚Üí ‚àÄ (a : Œ±), b + a < c + a",
  "constCategory": "Theorem"},
 {"references":
  ["MulHomClass",
   "NonUnitalNonAssocSemiring",
   "outParam",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.toMulHomClass",
  "constType":
  "{F : Type u_5} ‚Üí\n  {Œ± : outParam (Type u_6)} ‚Üí\n    {Œ≤ : outParam (Type u_7)} ‚Üí\n      [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring Œ≤] ‚Üí [self : NonUnitalRingHomClass F Œ± Œ≤] ‚Üí MulHomClass F Œ± Œ≤",
  "constCategory": "Definition"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{Œ± : Sort u} ‚Üí (c : Prop) ‚Üí [h : Decidable c] ‚Üí (c ‚Üí Œ±) ‚Üí (¬¨c ‚Üí Œ±) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "setOf",
   "Set",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "Metric.closedBall",
  "constType": "{Œ± : Type u} ‚Üí [inst : PseudoMetricSpace Œ±] ‚Üí Œ± ‚Üí ‚Ñù ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHasEquiv",
   "Or",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toField",
   "LT.lt",
   "LE",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : LinearOrderedField Œ±] ‚Üí LE (CauSeq Œ± abs)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "id"],
  "name": "RingHom.id.proof_1",
  "constType": "‚àÄ (Œ± : Type u_1) [inst : NonAssocSemiring Œ±], id 1 = id 1",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset",
   "Finset",
   "Multiset.nodup_singleton",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Finset.mk",
   "Singleton",
   "Singleton.mk"],
  "name": "Finset.instSingletonFinset",
  "constType": "{Œ± : Type u_1} ‚Üí Singleton Œ± (Finset Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "StronglyMeasurableAtFilter",
   "MeasureTheory.StronglyMeasurable",
   "TopologicalSpace",
   "Filter",
   "MeasureTheory.AEStronglyMeasurable.stronglyMeasurableAtFilter",
   "MeasurableSpace",
   "MeasureTheory.StronglyMeasurable.aestronglyMeasurable"],
  "name": "MeasureTheory.StronglyMeasurable.stronglyMeasurableAtFilter",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {l : Filter Œ±} {f : Œ± ‚Üí Œ≤}\n  {Œº : MeasureTheory.Measure Œ±}, MeasureTheory.StronglyMeasurable f ‚Üí StronglyMeasurableAtFilter f l",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "Subtype",
   "definition._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944"],
  "name": "wrapped._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
  "constType": "Subtype (Eq definition‚úù)",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "Real.instLTReal",
   "LT.lt",
   "Real",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "Real.denselyNormedField.match_1",
  "constType":
  "‚àÄ (x x_1 : ‚Ñù) (motive : (‚àÉ a, x < a ‚àß a < x_1) ‚Üí Prop) (x_2 : ‚àÉ a, x < a ‚àß a < x_1),\n  (‚àÄ (x_3 : ‚Ñù) (h : x < x_3 ‚àß x_3 < x_1), motive (_ : ‚àÉ a, x < a ‚àß a < x_1)) ‚Üí motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap",
   "Semiring",
   "TopologicalSpace",
   "LinearMap.instFunLike",
   "FunLike.coe_injective",
   "ContinuousLinearMap.coe_injective",
   "FunLike.coe",
   "Module",
   "LinearMap",
   "Eq",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass.proof_1",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_4} {R‚ÇÇ : Type u_3} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_2}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] (x x_1 : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ),\n  (fun f => ‚áë‚Üëf) x = (fun f => ‚áë‚Üëf) x_1 ‚Üí x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "OfNat.ofNat",
   "Fintype",
   "PiLp",
   "IsROrC",
   "EuclideanSpace.proof_1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "instOfNat"],
  "name": "EuclideanSpace",
  "constType":
  "(ùïú : Type u_8) ‚Üí [inst : IsROrC ùïú] ‚Üí (n : Type u_9) ‚Üí [inst : Fintype n] ‚Üí Type (max u_9 u_8)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "Eq.mpr",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Filter",
   "OrderedAddCommMonoid.toPartialOrder",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "Prod.snd",
   "HasSubset.Subset",
   "Filter.principal_mono",
   "Prod.fst",
   "idRel",
   "LE.le",
   "GT.gt",
   "le_iInf‚ÇÇ",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "Prod.mk",
   "LT.lt",
   "idRel_subset",
   "Filter.instPartialOrderFilter",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "congrFun",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofFun.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : OrderedAddCommMonoid Œ≤] (d : Œ± ‚Üí Œ± ‚Üí Œ≤),\n  (‚àÄ (x : Œ±), d x x = 0) ‚Üí Filter.principal idRel ‚â§ ‚®Ö i, ‚®Ö (_ : i > 0), Filter.principal {x | d x.1 x.2 < i}",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring",
   "CommSemiring.mk",
   "CommRing.toRing",
   "CommRing.mul_comm",
   "Ring.toSemiring",
   "CommRing"],
  "name": "CommRing.toCommSemiring",
  "constType": "{Œ± : Type u} ‚Üí [s : CommRing Œ±] ‚Üí CommSemiring Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "neg_add_cancel_right",
   "id"],
  "name": "sub_add_cancel",
  "constType": "‚àÄ {G : Type u_3} [inst : AddGroup G] (a b : G), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Exists",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "DifferentiableAt",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : NormedAddCommGroup F] ‚Üí [inst : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "Int",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_zero'",
  "constType":
  "‚àÄ {R : Type u} [self : AddGroupWithOne R] (a : R), AddGroupWithOne.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "instHMul",
   "Eq.mpr",
   "LinearOrderedRing.toLinearOrder",
   "Eq.ndrec",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "abs_mul_abs_self",
   "abs_mul",
   "HMul.hMul",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "abs_mul_self",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a : Œ±), |a * a| = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["SMulZeroClass.mk",
   "instHMul",
   "SMul.mk",
   "SMulWithZero",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "SMulWithZero.mk",
   "MulZeroClass.toMul"],
  "name": "MulZeroClass.toSMulWithZero",
  "constType": "(R : Type u_1) ‚Üí [inst : MulZeroClass R] ‚Üí SMulWithZero R R",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.toNNReal.proof_1",
   "OfNat.ofNat",
   "Real.instLinearOrderedRingReal",
   "Real.instLEReal",
   "Real",
   "Max.max",
   "LinearOrderedRing.toMax",
   "NNReal",
   "LE.le",
   "Subtype.mk"],
  "name": "Real.toNNReal",
  "constType": "‚Ñù ‚Üí NNReal",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "OrderedAddCommGroup.add_le_add_left",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.to_covariantClass_left_le",
  "constType":
  "‚àÄ (Œ± : Type u) [inst : OrderedAddCommGroup Œ±], CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references": ["Or", "propext", "or_true_iff", "True", "Eq"],
  "name": "Mathlib.Algebra.Order.Ring.Abs._auxLemma.2",
  "constType": "‚àÄ (p : Prop), (p ‚à® True) = True",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "MeasurableSet", "MeasurableSpace"],
  "name": "Measurable",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí [inst : MeasurableSpace Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Real",
   "Real.instAddMonoidReal",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Real.isROrC.proof_9",
  "constType": "‚Ñù ‚Üí 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "MonoidHom.monoidHomClass",
   "MulHomClass.toFunLike",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "RingHom.mk",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "MonoidHom.toOneHom",
   "Eq.rec",
   "RingHom.toMonoidHom",
   "Eq.symm",
   "FunLike.coe_injective'"],
  "name": "RingHom.instRingHomClass.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f g : Œ± ‚Üí+* Œ≤),\n  (fun f => f.toFun) f = (fun f => f.toFun) g ‚Üí f = g",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {Œ≥ : Sort u_3} ‚Üí\n      (Œ± ‚Üí Œ≤ ‚Üí Sort u) ‚Üí\n        (Œ≤ ‚Üí Œ≥ ‚Üí Sort v) ‚Üí outParam (Œ± ‚Üí Œ≥ ‚Üí Sort w) ‚Üí Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references": ["Nonempty"],
  "name": "Classical.choice",
  "constType": "{Œ± : Sort u} ‚Üí Nonempty Œ± ‚Üí Œ±",
  "constCategory": "Axiom"},
 {"references": ["Add"],
  "name": "AddHom",
  "constType":
  "(M : Type u_9) ‚Üí (N : Type u_10) ‚Üí [inst : Add M] ‚Üí [inst : Add N] ‚Üí Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "‚àÄ {Œ± : Sort u_1} (a : Œ±), a = a",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "exists_congr",
   "And.left",
   "Filter.HasBasis.mem_iff",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "mem_nhds_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {a : Œ±} {s : Set Œ±}, s ‚àà nhds a ‚Üî ‚àÉ t ‚äÜ s, IsOpen t ‚àß a ‚àà t",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {x y : Œ±}, x = y ‚Üí y ‚â§ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "min_le_right",
   "max_le",
   "Inf.mk",
   "le_min",
   "le_max_left",
   "Max.max",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "min_le_left",
   "le_max_right"],
  "name": "LinearOrder.toLattice",
  "constType": "{Œ± : Type u} ‚Üí [o : LinearOrder Œ±] ‚Üí Lattice Œ±",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "outParam"],
  "name": "NonUnitalRingHomClass",
  "constType":
  "Type u_5 ‚Üí\n  (Œ± : outParam (Type u_6)) ‚Üí\n    (Œ≤ : outParam (Type u_7)) ‚Üí\n      [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí [inst : NonUnitalNonAssocSemiring Œ≤] ‚Üí Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonAssocSemiring Œ±] ‚Üí NonUnitalNonAssocSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí a = b",
  "constCategory": "Axiom"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "SubNegMonoid.zsmul_succ'",
  "constType":
  "‚àÄ {G : Type u} [self : SubNegMonoid G] (n : ‚Ñï) (a : G),\n  SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup",
   "IsROrC.toDenselyNormedField",
   "InnerProductSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NormedSpace"],
  "name": "InnerProductSpace.toNormedSpace",
  "constType":
  "{ùïú : Type u_4} ‚Üí\n  {E : Type u_5} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [self : InnerProductSpace ùïú E] ‚Üí NormedSpace ùïú E",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_10",
  "constType": "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a : Œ±), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Inv"],
  "name": "DivisionRing.toInv",
  "constType": "{K : Type u} ‚Üí [self : DivisionRing K] ‚Üí Inv K",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.775"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.one",
  "constType": "‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
  "constType":
  "‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a b c : Œ±), a < b ‚Üí 0 < c ‚Üí c * a < c * b",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "ContinuousMul",
   "TopologicalSemiring",
   "TopologicalSpace",
   "NonUnitalNonAssocSemiring.toMul"],
  "name": "TopologicalSemiring.toContinuousMul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ±] [self : TopologicalSemiring Œ±],\n  ContinuousMul Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocSemiring Œ±] ‚Üí MulZeroClass Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Div Œ±] ‚Üí HDiv Œ± Œ± Œ±",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{Œ± : Type u} ‚Üí [self : One Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Or", "IsTotal"],
  "name": "IsTotal.mk",
  "constType":
  "‚àÄ {Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, (‚àÄ (a b : Œ±), r a b ‚à® r b a) ‚Üí IsTotal Œ± r",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.toMax",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "Max.max",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedSemiring.max_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a b : Œ±), max a b = if a ‚â§ b then b else a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop ‚Üí Prop ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toSemiring : Semiring Œ±] ‚Üí\n    [toPartialOrder : PartialOrder Œ±] ‚Üí\n      (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b) ‚Üí\n        (‚àÄ (a b c : Œ±), a + b ‚â§ a + c ‚Üí b ‚â§ c) ‚Üí\n          [toNontrivial : Nontrivial Œ±] ‚Üí\n            0 ‚â§ 1 ‚Üí\n              (‚àÄ (a b c : Œ±), a < b ‚Üí 0 < c ‚Üí c * a < c * b) ‚Üí\n                (‚àÄ (a b c : Œ±), a < b ‚Üí 0 < c ‚Üí a * c < b * c) ‚Üí StrictOrderedSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.univ_mem'",
   "tendsto_nhds",
   "Set.preimage",
   "nhds",
   "Set",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Filter",
   "IsOpen",
   "Iff.mpr",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "tendsto_const_nhds",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] {a : Œ±} {f : Filter Œ≤}, Filter.Tendsto (fun x => a) f (nhds a)",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "SetLike.instPartialOrder",
   "OrderTop.mk",
   "PartialOrder.toPreorder",
   "Submodule",
   "Top.top",
   "Semiring",
   "OrderTop",
   "Module",
   "Top.mk",
   "SetLike.instMembership",
   "Submodule.setLike",
   "Preorder.toLE",
   "Submodule.instTopSubmodule",
   "AddCommMonoid"],
  "name":
  "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí OrderTop (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "le_max_right",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "neg_le_abs_self",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Neg Œ±] [inst_1 : LinearOrder Œ±] (a : Œ±), -a ‚â§ |a|",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "AddHom.mk",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "LinearMap.smulRight.proof_2",
   "LinearMap.instFunLike",
   "LinearMap.mk",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "IsScalarTower",
   "RingHom.id",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "MonoidWithZero.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "LinearMap.smulRight.proof_1",
   "AddCommMonoid"],
  "name": "LinearMap.smulRight",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_9} ‚Üí\n      {M‚ÇÅ : Type u_10} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : AddCommMonoid M] ‚Üí\n            [inst_2 : AddCommMonoid M‚ÇÅ] ‚Üí\n              [inst_3 : Module R M] ‚Üí\n                [inst_4 : Module R M‚ÇÅ] ‚Üí\n                  [inst_5 : Semiring S] ‚Üí\n                    [inst_6 : Module R S] ‚Üí\n                      [inst_7 : Module S M] ‚Üí [inst_8 : IsScalarTower R S M] ‚Üí (M‚ÇÅ ‚Üí‚Çó[R] S) ‚Üí M ‚Üí M‚ÇÅ ‚Üí‚Çó[R] M",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "RingHom.instRingHomClass",
   "NormedAddCommGroup.toAddCommGroup",
   "AddZeroClass.toAdd",
   "RingHom",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.rightDistribClass",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "IsROrC.toStarRing",
   "Semifield.toCommSemiring",
   "AddCommGroup.toAddCommMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "True",
   "add_mul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "starRingEnd",
   "RingHomClass.toAddMonoidHomClass",
   "Semiring.toNonAssocSemiring",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "instHAdd",
   "AddHomClass.toFunLike",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "MulHomClass.toFunLike",
   "map_add",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NormedField.toNormedCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "EuclideanDomain.toCommRing",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "congrArg",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "congrFun"],
  "name": "IsROrC.innerProductSpace.proof_3",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] (x y z : ùïú),\n  (starRingEnd ùïú) (x + y) * z = (starRingEnd ùïú) x * z + (starRingEnd ùïú) y * z",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "HasDistribNeg",
  "constType": "(Œ± : Type u_1) ‚Üí [inst : Mul Œ±] ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{Œ± : Type u} ‚Üí [toPreorder : Preorder Œ±] ‚Üí (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b) ‚Üí PartialOrder Œ±",
  "constCategory": "Other"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{Œ± : Type u} ‚Üí [self : PartialOrder Œ±] ‚Üí Preorder Œ±",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "OrderedAddCommGroup"],
  "name": "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí OrderedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "Ring.zsmul",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (n : ‚Ñï) (a : Œ±),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "Norm"],
  "name": "NormedRing.toNorm",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedRing Œ±] ‚Üí Norm Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.principal",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter.lift'",
   "compRel",
   "Prod.swap",
   "Filter.Tendsto",
   "Prod",
   "Filter",
   "UniformSpace.Core",
   "idRel",
   "LE.le",
   "Preorder.toLE"],
  "name": "UniformSpace.Core.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  (uniformity : Filter (Œ± √ó Œ±)) ‚Üí\n    Filter.principal idRel ‚â§ uniformity ‚Üí\n      Filter.Tendsto Prod.swap uniformity uniformity ‚Üí\n        (Filter.lift' uniformity fun s => compRel s s) ‚â§ uniformity ‚Üí UniformSpace.Core Œ±",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bornology",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "CompleteSpace",
   "NormedAlgebra.toAlgebra",
   "PartialOrder.toPreorder",
   "Real.instLEReal",
   "Real.normedField",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instAddReal",
   "Semifield.toCommSemiring",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "semiOutParam",
   "Preorder.toLE",
   "NormedField.toNorm",
   "Eq",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Ring.toNeg",
   "Real.instCommSemiringReal",
   "Nat",
   "NormedAlgebra",
   "HPow.hPow",
   "instHSub",
   "Or",
   "NormedField.toMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "PartialOrder",
   "And",
   "instHMul",
   "DecidableEq",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "RingHom",
   "Real",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "starRingEnd",
   "instHPow",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "StarRing",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Real.instMonoidReal",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddSemigroup.toAdd",
   "algebraMap",
   "HSub.hSub",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Real.instZeroReal",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DenselyNormedField",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom"],
  "name": "IsROrC.mk",
  "constType":
  "{K : semiOutParam (Type u_1)} ‚Üí\n  [toDenselyNormedField : DenselyNormedField K] ‚Üí\n    [toStarRing : StarRing K] ‚Üí\n      [toNormedAlgebra : NormedAlgebra ‚Ñù K] ‚Üí\n        [toCompleteSpace : CompleteSpace K] ‚Üí\n          (re im : K ‚Üí+ ‚Ñù) ‚Üí\n            (I : K) ‚Üí\n              re I = 0 ‚Üí\n                I = 0 ‚à® I * I = -1 ‚Üí\n                  (‚àÄ (z : K), (algebraMap ‚Ñù K) (re z) + (algebraMap ‚Ñù K) (im z) * I = z) ‚Üí\n                    (‚àÄ (r : ‚Ñù), re ((algebraMap ‚Ñù K) r) = r) ‚Üí\n                      (‚àÄ (r : ‚Ñù), im ((algebraMap ‚Ñù K) r) = 0) ‚Üí\n                        (‚àÄ (z w : K), re (z * w) = re z * re w - im z * im w) ‚Üí\n                          (‚àÄ (z w : K), im (z * w) = re z * im w + im z * re w) ‚Üí\n                            (‚àÄ (z : K), re ((starRingEnd K) z) = re z) ‚Üí\n                              (‚àÄ (z : K), im ((starRingEnd K) z) = -im z) ‚Üí\n                                (starRingEnd K) I = -I ‚Üí\n                                  (‚àÄ (z : K), ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z) ‚Üí\n                                    (‚àÄ (z : K), im z * im I = im z) ‚Üí\n                                      [toPartialOrder : PartialOrder K] ‚Üí\n                                        (‚àÄ {z w : K}, z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w) ‚Üí\n                                          [toDecidableEq : DecidableEq K] ‚Üí IsROrC K",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Semifield",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "CommSemiring",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mk",
  "constType":
  "{Œ± : Type u_4} ‚Üí\n  [toCommSemiring : CommSemiring Œ±] ‚Üí\n    [toInv : Inv Œ±] ‚Üí\n      [toDiv : Div Œ±] ‚Üí\n        autoParam (‚àÄ (a b : Œ±), a / b = a * b‚Åª¬π) _auto‚úù ‚Üí\n          (zpow : ‚Ñ§ ‚Üí Œ± ‚Üí Œ±) ‚Üí\n            autoParam (‚àÄ (a : Œ±), zpow 0 a = 1) _auto‚úù¬π ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto‚úù¬≤ ‚Üí\n                autoParam (‚àÄ (n : ‚Ñï) (a : Œ±), zpow (Int.negSucc n) a = (zpow (‚Üë(Nat.succ n)) a)‚Åª¬π) _auto‚úù¬≥ ‚Üí\n                  [toNontrivial : Nontrivial Œ±] ‚Üí 0‚Åª¬π = 0 ‚Üí (‚àÄ (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1) ‚Üí Semifield Œ±",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{Œ± : Type u_3} ‚Üí\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid Œ±] ‚Üí\n    (‚àÄ (a b c : Œ±), a + b ‚â§ a + c ‚Üí b ‚â§ c) ‚Üí OrderedCancelAddCommMonoid Œ±",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} ‚Üí [self : SubNegMonoid G] ‚Üí AddMonoid G",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{Œ± : Type u} ‚Üí [self : OrderedSemiring Œ±] ‚Üí Semiring Œ±",
  "constCategory": "Definition"},
 {"references": ["NatCast", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toNatCast",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : CanonicallyOrderedCommSemiring Œ±] ‚Üí NatCast Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSeminormedRing",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} ‚Üí [self : AddSemigroup G] ‚Üí Add G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_13",
  "constType":
  "‚àÄ (a : ‚Ñö) (x : ‚Ñù), (qsmulRec Rat.cast) a x = (qsmulRec Rat.cast) a x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Or",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "rfl",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Field.toCommRing",
   "NormedField.toField",
   "instHMul",
   "Or.intro_left",
   "Ring.toNeg",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_2",
  "constType": "0 = 0 ‚à® 0 * 0 = -1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "‚àÄ {Œ± : Sort u} {a b : Œ±}, a = b ‚Üí b = a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "setOf",
   "MeasureTheory.Measure.ae.proof_2",
   "MeasureTheory.Measure.ae.proof_1",
   "Set",
   "MeasureTheory.Measure.ae.proof_3",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Filter.mk",
   "Filter",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.ae",
  "constType":
  "{Œ± : Type u_6} ‚Üí {m : MeasurableSpace Œ±} ‚Üí MeasureTheory.Measure Œ± ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": ["Semiring", "AddCommMonoid"],
  "name": "Module",
  "constType":
  "(R : Type u) ‚Üí (M : Type v) ‚Üí [inst : Semiring R] ‚Üí [inst : AddCommMonoid M] ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "TopologicalSpace",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "LE",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : Pow Œ± Œ≤] ‚Üí HPow Œ± Œ≤ Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "congrArg",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "congrFun"],
  "name": "Left.mul_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} {a b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulMono Œ±],\n  0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a * b",
  "constCategory": "Theorem"},
 {"references": ["Or", "propext", "true_or_iff", "True", "Eq"],
  "name": "Mathlib.Algebra.Order.Ring.Abs._auxLemma.1",
  "constType": "‚àÄ (p : Prop), (True ‚à® p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.inv_zero",
  "constType": "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±], 0‚Åª¬π = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mul_comm",
  "constType": "‚àÄ {Œ± : Type u} [self : CommRing Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Inter.inter",
   "Submodule.instInfSubmodule.proof_1",
   "Submodule.instInfSubmodule.proof_3",
   "AddMonoid.toAddZeroClass",
   "Inf.mk",
   "Inf",
   "Submodule.mk",
   "AddSubmonoid.mk",
   "Module",
   "Submodule.setLike",
   "Submodule.instInfSubmodule.proof_2",
   "AddCommMonoid",
   "Set.instInterSet",
   "SetLike.coe"],
  "name": "Submodule.instInfSubmodule",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Inf (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Norm", "NormedDivisionRing"],
  "name": "NormedDivisionRing.toNorm",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedDivisionRing Œ±] ‚Üí Norm Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing.toNorm",
   "NormedRing",
   "SeminormedRing",
   "NormedRing.norm_mul",
   "NormedRing.dist_eq",
   "MetricSpace.toPseudoMetricSpace",
   "NormedRing.toMetricSpace",
   "SeminormedRing.mk",
   "NormedRing.toRing"],
  "name": "NormedRing.toSeminormedRing",
  "constType": "{Œ± : Type u_1} ‚Üí [Œ≤ : NormedRing Œ±] ‚Üí SeminormedRing Œ±",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "‚àÄ {a : Prop}, a ‚Üî a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "OfNat.ofNat",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_5",
  "constType": "‚àÄ (r : ‚Ñù), 0 ((algebraMap ‚Ñù ‚Ñù) r) = 0 ((algebraMap ‚Ñù ‚Ñù) r)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "DivisionRing.toDiv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.div_eq_mul_inv",
  "constType":
  "‚àÄ {K : Type u} [self : DivisionRing K] (a b : K), a / b = a * b‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí DecidableRel fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNormedRing.toNorm",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "NonUnitalNormedRing",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le"],
  "name": "NonUnitalNormedRing.norm_mul",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NonUnitalNormedRing Œ±] (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "‚àÄ {Œ± : Type u_9} [self : CompleteLattice Œ±] (s : Set Œ±) (a : Œ±), (‚àÄ b ‚àà s, a ‚â§ b) ‚Üí a ‚â§ sInf s",
  "constCategory": "Definition"},
 {"references": ["Zero", "SMul", "PseudoMetricSpace"],
  "name": "BoundedSMul",
  "constType":
  "(Œ± : Type u_1) ‚Üí\n  (Œ≤ : Type u_2) ‚Üí\n    [inst : PseudoMetricSpace Œ±] ‚Üí\n      [inst : PseudoMetricSpace Œ≤] ‚Üí [inst : Zero Œ±] ‚Üí [inst : Zero Œ≤] ‚Üí [inst : SMul Œ± Œ≤] ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ±) ‚Üí Neg Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "IsROrC.re",
   "RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Semifield.toCommSemiring",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NormedField.toNorm",
   "Eq",
   "NormedRing.toNonUnitalNormedRing",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "IsROrC.mul_conj",
   "IsROrC.ofReal_re",
   "NormedAddCommGroup.toNorm",
   "MonoidWithZeroHom",
   "Nat",
   "HPow.hPow",
   "IsROrC.normSq",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "EuclideanDomain.toCommRing",
   "CommMagma.toMul",
   "instHMul",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "RingHom",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "IsROrC.toStarRing",
   "Eq.refl",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "mul_comm",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "starRingEnd",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "instHPow",
   "Monoid.toNatPow",
   "Inner.inner",
   "instOfNatNat",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMonoidReal",
   "IsROrC.toDenselyNormedField",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddHomClass.toFunLike",
   "Inner.mk",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "IsROrC.normSq_eq_def'",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "IsROrC.ofReal",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Real.semiring",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "IsROrC.innerProductSpace.proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] (x : ùïú), ‚Äñx‚Äñ ^ 2 = IsROrC.re (inner x x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.finRange.proof_1",
   "List.pmap",
   "List.mem_range",
   "List.instMembershipList",
   "Fin.val",
   "List.mem_pmap",
   "Eq.refl",
   "Exists.intro",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "List.finRange",
   "Nat",
   "Eq.symm",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "Fin.casesOn",
   "List.range"],
  "name": "List.mem_finRange",
  "constType": "‚àÄ {n : ‚Ñï} (a : Fin n), a ‚àà List.finRange n",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace",
   "Filter",
   "definition._@.Mathlib.Topology.Basic._hyg.10659",
   "Subtype",
   "Eq"],
  "name": "wrapped._@.Mathlib.Topology.Basic._hyg.10659",
  "constType": "Subtype (Eq @definition‚úù)",
  "constCategory": "Other"},
 {"references": ["EuclideanDomain", "CommRing"],
  "name": "EuclideanDomain.toCommRing",
  "constType": "{R : Type u} ‚Üí [self : EuclideanDomain R] ‚Üí CommRing R",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{Œ± : Type u} ‚Üí [self : Zero Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "FunLike", "Function.Injective"],
  "name": "FunLike.mk",
  "constType":
  "{F : Sort u_1} ‚Üí\n  {Œ± : outParam (Sort u_2)} ‚Üí\n    {Œ≤ : outParam (Œ± ‚Üí Sort u_3)} ‚Üí (coe : F ‚Üí (a : Œ±) ‚Üí Œ≤ a) ‚Üí Function.Injective coe ‚Üí FunLike F Œ± Œ≤",
  "constCategory": "Other"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Or",
   "Bot.bot",
   "LinearOrder",
   "Preorder.topology",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "nhds",
   "Classical.propDecidable",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Set.Iio",
   "CompleteLattice.toBot",
   "ite",
   "Eq",
   "DistribLattice.toLattice",
   "limUnder",
   "instDecidableNot",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Not",
   "Filter",
   "instDecidableOr",
   "Function.leftLim.proof_1",
   "nhdsWithin",
   "Filter.instCompleteLatticeFilter"],
  "name": "Function.leftLim",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : LinearOrder Œ±] ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Œ± ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Exists",
   "OfNat.ofNat",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Lean.IsNeutral",
   "Exists.casesOn",
   "Eq",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Eq.mpr",
   "Filter.inter_mem",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "instOfNatNat",
   "Filter",
   "Option.some",
   "List.nil",
   "Nat",
   "Eq.symm",
   "And.casesOn",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "List.cons",
   "setOf",
   "Set.inter_isComm",
   "Lean.Data.AC.eval",
   "instIsCommutative",
   "Lean.IsIdempotent",
   "Set.instMembershipSet",
   "And",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "instIsAssociative",
   "Lean.IsCommutative",
   "congr",
   "Bool",
   "And.intro",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "Set.inter_isAssoc",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} (f g : Filter Œ±) {x y : Set Œ±},\n  x ‚àà {s | ‚àÉ a ‚àà f, ‚àÉ b ‚àà g, s = a ‚à© b} ‚Üí\n    y ‚àà {s | ‚àÉ a ‚àà f, ‚àÉ b ‚àà g, s = a ‚à© b} ‚Üí x ‚à© y ‚àà {s | ‚àÉ a ‚àà f, ‚àÉ b ‚àà g, s = a ‚à© b}",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Zero.toOfNat0",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "AddGroup.toSubtractionMonoid.proof_2",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_4",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] (x : G), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} ‚Üí [toAddMonoid : AddMonoid M] ‚Üí (‚àÄ (a b : M), a + b = b + a) ‚Üí AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "Field",
   "Rat.cast",
   "Rat",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Field.qsmul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Field.toRatCast",
   "Eq"],
  "name": "Field.qsmul_eq_mul'",
  "constType":
  "‚àÄ {K : Type u} [self : Field K] (a : ‚Ñö) (x : K), Field.qsmul a x = ‚Üëa * x",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} ‚Üí [self : AddZeroClass M] ‚Üí Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{Œ± : Sort u_1} ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "MulOneClass",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Eq"],
  "name": "MulOneClass.mk",
  "constType":
  "{M : Type u} ‚Üí [toOne : One M] ‚Üí [toMul : Mul M] ‚Üí (‚àÄ (a : M), 1 * a = a) ‚Üí (‚àÄ (a : M), a * 1 = a) ‚Üí MulOneClass M",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "SemilatticeSup",
   "Exists",
   "PartialOrder.toPreorder",
   "propext",
   "Set",
   "Filter.mem_atTop_sets",
   "GE.ge",
   "Filter",
   "Filter.atTop",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Nonempty",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Instances.Real._auxLemma.4",
  "constType":
  "‚àÄ {Œ± : Type u_3} [inst : Nonempty Œ±] [inst : SemilatticeSup Œ±] {s : Set Œ±}, (s ‚àà Filter.atTop) = ‚àÉ a, ‚àÄ b ‚â• a, b ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["HasCompl", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHasCompl",
  "constType": "{Œ± : Type u} ‚Üí [self : BooleanAlgebra Œ±] ‚Üí HasCompl Œ±",
  "constCategory": "Definition"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MulActionWithZero",
  "constType":
  "(R : Type u_1) ‚Üí (M : Type u_3) ‚Üí [inst : MonoidWithZero R] ‚Üí [inst : Zero M] ‚Üí Type (max u_1 u_3)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "fderiv",
   "OfNat.ofNat",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "NormedSpace",
   "RingHom.id",
   "Semiring.toOne",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedField.toNormedSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "ContinuousMapClass.toFunLike"],
  "name": "deriv",
  "constType":
  "{ùïú : Type u} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {F : Type v} ‚Üí [inst_1 : NormedAddCommGroup F] ‚Üí [inst : NormedSpace ùïú F] ‚Üí (ùïú ‚Üí F) ‚Üí ùïú ‚Üí F",
  "constCategory": "Definition"},
 {"references": ["MetricSpace", "NonUnitalNormedRing"],
  "name": "NonUnitalNormedRing.toMetricSpace",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : NonUnitalNormedRing Œ±] ‚Üí MetricSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.GenerateSets.inter",
   "setOf",
   "Filter.GenerateSets",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ"],
  "name": "Filter.generate",
  "constType": "{Œ± : Type u} ‚Üí Set (Set Œ±) ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Sub"],
  "name": "AddGroupWithOne.toSub",
  "constType": "{R : Type u} ‚Üí [self : AddGroupWithOne R] ‚Üí Sub R",
  "constCategory": "Definition"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} ‚Üí [self : Monoid M] ‚Üí One M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.instMulReal",
   "DivisionRing.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Ring.toIntCast",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Real.instInvReal",
   "Nat",
   "Ne",
   "Rat.cast_mk'",
   "Real.ofCauchy_natCast",
   "Rat.instLinearOrderedRingRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.intCast",
   "Real.ofCauchy",
   "DivisionRing.toInv",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Real.ofCauchy_inv",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv",
   "StrictOrderedRing.toRing",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toDivisionSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "DivisionRing.toRing",
   "Real",
   "Real.ofCauchy_ratCast",
   "CauSeq.Completion.instNatCastCauchy",
   "Eq.refl",
   "Rat.mk'",
   "Real.ofCauchy_intCast",
   "Inv.mk",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Rat.instSupRat",
   "Real.ofCauchy_mul",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "RatCast.mk",
   "Rat",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "LinearOrderedCommRing.mk",
   "Rat.divisionRing",
   "Real.linearOrderedCommRing",
   "Nat.Coprime",
   "HMul.hMul",
   "Int.natAbs"],
  "name": "Real.instLinearOrderedFieldReal.proof_12",
  "constType":
  "‚àÄ (n : ‚Ñ§) (d : ‚Ñï) (hd : d ‚â† 0) (h2 : Nat.Coprime (Int.natAbs n) d), ‚Üë(Rat.mk' n d) = ‚Üën * (‚Üëd)‚Åª¬π",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Field.zpow_succ'",
  "constType":
  "‚àÄ {K : Type u} [self : Field K] (n : ‚Ñï) (a : K), Field.zpow (Int.ofNat (Nat.succ n)) a = a * Field.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{Œ± : Sort u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "Ring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Ring.toNonAssocRing.proof_9",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.instFunLike",
   "RingHom.id",
   "Eq",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "AddCommMonoid",
   "add_smul",
   "Semiring",
   "instHAdd",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "MulActionWithZero.toSMulWithZero",
   "Eq.ndrec",
   "LinearMap.map_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero"],
  "name": "LinearMap.smulRight.proof_1",
  "constType":
  "‚àÄ {R : Type u_4} {S : Type u_2} {M : Type u_1} {M‚ÇÅ : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid M‚ÇÅ] [inst_3 : Module R M‚ÇÅ] [inst_4 : Semiring S] [inst_5 : Module R S] [inst_6 : Module S M]\n  (f : M‚ÇÅ ‚Üí‚Çó[R] S) (x : M) (x_1 y : M‚ÇÅ), (fun b => f b ‚Ä¢ x) (x_1 + y) = (fun b => f b ‚Ä¢ x) x_1 + (fun b => f b ‚Ä¢ x) y",
  "constCategory": "Theorem"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "DistribMulAction.mk",
   "Pi.module.proof_2",
   "Semiring",
   "Pi.module.proof_1",
   "Semiring.toMonoidWithZero",
   "Pi.module.proof_3",
   "AddCommMonoid.toAddMonoid",
   "DistribMulAction",
   "Pi.addMonoid",
   "Pi.module.proof_4",
   "Pi.addCommMonoid",
   "MonoidWithZero.toMonoid",
   "Module",
   "Pi.distribMulAction",
   "AddCommMonoid",
   "Module.mk"],
  "name": "Pi.module",
  "constType":
  "(I : Type u) ‚Üí\n  (f : I ‚Üí Type v) ‚Üí\n    (Œ± : Type u_1) ‚Üí\n      {r : Semiring Œ±} ‚Üí\n        {m : (i : I) ‚Üí AddCommMonoid (f i)} ‚Üí [inst : (i : I) ‚Üí Module Œ± (f i)] ‚Üí Module Œ± ((i : I) ‚Üí f i)",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set",
   "MeasurableSpace.measurableSet_injective.match_1",
   "HasCompl.compl",
   "Eq.refl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.mk",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.iUnion",
   "Eq.ndrec",
   "Function.Injective",
   "Eq.rec",
   "MeasurableSet",
   "Nat",
   "MeasurableSpace"],
  "name": "MeasurableSpace.measurableSet_injective",
  "constType": "‚àÄ {Œ± : Type u_1}, Function.Injective (@MeasurableSet Œ±)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Int"],
  "name": "SubNegMonoid.zsmul",
  "constType": "{G : Type u} ‚Üí [self : SubNegMonoid G] ‚Üí ‚Ñ§ ‚Üí G ‚Üí G",
  "constCategory": "Definition"},
 {"references":
  ["Filter.instInfFilter.proof_3",
   "Membership.mem",
   "And",
   "Exists",
   "Inf.mk",
   "Filter.instInfFilter.proof_1",
   "setOf",
   "Inf",
   "Filter.mk",
   "Set",
   "Inter.inter",
   "Filter",
   "Filter.instInfFilter.proof_2",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instInfFilter",
  "constType": "{Œ± : Type u} ‚Üí Inf (Filter Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "LinearOrder",
   "LinearOrder.max_def",
   "Real",
   "Real.nontrivial",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.commRing",
   "CommRing.mul_comm",
   "StrictOrderedRing.toNontrivial",
   "StrictOrderedRing.mul_pos",
   "CommRing",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "Nontrivial",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.linearOrderedCommRing",
  "constType": "LinearOrderedCommRing ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "Int",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_zero'",
  "constType":
  "‚àÄ {Œ± : Type u_4} [self : Semifield Œ±] (a : Œ±), Semifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "‚àÄ {a b : Prop}, a ‚Üí a ‚à® b",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Sup",
   "Sup.sup",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toSup : Sup Œ±] ‚Üí\n    [toPartialOrder : PartialOrder Œ±] ‚Üí\n      (‚àÄ (a b : Œ±), a ‚â§ a ‚äî b) ‚Üí\n        (‚àÄ (a b : Œ±), b ‚â§ a ‚äî b) ‚Üí (‚àÄ (a b c : Œ±), a ‚â§ c ‚Üí b ‚â§ c ‚Üí a ‚äî b ‚â§ c) ‚Üí SemilatticeSup Œ±",
  "constCategory": "Other"},
 {"references": ["SeminormedAddCommGroup", "PseudoMetricSpace"],
  "name": "SeminormedAddCommGroup.toPseudoMetricSpace",
  "constType":
  "{E : Type u_9} ‚Üí [self : SeminormedAddCommGroup E] ‚Üí PseudoMetricSpace E",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.Regular.toIsFiniteMeasureOnCompacts",
   "Real.borelSpace",
   "NormedAddCommGroup",
   "PartialOrder.toPreorder",
   "MeasureTheory.Measure.Regular.of_sigmaCompactSpace_of_isLocallyFiniteMeasure",
   "Real.lattice",
   "Real.measurableSpace",
   "Real",
   "Inf.inf",
   "ConditionallyCompleteLinearOrder.toCompactIccSpace",
   "BorelSpace.opensMeasurable",
   "MetricSpace.toMetrizableSpace",
   "MeasureTheory.Measure",
   "Lattice.toInf",
   "instTopologicalAddGroupRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstAddGroupReal",
   "SemilatticeSup.toSup",
   "locally_compact_of_proper",
   "SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace",
   "instSecondCountableTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "Lattice.toSemilatticeSup",
   "MeasureTheory.IntegrableOn.intervalIntegrable",
   "MeasureTheory.IsLocallyFiniteMeasure",
   "TopologicalSpace.t2Space_of_metrizableSpace",
   "ContinuousOn.integrableOn_Icc",
   "IntervalIntegrable",
   "Lattice.toSemilatticeInf",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Set.uIcc",
   "TopologicalSpace.SecondCountableTopology.to_separableSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "instProperSpaceRealPseudoMetricSpace",
   "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace",
   "Real.metricSpace",
   "instWeaklyLocallyCompactSpace_1",
   "Real.instConditionallyCompleteLinearOrderReal",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.instAddGroupReal",
   "Sup.sup",
   "ContinuousOn"],
  "name": "ContinuousOn.intervalIntegrable",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {Œº : MeasureTheory.Measure ‚Ñù}\n  [inst_1 : MeasureTheory.IsLocallyFiniteMeasure Œº] {u : ‚Ñù ‚Üí E} {a b : ‚Ñù},\n  ContinuousOn u (Set.uIcc a b) ‚Üí IntervalIntegrable u Œº a b",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "‚Ñï ‚Üí ‚Ñï",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toZero", "ZeroHom", "AddZeroClass", "AddMonoidHom"],
  "name": "AddMonoidHom.toZeroHom",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : AddZeroClass M] ‚Üí [inst_1 : AddZeroClass N] ‚Üí (M ‚Üí+ N) ‚Üí ZeroHom M N",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "true_or", "iff_of_eq", "True"],
  "name": "true_or_iff",
  "constType": "‚àÄ (p : Prop), True ‚à® p ‚Üî True",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "HasDerivAtFilter.proof_2",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "HasFDerivAtFilter",
   "NormedField.toNormedSpace",
   "ContinuousLinearMap.smulRight",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "HasDerivAtFilter.proof_1",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAtFilter",
  "constType":
  "{ùïú : Type u} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {F : Type v} ‚Üí [inst_1 : NormedAddCommGroup F] ‚Üí [inst : NormedSpace ùïú F] ‚Üí (ùïú ‚Üí F) ‚Üí F ‚Üí ùïú ‚Üí Filter ùïú ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_zero'",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (a : Œ±), LinearOrderedField.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "AddMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_add",
   "NonAssocSemiring",
   "outParam",
   "AddHomClass.mk",
   "RingHomClass.toMonoidHomClass",
   "AddMonoidHomClass.mk",
   "RingHomClass.map_zero"],
  "name": "RingHomClass.toAddMonoidHomClass",
  "constType":
  "{F : Type u_5} ‚Üí\n  {Œ± : outParam (Type u_6)} ‚Üí\n    {Œ≤ : outParam (Type u_7)} ‚Üí\n      [inst : NonAssocSemiring Œ±] ‚Üí\n        [inst_1 : NonAssocSemiring Œ≤] ‚Üí [self : RingHomClass F Œ± Œ≤] ‚Üí AddMonoidHomClass F Œ± Œ≤",
  "constCategory": "Definition"},
 {"references": ["Field", "CommRing"],
  "name": "Field.toCommRing",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí CommRing K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Inter.inter",
   "Module",
   "Submodule.setLike",
   "Set.instInterSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_6",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 x_2 : Submodule R M), ‚Üëx ‚äÜ ‚Üëx_1 ‚Üí ‚Üëx ‚äÜ ‚Üëx_2 ‚Üí ‚Üëx ‚äÜ ‚Üëx_1 ‚à© ‚Üëx_2",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.partialOrder.proof_2",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Function.comp",
   "LE",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Prop.partialOrder.proof_1",
   "PartialOrder",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder",
  "constType": "PartialOrder Prop",
  "constCategory": "Definition"},
 {"references": ["Bornology.cobounded'", "Filter", "Bornology"],
  "name": "Bornology.cobounded",
  "constType": "(Œ± : Type u_4) ‚Üí [inst : Bornology Œ±] ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references":
  ["PiLp.instPseudoMetricSpacePiLp",
   "CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "PiLp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SeminormedAddCommGroup",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "Preorder.toLE",
   "SeminormedAddCommGroup.mk",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "PiLp.seminormedAddCommGroup.proof_1",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Fintype",
   "PiLp.hasNorm",
   "SeminormedAddCommGroup.toNorm",
   "AddCommGroup.toAddGroup",
   "Pi.addCommGroup",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "AddCommGroup",
   "PiLp.seminormedAddCommGroup.proof_2",
   "Fact",
   "AddCommGroup.mk"],
  "name": "PiLp.seminormedAddCommGroup",
  "constType":
  "(p : ENNReal) ‚Üí\n  {Œπ : Type u_3} ‚Üí\n    (Œ≤ : Œπ ‚Üí Type u_5) ‚Üí\n      [inst : Fintype Œπ] ‚Üí\n        [inst : Fact (1 ‚â§ p)] ‚Üí [inst : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)] ‚Üí SeminormedAddCommGroup (PiLp p Œ≤)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasCompl",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Other"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Mul Œ±",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NormedAlgebra.id.proof_3",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "Algebra.toRingHom",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "Algebra",
   "NormedAlgebra.id.proof_1",
   "NormedAlgebra",
   "DistribMulAction.toMulAction",
   "NormedAlgebra.id.proof_2",
   "NormedField",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "NormedField.toNormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "SeminormedRing.toRing",
   "MulAction.toSMul",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "Algebra.mk",
   "NormedSpace.toModule",
   "NormedAlgebra.mk"],
  "name": "NormedAlgebra.id",
  "constType": "(ùïú : Type u_5) ‚Üí [inst : NormedField ùïú] ‚Üí NormedAlgebra ùïú ùïú",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Semiring.toNonAssocSemiring",
   "instHAdd",
   "Distrib.rightDistribClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "HMul.hMul",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "add_mul"],
  "name": "Semiring.toModule.proof_3",
  "constType":
  "‚àÄ {R : Type u_1} [inst : Semiring R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.nonempty_iff_ne_empty",
   "Ne",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Not",
   "Set.instEmptyCollectionSet",
   "Classical.or_iff_not_imp_left",
   "Iff.mpr",
   "Eq"],
  "name": "Set.eq_empty_or_nonempty",
  "constType": "‚àÄ {Œ± : Type u} (s : Set Œ±), s = ‚àÖ ‚à® Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "NeZero.ne",
   "One",
   "One.toOfNat1"],
  "name": "one_ne_zero",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : NeZero 1], 1 ‚â† 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Definition"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{Œ± : Sort u_1} ‚Üí {Œ≥ : Sort u_2} ‚Üí (r : Œ± ‚Üí Œ≥ ‚Üí Sort u) ‚Üí Trans Eq r r",
  "constCategory": "Definition"},
 {"references":
  ["Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "Real",
   "LinearOrderedAddCommGroup.to_noMinOrder",
   "nhdsWithin_Iio_self_neBot",
   "Eq",
   "MetricSpace.toMetrizableSpace",
   "Real.linearOrder",
   "Filter.Tendsto.mono_left",
   "StieltjesFunction.mono",
   "nhdsWithin_le_nhds",
   "tendsto_nhds_unique",
   "LinearOrderedField.toLinearOrderedSemifield",
   "nhdsWithin",
   "StieltjesFunction.id",
   "UniformSpace.toTopologicalSpace",
   "id",
   "TopologicalSpace.t2Space_of_metrizableSpace",
   "Function.leftLim",
   "Lattice.toSemilatticeInf",
   "nhds",
   "instDistribLattice",
   "Real.nontrivial",
   "PseudoMetricSpace.toUniformSpace",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Set.Iio",
   "Real.instLinearOrderedAddCommGroupReal",
   "continuousAt_id",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "DistribLattice.toLattice",
   "StieltjesFunction.toFun",
   "Real.metricSpace",
   "Real.instConditionallyCompleteLinearOrderReal",
   "ContinuousAt.tendsto",
   "LinearOrderedSemiField.toDenselyOrdered",
   "Monotone.tendsto_leftLim"],
  "name": "StieltjesFunction.id_leftLim",
  "constType": "‚àÄ (x : ‚Ñù), Function.leftLim (‚ÜëStieltjesFunction.id) x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrder",
   "instDistribLattice",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_neg",
   "abs_eq_max_neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "SemilatticeSup.toSup",
   "InvolutiveNeg.toNeg",
   "Max.max",
   "LinearOrder.toMax",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "max_comm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "abs_neg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±] (a : Œ±), |(-a)| = |a|",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "‚àÄ {p : Prop}, p ‚Üí p = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toLE : LE Œ±] ‚Üí\n    [toLT : LT Œ±] ‚Üí\n      (‚àÄ (a : Œ±), a ‚â§ a) ‚Üí\n        (‚àÄ (a b c : Œ±), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c) ‚Üí autoParam (‚àÄ (a b : Œ±), a < b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a) _auto‚úù ‚Üí Preorder Œ±",
  "constCategory": "Other"},
 {"references": ["MetricSpace", "PseudoMetricSpace"],
  "name": "MetricSpace.toPseudoMetricSpace",
  "constType": "{Œ± : Type u} ‚Üí [self : MetricSpace Œ±] ‚Üí PseudoMetricSpace Œ±",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "AddHom", "Add", "Eq"],
  "name": "AddHom.mk",
  "constType":
  "{M : Type u_9} ‚Üí\n  {N : Type u_10} ‚Üí\n    [inst : Add M] ‚Üí [inst_1 : Add N] ‚Üí (toFun : M ‚Üí N) ‚Üí (‚àÄ (x y : M), toFun (x + y) = toFun x + toFun y) ‚Üí AddHom M N",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalNonAssocCommSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocCommSemiring Œ±] ‚Üí NonUnitalNonAssocSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "instHSMul",
   "LinearMap.map_smul'",
   "AddHom.toFun",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "MonoidWithZero.toZero",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass.proof_3",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_4} {R‚ÇÇ : Type u_3} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_2}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (r : R‚ÇÅ) (x : M‚ÇÅ),\n  AddHom.toFun f.toAddHom (r ‚Ä¢ x) = œÉ‚ÇÅ‚ÇÇ r ‚Ä¢ AddHom.toFun f.toAddHom x",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["LocallyCompactSpace",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "locallyCompactSpace_of_hasBasis",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Metric.closedBall",
   "LT.lt",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "ProperSpace.isCompact_closedBall",
   "UniformSpace.toTopologicalSpace",
   "ProperSpace",
   "PseudoMetricSpace",
   "Metric.nhds_basis_closedBall"],
  "name": "locally_compact_of_proper",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±], LocallyCompactSpace Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "One",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "‚àÄ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalRing.to_topologicalAddGroup",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instLinearOrderedFieldReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.commRing",
   "Real.pseudoMetricSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "Real.instDivisionRingReal",
   "inferInstance",
   "LinearOrderedField.toTopologicalDivisionRing",
   "Real.instAddGroupReal",
   "TopologicalDivisionRing.toTopologicalRing",
   "UniformSpace.toTopologicalSpace",
   "TopologicalAddGroup"],
  "name":
  "instTopologicalAddGroupRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstAddGroupReal",
  "constType": "TopologicalAddGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Ring.toSemiring",
   "Int",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_ofNat",
  "constType":
  "‚àÄ {R : Type u} [self : Ring R] (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën",
  "constCategory": "Definition"},
 {"references":
  ["Fintype", "NormedAddCommGroup", "InnerProductSpace", "IsROrC"],
  "name": "OrthonormalBasis",
  "constType":
  "(Œπ : Type u_1) ‚Üí\n  (ùïú : Type u_3) ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      (E : Type u_4) ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst : InnerProductSpace ùïú E] ‚Üí [inst : Fintype Œπ] ‚Üí Type (max (max u_1 u_3) u_4)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Real",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instRingReal",
   "AddMonoid"],
  "name": "Real.instAddMonoidReal",
  "constType": "AddMonoid ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{Œ± : Type u} ‚Üí [self : Inf Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{Œ± : Type u} ‚Üí [self : EmptyCollection Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "DenselyOrdered",
  "constType": "(Œ± : Type u) ‚Üí [inst : LT Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "nhds",
   "Set",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Filter.HasBasis.mem_iff",
   "Metric.nhds_basis_ball",
   "GT.gt",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "LT.lt",
   "Filter",
   "Metric.ball",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "instMembershipSetFilter"],
  "name": "Metric.mem_nhds_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {s : Set Œ±}, s ‚àà nhds x ‚Üî ‚àÉ Œµ > 0, Metric.ball x Œµ ‚äÜ s",
  "constCategory": "Theorem"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} ‚Üí [self : Distrib R] ‚Üí Add R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "MeasureTheory.OuterMeasure.comap",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "IsScalarTower.right",
   "Subtype.val",
   "Set",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.OuterMeasure.restrict.proof_2",
   "Set.instMembershipSet",
   "MeasureTheory.OuterMeasure.restrict.proof_1",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.OuterMeasure.map",
   "OrderedSemiring.toSemiring",
   "LinearMap.comp",
   "MeasureTheory.OuterMeasure.instModule",
   "Algebra.id",
   "MeasureTheory.OuterMeasure",
   "LinearMap",
   "Subtype",
   "Semiring.toModule"],
  "name": "MeasureTheory.OuterMeasure.restrict",
  "constType":
  "{Œ± : Type u_1} ‚Üí Set Œ± ‚Üí MeasureTheory.OuterMeasure Œ± ‚Üí‚Çó[ENNReal] MeasureTheory.OuterMeasure Œ±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "Real",
   "ENNReal.ofReal",
   "ENNReal.ofReal_lt_top",
   "True",
   "Eq",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "eq_true",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLinearOrder.toCompletelyDistribLattice"],
  "name": "Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.1",
  "constType": "‚àÄ {r : ‚Ñù}, (ENNReal.ofReal r < ‚ä§) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "‚àÄ (n : ‚Ñï), 0 ‚â§ n",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "‚àÄ {G : Type u} [inst : Add G], (‚àÄ (a b c : G), a + b = c + b ‚Üí a = c) ‚Üí IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["DivisionRing",
   "DivisionRing.toRing",
   "TopologicalRing",
   "TopologicalSpace",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "TopologicalDivisionRing",
   "Ring.toNonAssocRing"],
  "name": "TopologicalDivisionRing.toTopologicalRing",
  "constType":
  "‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : TopologicalSpace K] [self : TopologicalDivisionRing K],\n  TopologicalRing K",
  "constCategory": "Definition"},
 {"references":
  ["List.nodup_singleton",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_singleton",
  "constType": "‚àÄ {Œ± : Type u_1} (a : Œ±), Multiset.Nodup {a}",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "norm_mul_le",
   "NonUnitalSeminormedRing.toNorm",
   "NonUnitalNonAssocRing.toMul",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "NormedCommRing.toNormedRing",
   "NormedField.toNormedCommRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "LE.le",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NormedRing.toNonUnitalNormedRing",
   "instHMul",
   "HMul.hMul",
   "Norm.norm"],
  "name": "NormedField.toNormedSpace.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NormedField Œ±] (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "OrderedCommSemiring"],
  "name": "OrderedCommSemiring.toOrderedSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : OrderedCommSemiring Œ±] ‚Üí OrderedSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.neg.match_1",
  "constType":
  "(motive : ‚Ñ§ ‚Üí Sort u_1) ‚Üí (n : ‚Ñ§) ‚Üí ((n : ‚Ñï) ‚Üí motive (Int.ofNat n)) ‚Üí ((n : ‚Ñï) ‚Üí motive (Int.negSucc n)) ‚Üí motive n",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{Œ± : Type u} ‚Üí [self : StrictOrderedSemiring Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne"],
  "name": "CharZero",
  "constType": "(R : Type u_1) ‚Üí [inst : AddMonoidWithOne R] ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["Dist", "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toDist",
  "constType": "{Œ± : Type u} ‚Üí [self : PseudoMetricSpace Œ±] ‚Üí Dist Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "SetLike.instPartialOrder.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "PartialOrder",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Preorder.mk",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "SetLike.instPartialOrder.proof_3",
   "Set.instBooleanAlgebraSet",
   "Preorder.toLT",
   "SetLike.instPartialOrder.proof_2",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "SetLike.coe",
   "SetLike.coe_injective"],
  "name": "SetLike.instPartialOrder",
  "constType":
  "{A : Type u_1} ‚Üí {B : Type u_2} ‚Üí [i : SetLike A B] ‚Üí PartialOrder A",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "abs_le'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "Eq",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Iff",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "neg_le",
   "And",
   "and_comm",
   "Eq.ndrec",
   "propext",
   "NegZeroClass.toNeg",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {a b : Œ±}, |a| ‚â§ b ‚Üî -b ‚â§ a ‚àß a ‚â§ b",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "CanonicallyLinearOrderedSemifield.toNontrivial",
   "instDecidableEq",
   "WithTop",
   "instLinearOrder",
   "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "inferInstanceAs",
   "instNNRealCanonicallyOrderedCommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop",
   "CanonicallyOrderedCommSemiring",
   "NNReal"],
  "name": "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
  "constType": "CanonicallyOrderedCommSemiring ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_8",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±], NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CauchySeq",
   "Exists",
   "EMetric.complete_of_cauchySeq_tendsto",
   "CompleteSpace",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "Filter.Tendsto",
   "UniformSpace.toTopologicalSpace",
   "Nat",
   "Filter.atTop",
   "PseudoMetricSpace",
   "Nat.strictOrderedSemiring",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name": "Metric.complete_of_cauchySeq_tendsto",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±],\n  (‚àÄ (u : ‚Ñï ‚Üí Œ±), CauchySeq u ‚Üí ‚àÉ a, Filter.Tendsto u Filter.atTop (nhds a)) ‚Üí CompleteSpace Œ±",
  "constCategory": "Theorem"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.ratCast",
  "constType": "{K : Type u} ‚Üí [self : RatCast K] ‚Üí ‚Ñö ‚Üí K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedField",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Submodule",
   "instHSMul",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "Submodule.span",
   "SetLike.instMembership",
   "Eq",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Set.instSingletonSet",
   "propext",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Singleton.singleton",
   "Submodule.mem_span_singleton",
   "MonoidWithZero.toZero",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Mathlib.LinearAlgebra.Span._auxLemma.11",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x y : M},\n  (x ‚àà Submodule.span R {y}) = ‚àÉ a, a ‚Ä¢ y = x",
  "constCategory": "Theorem"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "Module.toMulActionWithZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsScalarTower",
   "NormedSpace",
   "NormedField.toField",
   "Monoid.toMulAction",
   "DivisionSemiring.toSemiring",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NegZeroClass.toZero",
   "MulActionWithZero.toMulAction",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "HasDerivAtFilter.proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F], IsScalarTower ùïú ùïú F",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "‚àÄ {Œ± : Sort u_1} (a : Œ±), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "GaloisInsertion.liftCompleteLattice.proof_1",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "GaloisInsertion.liftCompleteLattice.proof_2",
   "GaloisInsertion.liftBoundedOrder",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice.proof_4",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "GaloisInsertion.liftCompleteLattice.proof_6",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "GaloisInsertion.choice",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.liftCompleteLattice.proof_5",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "GaloisInsertion.liftCompleteLattice.proof_7",
   "OrderBot.toBot",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisInsertion.liftCompleteLattice",
  "constType":
  "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    {l : Œ± ‚Üí Œ≤} ‚Üí\n      {u : Œ≤ ‚Üí Œ±} ‚Üí [inst : PartialOrder Œ≤] ‚Üí [inst_1 : CompleteLattice Œ±] ‚Üí GaloisInsertion l u ‚Üí CompleteLattice Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "Semiring.toModule.proof_4",
  "constType": "‚àÄ {R : Type u_1} [inst : Semiring R] (a : R), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Real.natCast",
   "Metric.closedBall",
   "Set",
   "Real",
   "Set.univ",
   "Real.orderedSemiring",
   "Real.instArchimedean",
   "Iff.mpr",
   "exists_nat_ge",
   "Dist.dist",
   "Eq",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "PseudoMetricSpace.toDist",
   "Set.iUnion",
   "Nat.cast",
   "Nat",
   "PseudoMetricSpace"],
  "name": "Metric.iUnion_closedBall_nat",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±), ‚ãÉ n, Metric.closedBall x ‚Üën = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.right_distrib",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a b c : Œ±), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalRing",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "TopologicalSemiring",
   "TopologicalRing",
   "TopologicalSpace"],
  "name": "TopologicalRing.toTopologicalSemiring",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocRing Œ±] [self : TopologicalRing Œ±],\n  TopologicalSemiring Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedField",
  "constType": "Type u_2 ‚Üí Type u_2",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "Fin.fintype",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "OrthonormalBasis",
   "NormedField.toField",
   "InnerProductSpace.toNormedSpace",
   "DivisionSemiring.toSemiring",
   "FiniteDimensional.finrank",
   "InnerProductSpace",
   "NormedDivisionRing.toDivisionRing",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NormedField.toNormedDivisionRing",
   "wrapped._@.Mathlib.Analysis.InnerProductSpace.PiL2._hyg.13914",
   "FiniteDimensional",
   "Fin"],
  "name": "stdOrthonormalBasis",
  "constType":
  "(ùïú : Type u_8) ‚Üí\n  [inst : IsROrC ùïú] ‚Üí\n    (E : Type u_9) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : InnerProductSpace ùïú E] ‚Üí\n          [inst_3 : FiniteDimensional ùïú E] ‚Üí OrthonormalBasis (Fin (FiniteDimensional.finrank ùïú E)) ùïú E",
  "constCategory": "Definition"},
 {"references": ["Top", "OrderTop", "LE"],
  "name": "OrderTop.toTop",
  "constType": "{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [self : OrderTop Œ±] ‚Üí Top Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "GroupWithZero",
   "HMul.hMul",
   "IsUnit.mul_div_cancel",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "mul_div_cancel",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] {b : G‚ÇÄ} (a : G‚ÇÄ), b ‚â† 0 ‚Üí a * b / b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "Exists.intro",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Set.Subset.refl",
   "And",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "IsOpen.mem_nhds",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {a : Œ±} {s : Set Œ±}, IsOpen s ‚Üí a ‚àà s ‚Üí s ‚àà nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "NatCast",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "CauSeq.Completion.instNatCastCauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "NatCast.mk",
   "Abs.abs",
   "Rat.instSupRat",
   "Nat.cast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Nat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.natCast",
  "constType": "NatCast ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "SetLike.instPartialOrder",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "Module",
   "LE.le",
   "Preorder.toLE",
   "Submodule.setLike",
   "Set.subset_iInter‚ÇÇ",
   "SetLike.coe",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name":
  "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {S : Set (Submodule R M)} {p : Submodule R M}, (‚àÄ q ‚àà S, p ‚â§ q) ‚Üí p ‚â§ sInf S",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalNonAssocRing",
   "InvolutiveNeg.toNeg",
   "Neg.neg",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubtractionMonoid.toInvolutiveNeg",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocRing Œ±] (a : Œ±), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Filter",
   "Set.Ici",
   "Preorder",
   "ConditionallyCompleteLattice.toInfSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.atTop",
  "constType": "{Œ± : Type u_3} ‚Üí [inst : Preorder Œ±] ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": ["Ring", "CommRing"],
  "name": "CommRing.toRing",
  "constType": "{Œ± : Type u} ‚Üí [self : CommRing Œ±] ‚Üí Ring Œ±",
  "constCategory": "Definition"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [self : OrderBot Œ±] ‚Üí Bot Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Field.toNontrivial",
   "EuclideanDomain.mk",
   "Semifield.toCommGroupWithZero",
   "Field.toEuclideanDomain.proof_3",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Field.toEuclideanDomain.proof_4",
   "Field",
   "Ring.toSub",
   "Field.toEuclideanDomain.proof_1",
   "HDiv.hDiv",
   "instHSub",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "HSub.hSub",
   "Field.toSemifield",
   "CommGroupWithZero.toCommMonoidWithZero",
   "instHMul",
   "And",
   "Field.toEuclideanDomain.proof_2",
   "HMul.hMul",
   "Field.toDiv",
   "EuclideanDomain",
   "Field.toDivisionRing",
   "Field.toEuclideanDomain.proof_5"],
  "name": "Field.toEuclideanDomain",
  "constType": "{K : Type u_1} ‚Üí [inst : Field K] ‚Üí EuclideanDomain K",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast.intCast", "IntCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} ‚Üí [inst : IntCast R] ‚Üí ‚Ñ§ ‚Üí R",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddCommMonoid.toAddMonoid",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocSemiring Œ±] ‚Üí Distrib Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Exists",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "Real.natCast",
   "Real",
   "Real.instLEReal",
   "DenselyNormedField.toNormedField",
   "DenselyNormedField.lt_norm_lt",
   "Exists.intro",
   "NormedField.toNorm",
   "Real.instOneReal",
   "one_lt_two",
   "AddMonoid.toAddSemigroup",
   "DenselyNormedField.toNontriviallyNormedField.match_1",
   "Real.strictOrderedSemiring",
   "AddGroup.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "NeZero.charZero_one",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "instOfNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Real.partialOrder",
   "AddSemigroup.toAdd",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Real.instRingReal",
   "Real.orderedSemiring",
   "Real.instZeroReal",
   "And",
   "StrictOrderedSemiring.to_charZero",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "DenselyNormedField",
   "zero_le_one",
   "Real.instAddGroupReal",
   "instNatAtLeastTwo",
   "Norm.norm"],
  "name": "DenselyNormedField.toNontriviallyNormedField.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : DenselyNormedField Œ±], ‚àÉ x, 1 < ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalSeminormedRing", "PseudoMetricSpace"],
  "name": "NonUnitalSeminormedRing.toPseudoMetricSpace",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : NonUnitalSeminormedRing Œ±] ‚Üí PseudoMetricSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "Mul",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toAddCommGroup : AddCommGroup Œ±] ‚Üí\n    [toMul : Mul Œ±] ‚Üí\n      (‚àÄ (a b c : Œ±), a * (b + c) = a * b + a * c) ‚Üí\n        (‚àÄ (a b c : Œ±), (a + b) * c = a * c + b * c) ‚Üí\n          (‚àÄ (a : Œ±), 0 * a = 0) ‚Üí (‚àÄ (a : Œ±), a * 0 = 0) ‚Üí NonUnitalNonAssocRing Œ±",
  "constCategory": "Other"},
 {"references": ["Nat.linearOrder", "LinearOrder.toLattice", "Lattice", "Nat"],
  "name": "Nat.instLatticeNat",
  "constType": "Lattice ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "instOfNatInt",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_zero'",
  "constType":
  "‚àÄ {K : Type u} [self : DivisionRing K] (a : K), DivisionRing.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "instHSub",
   "PseudoMetricSpace.toDist",
   "NormedField.toMetricSpace",
   "Real",
   "NormedField",
   "Ring.toSub",
   "HSub.hSub",
   "CommRing.toRing",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedField.toNorm",
   "Dist.dist",
   "Eq"],
  "name": "NormedField.dist_eq",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : NormedField Œ±] (x y : Œ±), dist x y = ‚Äñx - y‚Äñ",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SemilatticeInf.toPartialOrder",
   "le_rfl",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Abs.abs",
   "Preorder.toLE",
   "abs_of_nonneg",
   "Eq",
   "Zero.toOfNat0",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_zero",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1], |0| = 0",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "MeasurableSpace"],
  "name": "BorelSpace",
  "constType":
  "(Œ± : Type u_6) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "separated_t3",
   "T25Space.t2Space",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "T2Space",
   "TopologicalSpace",
   "T3Space.t25Space",
   "TopologicalSpace.MetrizableSpace",
   "MetricSpace.to_separated",
   "TopologicalSpace.metrizableSpaceMetric"],
  "name": "TopologicalSpace.t2Space_of_metrizableSpace",
  "constType":
  "‚àÄ {X : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.MetrizableSpace X], T2Space X",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.mk",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Singleton Œ± Œ≤",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.re",
   "AddZeroClass.toAdd",
   "IsROrC.toNormedAlgebra",
   "Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "HAdd.hAdd",
   "Real",
   "Real.normedField",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "semiOutParam",
   "Eq",
   "IsROrC.I",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "Real.instCommSemiringReal",
   "AddMonoid.toAddSemigroup",
   "IsROrC.toDenselyNormedField",
   "AddHomClass.toFunLike",
   "AddSemigroup.toAdd",
   "instHAdd",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.im"],
  "name": "IsROrC.re_add_im_ax",
  "constType":
  "‚àÄ {K : semiOutParam (Type u_1)} [self : IsROrC K] (z : K),\n  (algebraMap ‚Ñù K) (IsROrC.re z) + (algebraMap ‚Ñù K) (IsROrC.im z) * IsROrC.I = z",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b c : Œ±}, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references": ["Min", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toMin",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí Min Œ±",
  "constCategory": "Definition"},
 {"references":
  ["FiniteDimensional.isROrC_to_real",
   "IsROrC.innerProductSpace",
   "inferInstance",
   "Real.borelSpace",
   "Real.measurableSpace",
   "Real",
   "MeasureTheory.MeasureSpace",
   "Real.isROrC",
   "measureSpaceOfInnerProductSpace",
   "Real.normedAddCommGroup"],
  "name": "Real.measureSpace",
  "constType": "MeasureTheory.MeasureSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.finRange",
  "constType": "(n : ‚Ñï) ‚Üí List (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_6",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a b : Œ±), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegZeroMonoid.toSubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.neg_zero",
  "constType": "‚àÄ {G : Type u_2} [self : SubNegZeroMonoid G], -0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Monoid.toMulAction.proof_2",
   "MulOneClass.toMul",
   "SMul.mk",
   "Monoid",
   "MulAction.mk",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulAction.proof_1",
   "Monoid.toMulOneClass"],
  "name": "Monoid.toMulAction",
  "constType": "(M : Type u_1) ‚Üí [inst : Monoid M] ‚Üí MulAction M M",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedSemiring.le_total",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "Norm",
   "PseudoMetricSpace.toDist",
   "Real",
   "HSub.hSub",
   "SeminormedAddCommGroup",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "AddCommGroup",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1573",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "PseudoMetricSpace",
   "Dist.dist",
   "Eq"],
  "name": "SeminormedAddCommGroup.mk",
  "constType":
  "{E : Type u_9} ‚Üí\n  [toNorm : Norm E] ‚Üí\n    [toAddCommGroup : AddCommGroup E] ‚Üí\n      [toPseudoMetricSpace : PseudoMetricSpace E] ‚Üí\n        autoParam (‚àÄ (x y : E), dist x y = ‚Äñx - y‚Äñ) _auto‚úù ‚Üí SeminormedAddCommGroup E",
  "constCategory": "Other"},
 {"references": [],
  "name": "Inv",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "‚àÄ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "one_mul",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Monoid.toMulAction.proof_1",
  "constType": "‚àÄ (M : Type u_1) [inst : Monoid M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["One", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toOne",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : CanonicallyOrderedCommSemiring Œ±] ‚Üí One Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedCommRing",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Sup", "_private.Mathlib.Data.Real.Basic.0.Real.sup", "Real", "Sup.mk"],
  "name": "Real.instSupReal",
  "constType": "Sup ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemiring", "Ord"],
  "name": "LinearOrderedSemiring.toOrd",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedSemiring Œ±] ‚Üí Ord Œ±",
  "constCategory": "Definition"},
 {"references":
  ["continuous_id",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "Semiring",
   "ContinuousLinearMap.mk",
   "TopologicalSpace",
   "LinearMap.id",
   "Module",
   "RingHom.id",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.id",
  "constType":
  "(R‚ÇÅ : Type u_1) ‚Üí\n  [inst : Semiring R‚ÇÅ] ‚Üí\n    (M‚ÇÅ : Type u_4) ‚Üí\n      [inst_1 : TopologicalSpace M‚ÇÅ] ‚Üí [inst_2 : AddCommMonoid M‚ÇÅ] ‚Üí [inst_3 : Module R‚ÇÅ M‚ÇÅ] ‚Üí M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom", "Eq"],
  "name": "ZeroHom.mk",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : Zero M] ‚Üí [inst_1 : Zero N] ‚Üí (toFun : M ‚Üí N) ‚Üí toFun 0 = 0 ‚Üí ZeroHom M N",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "HMul.hMul",
   "MulZeroOneClass",
   "Eq"],
  "name": "MulZeroOneClass.mk",
  "constType":
  "{M‚ÇÄ : Type u} ‚Üí\n  [toMulOneClass : MulOneClass M‚ÇÄ] ‚Üí\n    [toZero : Zero M‚ÇÄ] ‚Üí (‚àÄ (a : M‚ÇÄ), 0 * a = 0) ‚Üí (‚àÄ (a : M‚ÇÄ), a * 0 = 0) ‚Üí MulZeroOneClass M‚ÇÄ",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.gc_map_comap",
   "Filter.map",
   "GaloisConnection.monotone_l",
   "Filter.instPartialOrderFilter",
   "Monotone",
   "Filter.comap",
   "Filter"],
  "name": "Filter.map_mono",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {m : Œ± ‚Üí Œ≤}, Monotone (Filter.map m)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "NNReal.toReal",
   "Real.linearOrder",
   "OfNat.ofNat",
   "NNReal.eq",
   "Real.instLEReal",
   "Real",
   "Real.toNNReal",
   "LE.le",
   "NNReal",
   "Eq",
   "max_eq_left"],
  "name": "Real.toNNReal_coe",
  "constType": "‚àÄ {r : NNReal}, Real.toNNReal ‚Üër = r",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "IsROrC.re",
   "RingHom.instRingHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NormedAlgebra.toAlgebra",
   "PartialOrder.toPreorder",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "DenselyNormedField.toNormedField",
   "Module.Finite.mk",
   "Insert.insert",
   "Submodule.instTopSubmodule",
   "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "IsROrC.I",
   "Finset.toSet",
   "HSMul.hSMul",
   "NormedAlgebra.toNormedSpace'",
   "IsROrC.re_add_im",
   "NormedCommRing.toNormedRing",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "And",
   "IsROrC.toDecidableEq",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "And.intro",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "Submodule.setLike",
   "AddZeroClass.toAdd",
   "Exists",
   "DivisionRing.toDivisionSemiring",
   "Submodule",
   "eq_top_iff",
   "Set",
   "Real",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Submodule.span",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "Finset",
   "Submodule.mem_span_singleton",
   "Finset.instInsertFinset",
   "IsROrC.toDenselyNormedField",
   "Top.top",
   "AddHomClass.toFunLike",
   "algebraMap",
   "Field.toSemifield",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "LE.le",
   "Real.instDivisionRingReal",
   "NormedCommRing.toSeminormedCommRing",
   "Eq.ndrec",
   "SeminormedRing.toRing",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "AddMonoidHom",
   "Finset.instSingletonFinset",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "IsROrC.toNormedAlgebra",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.normedField",
   "Semifield.toCommSemiring",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "NormedRing.toNonUnitalNormedRing",
   "Eq.mpr",
   "SMulWithZero.toSMulZeroClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Submodule.mem_span_insert",
   "Algebra.toSMul",
   "Eq.trans",
   "FiniteDimensional",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Algebra.smul_def",
   "instHMul",
   "MulActionWithZero.toSMulWithZero",
   "of_eq_true",
   "CommRing.toRing",
   "Singleton.singleton",
   "mul_one",
   "Finset.coe_singleton",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "IsROrC.im",
   "NormedAddCommGroup.toAddCommGroup",
   "RingHom",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "OrderTop.toTop",
   "Set.instSingletonSet",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Membership.mem",
   "eq_self",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "Semiring.toOne",
   "IsROrC.ofReal",
   "DivisionSemiring.toSemiring",
   "HMul.hMul",
   "Finset.coe_insert",
   "AddMonoidHom.addMonoidHomClass",
   "Set.instInsertSet"],
  "name": "FiniteDimensional.isROrC_to_real",
  "constType": "‚àÄ {K : Type u_1} [inst : IsROrC K], FiniteDimensional ‚Ñù K",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "‚àÄ (p : Prop), (p ‚àß p) = p",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "Inv"],
  "name": "LinearOrderedField.toInv",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí Inv Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "Or",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.le_total",
  "constType":
  "‚àÄ {Œ± : Type u_3} [self : LinearOrderedCancelAddCommMonoid Œ±] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) ‚Üí (N : Type u_10) ‚Üí [inst : AddZeroClass M] ‚Üí [inst : AddZeroClass N] ‚Üí Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Field", "Rat"],
  "name": "Field.qsmul",
  "constType": "{K : Type u} ‚Üí [self : Field K] ‚Üí ‚Ñö ‚Üí K ‚Üí K",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instAddNat",
   "instHAdd",
   "Preorder.toLT",
   "HAdd.hAdd",
   "LT.lt",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "instIsTransLtToLT",
   "instOfNatNat",
   "Nat",
   "Preorder",
   "Nat.rel_of_forall_rel_succ_of_lt"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {f : ‚Ñï ‚Üí Œ±}, (‚àÄ (n : ‚Ñï), f n < f (n + 1)) ‚Üí StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Real.mk_le",
   "Rat",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Rat.divisionRing",
   "propext",
   "Real.mk",
   "Rat.instNegRat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.8",
  "constType": "‚àÄ {f g : CauSeq ‚Ñö abs}, (Real.mk f ‚â§ Real.mk g) = (f ‚â§ g)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{Œ± : Sort u2} ‚Üí {a : Œ±} ‚Üí {motive : Œ± ‚Üí Sort u1} ‚Üí motive a ‚Üí {b : Œ±} ‚Üí a = b ‚Üí motive b",
  "constCategory": "Definition"},
 {"references": ["Int", "Semifield"],
  "name": "Semifield.zpow",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Semifield Œ±] ‚Üí ‚Ñ§ ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Inv",
   "Inv.inv"],
  "name": "DivInvMonoid.div'",
  "constType": "{G : Type u} ‚Üí [inst : Monoid G] ‚Üí [inst : Inv G] ‚Üí G ‚Üí G ‚Üí G",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "inferInstance",
   "Real.instLinearOrderedRingReal",
   "Real",
   "LinearOrderedRing.toLinearOrderedAddCommGroup"],
  "name": "Real.instLinearOrderedAddCommGroupReal",
  "constType": "LinearOrderedAddCommGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["WithTop", "Option.some"],
  "name": "WithTop.some",
  "constType": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí WithTop Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toRing : Ring Œ±] ‚Üí\n    [toPartialOrder : PartialOrder Œ±] ‚Üí\n      (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b) ‚Üí\n        [toNontrivial : Nontrivial Œ±] ‚Üí 0 ‚â§ 1 ‚Üí (‚àÄ (a b : Œ±), 0 < a ‚Üí 0 < b ‚Üí 0 < a * b) ‚Üí StrictOrderedRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "IsScalarTower.right",
   "Set",
   "MeasureTheory.Measure.restrict‚Çó.proof_1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule",
   "MeasureTheory.Measure.liftLinear",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "Algebra.id",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.restrict",
   "LinearMap",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.restrict‚Çó",
  "constType":
  "{Œ± : Type u_2} ‚Üí {m0 : MeasurableSpace Œ±} ‚Üí Set Œ± ‚Üí MeasureTheory.Measure Œ± ‚Üí‚Çó[ENNReal] MeasureTheory.Measure Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.toLinearOrderedSemifield.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Topology.Constructions.0.instTopologicalSpaceProd._eq_1",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "Eq.refl",
   "Prod.fst",
   "Filter.instSProd",
   "Eq",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Eq.mpr",
   "Eq.ndrec",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Prod",
   "Filter.prod",
   "nhds_induced",
   "nhds_inf",
   "TopologicalSpace.induced",
   "_private.Mathlib.Topology.Constructions.0.Filter.prod._eq_1",
   "id"],
  "name": "nhds_prod_eq",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {a : Œ±} {b : Œ≤},\n  nhds (a, b) = nhds a √óÀ¢ nhds b",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Finset.val",
   "Multiset.ndinsert",
   "Finset.mk",
   "Finset.instInsertFinset.proof_1",
   "Insert",
   "Insert.mk"],
  "name": "Finset.instInsertFinset",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : DecidableEq Œ±] ‚Üí Insert Œ± (Finset Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_9",
  "constType": "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedRing Œ±] (a : Œ±), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Filter.instCompleteLatticeFilter.proof_10",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Filter.instCompleteLatticeFilter.proof_11",
   "Filter.instCompleteLatticeFilter.proof_2",
   "Inf.inf",
   "Set",
   "Filter.instCompleteLatticeFilter.proof_4",
   "CompleteLattice.mk",
   "SupSet.mk",
   "Filter.generate",
   "CompleteLattice.toBot",
   "Lattice.mk",
   "Filter.join",
   "Filter.instCompleteLatticeFilter.proof_7",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Preorder.toLT",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.mem_inf_of_right",
   "Filter.instCompleteLatticeFilter.proof_5",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.proof_12",
   "Membership.mem",
   "Filter.sets",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPartialOrder",
   "Filter.instCompleteLatticeFilter.proof_8",
   "Top.top",
   "Function.comp",
   "SemilatticeSup.mk",
   "Filter.instCompleteLatticeFilter.proof_3",
   "Set.Set.completeAtomicBooleanAlgebra",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter.instCompleteLatticeFilter.proof_9",
   "Filter.instCompleteLatticeFilter.proof_1",
   "Filter.instCompleteLatticeFilter.proof_6",
   "Top.mk",
   "Filter.mem_inf_of_left"],
  "name": "Filter.instCompleteLatticeFilter",
  "constType": "{Œ± : Type u} ‚Üí CompleteLattice (Filter Œ±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Neg",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "closure",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.preimage",
   "HasSubset.Subset.trans",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "Exists.intro",
   "Exists.casesOn",
   "Set.Countable.image",
   "Eq",
   "Set.Countable",
   "And",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "closure_subset_preimage_closure_image",
   "Eq.ndrec",
   "propext",
   "Continuous",
   "TopologicalSpace",
   "Set.image_subset_iff",
   "And.intro",
   "Set.image",
   "And.casesOn",
   "id"],
  "name": "TopologicalSpace.IsSeparable.image",
  "constType":
  "‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] {s : Set Œ±},\n  TopologicalSpace.IsSeparable s ‚Üí ‚àÄ {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí TopologicalSpace.IsSeparable (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "Field.toInv",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Field.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Field.toCommRing",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Field",
   "Rat.cast",
   "CommRing.toRing",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "Field.ratCast_mk",
  "constType":
  "‚àÄ {K : Type u} [self : Field K] (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{Œ± : Type u} ‚Üí Œ± ‚Üí Option Œ±",
  "constCategory": "Other"},
 {"references":
  ["mul_add",
   "instHAdd",
   "Semiring",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Distrib.leftDistribClass",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Semiring.toModule.proof_2",
  "constType":
  "‚àÄ {R : Type u_1} [inst : Semiring R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Set",
   "AddSubmonoid",
   "AddSubsemigroup.carrier",
   "AddZeroClass",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubmonoid.mk",
  "constType":
  "{M : Type u_4} ‚Üí\n  [inst : AddZeroClass M] ‚Üí (toAddSubsemigroup : AddSubsemigroup M) ‚Üí 0 ‚àà toAddSubsemigroup.carrier ‚Üí AddSubmonoid M",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OneHom.toFun",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "RingHom.toMonoidHom",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.map_add'",
  "constType":
  "‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_6} [inst : NonAssocSemiring Œ±] [inst_1 : NonAssocSemiring Œ≤] (self : Œ± ‚Üí+* Œ≤) (x y : Œ±),\n  OneHom.toFun (‚Üë‚Üëself) (x + y) = OneHom.toFun (‚Üë‚Üëself) x + OneHom.toFun (‚Üë‚Üëself) y",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNormedRing",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "FunLike",
  "constType":
  "Sort u_1 ‚Üí (Œ± : outParam (Sort u_2)) ‚Üí outParam (Œ± ‚Üí Sort u_3) ‚Üí Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "SemilatticeSup.toSup",
   "Sup",
   "Rat",
   "Rat.instSemilatticeSupRat"],
  "name": "Rat.instSupRat",
  "constType": "Sup ‚Ñö",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "id"],
  "name": "Set.Subset.refl",
  "constType": "‚àÄ {Œ± : Type u} (a : Set Œ±), a ‚äÜ a",
  "constCategory": "Theorem"},
 {"references": ["Inv"],
  "name": "Inv.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ±) ‚Üí Inv Œ±",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteLinearOrder",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "PartialOrder.le_antisymm",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_4",
  "constType": "‚àÄ {Œ± : Type u_1} (a b : (Filter Œ±)·µí·µà·µí·µà), a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
  "constType":
  "‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a b c : Œ±), a < b ‚Üí 0 < c ‚Üí a * c < b * c",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq",
  "constType": "{Œ± : Sort u} ‚Üí Œ± ‚Üí {Œ≤ : Sort u} ‚Üí Œ≤ ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "Set",
   "Set.inter_self",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "True",
   "Eq",
   "And",
   "of_eq_true",
   "Filter",
   "And.intro",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} (f g : Filter Œ±), ‚àÉ a ‚àà f, ‚àÉ b ‚àà g, Set.univ = a ‚à© b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_5",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a : Œ±), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "FunLike.coe",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "PartialOrder"],
  "name": "OmegaCompletePartialOrder.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [toPartialOrder : PartialOrder Œ±] ‚Üí\n    (œâSup : OmegaCompletePartialOrder.Chain Œ± ‚Üí Œ±) ‚Üí\n      (‚àÄ (c : OmegaCompletePartialOrder.Chain Œ±) (i : ‚Ñï), c i ‚â§ œâSup c) ‚Üí\n        (‚àÄ (c : OmegaCompletePartialOrder.Chain Œ±) (x : Œ±), (‚àÄ (i : ‚Ñï), c i ‚â§ x) ‚Üí œâSup c ‚â§ x) ‚Üí\n          OmegaCompletePartialOrder Œ±",
  "constCategory": "Other"},
 {"references": ["Div", "Semifield"],
  "name": "Semifield.toDiv",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Semifield Œ±] ‚Üí Div Œ±",
  "constCategory": "Definition"},
 {"references": ["SDiff", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toSDiff",
  "constType": "{Œ± : Type u} ‚Üí [self : BooleanAlgebra Œ±] ‚Üí SDiff Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "StronglyMeasurableAtFilter",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.restrict",
   "Exists.intro",
   "Set.univ",
   "MeasureTheory.AEStronglyMeasurable",
   "Filter.univ_mem",
   "Eq",
   "MeasureTheory.Measure",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "MeasurableSpace",
   "MeasureTheory.Measure.restrict_univ",
   "instMembershipSetFilter",
   "id"],
  "name": "MeasureTheory.AEStronglyMeasurable.stronglyMeasurableAtFilter",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {l : Filter Œ±} {f : Œ± ‚Üí Œ≤}\n  {Œº : MeasureTheory.Measure Œ±}, MeasureTheory.AEStronglyMeasurable f Œº ‚Üí StronglyMeasurableAtFilter f l",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "Function.swap",
   "AddGroup",
   "Iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "OrderIso.neg",
   "LE",
   "OrderDual",
   "OrderIso.symm_apply_le",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {a b : Œ±}, -a ‚â§ b ‚Üî -b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.ofCauchy",
  "constType": "CauSeq.Completion.Cauchy abs ‚Üí ‚Ñù",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocCommSemiring.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocCommRing.mul_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocCommRing Œ±] ‚Üí NonUnitalNonAssocCommSemiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "Iff.mpr",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "AddZeroClass.toZero",
   "AddGroup",
   "Iff",
   "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.27",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.12",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "of_eq_true",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "congrArg",
   "congrFun"],
  "name": "sub_lt_self",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : Œ±) {b : Œ±}, 0 < b ‚Üí a - b < a",
  "constCategory": "Theorem"},
 {"references": ["AddHom", "Add"],
  "name": "AddHom.toFun",
  "constType":
  "{M : Type u_9} ‚Üí {N : Type u_10} ‚Üí [inst : Add M] ‚Üí [inst_1 : Add N] ‚Üí AddHom M N ‚Üí M ‚Üí N",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "Submodule.instInfSetSubmodule.proof_3",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Set",
   "Submodule.instInfSetSubmodule.proof_2",
   "InfSet",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.instMembershipSet",
   "InfSet.mk",
   "Submodule.instInfSetSubmodule.proof_1",
   "Submodule.mk",
   "Set.iInter",
   "AddSubmonoid.mk",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid",
   "SetLike.coe"],
  "name": "Submodule.instInfSetSubmodule",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí InfSet (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.mk",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.npow",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedCommMonoid.toCovariantClassRight",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "mul_le_mul_right'",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedCommSemiring Œ±] (a b c : Œ±), a ‚â§ b ‚Üí 0 ‚â§ c ‚Üí a * c ‚â§ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.mk_le",
   "Real",
   "Real.instLEReal",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.ndrec",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "le_refl",
   "Rat.instNegRat",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_1",
  "constType": "‚àÄ (a : ‚Ñù), a ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} ‚Üí {n : ‚Ñï} ‚Üí [inst : NatCast R] ‚Üí [inst : Nat.AtLeastTwo n] ‚Üí OfNat R n",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a : Œ±), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Eq",
   "DistribLattice.toLattice",
   "instHMul",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "abs_mul",
   "HMul.hMul",
   "Lattice.toSemilatticeSup",
   "Eq.symm"],
  "name": "Mathlib.Data.IsROrC.Basic._auxLemma.26",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a b : Œ±), |a| * |b| = |a * b|",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{Œ± : Type u} ‚Üí [self : Semiring Œ±] ‚Üí NatCast Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Covariant",
   "Iff.mp",
   "AddGroup",
   "Contravariant",
   "AddGroup.covariant_iff_contravariant",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "ContravariantClass",
   "ContravariantClass.mk",
   "CovariantClass.elim"],
  "name": "AddGroup.covconv",
  "constType":
  "‚àÄ {N : Type u_2} {r : N ‚Üí N ‚Üí Prop} [inst : AddGroup N] [inst_1 : CovariantClass N N (fun x x_1 => x + x_1) r],\n  ContravariantClass N N (fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Max.max",
   "LinearOrderedRing.toMax",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.max_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a b : Œ±), max a b = if a ‚â§ b then b else a",
  "constCategory": "Definition"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≥ : Type v} ‚Üí [self : Insert Œ± Œ≥] ‚Üí Œ± ‚Üí Œ≥ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Field.toSemifield.proof_1",
  "constType": "‚àÄ {K : Type u_1} [inst : Field K] (a b : K), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real",
   "Real.instConditionallyCompleteLinearOrderReal",
   "Nonneg.conditionallyCompleteLinearOrderBot",
   "NNReal",
   "ConditionallyCompleteLinearOrderBot"],
  "name": "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
  "constType": "ConditionallyCompleteLinearOrderBot NNReal",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "‚àÄ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c ‚Üí b = c",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc"],
  "name": "WellFounded.intro",
  "constType":
  "‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), Acc r a) ‚Üí WellFounded r",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "RingHom",
   "CommSemiring.toSemiring",
   "CommRing.toNonUnitalCommRing",
   "Semifield.toCommSemiring",
   "IsROrC.toStarRing",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "IsROrC.innerProductSpace.proof_3",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "NormedField.toNormedSpace",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "Inner.mk",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "EuclideanDomain.toCommRing",
   "IsROrC.innerProductSpace.proof_4",
   "instHMul",
   "InnerProductSpace.mk",
   "IsROrC.innerProductSpace.proof_2",
   "InnerProductSpace",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "IsROrC.innerProductSpace.proof_1",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "IsROrC.innerProductSpace",
  "constType": "{ùïú : Type u_1} ‚Üí [inst : IsROrC ùïú] ‚Üí InnerProductSpace ùïú ùïú",
  "constCategory": "Definition"},
 {"references":
  ["Finsupp",
   "Basis",
   "Semiring",
   "LinearEquiv.trans",
   "LinearEquiv.symm",
   "Semiring.toMonoidWithZero",
   "LinearEquiv",
   "Finsupp.linearEquivFunOnFinite",
   "Finsupp.module",
   "RingHom.id",
   "Basis.ofRepr",
   "Fintype",
   "Semiring.toNonAssocSemiring",
   "Pi.addCommMonoid",
   "Finsupp.addCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Basis.ofEquivFun.proof_1",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "MonoidWithZero.toZero",
   "Pi.module",
   "Finite.of_fintype",
   "Semiring.toModule",
   "AddCommMonoid",
   "RingHomInvPair.ids"],
  "name": "Basis.ofEquivFun",
  "constType":
  "{Œπ : Type u_1} ‚Üí\n  {R : Type u_3} ‚Üí\n    {M : Type u_6} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí [inst_3 : Fintype Œπ] ‚Üí (M ‚âÉ‚Çó[R] Œπ ‚Üí R) ‚Üí Basis Œπ R M",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "Rat.cast",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedField.qsmul",
   "Rat",
   "HMul.hMul",
   "LinearOrderedField.toRatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.qsmul_eq_mul'",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (a : ‚Ñö) (x : Œ±), LinearOrderedField.qsmul a x = ‚Üëa * x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Function.Injective.ne_iff",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_ne_add_right",
  "constType":
  "‚àÄ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b ‚â† a + c ‚Üî b ‚â† c",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "add_le_add",
   "Set.Nonempty",
   "Eq.refl",
   "le_rfl",
   "Exists.intro",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Real.linearOrder",
   "Eq.mpr",
   "Eq.symm",
   "LinearOrderedRing.toMax",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Or.elim",
   "id",
   "Membership.mem",
   "Set.empty_union",
   "Or",
   "setOf",
   "Real.instLinearOrderedRingReal",
   "instHAdd",
   "Union.union",
   "LE.le.trans",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "LE.le",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "Real.orderedAddCommMonoid",
   "le_max_left",
   "Real.instPreorderReal",
   "Max.max",
   "Set.union_empty",
   "Set.eq_empty_or_nonempty",
   "congrArg",
   "le_max_right",
   "Set.instUnionSet",
   "congrFun"],
  "name": "Bornology.ofDist.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù),\n  (‚àÄ (x y : Œ±), dist x y = dist y x) ‚Üí\n    (‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) ‚Üí\n      ‚àÄ s ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C},\n        ‚àÄ t ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C},\n          s ‚à™ t ‚àà {s | ‚àÉ C, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C}",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.SeparableSpace.mk",
   "closure",
   "Classical.choose_spec",
   "Exists",
   "Classical.choose",
   "Set.countable_iUnion",
   "Set",
   "Exists.intro",
   "closure_mono",
   "Dense",
   "compactCovering",
   "And.left",
   "Exists.casesOn",
   "instCountableNat",
   "Eq",
   "Set.Countable",
   "PseudoEMetricSpace.toUniformSpace",
   "And.right",
   "Set.iUnion",
   "Iff.mp",
   "Set.subset_iUnion",
   "EMetric.instIsCountablyGeneratedUniformity",
   "UniformSpace.secondCountable_of_separable",
   "EMetric.subset_countable_closure_of_compact",
   "TopologicalSpace.SeparableSpace",
   "PseudoEMetricSpace",
   "Nat",
   "UniformSpace.toTopologicalSpace",
   "Membership.mem",
   "iUnion_compactCovering",
   "HasSubset.Subset",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "isCompact_compactCovering",
   "And",
   "SecondCountableTopology",
   "Set.instHasSubsetSet",
   "SigmaCompactSpace",
   "And.intro"],
  "name": "EMetric.secondCountable_of_sigmaCompact",
  "constType":
  "‚àÄ (Œ± : Type u) [inst : PseudoEMetricSpace Œ±] [inst_1 : SigmaCompactSpace Œ±], SecondCountableTopology Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HMul Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompleteLinearOrder"],
  "name": "CompleteLinearOrder.toCompleteLattice",
  "constType":
  "{Œ± : Type u_9} ‚Üí [self : CompleteLinearOrder Œ±] ‚Üí CompleteLattice Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) ‚Üí (N : Type u_2) ‚Üí (M ‚Üí N ‚Üí N) ‚Üí (N ‚Üí N ‚Üí Prop) ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalCommRing.mk",
  "constType":
  "{Œ± : Type u} ‚Üí [toNonUnitalRing : NonUnitalRing Œ±] ‚Üí (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí NonUnitalCommRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Field.toSemifield",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "And",
   "instHMul",
   "Field",
   "HMul.hMul",
   "CommRing.toRing",
   "And.intro",
   "And.casesOn",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Field.toEuclideanDomain.match_2",
  "constType":
  "‚àÄ {K : Type u_1} [inst : Field K] (a b : K) (motive : a * b = 0 ‚àß a ‚â† 0 ‚Üí Prop) (x : a * b = 0 ‚àß a ‚â† 0),\n  (‚àÄ (hab : a * b = 0) (hna : a ‚â† 0), motive (_ : a * b = 0 ‚àß a ‚â† 0)) ‚Üí motive x",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{Œ± : Type u_9} ‚Üí [self : CompleteLattice Œ±] ‚Üí InfSet Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "Submodule",
   "instHSMul",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Semiring.toMonoidWithZero",
   "Submodule.completeLattice",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Submodule.span",
   "SetLike.instMembership",
   "Iff.mpr",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "SMulWithZero.toSMulZeroClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "AddSubmonoid.mk",
   "Module",
   "Submodule.span_le",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid",
   "Membership.mem",
   "instHAdd",
   "Semiring",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HasSubset.Subset",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "LE.le",
   "Set.instMembershipSet",
   "SMulZeroClass.toSMul",
   "Set.instHasSubsetSet",
   "MulActionWithZero.toSMulWithZero",
   "Submodule.mk",
   "MonoidWithZero.toZero",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.span_induction",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M} {s : Set M}\n  {p : M ‚Üí Prop},\n  x ‚àà Submodule.span R s ‚Üí\n    (‚àÄ x ‚àà s, p x) ‚Üí p 0 ‚Üí (‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) ‚Üí (‚àÄ (a : R) (x : M), p x ‚Üí p (a ‚Ä¢ x)) ‚Üí p x",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "DivisionSemiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{Œ± : Type u_4} ‚Üí [self : DivisionSemiring Œ±] ‚Üí Semiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero", "Real", "Zero.mk", "_private.Mathlib.Data.Real.Basic.0.Real.zero"],
  "name": "Real.instZeroReal",
  "constType": "Zero ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.631", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.zero",
  "constType": "‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Monoid",
   "Real.instMonoidWithZeroReal",
   "MonoidWithZero.toMonoid",
   "Real"],
  "name": "Real.instMonoidReal",
  "constType": "Monoid ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "wrapped._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "fderiv",
  "constType":
  "(ùïú : Type u_6) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_7} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_8} ‚Üí [inst_3 : NormedAddCommGroup F] ‚Üí [inst_4 : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí E ‚Üí E ‚ÜíL[ùïú] F",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "MulHomClass",
   "outParam",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Eq"],
  "name": "MonoidHomClass.mk",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : MulOneClass M] ‚Üí\n        [inst_1 : MulOneClass N] ‚Üí [toMulHomClass : MulHomClass F M N] ‚Üí (‚àÄ (f : F), f 1 = 1) ‚Üí MonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["SigmaCompactSpace", "TopologicalSpace", "Set.univ", "IsSigmaCompact"],
  "name": "SigmaCompactSpace.mk",
  "constType":
  "‚àÄ {X : Type u_4} [inst : TopologicalSpace X], IsSigmaCompact Set.univ ‚Üí SigmaCompactSpace X",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Set.Ioo",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "instDistribLattice",
   "isOpen_Ioi",
   "isOpen_Iio",
   "IsOpen.inter",
   "SemilatticeInf.toPartialOrder",
   "TopologicalSpace",
   "OrderClosedTopology",
   "IsOpen"],
  "name": "isOpen_Ioo",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±] {a b : Œ±},\n  IsOpen (Set.Ioo a b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.inf_le_left",
  "constType": "‚àÄ {Œ± : Type u} [self : SemilatticeInf Œ±] (a b : Œ±), a ‚äì b ‚â§ a",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "star_star",
   "CommSemiring.toSemiring",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "StarRing.toStarAddMonoid",
   "starRingEnd",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "StarAddMonoid.toInvolutiveStar"],
  "name": "starRingEnd_self_apply",
  "constType":
  "‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : StarRing R] (x : R), (starRingEnd R) ((starRingEnd R) x) = x",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : Zero M] ‚Üí [inst_1 : Zero N] ‚Üí [self : ZeroHomClass F M N] ‚Üí FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["HImp", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHImp",
  "constType": "{Œ± : Type u} ‚Üí [self : BooleanAlgebra Œ±] ‚Üí HImp Œ±",
  "constCategory": "Definition"},
 {"references":
  ["continuousAt_const",
   "Continuous",
   "ContinuousAt",
   "TopologicalSpace",
   "continuous_iff_continuousAt",
   "Iff.mpr"],
  "name": "continuous_const",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {b : Œ≤}, Continuous fun x => b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "AddHomClass.toFunLike",
   "Semiring",
   "Continuous",
   "ContinuousSemilinearMapClass.toSemilinearMapClass",
   "TopologicalSpace",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.map_continuous",
  "constType":
  "‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M‚ÇÇ : outParam (Type u_5)} [inst_4 : TopologicalSpace M‚ÇÇ] [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M]\n  [inst_7 : Module S M‚ÇÇ] [self : ContinuousSemilinearMapClass F œÉ M M‚ÇÇ] (f : F), Continuous ‚áëf",
  "constCategory": "Definition"},
 {"references": ["outParam", "NonAssocSemiring"],
  "name": "RingHomClass",
  "constType":
  "Type u_5 ‚Üí\n  (Œ± : outParam (Type u_6)) ‚Üí\n    (Œ≤ : outParam (Type u_7)) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí [inst : NonAssocSemiring Œ≤] ‚Üí Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.const",
   "CauchySeq",
   "Metric.mem_nhds_iff",
   "CompleteSpace",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSupReal",
   "Mathlib.Topology.Instances.Real._auxLemma.4",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Dist.dist",
   "Eq.mpr",
   "Iff.mp",
   "Filter.Tendsto",
   "Filter",
   "Metric.ball",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "CauSeq.instSubCauSeq",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Nat.instLatticeNat",
   "Real.instRingReal",
   "Set.instMembershipSet",
   "And",
   "CauSeq.equiv_lim",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LT.lt",
   "instInhabitedNat",
   "Filter.atTop",
   "Exists",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "Subtype.val",
   "IsCauSeq",
   "Real",
   "Set",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Exists.imp",
   "Exists.intro",
   "Abs.abs",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Metric.cauchySeq_iff'",
   "instLENat",
   "Preorder.toLT",
   "Filter.map",
   "Lattice.toSemilatticeSup",
   "UniformSpace.toTopologicalSpace",
   "instNonempty",
   "id",
   "instMembershipSetFilter",
   "Neg.toHasAbs",
   "Membership.mem",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "CauSeq.lim",
   "Real.instLinearOrderedRingReal",
   "Set.preimage",
   "Real.instLTReal",
   "nhds",
   "HSub.hSub",
   "Metric.complete_of_cauchySeq_tendsto",
   "Real.pseudoMetricSpace",
   "CauSeq",
   "GT.gt",
   "Real.instZeroReal",
   "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
   "PseudoMetricSpace.toDist",
   "Set.instHasSubsetSet",
   "StrictOrderedSemiring.toPartialOrder",
   "Mathlib.Topology.Instances.Real._auxLemma.3",
   "Subtype.mk"],
  "name": "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
  "constType": "CompleteSpace ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "SMulWithZero.toSMulZeroClass",
   "instHSMul",
   "SMulWithZero",
   "HSMul.hSMul",
   "SMulWithZero.zero_smul",
   "SMulZeroClass.toSMul",
   "Eq"],
  "name": "zero_smul",
  "constType":
  "‚àÄ (R : Type u_1) {M : Type u_3} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] (m : M), 0 ‚Ä¢ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.toAlgebra",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "RingHom.id"],
  "name": "Algebra.id",
  "constType": "(R : Type u) ‚Üí [inst : CommSemiring R] ‚Üí Algebra R R",
  "constCategory": "Definition"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "Real.metricSpace",
   "Real",
   "MetricSpace.toPseudoMetricSpace",
   "rfl",
   "Eq",
   "Dist.dist"],
  "name": "Real.normedAddCommGroup.proof_1",
  "constType": "‚àÄ (_r _y : ‚Ñù), dist _r _y = dist _r _y",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "IsROrC.innerProductSpace",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OrthonormalBasis.toBasis.proof_1",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "PiLp.seminormedAddCommGroup",
   "AddCommGroup.toAddCommMonoid",
   "DenselyNormedField.toNormedField",
   "OrthonormalBasis",
   "IsROrC",
   "LinearIsometryEquiv.toLinearEquiv",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "ENNReal",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Fintype",
   "Semiring.toNonAssocSemiring",
   "fact_one_le_two_ennreal",
   "OrthonormalBasis.repr",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "IsROrC.toDenselyNormedField",
   "Basis",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "EuclideanSpace.proof_1",
   "EuclideanDomain.toCommRing",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "InnerProductSpace.toNormedSpace",
   "DivisionSemiring.toSemiring",
   "EuclideanSpace",
   "Field.toEuclideanDomain",
   "InnerProductSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "WithLp.instModule",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "Pi.module",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "Basis.ofEquivFun"],
  "name": "OrthonormalBasis.toBasis",
  "constType":
  "{Œπ : Type u_1} ‚Üí\n  {ùïú : Type u_3} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      {E : Type u_4} ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst_2 : InnerProductSpace ùïú E] ‚Üí [inst_3 : Fintype Œπ] ‚Üí OrthonormalBasis Œπ ùïú E ‚Üí Basis Œπ ùïú E",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "sub_self",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "dite",
   "MulZeroClass.mul_zero",
   "Semifield.toCommGroupWithZero",
   "div_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Eq",
   "CommGroupWithZero.toDiv",
   "Field",
   "sub_zero",
   "HDiv.hDiv",
   "not_false_eq_true",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "Classical.propDecidable",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "congr",
   "Not",
   "Field.toDiv",
   "mul_div_cancel'",
   "MonoidWithZero.toZero",
   "add_zero",
   "Field.toDivisionRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "congrFun",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "mul_div_cancel",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "zero_add",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "CommGroupWithZero.toGroupWithZero",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "Field.toSemifield",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "eq_false",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero"],
  "name": "Field.toEuclideanDomain.proof_2",
  "constType":
  "‚àÄ {K : Type u_1} [inst : Field K] (a b : K), b * (fun x x_1 => x / x_1) a b + (fun a b => a - a * b / b) a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet", "Eq"],
  "name": "Set.insert",
  "constType": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Set Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_9",
  "constType": "‚àÄ {Œ± : Type u_1} (x y : Set Œ±), x \\ y = x ‚äì y·∂ú",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "BorelSpace.mk",
   "Set",
   "Eq.refl",
   "rfl",
   "BorelSpace.opensMeasurable",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "Continuous.measurable",
   "MeasureTheory.StronglyMeasurable",
   "Continuous",
   "TopologicalSpace",
   "Measurable",
   "SecondCountableTopologyEither.out",
   "TopologicalSpace.PseudoMetrizableSpace",
   "Set.image",
   "Eq.symm",
   "TopologicalSpace.IsSeparable.image",
   "id",
   "SecondCountableTopologyEither",
   "OpensMeasurableSpace",
   "Or",
   "borel",
   "Or.inr",
   "TopologicalSpace.isSeparable_of_separableSpace",
   "Measurable.stronglyMeasurable",
   "Or.casesOn",
   "Set.image_univ",
   "Set.univ",
   "TopologicalSpace.SecondCountableTopology.to_separableSpace",
   "And",
   "SecondCountableTopology",
   "Or.inl",
   "Eq.ndrec",
   "propext",
   "And.intro",
   "MeasurableSpace",
   "stronglyMeasurable_iff_measurable_separable"],
  "name": "Continuous.stronglyMeasurable",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OpensMeasurableSpace Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : TopologicalSpace.PseudoMetrizableSpace Œ≤]\n  [h : SecondCountableTopologyEither Œ± Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí MeasureTheory.StronglyMeasurable f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_4",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a : Œ±), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Or",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "or_assoc",
   "CauSeq",
   "LE.le",
   "Or.imp_right",
   "Iff.mpr",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Or.inl",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LinearOrderedField.toField",
   "LT.lt",
   "CauSeq.lt_total",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name": "CauSeq.le_total",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] (f g : CauSeq Œ± abs), f ‚â§ g ‚à® g ‚â§ f",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_4",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : Lattice Œ±] [inst_1 : DecidableEq Œ±] [inst_2 : DecidableRel fun x x_1 => x < x_1] (a b : Œ±),\n  compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubNegMonoid",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["PseudoEMetricSpace.mk",
   "EDist.mk",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_2",
   "PseudoMetricSpace.edist",
   "Metric.uniformity_edist",
   "PseudoMetricSpace.toUniformSpace",
   "PseudoEMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_3",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_1",
   "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toPseudoEMetricSpace",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : PseudoMetricSpace Œ±] ‚Üí PseudoEMetricSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "instHMul",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedCommSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "OrderedCommSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí [toOrderedSemiring : OrderedSemiring Œ±] ‚Üí (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí OrderedCommSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["MonoidWithZero.toMulActionWithZero.proof_3",
   "MonoidWithZero.toMulActionWithZero.proof_1",
   "SMulWithZero",
   "MulActionWithZero.mk",
   "MulZeroClass.toSMulWithZero",
   "MulActionWithZero",
   "MonoidWithZero.toMulActionWithZero.proof_2",
   "MulZeroOneClass.toMulZeroClass",
   "SMulZeroClass.toSMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Monoid.toMulAction",
   "SMulWithZero.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "MulZeroClass.toZero",
   "MonoidWithZero.toZero",
   "MulAction",
   "MonoidWithZero.toMulActionWithZero.proof_4",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero",
  "constType":
  "(R : Type u_1) ‚Üí [inst : MonoidWithZero R] ‚Üí MulActionWithZero R R",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "Continuous",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "Set.instBooleanAlgebraSet",
   "BooleanAlgebra.toHImp",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_10",
  "constType": "‚àÄ {Œ± : Type u_1} (x y : Set Œ±), x ‚á® y = y ‚äî x·∂ú",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "AddCommSemigroup.toAddCommMagma",
   "Submodule",
   "instHSMul",
   "HAdd.hAdd",
   "Set",
   "Semiring.toMonoidWithZero",
   "Submodule.completeLattice",
   "AddCommMonoid.toAddMonoid",
   "Insert.insert",
   "Submodule.span",
   "SetLike.instMembership",
   "True",
   "iff_self",
   "Eq",
   "Set.instSingletonSet",
   "SMulWithZero.toSMulZeroClass",
   "SemilatticeSup.toSup",
   "Iff",
   "CompleteLattice.toConditionallyCompleteLattice",
   "AddMonoid.toZero",
   "Mathlib.Logic.Basic._auxLemma.33",
   "HSMul.hSMul",
   "Mathlib.LinearAlgebra.Span._auxLemma.13",
   "Lattice.toSemilatticeSup",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "AddCommMonoid",
   "Membership.mem",
   "funext",
   "Mathlib.LinearAlgebra.Span._auxLemma.11",
   "Semiring",
   "instHAdd",
   "eq_comm",
   "ConditionallyCompleteLattice.toLattice",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Submodule.span_insert",
   "SMulZeroClass.toSMul",
   "And",
   "MulActionWithZero.toSMulWithZero",
   "of_eq_true",
   "propext",
   "congr",
   "Sup.sup",
   "Singleton.singleton",
   "MonoidWithZero.toZero",
   "congrArg",
   "Submodule.setLike",
   "congrFun",
   "Set.instInsertSet"],
  "name": "Submodule.mem_span_insert",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M} {s : Set M}\n  {y : M}, x ‚àà Submodule.span R (insert y s) ‚Üî ‚àÉ a, ‚àÉ z ‚àà Submodule.span R s, x = a ‚Ä¢ y + z",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Nat"],
  "name": "Semiring.npow",
  "constType": "{Œ± : Type u} ‚Üí [self : Semiring Œ±] ‚Üí ‚Ñï ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Membership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} ‚Üí {B : Type u_2} ‚Üí [i : SetLike A B] ‚Üí Membership B A",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {motive : Exists p ‚Üí Prop} (t : Exists p),\n  (‚àÄ (w : Œ±) (h : p w), motive (_ : Exists p)) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "And",
   "Field.toEuclideanDomain.match_1",
   "OfNat.ofNat",
   "WellFounded.intro",
   "False.elim",
   "Field",
   "Field.toSemifield",
   "WellFounded",
   "Semifield.toCommGroupWithZero",
   "Acc.intro",
   "Acc",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "Field.toEuclideanDomain.proof_3",
  "constType":
  "‚àÄ {K : Type u_1} [inst : Field K], WellFounded fun a b => a = 0 ‚àß b ‚â† 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "‚àÄ {M‚ÇÄ : Type u} [self : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompletelyDistribLattice",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.mk",
  "constType":
  "{Œ± : Type u_6} ‚Üí [toMeasurableSpace : MeasurableSpace Œ±] ‚Üí MeasureTheory.Measure Œ± ‚Üí MeasureTheory.MeasureSpace Œ±",
  "constCategory": "Other"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.mul", "Mul", "Mul.mk"],
  "name": "Real.instMulReal",
  "constType": "Mul ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["setOf",
   "nhds",
   "Preorder.toLT",
   "LT.lt",
   "OrderTopology",
   "TopologicalSpace",
   "IsOpen.mem_nhds",
   "Filter.Eventually",
   "Preorder",
   "isOpen_gt'"],
  "name": "gt_mem_nhds",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [t : OrderTopology Œ±] {a b : Œ±},\n  a < b ‚Üí ‚àÄ·∂† (x : Œ±) in nhds a, x < b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure.Regular",
   "BorelSpace",
   "isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure",
   "MeasureTheory.Measure.WeaklyRegular.toOuterRegular",
   "MeasureTheory.Measure.WeaklyRegular.of_pseudoMetrizableSpace_secondCountable_of_locallyFinite",
   "TopologicalSpace.pseudoMetrizableSpacePseudoMetric",
   "MeasureTheory.Measure",
   "MeasureTheory.Measure.InnerRegularWRT.isCompact_isClosed",
   "SigmaCompactSpace",
   "TopologicalSpace",
   "MeasureTheory.Measure.Regular.mk",
   "IsClosed",
   "TopologicalSpace.PseudoMetrizableSpace",
   "EMetric.secondCountable_of_sigmaCompact",
   "MeasureTheory.Measure.InnerRegularWRT.trans",
   "IsCompact",
   "IsOpen",
   "MeasurableSpace",
   "PseudoMetricSpace",
   "MeasureTheory.Measure.InnerRegularWRT.of_pseudoMetrizableSpace",
   "MeasureTheory.IsLocallyFiniteMeasure",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name":
  "MeasureTheory.Measure.Regular.of_sigmaCompactSpace_of_isLocallyFiniteMeasure",
  "constType":
  "‚àÄ {X : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.PseudoMetrizableSpace X]\n  [inst_2 : SigmaCompactSpace X] [inst_3 : MeasurableSpace X] [inst_4 : BorelSpace X] (Œº : MeasureTheory.Measure X)\n  [inst_5 : MeasureTheory.IsLocallyFiniteMeasure Œº], MeasureTheory.Measure.Regular Œº",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.631",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.631",
  "constType": "Subtype (Eq Real.definition‚úù)",
  "constCategory": "Other"},
 {"references":
  ["outParam", "FunLike", "ContinuousMapClass", "TopologicalSpace"],
  "name": "ContinuousMapClass.toFunLike",
  "constType":
  "{F : Type u_1} ‚Üí\n  {Œ± : outParam (Type u_2)} ‚Üí\n    {Œ≤ : outParam (Type u_3)} ‚Üí\n      [inst : TopologicalSpace Œ±] ‚Üí\n        [inst_1 : TopologicalSpace Œ≤] ‚Üí [self : ContinuousMapClass F Œ± Œ≤] ‚Üí FunLike F Œ± fun x => Œ≤",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocSemiring Œ±] ‚Üí AddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "DivisionRing", "Rat", "Rat.field", "Field.toDivisionRing"],
  "name": "Rat.divisionRing",
  "constType": "DivisionRing ‚Ñö",
  "constCategory": "Definition"},
 {"references": ["Real", "StieltjesFunction"],
  "name": "StieltjesFunction.toFun",
  "constType": "StieltjesFunction ‚Üí ‚Ñù ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Real.instLTReal",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "LE.le",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "And",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Iff",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "LT.lt",
   "Rat.instNegRat",
   "congr",
   "Not",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_3",
  "constType": "‚àÄ (a b : ‚Ñù), a < b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["IsROrC.re",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsROrC.norm_sq_eq_def",
   "NormedField.toNorm",
   "Eq",
   "Field.toCommRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "MonoidWithZeroHom",
   "Nat",
   "Eq.symm",
   "HPow.hPow",
   "IsROrC.toDenselyNormedField",
   "Real.instMonoidReal",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "AddHomClass.toFunLike",
   "IsROrC.normSq",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Real.semiring",
   "HMul.hMul",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.im"],
  "name": "IsROrC.normSq_eq_def'",
  "constType":
  "‚àÄ {K : Type u_1} [inst : IsROrC K] (z : K), IsROrC.normSq z = ‚Äñz‚Äñ ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegZeroMonoid.neg_zero",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass.mk",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "NegZeroClass"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} ‚Üí [self : SubNegZeroMonoid G] ‚Üí NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["two_ne_zero",
   "Distrib.toAdd",
   "LinearOrderedSemifield.toSemifield",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "mul_div_cancel",
   "Eq",
   "Semiring.toNatCast",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_two",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "GroupWithZero.toDiv",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "ZeroLEOneClass.neZero.two",
   "instNatAtLeastTwo",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero"],
  "name": "add_self_div_two",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] (a : Œ±), (a + a) / 2 = a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "Rat"],
  "name": "LinearOrderedField.qsmul",
  "constType": "{Œ± : Type u_2} ‚Üí [self : LinearOrderedField Œ±] ‚Üí ‚Ñö ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{Œ± : Type u_1} ‚Üí (x y : Œ±) ‚Üí [inst : LT Œ±] ‚Üí [inst : Decidable (x < y)] ‚Üí [inst : DecidableEq Œ±] ‚Üí Ordering",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "WithTop",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Definition"},
 {"references":
  ["ZeroHom.mk",
   "MeasureTheory.Measure.zero_toOuterMeasure",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "MeasureTheory.Measure.add_toOuterMeasure",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.Measure.instSMul",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "MeasureTheory.Measure",
   "AddZeroClass.toZero",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "SMulWithZero.toSMulZeroClass",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "Module",
   "Algebra.toSMul",
   "AddMonoidHom.mk",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Function.Injective.module",
   "Semiring",
   "Module.toMulActionWithZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "instENNRealZero",
   "IsScalarTower",
   "SMulZeroClass.toSMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MulActionWithZero.toSMulWithZero",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule.proof_1",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasureTheory.OuterMeasure.instModule",
   "MonoidWithZero.toZero",
   "Algebra.id",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.instModule",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {R : Type u_6} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Module R ENNReal] ‚Üí\n        [inst_2 : IsScalarTower R ENNReal ENNReal] ‚Üí [inst_3 : MeasurableSpace Œ±] ‚Üí Module R (MeasureTheory.Measure Œ±)",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} ‚Üí [self : AddMonoid M] ‚Üí AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_add'",
  "constType":
  "‚àÄ {M : Type u_9} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M ‚Üí+ N) (x y : M),\n  ZeroHom.toFun (‚Üëself) (x + y) = ZeroHom.toFun (‚Üëself) x + ZeroHom.toFun (‚Üëself) y",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} ‚Üí [self : AddMonoidWithOne R] ‚Üí NatCast R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "UniformSpace",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["OpensMeasurableSpace",
   "Continuous.borel_measurable",
   "Measurable.mono",
   "BorelSpace",
   "PartialOrder.toPreorder",
   "borel",
   "Continuous",
   "OpensMeasurableSpace.borel_le",
   "TopologicalSpace",
   "Measurable",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "le_of_eq",
   "MeasurableSpace",
   "BorelSpace.measurable_eq"],
  "name": "Continuous.measurable",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±]\n  [inst_2 : OpensMeasurableSpace Œ±] [inst_3 : TopologicalSpace Œ≥] [inst_4 : MeasurableSpace Œ≥] [inst_5 : BorelSpace Œ≥]\n  {f : Œ± ‚Üí Œ≥}, Continuous f ‚Üí Measurable f",
  "constCategory": "Theorem"},
 {"references":
  ["Continuous.stronglyMeasurable",
   "MeasureTheory.Measure",
   "SecondCountableTopologyEither",
   "OpensMeasurableSpace",
   "StronglyMeasurableAtFilter",
   "Continuous",
   "TopologicalSpace",
   "Filter",
   "TopologicalSpace.PseudoMetrizableSpace",
   "MeasureTheory.StronglyMeasurable.stronglyMeasurableAtFilter",
   "MeasurableSpace"],
  "name": "Continuous.stronglyMeasurableAtFilter",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OpensMeasurableSpace Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : TopologicalSpace.PseudoMetrizableSpace Œ≤]\n  [inst_5 : SecondCountableTopologyEither Œ± Œ≤] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí ‚àÄ (Œº : MeasureTheory.Measure Œ±) (l : Filter Œ±), StronglyMeasurableAtFilter f l",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "HasSolidNorm.mk",
   "Neg.toHasAbs",
   "AddCommGroup.toDivisionAddCommMonoid",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Real.lattice",
   "Real",
   "SemilatticeInf.toPartialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "LE.le",
   "Preorder.toLE",
   "Abs.abs",
   "SemilatticeSup.toSup",
   "HasSolidNorm",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.normedAddCommGroup",
   "id"],
  "name": "instHasSolidNormRealNormedAddCommGroupLattice",
  "constType": "HasSolidNorm ‚Ñù",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Norm",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Real",
   "Ring.toAddCommGroup",
   "Real.instRingReal",
   "AddCommGroup"],
  "name": "Real.instAddCommGroupReal",
  "constType": "AddCommGroup ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "OrderedCancelAddCommMonoid",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.min_def",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.mk",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.toMin",
   "OrderedCancelAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedAddCommGroup.toMax"],
  "name": "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : LinearOrderedAddCommGroup Œ±] ‚Üí LinearOrderedCancelAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "DivisionRing.toInv",
   "DivisionRing.zpow",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.zpow_neg'",
  "constType":
  "‚àÄ {K : Type u} [self : DivisionRing K] (n : ‚Ñï) (a : K),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "False",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "exists_pair_ne",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toZero",
   "Exists.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NeZero",
   "Eq.mpr",
   "NeZero.mk",
   "one_mul",
   "Eq.ndrec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "instTransEq",
   "Nontrivial",
   "id"],
  "name": "NeZero.one",
  "constType":
  "‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "NormedRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedRing.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toNorm : Norm Œ±] ‚Üí\n    [toRing : Ring Œ±] ‚Üí\n      [toMetricSpace : MetricSpace Œ±] ‚Üí\n        (‚àÄ (x y : Œ±), dist x y = ‚Äñx - y‚Äñ) ‚Üí (‚àÄ (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ) ‚Üí NormedRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{Œ± : Type u} ‚Üí [self : Semiring Œ±] ‚Üí MonoidWithZero Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalCommRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_neg",
  "constType": "‚àÄ {G : Type u} [self : SubtractionMonoid G] (x : G), - -x = x",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(Œ± : Type u) ‚Üí [inst : LE Œ±] ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "instHSMul",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Mathlib.Topology.Algebra.Module.Basic._auxLemma.20",
   "RingHom.id",
   "True",
   "iff_self",
   "Eq",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "one_smul",
   "Iff",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "ContinuousLinearMap.smulRight",
   "ContinuousSMul",
   "Module",
   "Eq.trans",
   "Semiring.toModule",
   "MulActionWithZero.toMulAction",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "AddCommMonoid",
   "Semiring",
   "One.toOfNat1",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "SMulZeroClass.toSMul",
   "Semiring.toOne",
   "MulActionWithZero.toSMulWithZero",
   "MulAction.toSMul",
   "ContinuousLinearMap",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "congrArg",
   "ContinuousMapClass.toFunLike",
   "ContinuousLinearMap.one",
   "congrFun"],
  "name": "ContinuousLinearMap.smulRight_one_eq_iff",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_1} [inst : Semiring R‚ÇÅ] {M‚ÇÇ : Type u_6} [inst_1 : TopologicalSpace M‚ÇÇ] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : Module R‚ÇÅ M‚ÇÇ] [inst_4 : TopologicalSpace R‚ÇÅ] [inst_5 : ContinuousSMul R‚ÇÅ M‚ÇÇ] {f f' : M‚ÇÇ},\n  ContinuousLinearMap.smulRight 1 f = ContinuousLinearMap.smulRight 1 f' ‚Üî f = f'",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_5",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a : Œ±), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u ‚Üí Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.tendsto_inf",
   "Prod.snd",
   "Filter.tendsto_comap_iff",
   "Inf.inf",
   "Function.comp",
   "Prod.fst",
   "Filter.instSProd",
   "Iff.mpr",
   "And",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "Filter.comap",
   "Filter",
   "Filter.Tendsto",
   "Prod",
   "And.intro"],
  "name": "Filter.Tendsto.prod_mk",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} {m‚ÇÅ : Œ± ‚Üí Œ≤} {m‚ÇÇ : Œ± ‚Üí Œ≥},\n  Filter.Tendsto m‚ÇÅ f g ‚Üí Filter.Tendsto m‚ÇÇ f h ‚Üí Filter.Tendsto (fun x => (m‚ÇÅ x, m‚ÇÇ x)) f (g √óÀ¢ h)",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHomClass.toFunLike",
   "Semiring",
   "ZeroHom.zeroHomClass",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "AddCommGroup.toAddCommMonoid",
   "ZeroHom",
   "Module.rank",
   "FunLike.coe",
   "Nat",
   "Module",
   "AddCommGroup"],
  "name": "FiniteDimensional.finrank",
  "constType":
  "(R : Type u_1) ‚Üí (V : Type u_2) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst : Module R V] ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
  "constType":
  "{Œ± : Type u} ‚Üí [self : CompleteAtomicBooleanAlgebra Œ±] ‚Üí CompletelyDistribLattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.innerProductSpace",
   "NormedAddCommGroup",
   "CompleteSpace",
   "OfNat.ofNat",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "Inf.inf",
   "Real.normedField",
   "Real.measurableSpace",
   "Real.instSubReal",
   "intervalIntegral.integral_const",
   "Real.isROrC",
   "AddCommGroup.toAddCommMonoid",
   "Asymptotics.IsLittleO",
   "Real.locallyFinite_volume",
   "Real.instOneReal",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "HSMul.hSMul",
   "Filter",
   "Real.measureSpace",
   "Filter.Tendsto",
   "NormedAddCommGroup.toNorm",
   "Eq.trans",
   "Real.normedAddCommGroup",
   "instHSub",
   "PseudoMetricSpace.toUniformSpace",
   "Real.norm",
   "Module.toMulActionWithZero",
   "SMulZeroClass.toSMul",
   "InnerProductSpace.toNormedSpace",
   "MulActionWithZero.toSMulWithZero",
   "Eq.mp",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "congr",
   "mul_one",
   "NormedSpace.toModule",
   "congrArg",
   "NormedAddCommGroup.toAddCommGroup",
   "Pi.instSub",
   "AddCommGroup.toDivisionAddCommMonoid",
   "StronglyMeasurableAtFilter",
   "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
   "Real",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "NormedAddGroup.toAddGroup",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "MeasureTheory.Measure.ae",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "funext",
   "IntervalIntegrable",
   "Real.instMonoidWithZeroReal",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HSub.hSub",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "intervalIntegral.FTCFilter",
   "intervalIntegral.measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right",
   "Real.semiring",
   "Filter.instInfFilter",
   "NormedAddCommGroup.toNormedAddGroup",
   "NegZeroClass.toZero"],
  "name":
  "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right",
  "constType":
  "‚àÄ {Œπ : Type u_1} {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ‚Ñù E]\n  {f : ‚Ñù ‚Üí E} {c : E} {lb lb' : Filter ‚Ñù} {lt : Filter Œπ} {a b : ‚Ñù} {u v : Œπ ‚Üí ‚Ñù}\n  [inst_3 : intervalIntegral.FTCFilter b lb lb'],\n  IntervalIntegrable f MeasureTheory.volume a b ‚Üí\n    StronglyMeasurableAtFilter f lb' ‚Üí\n      Filter.Tendsto f (lb' ‚äì MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) ‚Üí\n        Filter.Tendsto u lt lb ‚Üí\n          Filter.Tendsto v lt lb ‚Üí\n            (fun t => ((‚à´ (x : ‚Ñù) in a..v t, f x) - ‚à´ (x : ‚Ñù) in a..u t, f x) - (v t - u t) ‚Ä¢ c) =o[lt] (v - u)",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance", "Real", "Real.commRing", "Ring", "CommRing.toRing"],
  "name": "Real.instRingReal",
  "constType": "Ring ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "dite",
   "Not",
   "absurd",
   "rfl",
   "Eq"],
  "name": "dif_pos",
  "constType":
  "‚àÄ {c : Prop} {h : Decidable c} (hc : c) {Œ± : Sort u} {t : c ‚Üí Œ±} {e : ¬¨c ‚Üí Œ±}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references": ["And", "setOf", "Preorder.toLT", "Set", "LT.lt", "Preorder"],
  "name": "Set.Ioo",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toStrictOrderedSemiring : StrictOrderedSemiring Œ±] ‚Üí\n    [toMin : Min Œ±] ‚Üí\n      [toMax : Max Œ±] ‚Üí\n        [toOrd : Ord Œ±] ‚Üí\n          (‚àÄ (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a) ‚Üí\n            (decidableLE : DecidableRel fun x x_1 => x ‚â§ x_1) ‚Üí\n              (decidableEq : DecidableEq Œ±) ‚Üí\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) ‚Üí\n                  autoParam (‚àÄ (a b : Œ±), min a b = if a ‚â§ b then a else b) _auto‚úù ‚Üí\n                    autoParam (‚àÄ (a b : Œ±), max a b = if a ‚â§ b then b else a) _auto‚úù¬π ‚Üí\n                      autoParam (‚àÄ (a b : Œ±), compare a b = compareOfLessAndEq a b) _auto‚úù¬≤ ‚Üí LinearOrderedSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "SeminormedRing",
   "Norm",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace"],
  "name": "SeminormedRing.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toNorm : Norm Œ±] ‚Üí\n    [toRing : Ring Œ±] ‚Üí\n      [toPseudoMetricSpace : PseudoMetricSpace Œ±] ‚Üí\n        (‚àÄ (x y : Œ±), dist x y = ‚Äñx - y‚Äñ) ‚Üí (‚àÄ (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ) ‚Üí SeminormedRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Finset.nodup",
   "DecidableEq",
   "Finset",
   "Multiset.ndinsert",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.Nodup.ndinsert"],
  "name": "Finset.instInsertFinset.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±) (s : Finset Œ±), Multiset.Nodup (Multiset.ndinsert a s.val)",
  "constCategory": "Theorem"},
 {"references": ["Norm", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} ‚Üí [self : NormedAddCommGroup E] ‚Üí Norm E",
  "constCategory": "Definition"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "Algebra",
  "constType":
  "(R : Type u) ‚Üí (A : Type v) ‚Üí [inst : CommSemiring R] ‚Üí [inst : Semiring A] ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} ‚Üí [self : AddRightCancelMonoid M] ‚Üí AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "TopologicalSemiring.toContinuousMul",
   "CommRing.toNonUnitalCommRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "TopologicalDivisionRing.mk",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "LinearOrderedField.topologicalRing",
   "Field.toCommRing",
   "LinearOrderedField",
   "LinearOrderedField.toField",
   "TopologicalRing.toTopologicalSemiring",
   "TopologicalSpace",
   "OrderTopology",
   "LinearOrderedField.toLinearOrderedSemifield",
   "TopologicalDivisionRing",
   "LinearOrderedSemifield.toHasContinuousInv‚ÇÄ",
   "Field.toDivisionRing",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedField.toTopologicalDivisionRing",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú],\n  TopologicalDivisionRing ùïú",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrder.mk",
   "LinearOrderedAddCommGroup.min_def",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd"],
  "name": "LinearOrderedAddCommGroup.toLinearOrder",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí LinearOrder Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inf",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "‚àÄ {R : Type u_1} [inst : Zero R] {n : R}, n ‚â† 0 ‚Üí NeZero n",
  "constCategory": "Other"},
 {"references": [],
  "name": "Dist",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "AddCommMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} ‚Üí [self : AddCommGroup G] ‚Üí AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring.npow",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.npow_succ",
  "constType":
  "‚àÄ {Œ± : Type u} [self : Semiring Œ±] (n : ‚Ñï) (x : Œ±), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "TopologicalSpace.isOpen_inter",
   "TopologicalSpace",
   "Inter.inter",
   "IsOpen",
   "Set.instInterSet"],
  "name": "IsOpen.inter",
  "constType":
  "‚àÄ {Œ± : Type u} {s‚ÇÅ s‚ÇÇ : Set Œ±} [inst : TopologicalSpace Œ±], IsOpen s‚ÇÅ ‚Üí IsOpen s‚ÇÇ ‚Üí IsOpen (s‚ÇÅ ‚à© s‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "Function.swap",
   "PartialOrder.toPreorder",
   "covariant_swap_add_of_covariant_add",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassRight",
  "constType":
  "‚àÄ (M : Type u_3) [inst : OrderedAddCommMonoid M],\n  CovariantClass M M (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Set.mem_setOf",
   "Set",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Filter.tendsto_principal_principal",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Filter",
   "Filter.Tendsto",
   "OrderedAddCommMonoid.toPartialOrder",
   "Filter.instCompleteLatticeFilter",
   "id",
   "Membership.mem",
   "setOf",
   "Prod.snd",
   "Filter.tendsto_iInf_iInf",
   "Prod.fst",
   "ConditionallyCompleteLattice.toInfSet",
   "GT.gt",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "iInf",
   "CompleteLattice.toInfSet",
   "propext",
   "LT.lt",
   "Prod.swap",
   "Prod",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofFun.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : OrderedAddCommMonoid Œ≤] (d : Œ± ‚Üí Œ± ‚Üí Œ≤),\n  (‚àÄ (x y : Œ±), d x y = d y x) ‚Üí\n    Filter.Tendsto Prod.swap (‚®Ö r, ‚®Ö (_ : r > 0), Filter.principal {x | d x.1 x.2 < r})\n      (‚®Ö r, ‚®Ö (_ : r > 0), Filter.principal {x | d x.1 x.2 < r})",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "ZeroLEOneClass.zero_le_one",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "zero_le_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [inst_3 : ZeroLEOneClass Œ±], 0 ‚â§ 1",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "Prod.snd",
   "instHSMul",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "ContinuousSMul.continuous_smul",
   "Continuous",
   "HSMul.hSMul",
   "Continuous.prod_mk",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "ContinuousSMul",
   "Continuous.comp"],
  "name": "Continuous.smul",
  "constType":
  "‚àÄ {M : Type u_1} {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : SMul M X] [inst_4 : ContinuousSMul M X] {f : Y ‚Üí M} {g : Y ‚Üí X},\n  Continuous f ‚Üí Continuous g ‚Üí Continuous fun x => f x ‚Ä¢ g x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Nat.linearOrder",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "CharZero.mk",
   "Nat.succ",
   "id",
   "IsCancelAdd.toIsLeftCancelAdd",
   "lt_add_one",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "Eq.ndrec",
   "CharZero",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoidWithOne.toOne",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "strictMono_nat_of_lt_succ",
   "StrictMono.injective"],
  "name": "StrictOrderedSemiring.to_charZero",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : StrictOrderedSemiring Œ±], CharZero Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_zero'",
  "constType": "‚àÄ {R : Type u} [self : Ring R] (a : R), Ring.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "instHMul",
   "outParam",
   "FunLike",
   "HMul.hMul",
   "FunLike.coe",
   "Mul",
   "Eq"],
  "name": "MulHomClass.mk",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : Mul M] ‚Üí\n        [inst_1 : Mul N] ‚Üí\n          [toFunLike : FunLike F M fun x => N] ‚Üí (‚àÄ (f : F) (x y : M), f (x * y) = f x * f y) ‚Üí MulHomClass F M N",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocSemiring Œ±] ‚Üí Mul Œ±",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "TopologicalSpace.isSeparable_univ_iff",
   "Set",
   "TopologicalSpace.SeparableSpace",
   "TopologicalSpace",
   "Set.univ",
   "Set.subset_univ",
   "Iff.mpr",
   "TopologicalSpace.IsSeparable.mono"],
  "name": "TopologicalSpace.isSeparable_of_separableSpace",
  "constType":
  "‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [h : TopologicalSpace.SeparableSpace Œ±] (s : Set Œ±),\n  TopologicalSpace.IsSeparable s",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : SemilatticeInf Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} ‚Üí [self : AddMonoidWithOne R] ‚Üí AddMonoid R",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddGroupWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} ‚Üí [self : AddGroupWithOne R] ‚Üí AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Classical.choose_spec",
   "Exists",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "Classical.choose",
   "NontriviallyNormedField.toNormedField",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "dite",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "HasFDerivAt",
   "fderiv_def",
   "UniformSpace.toTopologicalSpace",
   "id",
   "fderiv",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "dif_pos",
   "Classical.propDecidable",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "DivisionSemiring.toSemiring",
   "DifferentiableAt",
   "ContinuousLinearMap",
   "Eq.ndrec",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Not",
   "NormedSpace.toModule",
   "ContinuousLinearMap.zero"],
  "name": "DifferentiableAt.hasFDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  {x : E}, DifferentiableAt ùïú f x ‚Üí HasFDerivAt f (fderiv ùïú f x) x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Mul"],
  "name": "MulHomClass",
  "constType":
  "Type u_9 ‚Üí\n  (M : outParam (Type u_10)) ‚Üí\n    (N : outParam (Type u_11)) ‚Üí [inst : Mul M] ‚Üí [inst : Mul N] ‚Üí Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["AddCommMonoid.nat_isScalarTower",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring.toMonoidWithZero",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "IsScalarTower",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid.toNatSMul",
   "SMulZeroClass.toSMul",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Nat",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.instAddCommMonoid.proof_1",
  "constType": "IsScalarTower ‚Ñï ENNReal ENNReal",
  "constCategory": "Theorem"},
 {"references": ["Inner"],
  "name": "Inner.inner",
  "constType":
  "{ùïú : Type u_4} ‚Üí {E : Type u_5} ‚Üí [self : Inner ùïú E] ‚Üí E ‚Üí E ‚Üí ùïú",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Submodule.mem_sup",
   "AddCommSemigroup.toAddCommMagma",
   "Exists",
   "Submodule",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.completeLattice",
   "AddCommMagma.toAdd",
   "SetLike.instMembership",
   "Eq",
   "And",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Sup.sup",
   "Module",
   "Lattice.toSemilatticeSup",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Mathlib.LinearAlgebra.Span._auxLemma.13",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M}\n  {p p' : Submodule R M}, (x ‚àà p ‚äî p') = ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "NormedAddGroup"],
  "name": "NormedAddGroup.toAddGroup",
  "constType": "{E : Type u_9} ‚Üí [self : NormedAddGroup E] ‚Üí AddGroup E",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "LinearOrder.mk",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLT"],
  "name": "LinearOrderedRing.toLinearOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí LinearOrder Œ±",
  "constCategory": "Definition"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{Œ± : Type u_1} ‚Üí Singleton Œ± (Set Œ±)",
  "constCategory": "Definition"},
 {"references": ["NormedField", "SeminormedAddCommGroup"],
  "name": "NormedSpace",
  "constType":
  "(Œ± : Type u_5) ‚Üí (Œ≤ : Type u_6) ‚Üí [inst : NormedField Œ±] ‚Üí [inst : SeminormedAddCommGroup Œ≤] ‚Üí Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Min Œ±",
  "constCategory": "Other"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "AddHom.toFun",
   "Semiring",
   "ContinuousLinearMap.casesOn",
   "ContinuousLinearMap.mk",
   "Eq.refl",
   "autoParam",
   "AddCommMagma.toAdd",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "ContinuousLinearMap",
   "Function.Injective",
   "Eq.rec",
   "Continuous",
   "_auto._@.Mathlib.Topology.Algebra.Module.Basic._hyg.2648",
   "TopologicalSpace",
   "Module",
   "Eq.symm",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.coe_injective",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ],\n  Function.Injective ContinuousLinearMap.toLinearMap",
  "constCategory": "Theorem"},
 {"references": ["AddGroupWithOne", "Int"],
  "name": "AddGroupWithOne.zsmul",
  "constType": "{R : Type u} ‚Üí [self : AddGroupWithOne R] ‚Üí ‚Ñ§ ‚Üí R ‚Üí R",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toSemilatticeSup : SemilatticeSup Œ±] ‚Üí\n    [toInf : Inf Œ±] ‚Üí\n      (‚àÄ (a b : Œ±), a ‚äì b ‚â§ a) ‚Üí (‚àÄ (a b : Œ±), a ‚äì b ‚â§ b) ‚Üí (‚àÄ (a b c : Œ±), a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ b ‚äì c) ‚Üí Lattice Œ±",
  "constCategory": "Other"},
 {"references": ["OmegaCompletePartialOrder", "PartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{Œ± : Type u_1} ‚Üí [self : OmegaCompletePartialOrder Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalRing.mk",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing.proof_4",
   "CommRing.toNonUnitalCommRing.proof_11",
   "CommRing.toNonUnitalCommRing.proof_8",
   "CommRing.toNonUnitalCommRing.proof_2",
   "AddGroup.mk",
   "CommRing.toNonUnitalCommRing.proof_9",
   "CommRing.toNonUnitalCommRing.proof_1",
   "CommRing.mul_comm",
   "CommRing.toNonUnitalCommRing.proof_7",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing.proof_5",
   "CommRing",
   "CommRing.toNonUnitalCommRing.proof_10",
   "Ring.zsmul",
   "Ring.toNeg",
   "NonUnitalCommRing.mk",
   "Ring.toSub",
   "CommRing.toRing",
   "CommRing.toNonUnitalCommRing.proof_6",
   "CommRing.toNonUnitalCommRing.proof_3",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup.mk"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{Œ± : Type u} ‚Üí [s : CommRing Œ±] ‚Üí NonUnitalCommRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{Œ± : Type u} ‚Üí [self : StrictOrderedSemiring Œ±] ‚Üí OrderedCancelAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_succ'",
  "constType":
  "‚àÄ {K : Type u} [self : DivisionRing K] (n : ‚Ñï) (a : K),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "StrictOrderedRing"],
  "name": "LinearOrderedRing.toStrictOrderedRing",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí StrictOrderedRing Œ±",
  "constCategory": "Definition"},
 {"references": ["Exists", "Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{Œ± : Sort u} ‚Üí {p : Œ± ‚Üí Prop} ‚Üí (‚àÉ x, p x) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "‚Ñï ‚Üí ‚Ñ§",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "LinearOrderedAddCommMonoid",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.mk",
  "constType":
  "{Œ± : Type u_3} ‚Üí\n  [toLinearOrder : LinearOrder Œ±] ‚Üí\n    [toAddCommMonoid : AddCommMonoid Œ±] ‚Üí (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b) ‚Üí LinearOrderedAddCommMonoid Œ±",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "DenselyOrdered",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "instDistribLattice",
   "le_refl",
   "SemilatticeInf.toPartialOrder",
   "OrderTopology",
   "TopologicalSpace",
   "NoMaxOrder",
   "nhdsWithin",
   "Set.Ioi",
   "Filter.NeBot",
   "nhdsWithin_Ioi_neBot"],
  "name": "nhdsWithin_Ioi_self_neBot",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] [inst_4 : NoMaxOrder Œ±] (a : Œ±), Filter.NeBot (nhdsWithin a (Set.Ioi a))",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "‚àÄ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_3",
  "constType": "‚àÄ (a : ‚Ñù), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{Œ± Œ≤ : Sort u} ‚Üí Œ± = Œ≤ ‚Üí Œ± ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrder Œ±] ‚Üí Max Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocSemiring",
   "MulHomClass",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.mk",
  "constType":
  "{F : Type u_5} ‚Üí\n  {Œ± : outParam (Type u_6)} ‚Üí\n    {Œ≤ : outParam (Type u_7)} ‚Üí\n      [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring Œ≤] ‚Üí\n          [toMulHomClass : MulHomClass F Œ± Œ≤] ‚Üí\n            (‚àÄ (f : F) (x y : Œ±), f (x + y) = f x + f y) ‚Üí (‚àÄ (f : F), f 0 = 0) ‚Üí NonUnitalRingHomClass F Œ± Œ≤",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instZeroCardinal",
  "constType": "Zero Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a b c : Œ±), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "Semiring",
   "FunLike.mk",
   "LinearMap.instFunLike",
   "FunLike.coe",
   "AddCommMagma.toAdd",
   "SemilinearMapClass.mk",
   "AddHomClass.mk",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap.continuousSemilinearMapClass.proof_2",
   "ContinuousLinearMap",
   "ContinuousSemilinearMapClass",
   "ContinuousLinearMap.continuousSemilinearMapClass.proof_1",
   "ContinuousLinearMap.continuousSemilinearMapClass.proof_3",
   "TopologicalSpace",
   "Module",
   "ContinuousSemilinearMapClass.mk",
   "ContinuousLinearMap.cont",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass",
  "constType":
  "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí\n                        [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí ContinuousSemilinearMapClass (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) œÉ‚ÇÅ‚ÇÇ M‚ÇÅ M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "‚àÄ {b : Prop} (Œ± : Sort u_1) [i : Nonempty Œ±], (Œ± ‚Üí b) = b",
  "constCategory": "Theorem"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{Œ± : Type u_1} ‚Üí EmptyCollection (Set Œ±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Prod.snd",
   "setOf",
   "instTopologicalSpaceProd",
   "TopologicalSpace",
   "OrderClosedTopology",
   "Prod",
   "Prod.fst",
   "IsClosed",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderClosedTopology.mk",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±], IsClosed {p | p.1 ‚â§ p.2} ‚Üí OrderClosedTopology Œ±",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{Œ± : Type u} ‚Üí [self : Lattice Œ±] ‚Üí SemilatticeInf Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mpr",
   "Filter.Tendsto.prod_mk",
   "nhds_prod_eq",
   "Eq.ndrec",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "nhds",
   "SProd.sprod",
   "Eq.refl",
   "TopologicalSpace",
   "Prod",
   "Filter.Tendsto",
   "Filter",
   "Filter.instSProd",
   "Eq",
   "id"],
  "name": "Filter.Tendsto.prod_mk_nhds",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {Œ≥ : Type u_5} {a : Œ±} {b : Œ≤}\n  {f : Filter Œ≥} {ma : Œ≥ ‚Üí Œ±} {mb : Œ≥ ‚Üí Œ≤},\n  Filter.Tendsto ma f (nhds a) ‚Üí Filter.Tendsto mb f (nhds b) ‚Üí Filter.Tendsto (fun c => (ma c, mb c)) f (nhds (a, b))",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_self",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "left_neg_eq_right_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] {a b : G}, a + b = 0 ‚Üí -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Abs.abs",
   "True",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "CauSeq.Completion.instInvCauchyToRing",
   "Eq.trans",
   "GroupWithZero.toInv",
   "CauSeq.Completion.Cauchy.field",
   "eq_self",
   "Neg.toHasAbs",
   "DivisionSemiring.toGroupWithZero",
   "Rat",
   "Field.toSemifield",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "Rat.field",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "CauSeq.Completion.instZeroCauchy",
   "Real.instZeroReal",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal.proof_11",
  "constType": "0‚Åª¬π = 0",
  "constCategory": "Theorem"},
 {"references":
  ["SecondCountableTopology",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "secondCountable_of_proper",
   "Real.pseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "instProperSpaceRealPseudoMetricSpace"],
  "name":
  "instSecondCountableTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpace",
  "constType": "SecondCountableTopology ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.GenerateMeasurable.compl",
   "MeasurableSpace.GenerateMeasurable.iUnion",
   "MeasurableSpace.GenerateMeasurable",
   "Set",
   "MeasurableSpace.mk",
   "MeasurableSpace",
   "MeasurableSpace.GenerateMeasurable.empty"],
  "name": "MeasurableSpace.generateFrom",
  "constType": "{Œ± : Type u_1} ‚Üí Set (Set Œ±) ‚Üí MeasurableSpace Œ±",
  "constCategory": "Definition"},
 {"references": ["Rat", "RatCast.ratCast", "RatCast"],
  "name": "Rat.cast",
  "constType": "{K : Type u} ‚Üí [inst : RatCast K] ‚Üí ‚Ñö ‚Üí K",
  "constCategory": "Definition"},
 {"references":
  ["instLinearOrder.proof_3",
   "instLinearOrder.proof_1",
   "LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Max.mk",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLinearOrder.decidableLE",
   "instLinearOrder.proof_2",
   "Min.mk",
   "ConditionallyCompleteLinearOrder.le_total",
   "Lattice.toInf",
   "ConditionallyCompleteLinearOrder.decidableEq",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "LinearOrder.mk",
   "Sup.sup",
   "ConditionallyCompleteLinearOrder",
   "Lattice.toSemilatticeSup",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "ConditionallyCompleteLinearOrder.decidableLT"],
  "name": "instLinearOrder",
  "constType":
  "(Œ± : Type u_5) ‚Üí [inst : ConditionallyCompleteLinearOrder Œ±] ‚Üí LinearOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NormedDivisionRing.toNormedRing",
   "Real.instMulReal",
   "Real",
   "NormedDivisionRing.toNorm",
   "HMul.hMul",
   "Norm.norm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NormedDivisionRing.norm_mul'",
   "NormedDivisionRing",
   "NormedRing.toRing",
   "Ring.toNonAssocRing",
   "Eq"],
  "name": "norm_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±] (a b : Œ±), ‚Äña * b‚Äñ = ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.add", "Real", "Add", "Add.mk"],
  "name": "Real.instAddReal",
  "constType": "Add ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{Œ± : Type u_9} ‚Üí [self : CompleteSemilatticeInf Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.Frequently.and_eventually",
   "Exists",
   "And",
   "frequently_gt_nhds",
   "Filter.Frequently.exists",
   "Preorder.toLT",
   "nhds",
   "LT.lt",
   "TopologicalSpace",
   "Filter.Eventually",
   "nhdsWithin",
   "Preorder",
   "Set.Ioi",
   "Filter.NeBot",
   "GT.gt"],
  "name": "Filter.Eventually.exists_gt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] {a : Œ±}\n  [inst_2 : Filter.NeBot (nhdsWithin a (Set.Ioi a))] {p : Œ± ‚Üí Prop}, (‚àÄ·∂† (x : Œ±) in nhds a, p x) ‚Üí ‚àÉ b > a, p b",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{Œ± : Type u} ‚Üí [self : Mul Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u ‚Üí Type v ‚Üí outParam (Type w) ‚Üí Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NormedAddCommGroup.dist_eq",
   "AddCommGroup.toAddGroup",
   "NormedAddGroup",
   "NormedAddCommGroup.toNorm",
   "NormedAddGroup.mk"],
  "name": "NormedAddCommGroup.toNormedAddGroup",
  "constType":
  "{E : Type u_6} ‚Üí [inst : NormedAddCommGroup E] ‚Üí NormedAddGroup E",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "implies_congr",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Preorder.toLE",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.mpr",
   "Iff",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "id",
   "Neg.toHasAbs",
   "CauSeq.le_antisymm",
   "Real.instLTReal",
   "Mathlib.Data.Real.Basic._auxLemma.7",
   "Real.mk_le",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq",
   "LE.le",
   "Preorder.mk",
   "CauSeq.equiv",
   "And",
   "Eq.ndrec",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "propext",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "LT.lt",
   "Real.mk",
   "le_refl",
   "congr",
   "Not",
   "HasEquiv.Equiv",
   "congrArg",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.partialOrder.proof_4",
  "constType": "‚àÄ (a b : ‚Ñù), a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "mul_neg",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "abs_of_nonneg",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "HasDistribNeg.toInvolutiveNeg",
   "abs_eq",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "DistribLattice.toLattice",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "propext",
   "StrictOrderedSemiring.toOrderedSemiring",
   "congr",
   "LinearOrder.toPartialOrder",
   "MonoidWithZero.toZero",
   "congrArg",
   "OrderedSemiring.toPosMulMono",
   "OrderedAddCommGroup.toAddCommGroup",
   "mul_nonneg",
   "StrictOrderedRing.toRing",
   "abs_nonneg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedRing.toStrictOrderedRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Mathlib.Algebra.Order.Ring.Abs._auxLemma.1",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "True",
   "le_total",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedRing",
   "InvolutiveNeg.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Mathlib.Algebra.Order.Ring.Abs._auxLemma.2",
   "Lattice.toSemilatticeSup",
   "neg_mul",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Or.inr",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "abs_of_nonpos",
   "Eq.ndrec",
   "Or.inl",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "NegZeroClass.toNeg"],
  "name": "abs_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a b : Œ±), |a * b| = |a| * |b|",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí (Œ± ‚Üí Œ≤ ‚Üí Œ≥) ‚Üí HSub Œ± Œ≤ Œ≥",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.zero_mul",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a : Œ±), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.28",
  "constType": "‚àÄ {Œ± : Type u_1} {a b : Œ±}, (b ‚àà {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "IsROrC.re",
   "RingHom.instRingHomClass",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Module.toDistribMulAction",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "instHSMul",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "NormedAddCommGroup.toNorm",
   "Nat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AddCommMagma.toAdd",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "MulAction.toSMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "CommRing.toRing",
   "Norm.norm",
   "NormedSpace.toModule",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "NormedAddCommGroup.toAddCommGroup",
   "RingHom",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "IsROrC.toStarRing",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NormedSpace",
   "NormedField.toField",
   "Field.toCommRing",
   "Inner",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedAddCommGroup.toAddCommGroup",
   "starRingEnd",
   "instHPow",
   "Monoid.toNatPow",
   "Inner.inner",
   "instOfNatNat",
   "AddCommMonoid.toAddCommSemigroup",
   "DistribMulAction.toMulAction",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "Real.instMonoidReal",
   "AddHomClass.toFunLike",
   "instHAdd",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "InnerProductSpace",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom"],
  "name": "InnerProductSpace.mk",
  "constType":
  "{ùïú : Type u_4} ‚Üí\n  {E : Type u_5} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [toNormedSpace : NormedSpace ùïú E] ‚Üí\n          [toInner : Inner ùïú E] ‚Üí\n            (‚àÄ (x : E), ‚Äñx‚Äñ ^ 2 = IsROrC.re (inner x x)) ‚Üí\n              (‚àÄ (x y : E), (starRingEnd ùïú) (inner y x) = inner x y) ‚Üí\n                (‚àÄ (x y z : E), inner (x + y) z = inner x z + inner y z) ‚Üí\n                  (‚àÄ (x y : E) (r : ùïú), inner (r ‚Ä¢ x) y = (starRingEnd ùïú) r * inner x y) ‚Üí InnerProductSpace ùïú E",
  "constCategory": "Other"},
 {"references": ["setOf", "Set", "Eq"],
  "name": "Set.singleton",
  "constType": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "ConditionallyCompleteLattice",
   "LE.le",
   "BddAbove",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "upperBounds",
   "BddBelow",
   "lowerBounds",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "ConditionallyCompleteLattice.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toLattice : Lattice Œ±] ‚Üí\n    [toSupSet : SupSet Œ±] ‚Üí\n      [toInfSet : InfSet Œ±] ‚Üí\n        (‚àÄ (s : Set Œ±) (a : Œ±), BddAbove s ‚Üí a ‚àà s ‚Üí a ‚â§ sSup s) ‚Üí\n          (‚àÄ (s : Set Œ±) (a : Œ±), Set.Nonempty s ‚Üí a ‚àà upperBounds s ‚Üí sSup s ‚â§ a) ‚Üí\n            (‚àÄ (s : Set Œ±) (a : Œ±), BddBelow s ‚Üí a ‚àà s ‚Üí sInf s ‚â§ a) ‚Üí\n              (‚àÄ (s : Set Œ±) (a : Œ±), Set.Nonempty s ‚Üí a ‚àà lowerBounds s ‚Üí a ‚â§ sInf s) ‚Üí ConditionallyCompleteLattice Œ±",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "instHSMul",
   "Submodule",
   "Semiring",
   "Submodule.toAddSubmonoid",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "SetLike.coe_injective'",
   "Module.toMulActionWithZero",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "SMulZeroClass.toSMul",
   "Eq",
   "Set.instMembershipSet",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Eq.ndrec",
   "Eq.rec",
   "AddMonoid.toZero",
   "Submodule.casesOn",
   "Submodule.mk",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "Eq.symm",
   "AddSubsemigroup.carrier",
   "AddCommMonoid"],
  "name": "Submodule.setLike.proof_1",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p q : Submodule R M), (fun s => s.carrier) p = (fun s => s.carrier) q ‚Üí p = q",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "EmptyCollection.emptyCollection",
   "Set",
   "Eq.mp",
   "Eq.refl",
   "HasCompl.compl",
   "Set.compl_univ",
   "Set.instEmptyCollectionSet",
   "BooleanAlgebra.toHasCompl",
   "Eq.symm",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Bornology.ofBounded.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} (B : Set (Set Œ±)), ‚àÖ ‚àà B ‚Üí Set.univ·∂ú ‚àà B",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "Real.normedField",
   "Real",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "MeasureTheory.wrapped._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
   "NormedSpace",
   "MeasurableSpace"],
  "name": "MeasureTheory.integral",
  "constType":
  "{Œ± : Type u_6} ‚Üí\n  {G : Type u_7} ‚Üí\n    [inst : NormedAddCommGroup G] ‚Üí\n      [inst : NormedSpace ‚Ñù G] ‚Üí {x : MeasurableSpace Œ±} ‚Üí MeasureTheory.Measure Œ± ‚Üí (Œ± ‚Üí G) ‚Üí G",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "‚àÄ {Œ± : Type u} [self : Lattice Œ±] (a b c : Œ±), a ‚â§ b ‚Üí a ‚â§ c ‚Üí a ‚â§ b ‚äì c",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "RatCast.mk",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "RatCast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ratCast",
  "constType": "RatCast ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mul_neg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [self : HasDistribNeg Œ±] (x y : Œ±), x * -y = -(x * y)",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "MonoidHomClass",
   "outParam",
   "MulOneClass.toMul",
   "MulOneClass"],
  "name": "MonoidHomClass.toMulHomClass",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí\n      [inst : MulOneClass M] ‚Üí [inst_1 : MulOneClass N] ‚Üí [self : MonoidHomClass F M N] ‚Üí MulHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero.proof_3",
   "LinearOrderedCommSemiring.toMin",
   "Nat.linearOrderedCommMonoidWithZero.proof_1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.max_def",
   "Preorder.toLE",
   "inferInstance",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.min_def",
   "Nat.mul_le_mul_left",
   "AddMonoid.toZero",
   "LinearOrder.mk",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "LinearOrderedCommSemiring.toMax",
   "CommMonoidWithZero.toCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "Nat.linearOrderedCommMonoidWithZero.proof_2",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "CommMonoidWithZero",
   "LinearOrderedCommSemiring.decidableEq",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat.commSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "LinearOrder.toPartialOrder",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Exists",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "TopologicalSpace.MetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.exists_metric",
  "constType":
  "‚àÄ {X : Type u_5} [t : TopologicalSpace X] [self : TopologicalSpace.MetrizableSpace X],\n  ‚àÉ m, UniformSpace.toTopologicalSpace = t",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "AddHom.toFun",
   "LinearMap.map_smul'",
   "Semiring",
   "FunLike.mk",
   "LinearMap.semilinearMapClass.proof_2",
   "AddCommMagma.toAdd",
   "SemilinearMapClass.mk",
   "AddHomClass.mk",
   "LinearMap.semilinearMapClass.proof_1",
   "Semiring.toNonAssocSemiring",
   "SemilinearMapClass",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "LinearMap.semilinearMapClass",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_9} ‚Üí\n      {M‚ÇÉ : Type u_12} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÉ] ‚Üí\n                [inst_4 : Module R M] ‚Üí [inst_5 : Module S M‚ÇÉ] ‚Üí {œÉ : R ‚Üí+* S} ‚Üí SemilinearMapClass (M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ) œÉ M M‚ÇÉ",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "‚àÄ {a b c : Prop}, a ‚à® b ‚Üí (a ‚Üí c) ‚Üí (b ‚Üí c) ‚Üí c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
   "Semiring.mk",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.npow",
   "OrderedSemiring.mk",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
   "CanonicallyOrderedCommSemiring.toOne",
   "OrderedCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "OrderedCommSemiring.mk",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{Œ± : Type u} ‚Üí [inst : CanonicallyOrderedCommSemiring Œ±] ‚Üí OrderedCommSemiring Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí LT Œ±",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String ‚Üí Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "Eq",
   "instHMul",
   "One",
   "HMul.hMul",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "Nat",
   "Semigroup"],
  "name": "Monoid.mk",
  "constType":
  "{M : Type u} ‚Üí\n  [toSemigroup : Semigroup M] ‚Üí\n    [toOne : One M] ‚Üí\n      (‚àÄ (a : M), 1 * a = a) ‚Üí\n        (‚àÄ (a : M), a * 1 = a) ‚Üí\n          (npow : ‚Ñï ‚Üí M ‚Üí M) ‚Üí\n            autoParam (‚àÄ (x : M), npow 0 x = 1) _auto‚úù ‚Üí\n              autoParam (‚àÄ (n : ‚Ñï) (x : M), npow (n + 1) x = x * npow n x) _auto‚úù¬π ‚Üí Monoid M",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Filter.EventuallyEq",
   "MeasureTheory.StronglyMeasurable",
   "Filter.EventuallyEq.refl",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace",
   "MeasureTheory.AEStronglyMeasurable"],
  "name": "MeasureTheory.StronglyMeasurable.aestronglyMeasurable",
  "constType":
  "‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_6} {x : MeasurableSpace Œ±} [inst : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}\n  {Œº : MeasureTheory.Measure Œ±}, MeasureTheory.StronglyMeasurable f ‚Üí MeasureTheory.AEStronglyMeasurable f Œº",
  "constCategory": "Theorem"},
 {"references": ["Set", "Add", "AddSubsemigroup"],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_4} ‚Üí [inst : Add M] ‚Üí AddSubsemigroup M ‚Üí Set M",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.OuterMeasure.coeFnAddMonoidHom",
   "MeasureTheory.OuterMeasure.coe_fn_injective",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "MeasureTheory.OuterMeasure.instModule.proof_1",
   "Function.Injective.module",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "instENNRealZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "SMulZeroClass.toSMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "Pi.addCommMonoid",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "Algebra.id",
   "Module",
   "MonoidWithZero.toZero",
   "Pi.module",
   "MeasureTheory.OuterMeasure",
   "Algebra.toSMul"],
  "name": "MeasureTheory.OuterMeasure.instModule",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  {R : Type u_3} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Module R ENNReal] ‚Üí [inst_2 : IsScalarTower R ENNReal ENNReal] ‚Üí Module R (MeasureTheory.OuterMeasure Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_6",
  "constType": "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a b : Œ±), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instLinearOrderedRingReal",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedCommRing.toOrderedCommRing",
   "CanonicallyOrderedCommSemiring",
   "LinearOrderedRing.noZeroDivisors",
   "NNReal",
   "Nonneg.canonicallyOrderedCommSemiring"],
  "name": "instNNRealCanonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring NNReal",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Inhabited", "Nat", "Inhabited.mk"],
  "name": "instInhabitedNat",
  "constType": "Inhabited ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["Real.instConditionallyCompleteLinearOrderReal.proof_3",
   "LinearOrder.decidableLE",
   "Real.instConditionallyCompleteLinearOrderReal.proof_1",
   "LinearOrder",
   "Real.lattice",
   "Real",
   "LinearOrder.le_total",
   "InfSet.sInf",
   "SupSet.mk",
   "Lattice.mk",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Real.instSupSetReal",
   "Real.instConditionallyCompleteLinearOrderReal.proof_2",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "ConditionallyCompleteLattice.mk",
   "Lattice.toInf",
   "InfSet.mk",
   "Real.linearOrder",
   "Real.instConditionallyCompleteLinearOrderReal.proof_6",
   "Real.instConditionallyCompleteLinearOrderReal.proof_5",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "Lattice",
   "ConditionallyCompleteLinearOrder",
   "Lattice.toSemilatticeSup",
   "Real.instConditionallyCompleteLinearOrderReal.proof_4",
   "Real.instInfSetReal",
   "ConditionallyCompleteLinearOrder.mk"],
  "name": "Real.instConditionallyCompleteLinearOrderReal",
  "constType": "ConditionallyCompleteLinearOrder ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{Œ± : Sort u‚ÇÅ} ‚Üí {Œ≤ : Sort u‚ÇÇ} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} ‚Üí False ‚Üí C",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{Œ± : Type u} ‚Üí [self : Add Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "‚àÄ {M : Type u_1} {N : Type u_2} {Œº : M ‚Üí N ‚Üí N} {r : N ‚Üí N ‚Üí Prop} [self : CovariantClass M N Œº r], Covariant M N Œº r",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "Asymptotics.IsLittleO",
   "RingHom.id",
   "NormedField.toField",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toNorm",
   "UniformSpace.toTopologicalSpace",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "instHSub",
   "NontriviallyNormedField",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "HSub.hSub",
   "Field.toSemifield",
   "Prod.fst",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "AddGroup.toSubNegMonoid",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "Prod.mk",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Prod",
   "NormedAddCommGroup.toNormedAddGroup",
   "NormedSpace.toModule",
   "ContinuousMapClass.toFunLike"],
  "name": "HasStrictFDerivAt",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup F] ‚Üí [inst_4 : NormedSpace ùïú F] ‚Üí (E ‚Üí F) ‚Üí (E ‚ÜíL[ùïú] F) ‚Üí E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} ‚Üí [self : AddCommMagma G] ‚Üí Add G",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Norm",
   "Real",
   "Real.instSupReal",
   "Norm.mk",
   "Abs.abs",
   "Real.instNegReal"],
  "name": "Real.norm",
  "constType": "Norm ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["MulOneClass"],
  "name": "MonoidHom",
  "constType":
  "(M : Type u_9) ‚Üí (N : Type u_10) ‚Üí [inst : MulOneClass M] ‚Üí [inst : MulOneClass N] ‚Üí Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toNeg",
   "add_left_neg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "Eq"],
  "name": "AddGroup.toSubtractionMonoid.proof_1",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Norm",
   "Real",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.579",
   "Filter"],
  "name": "Asymptotics.IsBigOWith",
  "constType":
  "{Œ± : Type u_17} ‚Üí\n  {E : Type u_18} ‚Üí {F : Type u_19} ‚Üí [inst : Norm E] ‚Üí [inst : Norm F] ‚Üí ‚Ñù ‚Üí Filter Œ± ‚Üí (Œ± ‚Üí E) ‚Üí (Œ± ‚Üí F) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "IsScalarTower.mk",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalRingHomClass.toMulHomClass",
   "MulZeroClass.toMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "mul_assoc",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "CommSemiring",
   "HSMul.hSMul",
   "Algebra",
   "smul_eq_mul",
   "Algebra.toSMul",
   "id",
   "Mul.toSMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semiring",
   "algebraMap",
   "Algebra.smul_def",
   "MulZeroClass.toSMulWithZero",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "IsScalarTower",
   "SMulZeroClass.toSMul",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "MonoidWithZero.toZero"],
  "name": "IsScalarTower.right",
  "constType":
  "‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A], IsScalarTower R A A",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero",
   "MulAction",
   "MonoidWithZero"],
  "name": "MulActionWithZero.toMulAction",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_3} ‚Üí [inst : MonoidWithZero R] ‚Üí [inst_1 : Zero M] ‚Üí [self : MulActionWithZero R M] ‚Üí MulAction R M",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{Œ± : Type u_9} ‚Üí [self : CompleteLattice Œ±] ‚Üí SupSet Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedSemiring.toMax",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedSemifield",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedField.toLinearOrderedSemifield.proof_1",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "LinearOrderedField.inv_zero",
   "LinearOrderedField.toDiv",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedSemifield.mk",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedField.zpow_neg'",
   "LinearOrderedField.zpow",
   "LinearOrderedField.toInv",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedField.toLinearOrderedSemifield",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : LinearOrderedField Œ±] ‚Üí LinearOrderedSemifield Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "EmptyCollection.emptyCollection",
   "Real.natCast",
   "em",
   "Metric.closedBall",
   "Set",
   "Real",
   "Exists.intro",
   "Nonempty",
   "Iff.mpr",
   "Nonempty.casesOn",
   "Eq",
   "Set.iUnion",
   "Nat.cast",
   "Nat",
   "UniformSpace.toTopologicalSpace",
   "Metric.iUnion_closedBall_nat",
   "SigmaCompactSpace.mk",
   "PseudoMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace",
   "Membership.mem",
   "Or",
   "isCompact_empty",
   "PseudoMetricSpace.toUniformSpace",
   "ProperSpace.isCompact_closedBall",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "Nonempty.intro",
   "And",
   "SecondCountableTopology",
   "False.elim",
   "SigmaCompactSpace",
   "Not",
   "EMetric.secondCountable_of_sigmaCompact",
   "And.intro",
   "ProperSpace",
   "IsCompact"],
  "name": "secondCountable_of_proper",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±], SecondCountableTopology Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{Œ± : Sort u} ‚Üí [i : Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "NormedLatticeAddCommGroup",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "HasSolidNorm",
   "AddCommGroup.toAddGroup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "NormedLatticeAddCommGroup.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [toNormedAddCommGroup : NormedAddCommGroup Œ±] ‚Üí\n    [toLattice : Lattice Œ±] ‚Üí\n      [toHasSolidNorm : HasSolidNorm Œ±] ‚Üí (‚àÄ (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b) ‚Üí NormedLatticeAddCommGroup Œ±",
  "constCategory": "Other"},
 {"references": ["Field", "Nontrivial"],
  "name": "Field.toNontrivial",
  "constType": "‚àÄ {K : Type u} [self : Field K], Nontrivial K",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "RightDistribClass",
   "RightDistribClass.mk",
   "Distrib",
   "Distrib.right_distrib",
   "Distrib.toMul"],
  "name": "Distrib.rightDistribClass",
  "constType": "‚àÄ (R : Type u_1) [inst : Distrib R], RightDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalNonAssocCommRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalCommRing Œ±] ‚Üí NonUnitalNonAssocCommRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Subtype.val",
   "Real.instLEReal",
   "Real",
   "NNReal",
   "LE.le"],
  "name": "NNReal.toReal",
  "constType": "NNReal ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Set.insert", "Set", "Insert", "Insert.mk"],
  "name": "Set.instInsertSet",
  "constType": "{Œ± : Type u_1} ‚Üí Insert Œ± (Set Œ±)",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u ‚Üí Type v ‚Üí outParam (Type w) ‚Üí Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.add_le_add_left",
  "constType":
  "‚àÄ {Œ± : Type u} [self : OrderedAddCommGroup Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c + a ‚â§ c + b",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} ‚Üí {N : Type u_4} ‚Üí [inst : AddZeroClass M] ‚Üí [inst_1 : AddZeroClass N] ‚Üí AddMonoidHomClass (M ‚Üí+ N) M N",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Basic._auxLemma.62",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.63",
   "Set.instInsertSet"],
  "name": "Finset.coe_insert",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±) (s : Finset Œ±), ‚Üë(insert a s) = insert a ‚Üës",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "Eq"],
  "name": "Nat.Coprime",
  "constType": "‚Ñï ‚Üí ‚Ñï ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DenselyNormedField",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Real.instCommSemiringReal",
   "Semiring",
   "Real"],
  "name": "Real.semiring",
  "constType": "Semiring ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Distrib.toAdd",
   "Exists",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "AddCommSemigroup.toAddCommMagma",
   "add_halves",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "add_lt_add",
   "HAdd.hAdd",
   "Real",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "IsCancelAdd.toIsRightCancelAdd",
   "LinearOrderedField.toDiv",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "Eq.rec",
   "AddMonoid.toZero",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "AddCommMonoid.toAddCommSemigroup",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "OrderedAddCommMonoid.toPartialOrder",
   "instHDiv",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Real.partialOrder",
   "instHAdd",
   "AddCommMagma.toAdd",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "GT.gt",
   "And",
   "LinearOrderedSemifield.toDiv",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "instNatAtLeastTwo",
   "And.intro",
   "half_pos",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofDist.proof_1",
  "constType": "‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x < Œ¥, ‚àÄ y < Œ¥, x + y < Œµ",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "ENNReal.coe_lt_top",
   "Top.top",
   "Preorder.toLT",
   "LT.lt",
   "Real",
   "CompleteLattice.toTop",
   "ENNReal.ofReal",
   "Real.toNNReal",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "ENNReal.ofReal_lt_top",
  "constType": "‚àÄ {r : ‚Ñù}, ENNReal.ofReal r < ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "AddHomClass.map_add",
   "Eq"],
  "name": "map_add",
  "constType":
  "‚àÄ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Add M] [inst_1 : Add N] [inst_2 : AddHomClass F M N] (f : F)\n  (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} ‚Üí [self : AddCancelMonoid M] ‚Üí AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Add Œ±] ‚Üí HAdd Œ± Œ± Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocRing",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "NontriviallyNormedField",
  "constType": "Type u_5 ‚Üí Type u_5",
  "constCategory": "Other"},
 {"references": ["SMul"],
  "name": "SMul.mk",
  "constType": "{M : Type u} ‚Üí {Œ± : Type v} ‚Üí (M ‚Üí Œ± ‚Üí Œ±) ‚Üí SMul M Œ±",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí (Œ± ‚Üí Œ≤ ‚Üí Œ≥) ‚Üí HMul Œ± Œ≤ Œ≥",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mul_zero",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a : Œ±), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing.toNonUnitalNormedRing",
   "DifferentiableAt.hasFDerivAt",
   "fderiv",
   "DifferentiableAt",
   "NormedAddCommGroup",
   "NontriviallyNormedField",
   "NontriviallyNormedField.toNormedField",
   "NormedField.toNormedSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedCommRing.toNormedRing",
   "deriv",
   "HasFDerivAt.hasDerivAt",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "HasDerivAt",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "DifferentiableAt.hasDerivAt",
  "constType":
  "‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace ùïú F] {f : ùïú ‚Üí F} {x : ùïú}, DifferentiableAt ùïú f x ‚Üí HasDerivAt f (deriv f x) x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MonoidWithZero.toZero",
   "MulActionWithZero.toMulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.zero_smul",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (m : M),\n  0 ‚Ä¢ m = 0",
  "constCategory": "Definition"},
 {"references": ["Norm", "SeminormedAddCommGroup"],
  "name": "SeminormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} ‚Üí [self : SeminormedAddCommGroup E] ‚Üí Norm E",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "Set.Nonempty", "Preorder"],
  "name": "BddBelow",
  "constType": "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : Œ±), p a) = ‚àÄ (a : Œ±), q a",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.toNat.proof_2",
   "OfNat.ofNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "Classical.choose",
   "ZeroHom.mk",
   "ZeroHom",
   "dite",
   "Cardinal.partialOrder",
   "Cardinal.toNat.proof_1",
   "Cardinal.linearOrder",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Cardinal.instNatCastCardinal",
   "Cardinal.aleph0",
   "Nat.cast",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "instOfNatNat",
   "Not",
   "Nat"],
  "name": "Cardinal.toNat",
  "constType": "ZeroHom Cardinal.{v} ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl"],
  "name": "Or.intro_left",
  "constType": "‚àÄ {a : Prop} (b : Prop), a ‚Üí a ‚à® b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ring.toNonAssocRing.proof_5",
   "NonAssocRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing.proof_2",
   "Ring.intCast_ofNat",
   "Ring.toNonAssocRing.proof_3",
   "Semiring.toNatCast",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.toSub",
   "Ring",
   "Ring.add_left_neg",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing.proof_7",
   "AddGroup.mk",
   "Ring.intCast_negSucc",
   "Ring.toNonAssocRing.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toNonAssocRing.proof_4",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNonAssocRing.proof_6",
   "Ring.zsmul_succ'",
   "NonAssocRing.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing.proof_1",
   "Ring.toNonAssocRing.proof_9"],
  "name": "Ring.toNonAssocRing",
  "constType": "{Œ± : Type u} ‚Üí [inst : Ring Œ±] ‚Üí NonAssocRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "SemilatticeSup.toSup",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Sup.sup",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_12",
  "constType":
  "‚àÄ {Œ± : Type u_1} (a : Set Œ±) (s : Set (Set Œ±)), ‚®Ö b ‚àà s, a ‚äî b ‚â§ a ‚äî sInf s",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} ‚Üí [self : AddCommMonoid M] ‚Üí AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.semilinearMapClass",
   "SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "LinearMap.instFunLike.proof_1",
   "AddHomClass.toFunLike",
   "Semiring",
   "FunLike.mk",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "LinearMap.instFunLike",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_9} ‚Üí\n      {M‚ÇÉ : Type u_12} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÉ] ‚Üí\n                [inst_4 : Module R M] ‚Üí [inst_5 : Module S M‚ÇÉ] ‚Üí {œÉ : R ‚Üí+* S} ‚Üí FunLike (M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ) M fun x => M‚ÇÉ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_2",
  "constType": "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a : Œ±), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Or", "Not", "Classical.em"],
  "name": "em",
  "constType": "‚àÄ (p : Prop), p ‚à® ¬¨p",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "NormedAddCommGroup.toAddCommGroup",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "PartialOrder.toPreorder",
   "instHAdd",
   "Real.lattice",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Real",
   "add_le_add",
   "le_rfl",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "Real.orderedAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Real.instPreorderReal",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SemilatticeSup.toPartialOrder",
   "Real.normedAddCommGroup"],
  "name": "Real.normedLatticeAddCommGroup.proof_1",
  "constType": "‚àÄ (x x_1 : ‚Ñù), x ‚â§ x_1 ‚Üí ‚àÄ (x_2 : ‚Ñù), x_2 + x ‚â§ x_2 + x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "Real.instLinearOrderedFieldReal.proof_12",
   "zpowRec",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrder.decidableLE",
   "Monoid.mk",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_5",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Real.linearOrder",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.instInvReal",
   "Real.strictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_11",
   "Real.instLinearOrderedFieldReal.proof_2",
   "Semigroup.mk",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "Real.instLinearOrderedFieldReal.proof_13",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.ratCast",
   "Real.instLinearOrderedFieldReal.proof_7",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "DivInvMonoid.div'",
   "Ring.toSemiring",
   "Real.instLinearOrderedFieldReal.proof_4",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.instLinearOrderedFieldReal.proof_10",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "Real.linearOrderedCommRing",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "Real.instLinearOrderedFieldReal.proof_3",
   "LinearOrderedCommRing",
   "Real.instLinearOrderedFieldReal.proof_6",
   "LinearOrderedCommRing.mul_comm",
   "Real.instLinearOrderedFieldReal.proof_9",
   "Real.instLinearOrderedFieldReal.proof_1",
   "LinearOrderedRing.mk",
   "Real.instLinearOrderedFieldReal.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal",
  "constType": "LinearOrderedField ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["And", "setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Icc",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí LE Œ±",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instLEReal",
   "Real.instSubReal",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instHSub",
   "Neg.toHasAbs",
   "eq_self",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_2",
  "constType": "‚àÄ (x y : ‚Ñù), 0 ‚â§ |x - y|",
  "constCategory": "Theorem"},
 {"references":
  ["SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "AddHomClass.toFunLike",
   "SemilinearMapClass",
   "Semiring",
   "Continuous",
   "TopologicalSpace",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.mk",
  "constType":
  "{F : Type u_1} ‚Üí\n  {R : outParam (Type u_2)} ‚Üí\n    {S : outParam (Type u_3)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          {œÉ : outParam (R ‚Üí+* S)} ‚Üí\n            {M : outParam (Type u_4)} ‚Üí\n              [inst_2 : TopologicalSpace M] ‚Üí\n                [inst_3 : AddCommMonoid M] ‚Üí\n                  {M‚ÇÇ : outParam (Type u_5)} ‚Üí\n                    [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst_6 : Module R M] ‚Üí\n                          [inst_7 : Module S M‚ÇÇ] ‚Üí\n                            [toSemilinearMapClass : SemilinearMapClass F œÉ M M‚ÇÇ] ‚Üí\n                              (‚àÄ (f : F), Continuous ‚áëf) ‚Üí ContinuousSemilinearMapClass F œÉ M M‚ÇÇ",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "NatCast.natCast",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.natCast_zero",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "List", "Multiset", "List.isSetoid", "Quot.mk"],
  "name": "Multiset.ofList",
  "constType": "{Œ± : Type u_1} ‚Üí List Œ± ‚Üí Multiset Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.one_mul",
  "constType": "‚àÄ {Œ± : Type u} [self : NonAssocSemiring Œ±] (a : Œ±), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.mk",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí (Œ± ‚Üí Œ≤ ‚Üí Œ≥) ‚Üí HDiv Œ± Œ≤ Œ≥",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "CompleteLattice.sInf_le",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_9",
  "constType": "‚àÄ {Œ± : Type u_1} (s : Set (Filter Œ±)·µí·µà·µí·µà), ‚àÄ a ‚àà s, sInf s ‚â§ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.equiv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Quotient",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : LinearOrderedField Œ±] ‚Üí\n    {Œ≤ : Type u_2} ‚Üí [inst_1 : Ring Œ≤] ‚Üí (abv : Œ≤ ‚Üí Œ±) ‚Üí [inst : IsAbsoluteValue abv] ‚Üí Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "‚àÄ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        (R ‚Üí+* S) ‚Üí\n          (M : Type u_3) ‚Üí\n            [inst_2 : TopologicalSpace M] ‚Üí\n              [inst_3 : AddCommMonoid M] ‚Üí\n                (M‚ÇÇ : Type u_4) ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí [inst : Module R M] ‚Üí [inst : Module S M‚ÇÇ] ‚Üí Type (max u_3 u_4)",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Max.max",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.max_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a b : Œ±), max a b = if a ‚â§ b then b else a",
  "constCategory": "Definition"},
 {"references": ["upperBounds", "Set", "Set.Nonempty", "Preorder"],
  "name": "BddAbove",
  "constType": "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "GE.ge",
   "Eq.refl",
   "IsOpen.inter",
   "Inter.inter",
   "Exists.intro",
   "isOpen_univ",
   "Eq",
   "Filter.principal",
   "Filter.HasBasis",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Filter",
   "Set.inter_subset_right",
   "IsOpen",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "nhds",
   "nhds_basis_opens.match_1",
   "Set.univ",
   "Set.instLESet",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "nhds_def",
   "Order.Preimage",
   "And",
   "Eq.ndrec",
   "iInf",
   "Filter.hasBasis_biInf_principal",
   "And.intro",
   "Set.inter_subset_left",
   "Set.mem_univ",
   "Set.instInterSet"],
  "name": "nhds_basis_opens",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (a : Œ±), Filter.HasBasis (nhds a) (fun s => a ‚àà s ‚àß IsOpen s) fun s => s",
  "constCategory": "Theorem"},
 {"references": ["One"],
  "name": "OneHom",
  "constType":
  "(M : Type u_9) ‚Üí (N : Type u_10) ‚Üí [inst : One M] ‚Üí [inst : One N] ‚Üí Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} ‚Üí [self : AddCommMonoidWithOne R] ‚Üí AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_1",
  "constType": "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a b : Œ±), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "‚àÄ {Œ± : Type u} [inst : OrderedSemiring Œ±], ZeroLEOneClass Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionSemiring.mul_inv_cancel",
   "DivisionSemiring",
   "Semiring.mul_one",
   "DivisionSemiring.inv_zero",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "DivisionSemiring.div_eq_mul_inv",
   "DivisionSemiring.zpow_succ'",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.zpow_zero'",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "GroupWithZero",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_neg'",
   "DivisionSemiring.zpow",
   "DivisionSemiring.toInv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.mk",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{Œ± : Type u_4} ‚Üí [self : DivisionSemiring Œ±] ‚Üí GroupWithZero Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "‚àÄ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "outParam",
   "MonoidHomClass"],
  "name": "RingHomClass.mk",
  "constType":
  "{F : Type u_5} ‚Üí\n  {Œ± : outParam (Type u_6)} ‚Üí\n    {Œ≤ : outParam (Type u_7)} ‚Üí\n      [inst : NonAssocSemiring Œ±] ‚Üí\n        [inst_1 : NonAssocSemiring Œ≤] ‚Üí\n          [toMonoidHomClass : MonoidHomClass F Œ± Œ≤] ‚Üí\n            (‚àÄ (f : F) (x y : Œ±), f (x + y) = f x + f y) ‚Üí (‚àÄ (f : F), f 0 = 0) ‚Üí RingHomClass F Œ± Œ≤",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NormedField",
   "Eq.le",
   "Real",
   "Real.instMulReal",
   "NormedDivisionRing.toNorm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "norm_mul",
   "instHMul",
   "NormedDivisionRing.toNormedRing",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Norm.norm",
   "NormedField.toNormedDivisionRing",
   "NormedRing.toRing"],
  "name": "NormedField.toNormedCommRing.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NormedField Œ±] (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Semigroup", "Eq"],
  "name": "Semigroup.mk",
  "constType":
  "{G : Type u} ‚Üí [toMul : Mul G] ‚Üí (‚àÄ (a b c : G), a * b * c = a * (b * c)) ‚Üí Semigroup G",
  "constCategory": "Other"},
 {"references": ["SMul", "Semiring", "CommSemiring", "Algebra"],
  "name": "Algebra.toSMul",
  "constType":
  "{R : Type u} ‚Üí {A : Type v} ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : Semiring A] ‚Üí [self : Algebra R A] ‚Üí SMul R A",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "NormedField"],
  "name": "NormedAlgebra",
  "constType":
  "(ùïú : Type u_5) ‚Üí (ùïú' : Type u_6) ‚Üí [inst : NormedField ùïú] ‚Üí [inst : SeminormedRing ùïú'] ‚Üí Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "setOf",
   "Real.instLTReal",
   "Set",
   "LT.lt",
   "Real",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "Metric.ball",
  "constType": "{Œ± : Type u} ‚Üí [inst : PseudoMetricSpace Œ±] ‚Üí Œ± ‚Üí ‚Ñù ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{Œ± : Sort u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.Algebra.Module.Basic._hyg.2648",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "CanonicallyLinearOrderedSemifield.toCanonicallyLinearOrderedAddCommMonoid",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "WithTop",
   "inferInstanceAs",
   "CanonicallyLinearOrderedAddCommMonoid",
   "WithTop.instCanonicallyLinearOrderedAddCommMonoidWithTop",
   "NNReal"],
  "name": "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
  "constType": "CanonicallyLinearOrderedAddCommMonoid ENNReal",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references": ["DenselyOrdered", "And", "Exists", "LT.lt", "LT"],
  "name": "DenselyOrdered.mk",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LT Œ±], (‚àÄ (a‚ÇÅ a‚ÇÇ : Œ±), a‚ÇÅ < a‚ÇÇ ‚Üí ‚àÉ a, a‚ÇÅ < a ‚àß a < a‚ÇÇ) ‚Üí DenselyOrdered Œ±",
  "constCategory": "Other"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u ‚Üí Lean.Syntax ‚Üí Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegZeroMonoid",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.mk",
  "constType":
  "{G : Type u_2} ‚Üí [toSubNegMonoid : SubNegMonoid G] ‚Üí -0 = 0 ‚Üí SubNegZeroMonoid G",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_1",
   "PartialOrder.toPreorder",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "le_iSup_of_le",
   "OrderHom.mk",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "le_refl",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : CompleteLattice Œ±] (x : OmegaCompletePartialOrder.Chain Œ±) (i : ‚Ñï), x i ‚â§ (fun c => ‚®Ü i, c i) x",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u ‚Üí ‚Ñï ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le.trans",
   "CovariantClass",
   "add_le_add_right",
   "Preorder",
   "Add",
   "LE.le",
   "add_le_add_left",
   "Preorder.toLE"],
  "name": "add_le_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] {a b c d : Œ±},\n  a ‚â§ b ‚Üí c ‚â§ d ‚Üí a + c ‚â§ b + d",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk", "_private.Mathlib.Data.Real.Basic.0.Real.le", "Real", "LE"],
  "name": "Real.instLEReal",
  "constType": "LE ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "NontriviallyNormedField",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "LT.lt",
   "NormedField",
   "Norm.norm",
   "One.toOfNat1",
   "NormedField.toNorm",
   "Real.instOneReal"],
  "name": "NontriviallyNormedField.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí [toNormedField : NormedField Œ±] ‚Üí (‚àÉ x, 1 < ‚Äñx‚Äñ) ‚Üí NontriviallyNormedField Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedField.toField",
   "Field.toCommRing",
   "instHMul",
   "NormedField",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NormedField.toNormedCommRing.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NormedField Œ±] (a b : Œ±), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.toLinearOrder",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "OrderedAddCommMonoid.mk",
   "LinearOrder.toPartialOrder",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.add_le_add_left"],
  "name": "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedAddCommMonoid Œ±] ‚Üí OrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) ‚Üí Type v ‚Üí Type (max u v)",
  "constCategory": "Other"},
 {"references": ["PseudoMetricSpace"],
  "name": "ProperSpace",
  "constType": "(Œ± : Type u) ‚Üí [inst : PseudoMetricSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{Œ± : Type u_9} ‚Üí [self : CompleteLattice Œ±] ‚Üí Top Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing",
   "DivisionRing.toRing",
   "NormedDivisionRing.toDivisionRing",
   "NormedDivisionRing.toNormedRing.proof_1",
   "NormedDivisionRing.toNorm",
   "NormedRing.mk",
   "NormedDivisionRing",
   "NormedDivisionRing.dist_eq",
   "NormedDivisionRing.toMetricSpace"],
  "name": "NormedDivisionRing.toNormedRing",
  "constType": "{Œ± : Type u_1} ‚Üí [Œ≤ : NormedDivisionRing Œ±] ‚Üí NormedRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{Œ± : Type u_2} ‚Üí [self : CanonicallyOrderedCommSemiring Œ±] ‚Üí CanonicallyOrderedAddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "‚àÄ {Œ± : Sort u}, Œ± ‚Üí Nonempty Œ±",
  "constCategory": "Other"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "IsCauSeq", "Ring", "Nat", "Subtype"],
  "name": "CauSeq",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : LinearOrderedField Œ±] ‚Üí (Œ≤ : Type u_2) ‚Üí [inst : Ring Œ≤] ‚Üí (Œ≤ ‚Üí Œ±) ‚Üí Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Or",
   "LinearOrder",
   "instDistribLattice",
   "eq_comm",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Abs.abs",
   "Eq",
   "Mathlib.Algebra.Order.Group.Abs._auxLemma.1",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "AddGroup",
   "SemilatticeSup.toSup",
   "propext",
   "InvolutiveNeg.toNeg",
   "Eq.mp",
   "congr",
   "abs_choice",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "congrArg",
   "NegZeroClass.toNeg",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "eq_or_eq_neg_of_abs_eq",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±] {a b : Œ±}, |a| = b ‚Üí a = b ‚à® a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "Semiring.natCast_succ",
   "Ring.intCast_negSucc",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_ofNat",
   "Ring.toSemiring",
   "Ring.zsmul_neg'",
   "Semiring.toNatCast",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.zsmul_succ'",
   "Ring",
   "Ring.toSub",
   "AddGroupWithOne",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "AddMonoidWithOne.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.mk",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Semiring.toModule.proof_1",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MonoidWithZero.toMulActionWithZero",
   "Semiring.toModule.proof_2",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Semiring.toModule.proof_4",
   "Module",
   "Semiring.toModule.proof_3",
   "MulActionWithZero.toMulAction",
   "Module.mk"],
  "name": "Semiring.toModule",
  "constType": "{R : Type u_2} ‚Üí [inst : Semiring R] ‚Üí Module R R",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Inhabited", "Nonempty", "Inhabited.default"],
  "name": "instNonempty",
  "constType": "‚àÄ {Œ± : Sort u} [inst : Inhabited Œ±], Nonempty Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "EquivLike.coe",
   "RingHomClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "RingEquivClass.toRingHomClass.proof_5",
   "FunLike.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "RingEquivClass.toRingHomClass.proof_2",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "RingEquivClass.toRingHomClass.proof_1",
   "MulEquivClass.toEquivLike",
   "RingEquivClass.toRingHomClass.proof_3",
   "RingEquivClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingEquivClass.toMulEquivClass",
   "RingEquivClass.toRingHomClass.proof_4",
   "MonoidHomClass.mk"],
  "name": "RingEquivClass.toRingHomClass",
  "constType":
  "{F : Type u_1} ‚Üí\n  {R : Type u_4} ‚Üí\n    {S : Type u_5} ‚Üí\n      [inst : NonAssocSemiring R] ‚Üí [inst_1 : NonAssocSemiring S] ‚Üí [h : RingEquivClass F R S] ‚Üí RingHomClass F R S",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.neg_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "neg_mul",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : HasDistribNeg Œ±] (a b : Œ±), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Set.univ_inter",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_right",
  "constType": "‚àÄ {Œ± : Type u} {f g : Filter Œ±} {s : Set Œ±}, s ‚àà g ‚Üí s ‚àà f ‚äì g",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "IntervalIntegrable",
   "ContinuousOn.intervalIntegrable",
   "Real.lattice",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Continuous",
   "Real.measurableSpace",
   "Real",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "Set.uIcc",
   "UniformSpace.toTopologicalSpace",
   "Continuous.continuousOn",
   "MeasureTheory.IsLocallyFiniteMeasure"],
  "name": "Continuous.intervalIntegrable",
  "constType":
  "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {Œº : MeasureTheory.Measure ‚Ñù}\n  [inst_1 : MeasureTheory.IsLocallyFiniteMeasure Œº] {u : ‚Ñù ‚Üí E}, Continuous u ‚Üí ‚àÄ (a b : ‚Ñù), IntervalIntegrable u Œº a b",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{Œ± : Sort u_1} ‚Üí\n  {a : Œ±} ‚Üí {motive : (a_1 : Œ±) ‚Üí a = a_1 ‚Üí Sort u} ‚Üí motive a (_ : a = a) ‚Üí {a_1 : Œ±} ‚Üí (t : a = a_1) ‚Üí motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Top",
   "setOf",
   "Filter.mk",
   "Filter.instTopFilter.proof_2",
   "Set",
   "Filter.instTopFilter.proof_1",
   "Filter",
   "Set.mem_univ",
   "Top.mk",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter",
  "constType": "{Œ± : Type u} ‚Üí Top (Filter Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsScalarTower.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MulZeroClass.toSMulWithZero",
   "Semiring.toMonoidWithZero",
   "MonoidWithZero.toZero",
   "Algebra.id",
   "Algebra.toSMul",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "SMulZeroClass.toSMul"],
  "name": "MeasureTheory.Measure.restrict.proof_1",
  "constType": "IsScalarTower ENNReal ENNReal ENNReal",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.semilinearMapClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "instHAdd",
   "AddHomClass.toFunLike",
   "Semiring",
   "HAdd.hAdd",
   "map_add",
   "FunLike.coe",
   "AddCommMagma.toAdd",
   "Eq",
   "SemilinearMapClass.toAddHomClass",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "TopologicalSpace",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass.proof_2",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_4} {R‚ÇÇ : Type u_3} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_2}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ),\n  ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedRing", "Ord"],
  "name": "LinearOrderedRing.toOrd",
  "constType": "{Œ± : Type u} ‚Üí [self : LinearOrderedRing Œ±] ‚Üí Ord Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a b c : Œ±), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "Semiring",
   "AddHomClass.toFunLike",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Eq",
   "SMulZeroClass.toSMul",
   "RingHomClass.toNonUnitalRingHomClass",
   "outParam",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "SemilinearMapClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddHomClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "SemilinearMapClass.mk",
  "constType":
  "{F : Type u_17} ‚Üí\n  {R : outParam (Type u_18)} ‚Üí\n    {S : outParam (Type u_19)} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : Semiring S] ‚Üí\n          {œÉ : outParam (R ‚Üí+* S)} ‚Üí\n            {M : outParam (Type u_20)} ‚Üí\n              {M‚ÇÇ : outParam (Type u_21)} ‚Üí\n                [inst_2 : AddCommMonoid M] ‚Üí\n                  [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                    [inst_4 : Module R M] ‚Üí\n                      [inst_5 : Module S M‚ÇÇ] ‚Üí\n                        [toAddHomClass : AddHomClass F M M‚ÇÇ] ‚Üí\n                          (‚àÄ (f : F) (r : R) (x : M), f (r ‚Ä¢ x) = œÉ r ‚Ä¢ f x) ‚Üí SemilinearMapClass F œÉ M M‚ÇÇ",
  "constCategory": "Other"},
 {"references": ["Abs"],
  "name": "Abs.abs",
  "constType": "{Œ± : Type u_1} ‚Üí [self : Abs Œ±] ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedAddCommGroup",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "instOfNatNat",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "instAddNat",
   "instHAdd",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_5",
  "constType":
  "‚àÄ (n : ‚Ñï) (x : ‚Ñù), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references":
  ["top_le_iff",
   "OrderTop.toTop",
   "Iff.symm",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "eq_top_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, a = ‚ä§ ‚Üî ‚ä§ ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toStrictOrderedSemiring : StrictOrderedSemiring Œ±] ‚Üí (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí StrictOrderedCommSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "SetLike",
   "SetLike.mk",
   "Submodule",
   "Submodule.toAddSubmonoid",
   "Semiring",
   "AddSubmonoid.toAddSubsemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Module",
   "AddSubsemigroup.carrier",
   "Submodule.setLike.proof_1",
   "AddCommMonoid"],
  "name": "Submodule.setLike",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí SetLike (Submodule R M) M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Set.inter_univ",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_left",
  "constType": "‚àÄ {Œ± : Type u} {f g : Filter Œ±} {s : Set Œ±}, s ‚àà f ‚Üí s ‚àà f ‚äì g",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "MulPosMono",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toMulPosMono",
  "constType": "‚àÄ {Œ± : Type u} [inst : OrderedSemiring Œ±], MulPosMono Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddGroup",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_5",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] (n : ‚Ñï) (x : G), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommRing.toNonUnitalCommRing",
   "Semifield.toCommSemiring",
   "IsROrC.toStarRing",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "True",
   "Eq",
   "mul_comm",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "starRingEnd_self_apply",
   "map_mul",
   "Eq.trans",
   "eq_self",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "EuclideanDomain.toCommRing",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "congr",
   "congrArg"],
  "name": "IsROrC.innerProductSpace.proof_2",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] (x y : ùïú), (starRingEnd ùïú) ((starRingEnd ùïú) y * x) = (starRingEnd ùïú) x * y",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.decidableLE",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedAddCommGroup Œ±] ‚Üí DecidableRel fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLinearOrder", "ConditionallyCompleteLinearOrderBot"],
  "name":
  "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : ConditionallyCompleteLinearOrderBot Œ±] ‚Üí ConditionallyCompleteLinearOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MulAction",
   "AddMonoid",
   "DistribMulAction",
   "Eq"],
  "name": "DistribMulAction.mk",
  "constType":
  "{M : Type u_10} ‚Üí\n  {A : Type u_11} ‚Üí\n    [inst : Monoid M] ‚Üí\n      [inst_1 : AddMonoid A] ‚Üí\n        [toMulAction : MulAction M A] ‚Üí\n          (‚àÄ (a : M), a ‚Ä¢ 0 = 0) ‚Üí (‚àÄ (a : M) (x y : A), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y) ‚Üí DistribMulAction M A",
  "constCategory": "Other"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : Sub Œ±] ‚Üí HSub Œ± Œ± Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "‚àÄ {Œ± : Type u} [self : Semiring Œ±], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Filter Œ± ‚Üí Filter Œ≤ ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommMonoid", "AddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedAddCommMonoid Œ±] ‚Üí AddCommMonoid Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["AddCommMonoid.nat_isScalarTower",
   "instHSMul",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.Measure.smul_toOuterMeasure",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "AddMonoid.toNatSMul",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.OuterMeasure.instSMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "HSMul.hSMul",
   "OrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.instAddCommMonoid.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] (x : MeasureTheory.Measure Œ±) (x_1 : ‚Ñï), ‚Üë(x_1 ‚Ä¢ x) = x_1 ‚Ä¢ ‚Üëx",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí b ‚Üí a",
  "constCategory": "Definition"},
 {"references":
  ["Filter.Frequently.and_eventually",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "le_rfl",
   "And.left",
   "Iff.mpr",
   "LE.le.eq_or_lt",
   "And.right",
   "upperBounds",
   "OrderTopology.to_orderClosedTopology",
   "Filter.instPureFilter",
   "Std.Classes.Order._auxLemma.3",
   "Set.Icc_subset_Icc_union_Icc",
   "Set.Ico",
   "Or",
   "Mathlib.Order.Basic._auxLemma.1",
   "instDistribLattice",
   "Set.instSDiffSet",
   "SDiff.sdiff",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "IsLUB",
   "And",
   "eq_true",
   "False.elim",
   "Filter.le_principal_iff",
   "propext",
   "LT.lt",
   "congr",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "congrFun",
   "Exists",
   "Set.diff_subset_iff",
   "Set",
   "GE.ge",
   "Eq.refl",
   "mem_nhdsWithin_Iic_iff_exists_Ioc_subset'",
   "Exists.intro",
   "Set.Iic",
   "Set.Subset.rfl",
   "True",
   "Ioc_mem_nhdsWithin_Iic",
   "CompactIccSpace.mk''",
   "instMembershipSetFilter",
   "mem_nhdsWithin_of_mem_nhds",
   "Filter.le_pure_iff",
   "Or.inr",
   "LE.le.trans",
   "ConditionallyCompleteLattice.toLattice",
   "LE.le",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Or.inl",
   "mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset",
   "IsCompact",
   "Set.instUnionSet",
   "and_self",
   "Ultrafilter.instMembershipSetUltrafilter",
   "dite",
   "Set.Icc_self",
   "Exists.casesOn",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "isLUB_csSup",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Eq.mpr",
   "Iff.mp",
   "ConditionallyCompleteLattice.toSupSet",
   "instLinearOrder",
   "OrderTopology",
   "Filter",
   "And.casesOn",
   "not_false_eq_true",
   "Eq.trans",
   "Ultrafilter.toFilter",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "setOf",
   "Filter.Frequently.exists",
   "Lattice.toSemilatticeInf",
   "Classical.propDecidable",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.Iio",
   "Or.casesOn",
   "BddAbove",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Ultrafilter",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "Singleton.singleton",
   "Not",
   "Set.Ioc",
   "Mathlib.Tactic.Contrapose.mtr",
   "ConditionallyCompleteLinearOrder",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "congrArg",
   "Set.Icc",
   "IsLUB.frequently_mem",
   "Filter.mem_of_superset",
   "CompactIccSpace",
   "Set.Ici",
   "Mathlib.Topology.Compactness.Compact._auxLemma.23",
   "Mathlib.Init.Order.Defs._auxLemma.2",
   "Pure.pure",
   "Set.Ioc_subset_Ioc_left",
   "Filter.principal",
   "Set.Icc_subset_Icc_union_Ioc",
   "Set.instSingletonSet",
   "forall_congr",
   "Preorder.toLT",
   "TopologicalSpace",
   "Ultrafilter.diff_mem_iff",
   "nhdsWithin",
   "Set.union_comm",
   "Set.Icc_eq_empty",
   "id",
   "isCompact_iff_ultrafilter_le_nhds",
   "le_or_lt",
   "Membership.mem",
   "funext",
   "pure_le_nhds",
   "LT.lt.le",
   "False",
   "nhds",
   "Union.union",
   "SemilatticeInf.toPartialOrder",
   "SupSet.sSup",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.4",
   "eq_false",
   "LE.le.not_lt",
   "lowerBounds",
   "Set.Subset.trans",
   "Set.union_subset_union",
   "Set.Ico_union_right"],
  "name": "ConditionallyCompleteLinearOrder.toCompactIccSpace",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±],\n  CompactIccSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_self",
  "constType": "‚àÄ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedAddCommGroup",
  "constType": "Type u_9 ‚Üí Type u_9",
  "constCategory": "Other"},
 {"references":
  ["RingHomInvPair",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "DenselyNormedField.toNormedField",
   "Semifield.toDivisionSemiring",
   "IsROrC",
   "RingHom.id",
   "RingHomInvPair.ids"],
  "name": "OrthonormalBasis.toBasis.proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú], RingHomInvPair (RingHom.id ùïú) (RingHom.id ùïú)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHomClass.mk",
   "RingHom",
   "MulOneClass.toMul",
   "RingHom.instRingHomClass.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MulOneClass.toOne",
   "FunLike.mk",
   "RingHom.instRingHomClass.proof_2",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "NonAssocSemiring",
   "OneHom.toFun",
   "RingHom.instRingHomClass.proof_1",
   "MonoidHom.toOneHom",
   "RingHom.map_zero'",
   "RingHom.map_add'",
   "RingHom.toMonoidHom",
   "MonoidHomClass.mk"],
  "name": "RingHom.instRingHomClass",
  "constType":
  "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí {x : NonAssocSemiring Œ±} ‚Üí {x_1 : NonAssocSemiring Œ≤} ‚Üí RingHomClass (Œ± ‚Üí+* Œ≤) Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Iff.mp",
   "AddMonoid.toZero",
   "Field",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Ne",
   "mul_eq_zero",
   "Or",
   "False",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Or.casesOn",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "And",
   "instHMul",
   "Field.toEuclideanDomain.match_2",
   "CommRing.toRing",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.noZeroDivisors",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Field.toEuclideanDomain.proof_5",
  "constType":
  "‚àÄ {K : Type u_1} [inst : Field K] (a b : K), b ‚â† 0 ‚Üí a * b = 0 ‚àß a ‚â† 0 ‚Üí False",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{Œ± : Type u} ‚Üí [self : OrderedSemiring Œ±] ‚Üí PartialOrder Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "constType":
  "‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a : Œ±), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Units.mk0",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Or",
   "Eq.refl",
   "NoZeroDivisors.mk",
   "And.left",
   "implies_congr",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "Units.ne_zero",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "Units",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "And",
   "And.right",
   "Eq.mpr",
   "Mathlib.Tactic.PushNeg.not_or_eq",
   "Units.instMulOneClassUnits",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.toNontrivial",
   "GroupWithZero",
   "HMul.hMul",
   "Not",
   "Mathlib.Tactic.Contrapose.mtr",
   "MonoidWithZero.toZero",
   "id"],
  "name": "GroupWithZero.noZeroDivisors",
  "constType": "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ], NoZeroDivisors G‚ÇÄ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "EuclideanDomain",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{Œ± : Sort u_1} ‚Üí\n  {a : Œ±} ‚Üí {motive : (a_1 : Œ±) ‚Üí a = a_1 ‚Üí Sort u} ‚Üí {a_1 : Œ±} ‚Üí (t : a = a_1) ‚Üí motive a (_ : a = a) ‚Üí motive a_1 t",
  "constCategory": "Definition"},
 {"references": ["Quotient", "Cardinal.isEquivalent"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerBounds",
  "constType": "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí Set Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MeasureTheory.MeasureSpace",
  "constType": "Type u_6 ‚Üí Type u_6",
  "constCategory": "Other"},
 {"references": ["outParam", "Add"],
  "name": "AddHomClass",
  "constType":
  "Type u_9 ‚Üí\n  (M : outParam (Type u_10)) ‚Üí\n    (N : outParam (Type u_11)) ‚Üí [inst : Add M] ‚Üí [inst : Add N] ‚Üí Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} (s : Set (Set Œ±)), ‚àÄ t ‚àà s, ‚àÄ a ‚àà t, ‚àÉ t ‚àà s, a ‚àà t",
  "constCategory": "Theorem"},
 {"references":
  ["SeminormedAddCommGroup.mk",
   "NonUnitalSeminormedRing.dist_eq",
   "NonUnitalSeminormedRing.toNorm",
   "SeminormedAddCommGroup",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalSeminormedRing.toPseudoMetricSpace"],
  "name": "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : NonUnitalSeminormedRing Œ±] ‚Üí SeminormedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references": ["AddMonoid.nsmul", "SMul", "SMul.mk", "Nat", "AddMonoid"],
  "name": "AddMonoid.toNatSMul",
  "constType": "{M : Type u_2} ‚Üí [inst : AddMonoid M] ‚Üí SMul ‚Ñï M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCancelAddCommMonoid",
  "constType": "Type u_3 ‚Üí Type u_3",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{Œ± : Type u} ‚Üí [self : StrictOrderedSemiring Œ±] ‚Üí Semiring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instCommSemiringReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "StarRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "starRingOfComm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name":
  "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
  "constType": "StarRing ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "RingHomClass.toRingHom.proof_3",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MonoidHomClass.toMonoidHom",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "RingHom.mk",
   "NonAssocSemiring",
   "AddMonoidHomClass.toAddMonoidHom",
   "RingHomClass.toAddMonoidHomClass",
   "RingHomClass.toRingHom.proof_1",
   "RingHomClass.toMonoidHomClass",
   "MonoidHom.toOneHom",
   "RingHomClass.toRingHom.proof_2",
   "MonoidHom.mk",
   "AddMonoidHom"],
  "name": "RingHomClass.toRingHom",
  "constType":
  "{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí {x : NonAssocSemiring Œ±} ‚Üí {x_1 : NonAssocSemiring Œ≤} ‚Üí [inst : RingHomClass F Œ± Œ≤] ‚Üí F ‚Üí Œ± ‚Üí+* Œ≤",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String ‚Üí String ‚Üí String ‚Üí String ‚Üí Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "MeasureTheory.OuterMeasure.empty'",
   "Set",
   "HasCompl.compl",
   "Set.compl_univ",
   "Set.instEmptyCollectionSet",
   "BooleanAlgebra.toHasCompl",
   "Set.univ",
   "instENNRealZero",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "congrArg",
   "MeasurableSpace",
   "Eq.trans",
   "congrFun"],
  "name": "MeasureTheory.Measure.ae.proof_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±), ‚Üë‚ÜëŒº Set.univ·∂ú = 0",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Basis",
  "constType":
  "Type u_1 ‚Üí\n  (R : Type u_3) ‚Üí\n    (M : Type u_6) ‚Üí\n      [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst : Module R M] ‚Üí Type (max (max u_1 u_3) u_6)",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1771",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype"],
  "name": "PosMulMono",
  "constType":
  "(Œ± : Type u_1) ‚Üí [inst : Mul Œ±] ‚Üí [inst : Zero Œ±] ‚Üí [inst : Preorder Œ±] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MulAction", "AddMonoid", "DistribMulAction"],
  "name": "DistribMulAction.toMulAction",
  "constType":
  "{M : Type u_10} ‚Üí\n  {A : Type u_11} ‚Üí [inst : Monoid M] ‚Üí [inst_1 : AddMonoid A] ‚Üí [self : DistribMulAction M A] ‚Üí MulAction M A",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap",
   "AddHom.toFun",
   "Semiring",
   "Continuous",
   "TopologicalSpace",
   "Module",
   "AddCommMagma.toAdd",
   "LinearMap.toAddHom",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.cont",
  "constType":
  "‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {M : Type u_3}\n  [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M] {M‚ÇÇ : Type u_4} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M] [inst_7 : Module S M‚ÇÇ] (self : M ‚ÜíSL[œÉ] M‚ÇÇ), Continuous self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalSeminormedRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Eq",
   "Dist.dist",
   "instHMul",
   "Norm",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "HMul.hMul",
   "NonUnitalRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "PseudoMetricSpace",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalSeminormedRing.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  [toNorm : Norm Œ±] ‚Üí\n    [toNonUnitalRing : NonUnitalRing Œ±] ‚Üí\n      [toPseudoMetricSpace : PseudoMetricSpace Œ±] ‚Üí\n        (‚àÄ (x y : Œ±), dist x y = ‚Äñx - y‚Äñ) ‚Üí (‚àÄ (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ) ‚Üí NonUnitalSeminormedRing Œ±",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instHDiv",
   "DivisionSemiring.toGroupWithZero",
   "Field",
   "Field.toSemifield",
   "Semifield.toDivisionSemiring",
   "HDiv.hDiv",
   "div_zero",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "Eq"],
  "name": "Field.toEuclideanDomain.proof_1",
  "constType": "‚àÄ {K : Type u_1} [inst : Field K] (a : K), a / 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "Min.min",
   "OrderedAddCommGroup",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toOrderedAddCommGroup : OrderedAddCommGroup Œ±] ‚Üí\n    [toMin : Min Œ±] ‚Üí\n      [toMax : Max Œ±] ‚Üí\n        [toOrd : Ord Œ±] ‚Üí\n          (‚àÄ (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a) ‚Üí\n            (decidableLE : DecidableRel fun x x_1 => x ‚â§ x_1) ‚Üí\n              (decidableEq : DecidableEq Œ±) ‚Üí\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) ‚Üí\n                  autoParam (‚àÄ (a b : Œ±), min a b = if a ‚â§ b then a else b) _auto‚úù ‚Üí\n                    autoParam (‚àÄ (a b : Œ±), max a b = if a ‚â§ b then b else a) _auto‚úù¬π ‚Üí\n                      autoParam (‚àÄ (a b : Œ±), compare a b = compareOfLessAndEq a b) _auto‚úù¬≤ ‚Üí\n                        LinearOrderedAddCommGroup Œ±",
  "constCategory": "Other"},
 {"references":
  ["CommMagma",
   "CommMagma.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toCommMagma",
  "constType":
  "{Œ± : Type u} ‚Üí [self : NonUnitalNonAssocCommSemiring Œ±] ‚Üí CommMagma Œ±",
  "constCategory": "Definition"},
 {"references":
  ["right_distrib",
   "instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "add_mul",
  "constType":
  "‚àÄ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.union_eq_self_of_subset_left",
   "Union.union",
   "Set",
   "Filter.mem_of_superset",
   "Eq.refl",
   "HasSubset.Subset",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Set.subset_union_left",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.inter_union_distrib_right",
   "Filter",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Set.instUnionSet",
   "id",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} (f g : Filter Œ±) {x y : Set Œ±},\n  x ‚àà {s | ‚àÉ a ‚àà f, ‚àÉ b ‚àà g, s = a ‚à© b} ‚Üí x ‚äÜ y ‚Üí y ‚àà {s | ‚àÉ a ‚àà f, ‚àÉ b ‚àà g, s = a ‚à© b}",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalRing", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNonUnitalRing",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : NonUnitalSeminormedRing Œ±] ‚Üí NonUnitalRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "‚àÄ {M‚ÇÄ : Type u} [self : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["NormedAddCommGroup", "AddCommGroup"],
  "name": "NormedAddCommGroup.toAddCommGroup",
  "constType":
  "{E : Type u_9} ‚Üí [self : NormedAddCommGroup E] ‚Üí AddCommGroup E",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≤ : Type v} ‚Üí [self : Singleton Œ± Œ≤] ‚Üí Œ± ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.neg_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [self : HasDistribNeg Œ±] (x y : Œ±), -x * y = -(x * y)",
  "constCategory": "Definition"},
 {"references": ["Set.range", "InfSet.sInf", "InfSet"],
  "name": "iInf",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : InfSet Œ±] ‚Üí {Œπ : Sort u_9} ‚Üí (Œπ ‚Üí Œ±) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["UniformSpace.Core.uniformity",
   "UniformSpace",
   "Prod",
   "Filter",
   "UniformSpace.toCore"],
  "name": "uniformity",
  "constType": "(Œ± : Type u) ‚Üí [inst : UniformSpace Œ±] ‚Üí Filter (Œ± √ó Œ±)",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "SecondCountableTopology",
  "constType": "(Œ± : Type u) ‚Üí [t : TopologicalSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["SMulZeroClass.mk",
   "Zero",
   "MulAction.toSMul",
   "SMulWithZero",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero.smul_zero",
   "MulActionWithZero",
   "MulActionWithZero.zero_smul",
   "MonoidWithZero.toZero",
   "SMulWithZero.mk",
   "MulActionWithZero.toMulAction",
   "MonoidWithZero"],
  "name": "MulActionWithZero.toSMulWithZero",
  "constType":
  "(R : Type u_1) ‚Üí\n  (M : Type u_3) ‚Üí [inst : MonoidWithZero R] ‚Üí [inst_1 : Zero M] ‚Üí [m : MulActionWithZero R M] ‚Üí SMulWithZero R M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroOneClass",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "One.toOfNat1",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "instOfNatNat",
   "LinearOrder.decidableEq",
   "Nat",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.instLinearOrderedFieldReal.proof_4",
  "constType": "‚àÄ (x : ‚Ñù), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalCommRing", "NonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalRing",
  "constType": "{Œ± : Type u} ‚Üí [self : NonUnitalCommRing Œ±] ‚Üí NonUnitalRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Rat",
   "Rat.instLinearOrderedCommRingRat"],
  "name": "Rat.instLinearOrderedRingRat",
  "constType": "LinearOrderedRing ‚Ñö",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "Nat.cast",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_neg'",
  "constType":
  "‚àÄ {G : Type u} [self : SubNegMonoid G] (n : ‚Ñï) (a : G),\n  SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (‚Üë(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{Œ± : Type u_1} ‚Üí Membership Œ± (Finset Œ±)",
  "constCategory": "Definition"},
 {"references": ["instHMul", "Rat", "HMul.hMul", "Mul"],
  "name": "qsmulRec",
  "constType": "{K : Type u_3} ‚Üí (‚Ñö ‚Üí K) ‚Üí [inst : Mul K] ‚Üí ‚Ñö ‚Üí K ‚Üí K",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "RingHom",
   "OfNat.ofNat",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "OneHom.map_one'",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.instRingHomClass.proof_3",
  "constType":
  "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤),\n  OneHom.toFun (‚Üë‚Üëf) 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "instHMul",
   "NormedRing.norm_mul",
   "NormedCommRing",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [Œ≤ : NormedCommRing Œ±] (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_1",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = a + c ‚Üí b = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Filter",
  "constType": "Type u_1 ‚Üí Type u_1",
  "constCategory": "Other"},
 {"references": ["Rat", "Rat.neg", "Neg", "Neg.mk"],
  "name": "Rat.instNegRat",
  "constType": "Neg ‚Ñö",
  "constCategory": "Definition"},
 {"references": ["Ring", "IntCast"],
  "name": "Ring.toIntCast",
  "constType": "{R : Type u} ‚Üí [self : Ring R] ‚Üí IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalRing.mk",
   "NormedRing.toNorm",
   "NormedRing.toNonUnitalNormedRing.proof_6",
   "AddCommMonoid.toAddMonoid",
   "NormedRing.toNonUnitalNormedRing.proof_7",
   "Ring.toNeg",
   "NormedRing.toNonUnitalNormedRing.proof_3",
   "NormedRing.dist_eq",
   "Ring.toSub",
   "NormedRing.toNonUnitalNormedRing.proof_2",
   "NormedRing.toNonUnitalNormedRing.proof_11",
   "NonUnitalNormedRing",
   "NormedRing.toNonUnitalNormedRing.proof_10",
   "NormedRing.toRing",
   "AddCommGroup.mk",
   "NormedRing.toNonUnitalNormedRing.proof_5",
   "NormedRing.toNonUnitalNormedRing.proof_1",
   "NormedRing.toNonUnitalNormedRing.proof_9",
   "NormedRing.norm_mul",
   "AddGroup.mk",
   "NormedRing.toMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "NormedRing",
   "Ring.zsmul",
   "NormedRing.toNonUnitalNormedRing.proof_4",
   "NormedRing.toNonUnitalNormedRing.proof_8",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNormedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedRing.toNonUnitalNormedRing",
  "constType": "{Œ± : Type u_1} ‚Üí [Œ≤ : NormedRing Œ±] ‚Üí NonUnitalNormedRing Œ±",
  "constCategory": "Definition"},
 {"references": ["Semifield", "Inv"],
  "name": "Semifield.toInv",
  "constType": "{Œ± : Type u_4} ‚Üí [self : Semifield Œ±] ‚Üí Inv Œ±",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "OrderedAddCommGroup",
   "NormedLatticeAddCommGroup.toLattice",
   "NormedLatticeAddCommGroup",
   "NormedLatticeAddCommGroup.add_le_add_left",
   "Lattice.toSemilatticeSup",
   "NormedLatticeAddCommGroup.toNormedAddCommGroup",
   "OrderedAddCommGroup.mk",
   "SemilatticeSup.toPartialOrder"],
  "name": "NormedLatticeAddCommGroup.toOrderedAddCommGroup",
  "constType":
  "{Œ± : Type u_1} ‚Üí [h : NormedLatticeAddCommGroup Œ±] ‚Üí OrderedAddCommGroup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "Not",
   "WellFounded",
   "EuclideanDomain",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "EuclideanDomain.mk",
  "constType":
  "{R : Type u} ‚Üí\n  [toCommRing : CommRing R] ‚Üí\n    [toNontrivial : Nontrivial R] ‚Üí\n      (quotient : R ‚Üí R ‚Üí R) ‚Üí\n        (‚àÄ (a : R), quotient a 0 = 0) ‚Üí\n          (remainder : R ‚Üí R ‚Üí R) ‚Üí\n            (‚àÄ (a b : R), b * quotient a b + remainder a b = a) ‚Üí\n              (r : R ‚Üí R ‚Üí Prop) ‚Üí\n                WellFounded r ‚Üí\n                  (‚àÄ (a : R) {b : R}, b ‚â† 0 ‚Üí r (remainder a b) b) ‚Üí\n                    (‚àÄ (a : R) {b : R}, b ‚â† 0 ‚Üí ¬¨r (a * b) a) ‚Üí EuclideanDomain R",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "Or",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq.le_total",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "IsTotal",
   "Rat.instNegRat",
   "congr",
   "IsTotal.mk",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.instIsTotalRealLeInstLEReal",
  "constType": "IsTotal ‚Ñù fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Set",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_2",
   "Prop.partialOrder",
   "LT.mk",
   "LE.le",
   "PartialOrder",
   "Preorder.mk",
   "MeasurableSpace.instLEMeasurableSpace",
   "And",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_1",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_3",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "MeasurableSet",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_4",
   "Not",
   "MeasurableSpace"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace",
  "constType": "{Œ± : Type u_1} ‚Üí PartialOrder (MeasurableSpace Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "Ring.toNonAssocRing.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (a b c : Œ±), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_5",
   "CanonicallyOrderedCommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_2",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_11",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_6",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_13",
   "Semiring.toNatCast",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_1",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_9",
   "Semiring.npow",
   "WithTop",
   "CommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_4",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.mk",
   "WithTop.commSemiring",
   "WithTop.canonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mk",
   "CanonicallyOrderedAddCommMonoid.toOrderBot",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_15",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_12",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "DecidableEq",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_14",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_10",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_3",
   "CanonicallyOrderedAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_7"],
  "name": "WithTop.instCanonicallyOrderedCommSemiringWithTop",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : DecidableEq Œ±] ‚Üí\n    [inst : CanonicallyOrderedCommSemiring Œ±] ‚Üí [inst : Nontrivial Œ±] ‚Üí CanonicallyOrderedCommSemiring (WithTop Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring Œ±] ‚Üí\n    (‚àÄ (a b : Œ±), a * b = b * a) ‚Üí NonUnitalNonAssocCommSemiring Œ±",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid",
   "DecidableRel"],
  "name": "LinearOrderedCancelAddCommMonoid.decidableLE",
  "constType":
  "{Œ± : Type u_3} ‚Üí [self : LinearOrderedCancelAddCommMonoid Œ±] ‚Üí DecidableRel fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references": ["Union", "Set.union", "Union.mk", "Set"],
  "name": "Set.instUnionSet",
  "constType": "{Œ± : Type u_1} ‚Üí Union (Set Œ±)",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "And",
   "sup_lt_iff",
   "PartialOrder.toPreorder",
   "Iff",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "instDistribLattice",
   "LT.lt",
   "LinearOrder.toMax",
   "Max.max",
   "SemilatticeInf.toPartialOrder"],
  "name": "max_lt_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, max a b < c ‚Üî a < c ‚àß b < c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.Tendsto.mono_left",
   "Set.instHasSubsetSet",
   "nhds",
   "Set",
   "nhdsWithin_mono",
   "HasSubset.Subset",
   "TopologicalSpace",
   "nhdsWithin",
   "ContinuousOn",
   "Set.instMembershipSet"],
  "name": "ContinuousOn.mono",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s t : Set Œ±},\n  ContinuousOn f s ‚Üí t ‚äÜ s ‚Üí ContinuousOn f t",
  "constCategory": "Theorem"},
 {"references":
  ["MetricSpace",
   "Exists",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "TopologicalSpace.MetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.mk",
  "constType":
  "‚àÄ {X : Type u_5} [t : TopologicalSpace X],\n  (‚àÉ m, UniformSpace.toTopologicalSpace = t) ‚Üí TopologicalSpace.MetrizableSpace X",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Filter.giGenerate.proof_1",
   "Filter.giGenerate.proof_3",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter.mkOfClosure",
   "Filter.le_generate_iff",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "GaloisInsertion.mk",
   "Filter",
   "Filter.giGenerate.proof_2",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "Filter.giGenerate",
  "constType": "(Œ± : Type u_2) ‚Üí GaloisInsertion Filter.generate Filter.sets",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ‚Ñ§",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "Ring"],
  "name": "SeminormedRing.toRing",
  "constType": "{Œ± : Type u_5} ‚Üí [self : SeminormedRing Œ±] ‚Üí Ring Œ±",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "WithTop",
   "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
   "inferInstanceAs",
   "CompleteLinearOrder",
   "WithTop.instCompleteLinearOrderWithTop",
   "NNReal"],
  "name": "ENNReal.instCompleteLinearOrderENNReal",
  "constType": "CompleteLinearOrder ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.npow",
   "One.toOfNat1",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "Nat",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.npow_zero",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : CanonicallyOrderedCommSemiring Œ±] (x : Œ±), CanonicallyOrderedCommSemiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "StrictOrderedRing.toRing",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedRing",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a : Œ±), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} ‚Üí {Œ± : outParam (Sort u_2)} ‚Üí {Œ≤ : outParam (Œ± ‚Üí Sort u_3)} ‚Üí [self : FunLike F Œ± Œ≤] ‚Üí F ‚Üí (a : Œ±) ‚Üí Œ≤ a",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "MetricSpace"],
  "name": "NormedRing.toMetricSpace",
  "constType": "{Œ± : Type u_5} ‚Üí [self : NormedRing Œ±] ‚Üí MetricSpace Œ±",
  "constCategory": "Definition"},
 {"references": ["MulHomClass", "outParam", "FunLike", "Mul"],
  "name": "MulHomClass.toFunLike",
  "constType":
  "{F : Type u_9} ‚Üí\n  {M : outParam (Type u_10)} ‚Üí\n    {N : outParam (Type u_11)} ‚Üí [inst : Mul M] ‚Üí [inst_1 : Mul N] ‚Üí [self : MulHomClass F M N] ‚Üí FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["Inner"],
  "name": "Inner.mk",
  "constType": "{ùïú : Type u_4} ‚Üí {E : Type u_5} ‚Üí (E ‚Üí E ‚Üí ùïú) ‚Üí Inner ùïú E",
  "constCategory": "Other"},
 {"references": ["InvolutiveNeg", "InvolutiveNeg.toNeg", "Neg.neg", "Eq"],
  "name": "InvolutiveNeg.neg_neg",
  "constType": "‚àÄ {A : Type u_2} [self : InvolutiveNeg A] (x : A), - -x = x",
  "constCategory": "Definition"},
 {"references":
  ["Trans", "le_trans", "Preorder", "LE.le", "Trans.mk", "Preorder.toLE"],
  "name": "instTransLeToLE",
  "constType": "{Œ± : Type u} ‚Üí [inst : Preorder Œ±] ‚Üí Trans LE.le LE.le LE.le",
  "constCategory": "Definition"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LE.le.trans",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a b c : Œ±}, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : OrderedAddCommMonoid Œ±], CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "SeminormedAddCommGroup",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "Module"],
  "name": "NormedSpace.mk",
  "constType":
  "{Œ± : Type u_5} ‚Üí\n  {Œ≤ : Type u_6} ‚Üí\n    [inst : NormedField Œ±] ‚Üí\n      [inst_1 : SeminormedAddCommGroup Œ≤] ‚Üí\n        [toModule : Module Œ± Œ≤] ‚Üí (‚àÄ (a : Œ±) (b : Œ≤), ‚Äña ‚Ä¢ b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ) ‚Üí NormedSpace Œ± Œ≤",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedRing.toNorm",
   "NonUnitalSeminormedRing.norm_mul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le"],
  "name": "norm_mul_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±] (a b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedRing", "LinearOrderedCommRing"],
  "name": "LinearOrderedCommRing.toLinearOrderedRing",
  "constType":
  "{Œ± : Type u} ‚Üí [self : LinearOrderedCommRing Œ±] ‚Üí LinearOrderedRing Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "Continuous.tendsto.match_1",
  "constType":
  "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} (x : Œ±) (t : Set Œ≤)\n  (motive : f x ‚àà t ‚àß IsOpen t ‚Üí Prop) (x_1 : f x ‚àà t ‚àß IsOpen t),\n  (‚àÄ (hxt : f x ‚àà t) (ht : IsOpen t), motive (_ : f x ‚àà t ‚àß IsOpen t)) ‚Üí motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toZero",
   "ZeroHom.mk",
   "AddMonoidHom.id.proof_2",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.id.proof_1"],
  "name": "AddMonoidHom.id",
  "constType": "(M : Type u_9) ‚Üí [inst : AddZeroClass M] ‚Üí M ‚Üí+ M",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["SMul"],
  "name": "SMul.smul",
  "constType": "{M : Type u} ‚Üí {Œ± : Type v} ‚Üí [self : SMul M Œ±] ‚Üí M ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "NormedField",
   "Semiring.toMonoidWithZero",
   "NormedSpace.norm_smul_le",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "SeminormedRing.toPseudoMetricSpace",
   "Field.toSemifield",
   "BoundedSMul.of_norm_smul_le",
   "Semifield.toCommGroupWithZero",
   "Module.toMulActionWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SMulZeroClass.toSMul",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "SeminormedAddCommGroup.toAddCommGroup",
   "SeminormedCommRing.toSeminormedRing",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "BoundedSMul"],
  "name": "NormedSpace.boundedSMul",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NormedField Œ±] [inst_1 : SeminormedAddCommGroup Œ≤] [inst_2 : NormedSpace Œ± Œ≤],\n  BoundedSMul Œ± Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.semilinearMapClass",
   "SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Function.Injective",
   "AddHomClass.toFunLike",
   "Semiring",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "FunLike.coe_injective'",
   "AddCommMonoid"],
  "name": "LinearMap.instFunLike.proof_1",
  "constType":
  "‚àÄ {R : Type u_4} {S : Type u_3} {M : Type u_2} {M‚ÇÉ : Type u_1} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÉ] [inst_4 : Module R M] [inst_5 : Module S M‚ÇÉ] {œÉ : R ‚Üí+* S},\n  Function.Injective FunLike.coe",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Fintype", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.mk",
  "constType":
  "{Œ± : Type u_4} ‚Üí (elems : Finset Œ±) ‚Üí (‚àÄ (x : Œ±), x ‚àà elems) ‚Üí Fintype Œ±",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{Œ± : Type u} ‚Üí\n  [toAddCommMonoid : AddCommMonoid Œ±] ‚Üí\n    [toMul : Mul Œ±] ‚Üí\n      (‚àÄ (a b c : Œ±), a * (b + c) = a * b + a * c) ‚Üí\n        (‚àÄ (a b c : Œ±), (a + b) * c = a * c + b * c) ‚Üí\n          (‚àÄ (a : Œ±), 0 * a = 0) ‚Üí (‚àÄ (a : Œ±), a * 0 = 0) ‚Üí NonUnitalNonAssocSemiring Œ±",
  "constCategory": "Other"},
 {"references": [],
  "name": "Acc",
  "constType": "{Œ± : Sort u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "DivisionSemiring",
  "constType": "Type u_4 ‚Üí Type u_4",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a b : Œ±), max a b = if a ‚â§ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing.mul_inv_cancel",
   "DivisionRing",
   "DivisionRing.div_eq_mul_inv",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.toNontrivial",
   "DivisionSemiring",
   "DivisionRing.zpow_zero'",
   "DivisionSemiring.mk",
   "DivisionRing.inv_zero",
   "Ring.toSemiring",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toDiv",
   "DivisionRing.toInv"],
  "name": "DivisionRing.toDivisionSemiring",
  "constType": "{Œ± : Type u_1} ‚Üí [inst : DivisionRing Œ±] ‚Üí DivisionSemiring Œ±",
  "constCategory": "Definition"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M‚ÇÄ : Type u_4} ‚Üí [self : CommMonoidWithZero M‚ÇÄ] ‚Üí Zero M‚ÇÄ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.decidableLT",
   "Ord.compare",
   "Ordering",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "compareOfLessAndEq",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
  "constType":
  "‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a b : Œ±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "LinearOrderedField",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.mul_inv_cancel",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "Eq",
   "Field.toCommRing",
   "NormedField.toField",
   "of_eq_true",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom.id",
   "AddMonoidHom",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_8",
  "constType": "‚àÄ (z : ‚Ñù), (AddMonoidHom.id ‚Ñù) z = (AddMonoidHom.id ‚Ñù) z",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "DenselyOrdered",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "zero_lt_two",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "div_lt_div_of_lt",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "NeZero.one",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "add_lt_add_right",
   "DenselyOrdered.mk",
   "Semiring.toNatCast",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHDiv",
   "IsCancelAdd.toIsLeftCancelAdd",
   "LinearOrderedSemifield",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "add_self_div_two",
   "add_lt_add_left",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instTransEq_1",
   "And",
   "LinearOrderedSemifield.toDiv",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "instTransEq",
   "And.intro"],
  "name": "LinearOrderedSemiField.toDenselyOrdered",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±], DenselyOrdered Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "EmptyCollection.emptyCollection",
   "Union.union",
   "Set",
   "Set.instEmptyCollectionSet",
   "or_false_iff",
   "Set.instUnionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.union_empty",
  "constType": "‚àÄ {Œ± : Type u} (a : Set Œ±), a ‚à™ ‚àÖ = a",
  "constCategory": "Theorem"},
 {"references": ["iInf", "Set", "Set.instInfSetSet"],
  "name": "Set.iInter",
  "constType": "{Œ≤ : Type u_2} ‚Üí {Œπ : Sort u_4} ‚Üí (Œπ ‚Üí Set Œ≤) ‚Üí Set Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure", "MeasureTheory.OuterMeasure", "MeasurableSpace"],
  "name": "MeasureTheory.Measure.toOuterMeasure",
  "constType":
  "{Œ± : Type u_6} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí MeasureTheory.Measure Œ± ‚Üí MeasureTheory.OuterMeasure Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} ‚Üí\n  {Œ± : outParam (Type u_6)} ‚Üí\n    {Œ≤ : outParam (Type u_7)} ‚Üí\n      {r : outParam (Œ± ‚Üí Œ± ‚Üí Prop)} ‚Üí\n        {s : outParam (Œ≤ ‚Üí Œ≤ ‚Üí Prop)} ‚Üí [self : RelHomClass F r s] ‚Üí FunLike F Œ± fun x => Œ≤",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} ‚Üí [self : NatCast R] ‚Üí ‚Ñï ‚Üí R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_5",
  "constType": "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a : Œ±), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "LinearOrderedCancelAddCommMonoid",
   "Preorder.toLE",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "OrderedAddCommMonoid.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrderedCancelAddCommMonoid.mk",
  "constType":
  "{Œ± : Type u_3} ‚Üí\n  [toOrderedCancelAddCommMonoid : OrderedCancelAddCommMonoid Œ±] ‚Üí\n    [toMin : Min Œ±] ‚Üí\n      [toMax : Max Œ±] ‚Üí\n        [toOrd : Ord Œ±] ‚Üí\n          (‚àÄ (a b : Œ±), a ‚â§ b ‚à® b ‚â§ a) ‚Üí\n            (decidableLE : DecidableRel fun x x_1 => x ‚â§ x_1) ‚Üí\n              (decidableEq : DecidableEq Œ±) ‚Üí\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) ‚Üí\n                  autoParam (‚àÄ (a b : Œ±), min a b = if a ‚â§ b then a else b) _auto‚úù ‚Üí\n                    autoParam (‚àÄ (a b : Œ±), max a b = if a ‚â§ b then b else a) _auto‚úù¬π ‚Üí\n                      autoParam (‚àÄ (a b : Œ±), compare a b = compareOfLessAndEq a b) _auto‚úù¬≤ ‚Üí\n                        LinearOrderedCancelAddCommMonoid Œ±",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_add_rev",
  "constType":
  "‚àÄ {G : Type u} [self : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.isBasis_countableBasis",
   "Membership.mem",
   "TopologicalSpace.SeparableSpace.mk",
   "Classical.choose_spec",
   "TopologicalSpace.nonempty_of_mem_countableBasis",
   "Classical.choose",
   "Subtype.val",
   "TopologicalSpace.IsTopologicalBasis.dense_iff",
   "Set",
   "Set.Nonempty",
   "TopologicalSpace.encodableCountableBasis",
   "Inter.inter",
   "Exists.intro",
   "Dense",
   "TopologicalSpace.countableBasis",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Subtype.property",
   "Set.Countable",
   "Set.range",
   "And",
   "SecondCountableTopology",
   "Set.Elem",
   "Encodable.countable",
   "TopologicalSpace.SeparableSpace",
   "TopologicalSpace",
   "Set.countable_range",
   "And.intro",
   "Set.mem_range_self",
   "Subtype",
   "Subtype.mk",
   "Set.instInterSet"],
  "name": "TopologicalSpace.SecondCountableTopology.to_separableSpace",
  "constType":
  "‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : SecondCountableTopology Œ±], TopologicalSpace.SeparableSpace Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommSemiring",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Other"},
 {"references": ["UniformSpace", "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toUniformSpace",
  "constType": "{Œ± : Type u} ‚Üí [self : PseudoMetricSpace Œ±] ‚Üí UniformSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_8",
  "constType":
  "‚àÄ {Œ± : Type u_1} [s : CommRing Œ±] (a b c : Œ±), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "LinearOrder.toLattice",
   "DistribLattice",
   "LinearOrder",
   "instDistribLattice.proof_1",
   "DistribLattice.mk",
   "inferInstanceAs",
   "Lattice.mk",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left"],
  "name": "instDistribLattice",
  "constType": "{Œ± : Type u} ‚Üí [inst : LinearOrder Œ±] ‚Üí DistribLattice Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Not.elim",
   "Exists",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Filter.empty_mem_iff_bot",
   "Set",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "LE.le",
   "ClusterPt",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Filter.principal",
   "Iff.mp",
   "Filter.le_principal_iff",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsCompact",
   "Filter.NeBot.ne",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "isCompact_empty",
  "constType": "‚àÄ {X : Type u} [inst : TopologicalSpace X], IsCompact ‚àÖ",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "DistribMulAction.toMulAction",
   "OfNat.ofNat",
   "Module.toDistribMulAction",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "Semiring",
   "AddMonoid.toZero",
   "Semiring.toMonoidWithZero",
   "HSMul.hSMul",
   "AddCommMonoid.toAddMonoid",
   "MonoidWithZero.toZero",
   "Module",
   "Eq",
   "AddCommMonoid"],
  "name": "Module.zero_smul",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (x : M), 0 ‚Ä¢ x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Set Œ± ‚Üí Set Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MonoidHom",
   "OneHom",
   "Eq"],
  "name": "MonoidHom.mk",
  "constType":
  "{M : Type u_9} ‚Üí\n  {N : Type u_10} ‚Üí\n    [inst : MulOneClass M] ‚Üí\n      [inst_1 : MulOneClass N] ‚Üí\n        (toOneHom : OneHom M N) ‚Üí\n          (‚àÄ (x y : M), OneHom.toFun toOneHom (x * y) = OneHom.toFun toOneHom x * OneHom.toFun toOneHom y) ‚Üí M ‚Üí* N",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.toSet",
  "constType": "{Œ± : Type u_1} ‚Üí Finset Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{Œ± : Type u} ‚Üí [self : SemilatticeSup Œ±] ‚Üí Sup Œ±",
  "constCategory": "Definition"},
 {"references":
  ["MulAction.one_smul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "One.toOfNat1",
   "MulAction",
   "Eq"],
  "name": "one_smul",
  "constType":
  "‚àÄ (M : Type u_1) {Œ± : Type u_6} [inst : Monoid M] [inst_1 : MulAction M Œ±] (b : Œ±), 1 ‚Ä¢ b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHDiv",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedField.toDiv",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.div_eq_mul_inv",
  "constType":
  "‚àÄ {Œ± : Type u_2} [self : LinearOrderedField Œ±] (a b : Œ±), a / b = a * b‚Åª¬π",
  "constCategory": "Definition"},
 {"references": ["IsROrC", "semiOutParam"],
  "name": "IsROrC.I",
  "constType": "{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K",
  "constCategory": "Definition"},
 {"references": ["Real", "Dist"],
  "name": "Dist.dist",
  "constType": "{Œ± : Type u_3} ‚Üí [self : Dist Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} ‚Üí [self : SubNegMonoid G] ‚Üí Neg G",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Real",
   "Lattice",
   "Real.instDistribLatticeReal"],
  "name": "Real.lattice",
  "constType": "Lattice ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["NontriviallyNormedField", "NormedField"],
  "name": "NontriviallyNormedField.toNormedField",
  "constType":
  "{Œ± : Type u_5} ‚Üí [self : NontriviallyNormedField Œ±] ‚Üí NormedField Œ±",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Max Œ±",
  "constCategory": "Other"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "instHAdd",
   "PseudoMetricSpace.dist_triangle",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "dist_triangle",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x y z : Œ±), dist x z ‚â§ dist x y + dist y z",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Filter.HasBasis.tendsto_right_iff",
   "Filter.Eventually",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis.eventually_iff",
   "Filter.HasBasis",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "propext",
   "Filter",
   "Filter.Tendsto",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Filter.HasBasis.tendsto_iff",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Sort u_4} {Œπ' : Sort u_5} {la : Filter Œ±} {pa : Œπ ‚Üí Prop} {sa : Œπ ‚Üí Set Œ±}\n  {lb : Filter Œ≤} {pb : Œπ' ‚Üí Prop} {sb : Œπ' ‚Üí Set Œ≤} {f : Œ± ‚Üí Œ≤},\n  Filter.HasBasis la pa sa ‚Üí\n    Filter.HasBasis lb pb sb ‚Üí (Filter.Tendsto f la lb ‚Üî ‚àÄ (ib : Œπ'), pb ib ‚Üí ‚àÉ ia, pa ia ‚àß ‚àÄ x ‚àà sa ia, f x ‚àà sb ib)",
  "constCategory": "Theorem"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Œ± ‚Üí Ordering) ‚Üí Ord Œ±",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "Monoid.toSemigroup",
   "mul_assoc",
   "Monoid",
   "HMul.hMul",
   "Eq"],
  "name": "Monoid.toMulAction.proof_2",
  "constType":
  "‚àÄ (M : Type u_1) [inst : Monoid M] (a b c : M), a * b * c = a * (b * c)",
  "constCategory": "Theorem"}]