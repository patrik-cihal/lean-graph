[{"references": ["Quot", "Quot.mk", "Eq"],
  "name": "Quot.sound",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±}, r a b â†’ Quot.mk r a = Quot.mk r b",
  "constCategory": "Axiom"},
 {"references":
  ["OfNat.ofNat",
   "List.filter",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List.filter_cons_of_neg",
   "HAdd.hAdd",
   "List.countP_cons_of_neg",
   "Eq.refl",
   "List.filter_cons_of_pos",
   "dite",
   "List.length",
   "_private.Std.Data.List.Count.0.List.length._eq_2",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "List",
   "Bool.true",
   "Not",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat",
   "List.countP",
   "List.countP_cons_of_pos",
   "id",
   "instDecidableEqBool"],
  "name": "List.countP_eq_length_filter",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (l : List Î±), List.countP p l = List.length (List.filter p l)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.add_zero",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] (a : Î±), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["And", "Iff", "and_congr"],
  "name": "Iff.and",
  "constType": "âˆ€ {a c b d : Prop}, (a â†” c) â†’ (b â†” d) â†’ (a âˆ§ b â†” c âˆ§ d)",
  "constCategory": "Theorem"},
 {"references": ["PProd.rec", "PProd", "PProd.mk"],
  "name": "PProd.casesOn",
  "constType":
  "{Î± : Sort u} â†’\n  {Î² : Sort v} â†’\n    {motive : PProd Î± Î² â†’ Sort u_1} â†’\n      (t : PProd Î± Î²) â†’ ((fst : Î±) â†’ (snd : Î²) â†’ motive { fst := fst, snd := snd }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "propext",
   "LT.lt",
   "Nat.succ_le",
   "Nat",
   "instLTNat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.104",
  "constType": "âˆ€ {n m : â„•}, (Nat.succ n â‰¤ m) = (n < m)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instIsTransSetSubsetInstHasSubsetSet",
   "PartialOrder.toPreorder",
   "Set.Nonempty",
   "Inter.inter",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.mpr",
   "Iff.of_eq",
   "Eq",
   "TopologicalSpace.nhds_generateFrom",
   "Eq.mpr",
   "Set.iUnion",
   "Iff",
   "Iff.mp",
   "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff.match_1",
   "Mathlib.Topology.Bases._auxLemma.2",
   "Filter",
   "And.casesOn",
   "Set.inter_subset_right",
   "Eq.trans",
   "TopologicalSpace.IsTopologicalBasis",
   "Filter.sets",
   "TopologicalSpace.generateFrom",
   "setOf",
   "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
   "HasSubset.Subset",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "And",
   "TopologicalSpace.IsTopologicalBasis.exists_subset_inter",
   "iInf",
   "Filter.le_principal_iff",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "congr",
   "Set.sUnion",
   "And.intro",
   "Set.inter_subset_left",
   "congrArg",
   "exists_prop_congr'",
   "Exists",
   "Set",
   "GE.ge",
   "Filter.biInf_sets_eq",
   "Eq.refl",
   "Set.eq_univ_iff_forall",
   "Exists.intro",
   "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
   "True",
   "iff_self",
   "Filter.principal",
   "Mathlib.Order.Filter.Basic._auxLemma.2",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Std.Logic._auxLemma.52",
   "Filter.instCompleteLatticeFilter",
   "id",
   "instMembershipSetFilter",
   "Membership.mem",
   "Mathlib.Topology.Bases._auxLemma.1",
   "funext",
   "nhds",
   "HasSubset.Subset.trans",
   "Set.univ",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Order.Preimage",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "CompleteLattice.toInfSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {a : Î±} {s : Set Î±} {b : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis b â†’ (s âˆˆ nhds a â†” âˆƒ t âˆˆ b, a âˆˆ t âˆ§ t âŠ† s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "Iff.intro",
   "List.instHasSubsetList",
   "Iff",
   "Iff.mp",
   "List.Sublist.subset",
   "List",
   "Eq.rec",
   "List.subset_nil",
   "List.Sublist",
   "HasSubset.Subset",
   "List.nil",
   "Eq"],
  "name": "List.sublist_nil",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, List.Sublist l [] â†” l = []",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Function.LeftInverse", "Function.RightInverse"],
  "name": "Equiv.mk",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    (toFun : Î± â†’ Î²) â†’ (invFun : Î² â†’ Î±) â†’ Function.LeftInverse invFun toFun â†’ Function.RightInverse invFun toFun â†’ Î± â‰ƒ Î²",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Set",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_4",
  "constType": "âˆ€ {Î± : Type u_1} (a : Set Î±), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instDecidableOr",
   "eq_true_of_decide",
   "Bool",
   "Eq.symm",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.dichotomy",
  "constType": "âˆ€ (b : Bool), b = false âˆ¨ b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithUpperSet.to_WithUpperSet_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithUpperSet.toUpperSet.symm = Topology.WithUpperSet.ofUpperSet",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Nat.zero",
   "List",
   "Eq.refl",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "List.take",
   "Nat.casesOn",
   "Eq"],
  "name": "List.take_nil",
  "constType": "âˆ€ {Î± : Type u_1} {i : â„•}, List.take i [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "âˆ€ {p : Prop}, Â¬p â†’ p = False",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_5",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.instUnionList",
   "List.insert",
   "of_eq_true",
   "DecidableEq",
   "List",
   "Union.union",
   "List.foldr",
   "Eq"],
  "name": "List.cons_union",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (lâ‚ lâ‚‚ : List Î±), a :: lâ‚ âˆª lâ‚‚ = List.insert a (lâ‚ âˆª lâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB",
   "IsGreatest.unique",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "Eq",
   "PartialOrder"],
  "name": "IsGLB.unique",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {s : Set Î±} {a b : Î±}, IsGLB s a â†’ IsGLB s b â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "Set.univ",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_univ",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²}, f '' Set.univ = Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.map_le_iff_le_comap.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {g : Filter Î²} {m : Î± â†’ Î²} (x : Set Î±) (motive : x âˆˆ Filter.comap m g â†’ Prop)\n  (x_1 : x âˆˆ Filter.comap m g),\n  (âˆ€ (w : Set Î²) (ht : w âˆˆ g) (hts : m â»Â¹' w âŠ† x), motive (_ : âˆƒ t âˆˆ g, m â»Â¹' t âŠ† x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "Exists", "Iff.mp", "Iff", "Exists.imp", "Iff.mpr"],
  "name": "exists_congr",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (a : Î±), p a â†” q a) â†’ ((âˆƒ a, p a) â†” âˆƒ a, q a)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Continuous_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "instIsCommutativeInfToInf.proof_1",
   "Inf.inf",
   "SemilatticeInf",
   "IsCommutative"],
  "name": "instIsCommutativeInfToInf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±], IsCommutative Î± fun x x_1 â†¦ x âŠ“ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰¤]_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.inductionOnâ‚‚",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.append_assoc",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "add_le_add_left",
   "Multiset.instPartialOrderMultiset",
   "instHAppend",
   "Setoid.r",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Zero.mk",
   "Quotient.inductionOnâ‚ƒ",
   "Quotient.inductionOn",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
  "constType":
  "âˆ€ {Î± : Type u_1} (sâ‚ sâ‚‚ : Multiset Î±), sâ‚ â‰¤ sâ‚‚ â†’ âˆ€ (a : Multiset Î±), a + sâ‚ â‰¤ a + sâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "mem_of_mem_nhds",
   "Pure.pure",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Filter.instPureFilter",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "Filter.mem_pure",
   "Pi.hasLe",
   "instMembershipSetFilter"],
  "name": "pure_le_nhds",
  "constType": "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], pure â‰¤ nhds",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet.mk",
   "Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.rec",
  "constType":
  "{Î± : Type u_4} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsUpperSet Î± â†’ Sort u} â†’\n        ((topology_eq_upperSetTopology : t = Topology.upperSet Î±) â†’ motive (_ : Topology.IsUpperSet Î±)) â†’\n          (t : Topology.IsUpperSet Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not"],
  "name": "decide_eq_false.match_1",
  "constType":
  "âˆ€ {p : Prop} (motive : Decidable p â†’ Â¬p â†’ Prop) (x : Decidable p) (x_1 : Â¬p),\n  (âˆ€ (hâ‚ : p) (hâ‚‚ : Â¬p), motive (isTrue hâ‚) hâ‚‚) â†’ (âˆ€ (h x : Â¬p), motive (isFalse h) x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "iff_of_eq", "and_true", "True"],
  "name": "and_true_iff",
  "constType": "âˆ€ (p : Prop), p âˆ§ True â†” p",
  "constCategory": "Theorem"},
 {"references":
  ["List.instUnionList",
   "List.Nodup",
   "List.rec",
   "DecidableEq",
   "List.Nodup.insert",
   "List",
   "Union.union"],
  "name": "List.Nodup.union",
  "constType":
  "âˆ€ {Î± : Type u} {lâ‚‚ : List Î±} [inst : DecidableEq Î±] (lâ‚ : List Î±), List.Nodup lâ‚‚ â†’ List.Nodup (lâ‚ âˆª lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Quotient"],
  "name": "Trunc",
  "constType": "Sort u â†’ Sort u",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.ofLower",
  "constType": "{Î± : Type u_1} â†’ Topology.WithLower Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} â†’ [self : AddRightCancelMonoid M] â†’ AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "le_himp_iff",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "propext",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedHeytingAlgebra Î±] {a b c : Î±}, (a â‰¤ b â‡¨ c) = (a âŠ“ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_false",
   "False",
   "Lean.Data.AC.insert",
   "List",
   "Lean.Data.AC.insert_nonEmpty",
   "List.nil",
   "Nat",
   "Eq"],
  "name": "Init.Data.AC._auxLemma.1",
  "constType":
  "âˆ€ {x : â„•} {xs : List â„•}, (Lean.Data.AC.insert x xs = []) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Function.comp",
   "ContinuousAt",
   "Inducing",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "Continuous",
   "TopologicalSpace",
   "congr",
   "Mathlib.Topology.Maps._auxLemma.1",
   "Inducing.continuousAt_iff",
   "congrArg",
   "Eq.trans",
   "id",
   "congrFun"],
  "name": "Inducing.continuous_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³}, Inducing g â†’ (Continuous f â†” Continuous (g âˆ˜ f))",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "setOf",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.comap.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (m : Î± â†’ Î²) (f : Filter Î²) {x : Set Î±} (motive : x âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s} â†’ Prop)\n  (x_1 : x âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s}),\n  (âˆ€ (a' : Set Î²) (ha' : a' âˆˆ f) (ma'a : m â»Â¹' a' âŠ† x), motive (_ : âˆƒ t âˆˆ f, m â»Â¹' t âŠ† x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references": ["Or", "False", "propext", "or_false_iff", "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.13",
  "constType": "âˆ€ (p : Prop), (p âˆ¨ False) = p",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termÎ©",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["SupSet", "outParam", "FunLike", "sSupHomClass"],
  "name": "sSupHomClass.toFunLike",
  "constType":
  "{F : Type u_8} â†’\n  {Î± : outParam (Type u_9)} â†’\n    {Î² : outParam (Type u_10)} â†’\n      [inst : SupSet Î±] â†’ [inst_1 : SupSet Î²] â†’ [self : sSupHomClass F Î± Î²] â†’ FunLike F Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toCompleteLattice : CompleteLattice Î±] â†’\n    (âˆ€ {Î¹ : Type u} {Îº : Î¹ â†’ Type u} (f : (a : Î¹) â†’ Îº a â†’ Î±), â¨… a, â¨† b, f a b = â¨† g, â¨… a, f a (g a)) â†’\n      CompletelyDistribLattice Î±",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.instPreorder",
   "funext",
   "Iff.rfl",
   "TopologicalSpace.ext",
   "Set",
   "Topology.lowerSet",
   "Eq.refl",
   "Topology.upperSet",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "Topology.IsLowerSet",
   "Eq",
   "Topology.IsUpperSet",
   "Topology.IsUpperSet.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "TopologicalSpace",
   "OrderDual",
   "Topology.IsLowerSet.topology_eq",
   "IsOpen",
   "id"],
  "name": "OrderDual.instIsUpperSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±],\n  Topology.IsUpperSet Î±áµ’áµˆ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Syntax.casesOn",
   "Array",
   "Lean.Syntax.missing",
   "List",
   "String",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.setKind.match_1",
  "constType":
  "(motive : Lean.Syntax â†’ Sort u_1) â†’\n  (stx : Lean.Syntax) â†’\n    ((info : Lean.SourceInfo) â†’\n        (kind : Lean.SyntaxNodeKind) â†’ (args : Array Lean.Syntax) â†’ motive (Lean.Syntax.node info kind args)) â†’\n      ((x : Lean.Syntax) â†’ motive x) â†’ motive stx",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context",
   "Lean.IsCommutative",
   "Option"],
  "name": "Lean.Data.AC.Context.comm",
  "constType":
  "{Î± : Sort u} â†’ (self : Lean.Data.AC.Context Î±) â†’ Option (Lean.IsCommutative self.op)",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.topology_eq_upperSetTopology",
  "constType":
  "âˆ€ {Î± : Type u_4} [t : TopologicalSpace Î±] [inst : Preorder Î±] [self : Topology.IsUpperSet Î±], t = Topology.upperSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Filter.GenerateSets", "Set", "Set.instMembershipSet"],
  "name": "Filter.GenerateSets.basic",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {s : Set Î±}, s âˆˆ g â†’ Filter.GenerateSets g s",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.IsOpen", "TopologicalSpace", "Set.univ"],
  "name": "TopologicalSpace.isOpen_univ",
  "constType":
  "âˆ€ {Î± : Type u} [self : TopologicalSpace Î±], TopologicalSpace.IsOpen Set.univ",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Exists.fst.match_1",
  "constType":
  "âˆ€ {b : Prop} {p : b â†’ Prop} (motive : Exists p â†’ Prop) (x : Exists p),\n  (âˆ€ (h : b) (h_1 : p h), motive (_ : Exists p)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Option.noConfusion",
   "Option.some",
   "Eq.casesOn",
   "Eq.symm",
   "Eq.propIntro",
   "Option",
   "Eq"],
  "name": "Option.some.injEq",
  "constType":
  "âˆ€ {Î± : Type u} (val val_1 : Î±), (some val = some val_1) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references": ["Prod", "semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.modifyGet",
  "constType":
  "{Ïƒ : semiOutParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadStateOf Ïƒ m] â†’ {Î± : Type u} â†’ (Ïƒ â†’ Î± Ã— Ïƒ) â†’ m Î±",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Lean.Name â†’ String â†’ Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_12"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.IsUpperSet.topology_eq_upperSetTopology",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.topology_eq",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±],\n  inst_1 = Topology.upperSet Î±",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Min.min",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Nat.min_succ_succ",
   "List.length",
   "Nat.zero_min",
   "List.take",
   "True",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "List.take_nil",
   "of_eq_true",
   "List",
   "PUnit",
   "congr",
   "Nat.min_zero",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "instMinNat",
   "congrArg",
   "Nat.succ",
   "List.length_take.match_1",
   "Eq.trans"],
  "name": "List.length_take",
  "constType":
  "âˆ€ {Î± : Type u_1} (i : â„•) (l : List Î±), List.length (List.take i l) = min i (List.length l)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.getArgs",
   "OfNat.ofNat",
   "GE.ge",
   "Nat.sub",
   "Lean.Name.mkStr1",
   "EStateM.Result",
   "Lean.Syntax.node4",
   "EStateM.Result.error",
   "Lean.TSyntax",
   "Array",
   "Decidable.casesOn",
   "PUnit.unit",
   "instLENat",
   "Lean.replaceRef",
   "Array.append",
   "Decidable",
   "instOfNatNat",
   "List.nil",
   "Lean.SourceInfo.fromRef",
   "Nat",
   "Lean.Name.anonymous",
   "Nat.decLe",
   "Array.extract",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.Syntax.getNumArgs",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "LE.le",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "Lean.SourceInfo.none",
   "Bool.casesOn",
   "List",
   "Bool.false",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "Not",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Iff",
   "Iff.rfl",
   "Set",
   "SetLike.instMembership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.mem_coe",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x âˆˆ â†‘p â†” x âˆˆ p",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_GenLoop_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Trans", "Eq.rec", "Trans.mk", "Eq"],
  "name": "instTransEq_1",
  "constType":
  "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (r : Î± â†’ Î² â†’ Sort u) â†’ Trans r Eq r",
  "constCategory": "Definition"},
 {"references":
  ["Prod.mk.inj_iff",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Prod.snd",
   "Iff",
   "Iff.rfl",
   "propext",
   "Prod.mk",
   "Eq.refl",
   "Prod",
   "Prod.fst",
   "id",
   "Eq"],
  "name": "Prod.ext_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p q : Î± Ã— Î²}, p = q â†” p.1 = q.1 âˆ§ p.2 = q.2",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadWithReader"],
  "name": "MonadWithReader.mk",
  "constType":
  "{Ï : outParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ ({Î± : Type u} â†’ (Ï â†’ Ï) â†’ m Î± â†’ m Î±) â†’ MonadWithReader Ï m",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "SupSet.sSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²]\n  (gi : GaloisCoinsertion l u) (s : Set Î±áµ’áµˆáµ’áµˆ) (a : Î±áµ’áµˆáµ’áµˆ), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "Prod.snd",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Prod.fst",
   "Exists.intro",
   "And.left",
   "Set.instMembershipSet",
   "Set.Nonempty.fst.match_1"],
  "name": "Set.Nonempty.fst",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, Set.Nonempty (s Ã—Ë¢ t) â†’ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "GaloisCoinsertion.liftCompleteLattice.proof_2",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "GaloisCoinsertion.liftCompleteLattice.proof_7",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "SupSet.mk",
   "CompleteLattice.toBot",
   "CompleteLattice.toLattice",
   "GaloisCoinsertion",
   "GaloisCoinsertion.liftCompleteLattice.proof_6",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice",
   "CompleteLattice.toSupSet",
   "GaloisCoinsertion.liftCompleteLattice.proof_1",
   "GaloisCoinsertion.choice",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "GaloisCoinsertion.liftCompleteLattice.proof_4",
   "Function.comp",
   "FunLike.coe",
   "SupSet.sSup",
   "GaloisCoinsertion.liftCompleteLattice.proof_3",
   "GaloisCoinsertion.dual",
   "Equiv.instFunLikeEquiv",
   "PartialOrder",
   "InfSet.mk",
   "OrderDual.ofDual",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "CompleteLattice.toTop",
   "OrderDual",
   "GaloisCoinsertion.liftCompleteLattice.proof_5",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisCoinsertion.liftCompleteLattice",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’\n      {u : Î² â†’ Î±} â†’ [inst : PartialOrder Î±] â†’ [inst_1 : CompleteLattice Î²] â†’ GaloisCoinsertion l u â†’ CompleteLattice Î±",
  "constCategory": "Definition"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ HAdd Î± Î² Î³",
  "constCategory": "Other"},
 {"references": [],
  "name": "Max",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "Set",
   "HasCompl.compl",
   "ClosedIciTopology.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "Set.Ici",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "rfl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "isOpen_compl_iff",
   "Preorder.toLE",
   "Iff.mpr",
   "Topology.IsLower.isOpen_iff_generate_Ici_compl",
   "Eq",
   "Iff.mp",
   "Topology.IsLower",
   "TopologicalSpace",
   "IsClosed",
   "ClosedIciTopology",
   "IsOpen"],
  "name": "Topology.IsLower.instClosedIciTopology.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±], ClosedIciTopology Î±",
  "constCategory": "Theorem"},
 {"references":
  ["iSup_congr_Prop",
   "Iff",
   "iInf",
   "OrderDual",
   "InfSet",
   "OrderDual.supSet",
   "Iff.mpr",
   "Eq"],
  "name": "iInf_congr_Prop",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : InfSet Î±] {p q : Prop} {fâ‚ : p â†’ Î±} {fâ‚‚ : q â†’ Î±} (pq : p â†” q),\n  (âˆ€ (x : q), fâ‚ (_ : p) = fâ‚‚ x) â†’ iInf fâ‚ = iInf fâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Or",
   "Nat.below",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "LE.le",
   "instLTNat",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.eq_or_lt_of_le.match_2",
   "instLENat",
   "Nat.zero",
   "Or.inl",
   "Nat.le_of_succ_le_succ",
   "Nat.eq_or_lt_of_le.match_1",
   "Eq.rec",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.zero_le",
   "absurd",
   "Nat.succ"],
  "name": "Nat.eq_or_lt_of_le",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ n = m âˆ¨ n < m",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.ofLowerSet",
  "constType": "{Î± : Type u_1} â†’ Topology.WithLowerSet Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "inferInstanceAs",
   "OrderDual",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder.proof_1",
  "constType": "âˆ€ (Î± : Type u_1) [inst : PartialOrder Î±] (a : Î±áµ’áµˆ), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.EvalInformation"],
  "name": "Lean.Data.AC.EvalInformation.arbitrary",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ [self : Lean.Data.AC.EvalInformation Î± Î²] â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "absurd"],
  "name": "instDecidableForAll.proof_1",
  "constType": "âˆ€ {p q : Prop}, p â†’ Â¬q â†’ (p â†’ q) â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "DecidableEq",
   "Set.toFinset",
   "Finset.image",
   "Set",
   "Set.fintypeImage.proof_1",
   "Set.image",
   "Fintype.ofFinset"],
  "name": "Set.fintypeImage",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’ [inst : DecidableEq Î²] â†’ (s : Set Î±) â†’ (f : Î± â†’ Î²) â†’ [inst : Fintype â†‘s] â†’ Fintype â†‘(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["outParam",
   "MonadExcept",
   "tryCatchThe",
   "MonadExcept.mk",
   "throwThe",
   "MonadExceptOf"],
  "name": "instMonadExcept",
  "constType":
  "(Îµ : outParam (Type u)) â†’ (m : Type v â†’ Type w) â†’ [inst : MonadExceptOf Îµ m] â†’ MonadExcept Îµ m",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder â„•",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Disjoint.symm",
   "Disjoint",
   "HeytingAlgebra.toBoundedOrder",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "disjoint_compl_left",
   "HeytingAlgebra.toHasCompl",
   "Preorder.toLE",
   "BoundedOrder.toOrderBot"],
  "name": "disjoint_compl_right",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a : Î±}, Disjoint a aá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "False",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "And",
   "Nat.instModNat",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "Nat.not_le_of_gt",
   "Eq.rec",
   "LT.lt",
   "HMod.hMod",
   "Not",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "if_neg",
   "Nat.decLe"],
  "name": "Nat.mod_eq_of_lt",
  "constType": "âˆ€ {a b : â„•}, a < b â†’ a % b = a",
  "constCategory": "Theorem"},
 {"references":
  ["outParam", "SetLike", "Function.Injective", "Set", "SetLike.coe"],
  "name": "SetLike.coe_injective'",
  "constType":
  "âˆ€ {A : Type u_1} {B : outParam (Type u_2)} [self : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Definition"},
 {"references": ["SizeOf", "Nat", "SizeOf.mk"],
  "name": "instSizeOfNat",
  "constType": "SizeOf â„•",
  "constCategory": "Definition"},
 {"references": ["Ne", "Not", "rfl", "Eq"],
  "name": "ne_eq",
  "constType": "âˆ€ {Î± : Sort u_1} (a b : Î±), (a â‰  b) = Â¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["congr_fun",
   "Filter.map",
   "Function.comp",
   "Filter",
   "Filter.map_compose",
   "Eq"],
  "name": "Filter.map_map",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {f : Filter Î±} {m : Î± â†’ Î²} {m' : Î² â†’ Î³},\n  Filter.map m' (Filter.map m f) = Filter.map (m' âˆ˜ m) f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sup",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Preorder.toLE",
   "disjoint_compl_right",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "Disjoint.eq_bot",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "inf_compl_self",
  "constType": "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] (a : Î±), a âŠ“ aá¶œ = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.instMembershipList",
   "List",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "List.mem_map_of_injective.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {a : Î±} {l : List Î±} (motive : (âˆƒ a_1 âˆˆ l, f a_1 = f a) â†’ Prop)\n  (x : âˆƒ a_1 âˆˆ l, f a_1 = f a), (âˆ€ (w : Î±) (m' : w âˆˆ l) (e : f w = f a), motive (_ : âˆƒ a_1 âˆˆ l, f a_1 = f a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin.mk", "Fin", "Fin.casesOn"],
  "name": "Fin.succ.match_1",
  "constType":
  "{n : â„•} â†’\n  (motive : Fin n â†’ Sort u_1) â†’ (x : Fin n) â†’ ((i : â„•) â†’ (h : i < n) â†’ motive { val := i, isLt := h }) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.Pairwise.chain.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±} (motive : (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l â†’ Prop)\n  (x : (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l),\n  (âˆ€ (r : âˆ€ a' âˆˆ l, R a a') (p' : List.Pairwise R l), motive (_ : (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "List.Sublist",
   "List.Mem.tail",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Mem",
   "List.Sublist.slnil",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.below.consâ‚‚",
   "List.Sublist.consâ‚‚",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Sublist.subset.match_1._@.Std.Data.List.Lemmas._hyg.8578",
  "constType":
  "âˆ€ {Î± : Type u_1}\n  (motive : (lâ‚‚ lâ‚ : List Î±) â†’ (x : List.Sublist lâ‚ lâ‚‚) â†’ (x_1 : Î±) â†’ x_1 âˆˆ lâ‚ â†’ List.Sublist.below x â†’ Prop)\n  (lâ‚‚ lâ‚ : List Î±) (x : List.Sublist lâ‚ lâ‚‚) (x_1 : Î±) (x_2 : x_1 âˆˆ lâ‚) (h_below : List.Sublist.below x),\n  (âˆ€ (x : Î±) (h : x âˆˆ []),\n      motive [] [] (_ : List.Sublist [] []) x h (_ : List.Sublist.below (_ : List.Sublist [] []))) â†’\n    (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (s : List.Sublist lâ‚ lâ‚‚) (x : Î±) (h : x âˆˆ lâ‚) (h_2 : List.Sublist.below s)\n        (a_1 : âˆ€ x âˆˆ lâ‚, x âˆˆ lâ‚‚),\n        motive (a :: lâ‚‚) lâ‚ (_ : List.Sublist lâ‚ (a :: lâ‚‚)) x h\n          (_ : List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚)))) â†’\n      (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (a_1 : List.Sublist lâ‚ lâ‚‚) (h : List.Sublist.below a_1) (a_2 : âˆ€ x âˆˆ lâ‚, x âˆˆ lâ‚‚),\n          motive (a :: lâ‚‚) (a :: lâ‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)) a (_ : List.Mem a (a :: lâ‚))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n        (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (s : List.Sublist lâ‚ lâ‚‚) (a_1 : Î±) (h : List.Mem a_1 lâ‚)\n            (h_4 : List.Sublist.below s) (a_2 : âˆ€ x âˆˆ lâ‚, x âˆˆ lâ‚‚),\n            motive (a :: lâ‚‚) (a :: lâ‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)) a_1 (_ : List.Mem a_1 (a :: lâ‚))\n              (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n          motive lâ‚‚ lâ‚ x x_1 x_2 h_below",
  "constCategory": "Definition"},
 {"references": ["InvImage.accessible.proof_1", "InvImage", "Acc"],
  "name": "InvImage.accessible",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {r : Î² â†’ Î² â†’ Prop} {a : Î±} (f : Î± â†’ Î²), Acc r (f a) â†’ Acc (InvImage r f) a",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "Preorder",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisInsertion.mk",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’\n        {l : Î± â†’ Î²} â†’\n          {u : Î² â†’ Î±} â†’\n            (choice : (x : Î±) â†’ u (l x) â‰¤ x â†’ Î²) â†’\n              GaloisConnection l u â†’\n                (âˆ€ (x : Î²), x â‰¤ l (u x)) â†’ (âˆ€ (a : Î±) (h : u (l a) â‰¤ a), choice a h = l a) â†’ GaloisInsertion l u",
  "constCategory": "Other"},
 {"references": ["InfSet", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toInfSet",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteSemilatticeInf Î±] â†’ InfSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.IsOpen_of._closed_14",
   "Topology.IsOpen_of._closed_3"],
  "name": "Topology.IsOpen_of._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "List",
   "And.intro",
   "Exists.intro",
   "List.map",
   "rfl",
   "Iff.mpr",
   "Eq"],
  "name": "List.mem_map_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {a : Î±} {l : List Î±} (f : Î± â†’ Î²), a âˆˆ l â†’ f a âˆˆ List.map f l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "GeneralizedCoheytingAlgebra.mk",
   "GeneralizedBooleanAlgebra.toSDiff",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "OrderBot",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_2",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_1",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "SDiff.mk",
   "GeneralizedCoheytingAlgebra",
   "GeneralizedBooleanAlgebra",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
  "constType":
  "{Î± : Type u} â†’ [inst : GeneralizedBooleanAlgebra Î±] â†’ GeneralizedCoheytingAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "List.Nodup",
   "propext",
   "List",
   "List.Perm.nodup_iff",
   "List.isSetoid",
   "Eq"],
  "name": "Multiset.Nodup.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (x x_1 : List Î±), Setoid.r x x_1 â†’ List.Nodup x = List.Nodup x_1",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded.apply",
   "WellFounded.intro",
   "WellFounded",
   "InvImage",
   "InvImage.accessible"],
  "name": "InvImage.wf.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {r : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²), WellFounded r â†’ WellFounded (InvImage r f)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Eq.rec",
   "AddMonoidHom.toZeroHom",
   "Eq.symm",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.casesOn",
   "FunLike.coe_injective'"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_1",
  "constType":
  "âˆ€ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f g : M â†’+ N),\n  (fun f â†¦ f.toFun) f = (fun f â†¦ f.toFun) g â†’ f = g",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{Î± : Type u_5} â†’ [self : ConditionallyCompleteLattice Î±] â†’ InfSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "And",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.42",
   "Mathlib.Data.Set.Image._auxLemma.4",
   "congr",
   "Singleton.singleton",
   "Set.image",
   "congrArg",
   "Eq.trans"],
  "name": "Set.image_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {a : Î±}, f '' {a} = {f a}",
  "constCategory": "Theorem"},
 {"references": ["maxOfLe", "instLENat", "Max", "Nat", "Nat.decLe"],
  "name": "Nat.instMaxNat",
  "constType": "Max â„•",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.replicate.match_1",
  "constType":
  "{Î± : Type u_2} â†’\n  (motive : â„• â†’ Î± â†’ Sort u_1) â†’\n    (x : â„•) â†’ (x_1 : Î±) â†’ ((x : Î±) â†’ motive 0 x) â†’ ((n : â„•) â†’ (a : Î±) â†’ motive (Nat.succ n) a) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.instHasSubsetSet",
   "Set",
   "le_sInf",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.sInter",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.subset_sInter",
  "constType":
  "âˆ€ {Î± : Type u_1} {S : Set (Set Î±)} {t : Set Î±}, (âˆ€ t' âˆˆ S, t âŠ† t') â†’ t âŠ† â‹‚â‚€ S",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddRightCancelMonoid"],
  "name": "AddRightCancelMonoid.toZero",
  "constType": "{M : Type u} â†’ [self : AddRightCancelMonoid M] â†’ Zero M",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Preorder",
   "GaloisInsertion",
   "PartialOrder"],
  "name": "GaloisInsertion.liftBoundedOrder.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : Preorder Î±],\n  GaloisInsertion l u â†’ GaloisConnection l u",
  "constCategory": "Theorem"},
 {"references": ["Or", "False", "Or.elim.match_1", "Not"],
  "name": "instDecidableOr.proof_1",
  "constType": "âˆ€ {p q : Prop}, Â¬p â†’ Â¬q â†’ p âˆ¨ q â†’ False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Order.Frame",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Pi.generalizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "Pi.heytingAlgebra.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ HeytingAlgebra (Î± i)] (a : (i : Î¹) â†’ Î± i), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "âˆ€ {G : Type u} [inst : Add G], (âˆ€ (a b c : G), a + b = a + c â†’ b = c) â†’ IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} â†’ [self : AddLeftCancelMonoid M] â†’ AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.ParserDescr",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["List.cons", "List", "List.replicate", "Eq.refl", "Nat", "Nat.succ", "Eq"],
  "name": "_private.Std.Data.List.Lemmas.0.List.replicate._eq_2",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (n : â„•), List.replicate (Nat.succ n) x = x :: List.replicate n x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Quot",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Prop) â†’ Sort u",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "And",
   "Or",
   "Iff",
   "False",
   "Or.inl",
   "Or.inr",
   "Decidable.not_and_iff_or_not.match_1",
   "Decidable",
   "And.comm.match_1",
   "Not",
   "And.intro",
   "Decidable.not_and_iff_or_not.match_2",
   "absurd"],
  "name": "Decidable.not_and_iff_or_not",
  "constType":
  "âˆ€ (p q : Prop) [dâ‚ : Decidable p] [dâ‚‚ : Decidable q], Â¬(p âˆ§ q) â†” Â¬p âˆ¨ Â¬q",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.ofUpper._cstage1",
  "constType": "{Î± : Type u_1} â†’ Topology.WithUpper Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "TopologicalSpace",
   "Set.sUnion",
   "IsOpen",
   "interior",
   "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.interior._eq_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), interior s = â‹ƒâ‚€ {t | IsOpen t âˆ§ t âŠ† s}",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.get",
  "constType":
  "{Ïƒ : semiOutParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadStateOf Ïƒ m] â†’ m Ïƒ",
  "constCategory": "Definition"},
 {"references":
  ["Set.sUnion_eq_compl_sInter_compl",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Set",
   "Eq.refl",
   "HasCompl.compl",
   "Set.compl_compl_image",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Set.sInter",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "id",
   "Eq"],
  "name": "Set.compl_sInter",
  "constType": "âˆ€ {Î± : Type u_1} (S : Set (Set Î±)), (â‹‚â‚€ S)á¶œ = â‹ƒâ‚€ (compl '' S)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{Î± : Type u_1} â†’ [inst : CompleteLattice Î±] â†’ ConditionallyCompleteLattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "HEq",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "Unit",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.length",
   "List.Sublist.slnil",
   "LE.le",
   "Eq",
   "Eq.ndrec",
   "instLENat",
   "HEq.refl",
   "List",
   "List.Sublist.below.consâ‚‚",
   "Unit.unit",
   "List.Sublist.consâ‚‚",
   "List.nil",
   "Nat",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Sublist.reverse.match_1._@.Std.Data.List.Lemmas._hyg.8887",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (lâ‚‚ lâ‚ : List Î±) â†’ (x : List.Sublist lâ‚ lâ‚‚) â†’ List.Sublist.below x â†’ Prop) (lâ‚‚ lâ‚ : List Î±)\n  (x : List.Sublist lâ‚ lâ‚‚) (h_below : List.Sublist.below x),\n  (Unit â†’ motive [] [] (_ : List.Sublist [] []) (_ : List.Sublist.below (_ : List.Sublist [] []))) â†’\n    (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (h : List.Sublist lâ‚ lâ‚‚) (h_2 : List.Sublist.below h)\n        (a_1 : List.length lâ‚ â‰¤ List.length lâ‚‚),\n        motive (a :: lâ‚‚) lâ‚ (_ : List.Sublist lâ‚ (a :: lâ‚‚)) (_ : List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚)))) â†’\n      (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (h : List.Sublist lâ‚ lâ‚‚) (h_3 : List.Sublist.below h)\n          (a_1 : List.length lâ‚ â‰¤ List.length lâ‚‚),\n          motive (a :: lâ‚‚) (a :: lâ‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n        motive lâ‚‚ lâ‚ x h_below",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.ne_of_lt",
   "Nat.zero_lt_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.linearOrderedCommSemiring.proof_5",
  "constType": "Nontrivial â„•",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "âˆ€ (p : Prop), (p â†” p) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.IsNeutral",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Î± â†’ Type",
  "constCategory": "Other"},
 {"references": ["Iff", "iff_true_intro", "True", "id"],
  "name": "imp_self",
  "constType": "âˆ€ {a : Prop}, a â†’ a â†” True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "CompleteLattice.le_sSup",
   "CompleteSemilatticeSup",
   "CompleteLattice.sSup_le",
   "CompleteLattice",
   "CompleteSemilatticeSup.mk",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeSup",
  "constType":
  "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ CompleteSemilatticeSup Î±",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String.mk", "String", "String.casesOn"],
  "name": "String.decEq.match_1",
  "constType":
  "(motive : String â†’ String â†’ Sort u_1) â†’\n  (sâ‚ sâ‚‚ : String) â†’ ((sâ‚ sâ‚‚ : List Char) â†’ motive { data := sâ‚ } { data := sâ‚‚ }) â†’ motive sâ‚ sâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_GenLoop_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{Î± : Sort u} â†’ {p : Î± â†’ Prop} â†’ Subtype p â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instSubNat",
   "Eq.refl",
   "instLTNat",
   "True",
   "Eq",
   "PProd",
   "Nat.succ_sub_succ",
   "Eq.mpr",
   "Nat.lt_of_succ_lt_succ",
   "eq_false'",
   "PUnit",
   "Nat.sub_ne_zero_of_lt.match_1",
   "instOfNatNat",
   "Nat",
   "not_false_eq_true",
   "Nat.succ",
   "absurd",
   "Eq.trans",
   "Nat.not_lt_zero",
   "id",
   "instHSub",
   "Ne",
   "Nat.below",
   "Nat.brecOn",
   "False",
   "HSub.hSub",
   "PProd.fst",
   "Nat.rec",
   "Eq.ndrec",
   "of_eq_true",
   "Nat.noConfusion",
   "LT.lt",
   "Nat.lt_irrefl",
   "Not",
   "congrArg"],
  "name": "Nat.sub_ne_zero_of_lt",
  "constType": "âˆ€ {a b : â„•}, a < b â†’ b - a â‰  0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Set.instSProd",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Prod.fst",
   "Set.univ",
   "True",
   "Set.inter_univ",
   "Eq",
   "of_eq_true",
   "SProd.sprod",
   "Prod",
   "congrArg",
   "Eq.trans",
   "Set.instInterSet",
   "congrFun"],
  "name": "Set.prod_univ",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±}, s Ã—Ë¢ Set.univ = Prod.fst â»Â¹' s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ReaderT",
  "constType": "Type u â†’ (Type u â†’ Type v) â†’ Type u â†’ Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "forall_congr'",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (a : Î±), p a â†” q a) â†’ ((âˆ€ (a : Î±), p a) â†” âˆ€ (a : Î±), q a)",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.nodup_dedup",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.dedup"],
  "name": "Multiset.nodup_dedup",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (s : Multiset Î±), Multiset.Nodup (Multiset.dedup s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.topology_eq",
   "Equiv",
   "induced_id",
   "Topology.WithUpper",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Inducing.mk",
   "Topology.IsUpper",
   "Eq.refl",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "Topology.WithUpper.ofUpper",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Topology.upper",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "id"],
  "name": "Topology.IsUpper.WithUpperHomeomorph.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±],\n  Inducing â†‘Topology.WithUpper.ofUpper",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ DecidableRel fun x x_1 â†¦ x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "IsLowerSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Topology.WithLowerSet",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsLowerSet.WithLowerSetHomeomorph._spec_1",
  "constType":
  "(Î± : Type u_1) â†’\n  (inst : Preorder Î±) â†’\n    (inst_1 : TopologicalSpace Î±) â†’\n      let _x_1 :=\n        { IsOpen := IsLowerSet, isOpen_univ := (_ : âˆ€ â¦ƒa b : Î±â¦„, b â‰¤ a â†’ a âˆˆ Set.univ â†’ b âˆˆ Set.univ),\n          isOpen_inter := (_ : âˆ€ (x x_1 : Set Î±), IsLowerSet x â†’ IsLowerSet x_1 â†’ IsLowerSet (Inter.interâœ x x_1)),\n          isOpen_sUnion := (_ : âˆ€ (x : Set (Set Î±)), (âˆ€ s âˆˆ x, IsLowerSet s) â†’ IsLowerSet (â‹ƒâ‚€ x)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithLowerSet Î± â‰ƒ Î±) â†’ Inducing â†‘f â†’ Topology.WithLowerSet Î± â‰ƒâ‚œ Î±",
  "constCategory": "Axiom"},
 {"references":
  ["And",
   "OfNat.ofNat",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div_rec_lemma.match_1",
  "constType":
  "âˆ€ {x y : â„•} (motive : 0 < y âˆ§ y â‰¤ x â†’ Prop) (x_1 : 0 < y âˆ§ y â‰¤ x),\n  (âˆ€ (ypos : 0 < y) (ylex : y â‰¤ x), motive (_ : 0 < y âˆ§ y â‰¤ x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references": ["Set.iUnion", "iSup_congr", "Set", "Set.instSupSetSet", "Eq"],
  "name": "Set.iUnion_congr",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {s t : Î¹ â†’ Set Î±}, (âˆ€ (i : Î¹), s i = t i) â†’ â‹ƒ i, s i = â‹ƒ i, t i",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "_auto._@.Mathlib.Data.List.Range._hyg.49",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "optParam",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "List.pairwise_lt_range'.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ â„• â†’ (x : optParam â„• 1) â†’ autoParam (0 < x) _autoâœ â†’ Prop) (x x_1 : â„•) (x_2 : optParam â„• 1)\n  (x_3 : autoParam (0 < x_2) _autoâœ),\n  (âˆ€ (x : â„•) (x_4 : optParam â„• 1) (x_5 : autoParam (0 < x_4) _autoâœ), motive x 0 x_4) â†’\n    (âˆ€ (s n : â„•) (x : optParam â„• 1) (h : autoParam (0 < x) _autoâœ), motive s (Nat.succ n) x) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["PProd"],
  "name": "PProd.snd",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ PProd Î± Î² â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length.match_1",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat"],
  "name": "List.length",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteBooleanAlgebra.toInfSet",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.sInf_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a",
  "constCategory": "Definition"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ Max Î±",
  "constCategory": "Definition"},
 {"references":
  ["outParam",
   "Continuous",
   "ContinuousMapClass",
   "TopologicalSpace",
   "FunLike.coe",
   "ContinuousMapClass.toFunLike"],
  "name": "ContinuousMapClass.map_continuous",
  "constType":
  "âˆ€ {F : Type u_1} {Î± : outParam (Type u_2)} {Î² : outParam (Type u_3)} [inst : TopologicalSpace Î±]\n  [inst_1 : TopologicalSpace Î²] [self : ContinuousMapClass F Î± Î²] (f : F), Continuous â†‘f",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HPow Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "instLENat",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.casesOn"],
  "name": "Nat.not_succ_le_zero.match_3",
  "constType":
  "âˆ€ (motive : (x : â„•) â†’ Nat.succ x â‰¤ 0 â†’ Prop) (x : â„•) (x_1 : Nat.succ x â‰¤ 0),\n  (âˆ€ (h : Nat.succ 0 â‰¤ 0), motive 0 h) â†’\n    (âˆ€ (n : â„•) (h : Nat.succ (Nat.succ n) â‰¤ 0), motive (Nat.succ n) h) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.prod",
   "Prod.snd",
   "Set",
   "Prod",
   "And.intro",
   "Prod.fst",
   "And.casesOn",
   "Set.instMembershipSet"],
  "name": "Filter.mem_prod_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (sâ‚ : Set Î±) (sâ‚‚ : Set Î²) (p : Î± Ã— Î²) (motive : p âˆˆ Set.prod sâ‚ sâ‚‚ â†’ Prop)\n  (x : p âˆˆ Set.prod sâ‚ sâ‚‚), (âˆ€ (h : p.1 âˆˆ sâ‚) (h' : p.2 âˆˆ sâ‚‚), motive (_ : p.1 âˆˆ sâ‚ âˆ§ p.2 âˆˆ sâ‚‚)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.iUnion",
   "CompleteAtomicBooleanAlgebra.toCompleteBooleanAlgebra",
   "Set",
   "Set.iInter",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "compl_iSup",
   "Eq"],
  "name": "Set.compl_iUnion",
  "constType":
  "âˆ€ {Î² : Type u_2} {Î¹ : Sort u_4} (s : Î¹ â†’ Set Î²), (â‹ƒ i, s i)á¶œ = â‹‚ i, (s i)á¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "congr",
   "Singleton.singleton",
   "Mathlib.Data.Finset.Basic._auxLemma.26",
   "congrArg",
   "Eq.trans",
   "Finset.instSingletonFinset"],
  "name": "Set.fintypeSingleton.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a a_1 : Î±), a_1 âˆˆ {a} â†” a_1 âˆˆ {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "IsUpperSet",
   "Preorder",
   "Set.Ici",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "forall_swap",
   "Iff.mp",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "congrArg",
   "Eq.trans"],
  "name": "IsUpperSet.Ici_subset",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, IsUpperSet s â†’ âˆ€ â¦ƒa : Î±â¦„, a âˆˆ s â†’ Set.Ici a âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.cons",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.subperm_cons.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) {lâ‚ lâ‚‚ : List Î±} (motive : a :: lâ‚ <+~ a :: lâ‚‚ â†’ Prop) (x : a :: lâ‚ <+~ a :: lâ‚‚),\n  (âˆ€ (l : List Î±) (p : l ~ a :: lâ‚) (s : List.Sublist l (a :: lâ‚‚)),\n      motive (_ : âˆƒ l, âˆƒ (_ : l ~ a :: lâ‚), List.Sublist l (a :: lâ‚‚))) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references": ["invImage", "WellFoundedRelation", "Nat.lt_wfRel", "Nat"],
  "name": "measure",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ â„•) â†’ WellFoundedRelation Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLowerSet.of_WithLowerSet_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithLowerSet.ofLowerSet.symm = Topology.WithLowerSet.toLowerSet",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Prod.snd",
   "setOf",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.instMembershipSet"],
  "name": "Set.prod",
  "constType": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ Set Î± â†’ Set Î² â†’ Set (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.le_total.match_1",
  "constType":
  "âˆ€ (m n : â„•) (motive : m < n âˆ¨ m â‰¥ n â†’ Prop) (x : m < n âˆ¨ m â‰¥ n),\n  (âˆ€ (h : m < n), motive (_ : m < n âˆ¨ m â‰¥ n)) â†’ (âˆ€ (h : m â‰¥ n), motive (_ : m < n âˆ¨ m â‰¥ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "BEq.beq",
   "List.cons",
   "BEq",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "Bool",
   "List.erase.match_1",
   "List.nil",
   "List.erase.match_2"],
  "name": "List.erase",
  "constType": "{Î± : Type u_1} â†’ [inst : BEq Î±] â†’ List Î± â†’ Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "iSup_exists.match_1",
  "constType":
  "âˆ€ {Î¹ : Sort u_1} {p : Î¹ â†’ Prop} (motive : Exists p â†’ Prop) (x : Exists p),\n  (âˆ€ (i : Î¹) (h : p i), motive (_ : Exists p)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.filter",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "Unit",
   "Bool.true",
   "Eq.refl",
   "List.erase.match_1",
   "Bool",
   "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
   "id",
   "Eq"],
  "name": "List.filter_cons_of_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {a : Î±} (l : List Î±), p a = true â†’ List.filter p (a :: l) = a :: List.filter p l",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Top.top",
   "OrderTop.le_top",
   "BoundedOrder.toOrderTop",
   "Prop.le",
   "LE.le",
   "Prop.boundedOrder"],
  "name": "Prop.heytingAlgebra.proof_1",
  "constType": "âˆ€ (a : Prop), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds_empty",
   "OrderDual.instPreorder",
   "EmptyCollection.emptyCollection",
   "Set",
   "lowerBounds",
   "OrderDual",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Set.univ",
   "Eq"],
  "name": "lowerBounds_empty",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±], lowerBounds âˆ… = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "And",
   "Iff",
   "Preorder.toLT",
   "Pi.partialOrder",
   "LT.lt",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "Not",
   "IsOpen",
   "Preorder.lt_iff_le_not_le"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b : TopologicalSpace Î±), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Â«termð“[â‰¥]_Â»._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[_]_Â»._closed_9"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Not", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_not_le.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (motive : (x x_1 : Î±) â†’ x â‰¤ x_1 â†’ Â¬x_1 â‰¤ x â†’ Prop) (x x_1 : Î±) (x_2 : x â‰¤ x_1)\n  (x_3 : Â¬x_1 â‰¤ x), (âˆ€ (_a _b : Î±) (hab : _a â‰¤ _b) (hba : Â¬_b â‰¤ _a), motive _a _b hab hba) â†’ motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.removeNeutrals.loop.match_2",
   "List.cons",
   "Lean.Data.AC.removeNeutrals.loop",
   "List",
   "Unit",
   "List.nil",
   "Lean.Data.AC.ContextInformation",
   "Lean.Data.AC.removeNeutrals.match_1",
   "Nat"],
  "name": "Lean.Data.AC.removeNeutrals",
  "constType":
  "{Î± : Sort u_1} â†’ [info : Lean.Data.AC.ContextInformation Î±] â†’ Î± â†’ List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.bot_le",
  "constType": "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (a : Î±), âŠ¥ â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "CompleteBooleanAlgebra.toSupSet",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.le_sSup",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±), âˆ€ a âˆˆ s, a â‰¤ sSup s",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Classical.choose", "Quot", "Quot.exists_rep", "Quot.mk", "Eq"],
  "name": "Quot.out",
  "constType": "{Î± : Sort u_1} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ Quot r â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.le.step",
   "Nat.le",
   "Nat.below",
   "Nat.brecOn",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.le_trans.match_1"],
  "name": "Nat.le_trans",
  "constType": "âˆ€ {n m k : â„•}, n â‰¤ m â†’ m â‰¤ k â†’ n â‰¤ k",
  "constCategory": "Theorem"},
 {"references":
  ["le_iSup_of_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iSup",
   "iSup_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "iSup_mono",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f g : Î¹ â†’ Î±}, (âˆ€ (i : Î¹), f i â‰¤ g i) â†’ iSup f â‰¤ iSup g",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "List.cons",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.replicate.match_1",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.replicate",
  "constType": "{Î± : Type u} â†’ â„• â†’ Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_4",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_6"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLower.toLower._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.toDualHomeomorph._lambda_1._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "PUnit.unit",
   "Lean.Syntax.missing",
   "List",
   "String",
   "PUnit",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax.rec",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.casesOn",
  "constType":
  "{motive_1 : Lean.Syntax â†’ Sort u} â†’\n  (t : Lean.Syntax) â†’\n    motive_1 Lean.Syntax.missing â†’\n      ((info : Lean.SourceInfo) â†’\n          (kind : Lean.SyntaxNodeKind) â†’ (args : Array Lean.Syntax) â†’ motive_1 (Lean.Syntax.node info kind args)) â†’\n        ((info : Lean.SourceInfo) â†’ (val : String) â†’ motive_1 (Lean.Syntax.atom info val)) â†’\n          ((info : Lean.SourceInfo) â†’\n              (rawVal : Substring) â†’\n                (val : Lean.Name) â†’\n                  (preresolved : List Lean.Syntax.Preresolved) â†’\n                    motive_1 (Lean.Syntax.ident info rawVal val preresolved)) â†’\n            motive_1 t",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.symm.match_1",
  "constType":
  "âˆ€ {a b : Prop} (motive : a âˆ§ b â†’ Prop) (x : a âˆ§ b), (âˆ€ (ha : a) (hb : b), motive (_ : a âˆ§ b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Iff.symm", "and_imp", "And", "Iff"],
  "name": "Prop.heytingAlgebra.proof_2",
  "constType": "âˆ€ (x x_1 x_2 : Prop), x â†’ x_1 â†’ x_2 â†” x âˆ§ x_1 â†’ x_2",
  "constCategory": "Theorem"},
 {"references": ["Char", "UInt32.toNat", "Nat", "Char.utf8Size"],
  "name": "String.csize",
  "constType": "Char â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "List.instLawfulBEqListInstBEqList.match_1",
   "BEq",
   "LawfulBEq",
   "Eq.refl",
   "List.casesOn",
   "beq_self_eq_true",
   "implies_congr",
   "rfl",
   "Eq",
   "BEq.beq",
   "Eq.mpr",
   "List.rec",
   "Bool.true",
   "Init.Core._auxLemma.1",
   "List.nil",
   "Eq.symm",
   "Eq.trans",
   "id",
   "List.cons",
   "Bool.true_and",
   "List.beq",
   "And",
   "Eq.ndrec",
   "List.instBEqList",
   "List",
   "and",
   "LawfulBEq.mk",
   "Bool.and_eq_true",
   "Bool",
   "And.intro",
   "congrArg",
   "List.cons.injEq",
   "congrFun"],
  "name": "List.instLawfulBEqListInstBEqList.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±], LawfulBEq (List Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "Union.union",
   "Set",
   "Singleton.singleton",
   "Insert.insert",
   "rfl",
   "Set.instUnionSet",
   "Eq",
   "Set.instInsertSet"],
  "name": "Set.insert_eq",
  "constType": "âˆ€ {Î± : Type u} (x : Î±) (s : Set Î±), insert x s = {x} âˆª s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "le_iSupâ‚‚",
   "iSup",
   "Exists.intro",
   "le_iSup",
   "iSup_le",
   "iSup_exists.match_1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "iSupâ‚‚_le",
   "CompleteLattice.toSupSet"],
  "name": "iSup_exists",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {p : Î¹ â†’ Prop} {f : Exists p â†’ Î±},\n  â¨† (x : Exists p), f x = â¨† i, â¨† (h : p i), f (_ : Exists p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "mem_of_mem_nhds.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {a : Î±} {s : Set Î±} (motive : (âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ a âˆˆ t) â†’ Prop)\n  (x : âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ a âˆˆ t),\n  (âˆ€ (_t : Set Î±) (ht : _t âŠ† s) (left : IsOpen _t) (hs : a âˆˆ _t), motive (_ : âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ a âˆˆ t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["SProd.sprod",
   "Inf.inf",
   "Filter.prod_inf_prod",
   "Filter.instInfFilter",
   "Prod",
   "Filter",
   "Filter.instSProd",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Topology.Constructions._auxLemma.11",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²}, (fâ‚ âŠ“ fâ‚‚) Ã—Ë¢ (gâ‚ âŠ“ gâ‚‚) = fâ‚ Ã—Ë¢ gâ‚ âŠ“ fâ‚‚ Ã—Ë¢ gâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "PartialOrder.toPreorder",
   "t0Space_iff_inseparable",
   "Set",
   "Set.Ici",
   "Iff.mpr",
   "PartialOrder",
   "Eq",
   "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.2",
   "Set.instSingletonSet",
   "Topology.IsLower",
   "Set.Ici_injective",
   "Eq.mp",
   "congr",
   "TopologicalSpace",
   "Singleton.singleton",
   "T0Space",
   "Inseparable",
   "congrArg",
   "Topology.IsLower.closure_singleton",
   "Eq.trans"],
  "name": "Topology.IsLower.t0Space.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsLower Î±], T0Space Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.ext",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.Subset.antisymm",
  "constType": "âˆ€ {Î± : Type u} {a b : Set Î±}, a âŠ† b â†’ b âŠ† a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.mk",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Sort v) â†’ HasEquiv Î±",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Set.preimage",
   "Set",
   "coinduced_le_iff_le_induced.match_1",
   "Exists.intro",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "TopologicalSpace.coinduced",
   "Eq",
   "Iff.intro",
   "And",
   "Iff",
   "Eq.rec",
   "TopologicalSpace",
   "And.intro",
   "TopologicalSpace.induced",
   "IsOpen"],
  "name": "coinduced_le_iff_le_induced",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {tÎ± : TopologicalSpace Î±} {tÎ² : TopologicalSpace Î²},\n  TopologicalSpace.coinduced f tÎ± â‰¤ tÎ² â†” tÎ± â‰¤ TopologicalSpace.induced f tÎ²",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.sup_le",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Preorder",
   "LE.le",
   "UpperSet",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "mem_upperClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {x : Î±}, x âˆˆ upperClosure s â†” âˆƒ a âˆˆ s, a â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.toFun", "Function.LeftInverse", "Equiv.invFun"],
  "name": "Equiv.left_inv",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (self : Î± â‰ƒ Î²), Function.LeftInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List.Perm", "propext", "List", "List.perm_cons", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.18",
  "constType":
  "âˆ€ {Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : List Î±}, (a :: lâ‚ ~ a :: lâ‚‚) = (lâ‚ ~ lâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "List.cons",
   "Nat.le",
   "HEq",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "instBEq",
   "List.indexOf",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "HEq.refl",
   "DecidableEq",
   "List",
   "Nat.noConfusion",
   "LT.lt",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.indexOf_get.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} (motive : (x : List Î±) â†’ List.indexOf a x < List.length x â†’ Prop)\n  (x : List Î±) (x_1 : List.indexOf a x < List.length x),\n  (âˆ€ (b : Î±) (l : List Î±) (h : List.indexOf a (b :: l) < List.length (b :: l)), motive (b :: l) h) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "Multiset",
   "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
   "CovariantClass.mk",
   "LE.le",
   "Multiset.instAddMultiset",
   "Iff.mpr",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1}, CovariantClass (Multiset Î±) (Multiset Î±) (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["T0Space.rec",
   "TopologicalSpace",
   "T0Space.mk",
   "T0Space",
   "Inseparable",
   "Eq"],
  "name": "T0Space.casesOn",
  "constType":
  "{Î± : Type u} â†’\n  [inst : TopologicalSpace Î±] â†’\n    {motive : T0Space Î± â†’ Sort u_1} â†’\n      (t : T0Space Î±) â†’ ((t0 : âˆ€ â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y) â†’ motive (_ : T0Space Î±)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Or",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.7",
   "congr",
   "congrArg",
   "Std.Logic._auxLemma.25",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun"],
  "name": "or_and_right",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_insert_iff",
   "Membership.mem",
   "Or",
   "propext",
   "Set",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.32",
  "constType":
  "âˆ€ {Î± : Type u} {x a : Î±} {s : Set Î±}, (x âˆˆ insert a s) = (x = a âˆ¨ x âˆˆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Prod.semilatticeSup",
   "SemilatticeSup.le_sup_right",
   "inferInstanceAs",
   "Sup.sup",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.lattice.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Lattice Î±] [inst_1 : Lattice Î²] (a b : Î± Ã— Î²), b â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{Î± : Type u} â†’ [inst : OrderedCancelAddCommMonoid Î±] â†’ AddCancelCommMonoid Î±",
  "constCategory": "Definition"},
 {"references": ["LowerSet", "Set", "LE"],
  "name": "LowerSet.carrier",
  "constType": "{Î± : Type u_6} â†’ [inst : LE Î±] â†’ LowerSet Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableEqList",
   "Eq.refl",
   "eq_true_of_decide",
   "Classical.em",
   "Lean.Data.AC.mergeIdem.loop",
   "implies_congr",
   "instDecidableEqNat",
   "True",
   "Eq",
   "ite",
   "Eq.mpr",
   "instDecidableNot",
   "Lean.Data.AC.List.two_step_induction",
   "eq_false'",
   "Bool.true",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "if_neg",
   "id",
   "true_implies",
   "Ne",
   "List.cons",
   "Or",
   "False",
   "eq_false_of_decide",
   "Or.casesOn",
   "instDecidableFalse",
   "eq_false",
   "if_pos",
   "False.elim",
   "of_eq_true",
   "Bool.false",
   "List",
   "Eq.mp",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Bool",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.mergeIdem_nonEmpty",
  "constType": "âˆ€ (e : List â„•), e â‰  [] â†’ Lean.Data.AC.mergeIdem e â‰  []",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.Mem.tail"],
  "name": "List.mem_cons_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} (y : Î±) {a : Î±} {l : List Î±}, a âˆˆ l â†’ a âˆˆ y :: l",
  "constCategory": "Theorem"},
 {"references": ["Nat.sub", "Sub", "Nat", "Sub.mk"],
  "name": "instSubNat",
  "constType": "Sub â„•",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Set.Elem",
   "Set",
   "Finset",
   "Set.instEmptyCollectionSet",
   "Fintype.ofFinset",
   "Set.fintypeEmpty.proof_1"],
  "name": "Set.fintypeEmpty",
  "constType": "{Î± : Type u} â†’ Fintype â†‘âˆ…",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Contravariant",
  "constType":
  "(M : Type u_1) â†’ (N : Type u_2) â†’ (M â†’ N â†’ N) â†’ (N â†’ N â†’ Prop) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["WellFoundedRelation.rel", "WellFoundedRelation", "WellFounded"],
  "name": "WellFoundedRelation.wf",
  "constType":
  "âˆ€ {Î± : Sort u} [self : WellFoundedRelation Î±], WellFounded WellFoundedRelation.rel",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termI^_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "isGLB_sInf",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Monotone.mem_lowerBounds_image",
   "And.left",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image",
   "GaloisInsertion.isGLB_of_u_image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±],\n  GaloisInsertion l u â†’ âˆ€ (s : Set Î²), u (l (sInf (u '' s))) â‰¤ sInf (u '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Variable",
   "Lean.Data.AC.Context",
   "List",
   "Lean.IsCommutative",
   "Lean.IsAssociative",
   "Lean.IsIdempotent",
   "Option"],
  "name": "Lean.Data.AC.Context.mk",
  "constType":
  "{Î± : Sort u} â†’\n  (op : Î± â†’ Î± â†’ Î±) â†’\n    Lean.IsAssociative op â†’\n      Option (Lean.IsCommutative op) â†’\n        Option (Lean.IsIdempotent op) â†’ List (Lean.Data.AC.Variable op) â†’ Î± â†’ Lean.Data.AC.Context Î±",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr", "Not", "Or.casesOn"],
  "name": "Decidable.not_and_iff_or_not.match_2",
  "constType":
  "âˆ€ (p q : Prop) (motive : Â¬p âˆ¨ Â¬q â†’ Prop) (h : Â¬p âˆ¨ Â¬q),\n  (âˆ€ (h : Â¬p), motive (_ : Â¬p âˆ¨ Â¬q)) â†’ (âˆ€ (h : Â¬q), motive (_ : Â¬p âˆ¨ Â¬q)) â†’ motive h",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{Î± : Type u} â†’ Î± â†’ Bot Î±",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Or", "Iff", "Or.symm"],
  "name": "Or.comm",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†” b âˆ¨ a",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike", "Set", "SetLike.coe_injective", "SetLike.coe", "Eq"],
  "name": "SetLike.ext'",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, â†‘p = â†‘q â†’ p = q",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "le_sup_right",
   "Sup.sup",
   "le_trans",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_of_le_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, c â‰¤ b â†’ c â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.instPreorderWithLower._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Classical.choice",
   "Classical.indefiniteDescription.proof_1",
   "Subtype"],
  "name": "Classical.indefiniteDescription",
  "constType": "{Î± : Sort u} â†’ (p : Î± â†’ Prop) â†’ (âˆƒ x, p x) â†’ { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "Nat.add_assoc.match_1",
   "PUnit",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.mul_assoc",
  "constType": "âˆ€ (n m k : â„•), n * m * k = n * (m * k)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{Î± : Type u_1} â†’ Membership Î± (Set Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 â†’ Type u_2",
  "constCategory": "Other"},
 {"references": ["SupSet", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toSupSet",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteSemilatticeSup Î±] â†’ SupSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "And.right",
   "Nat.gt_of_not_le",
   "Iff",
   "instLENat",
   "Nat.not_le_of_gt",
   "LT.lt",
   "Not",
   "Nat.le_of_lt",
   "And.intro",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_iff_le_not_le",
  "constType": "âˆ€ {m n : â„•}, m < n â†” m â‰¤ n âˆ§ Â¬n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "IsOpen.inter",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "OrderBot",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.of_eq",
   "Eq",
   "TopologicalSpace.IsTopologicalBasis.prod",
   "Topology.IsLower.isTopologicalBasis",
   "Eq.mpr",
   "Set.iUnion",
   "Topology.IsLower",
   "And.casesOn",
   "IsOpen",
   "Eq.trans",
   "Set.compl_iUnion",
   "Set.instSProd",
   "isClosed_Ici",
   "TopologicalSpace.generateFrom",
   "Set.image2",
   "Prod.snd",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "instTopologicalSpaceProd",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Prod.fst",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "propext",
   "Set.Finite.isOpen_biInter",
   "OrderBot.toBot",
   "congr",
   "Set.iInter",
   "Set.preimage_iInter",
   "le_antisymm",
   "congrArg",
   "congrFun",
   "SetLike.coe",
   "Set.Ici_bot",
   "Exists",
   "Set.prod_univ",
   "coe_upperClosure",
   "Topology.IsLower.instClosedIciTopology",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Exists.intro",
   "Set.Ici",
   "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
   "UpperSet",
   "True",
   "Set.univ_prod",
   "IsClosed.isOpen_compl",
   "Topology.lower",
   "Prod.instPreorderProd",
   "SProd.sprod",
   "upperClosure",
   "TopologicalSpace",
   "le_generateFrom",
   "Topology.IsLower.lowerBasis",
   "id",
   "eq_self",
   "Membership.mem",
   "Bot.bot",
   "TopologicalSpace.GenerateOpen.basic",
   "funext",
   "Set.preimage",
   "Set.iInter_congr_Prop",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.univ",
   "LE.le",
   "IsClosed.prod",
   "Set.Finite",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "Set.image2_subset_iff",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Prod.mk",
   "Prod",
   "Topology.IsLower.mk",
   "Set.instInterSet"],
  "name": "Topology.instIsLowerProd.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±]\n  [inst_3 : OrderBot Î±] [inst_4 : Preorder Î²] [inst_5 : TopologicalSpace Î²] [inst_6 : Topology.IsLower Î²]\n  [inst_7 : OrderBot Î²], Topology.IsLower (Î± Ã— Î²)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "Or.inr",
   "instOfNatNat",
   "Or.casesOn",
   "Nat",
   "instLTNat",
   "GT.gt",
   "Eq"],
  "name": "Nat.mod_eq_sub_mod.match_1",
  "constType":
  "âˆ€ {b : â„•} (motive : b = 0 âˆ¨ b > 0 â†’ Prop) (x : b = 0 âˆ¨ b > 0),\n  (âˆ€ (hâ‚ : b = 0), motive (_ : b = 0 âˆ¨ b > 0)) â†’ (âˆ€ (hâ‚ : b > 0), motive (_ : b = 0 âˆ¨ b > 0)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Eq.refl",
   "Filter",
   "Filter.Eventually",
   "instMembershipSetFilter",
   "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.Filter.Eventually._eq_1",
  "constType":
  "âˆ€ {Î± : Type u} (p : Î± â†’ Prop) (f : Filter Î±), Filter.Eventually p f = ({x | p x} âˆˆ f)",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra",
   "Prop.distribLattice",
   "Prop.heytingAlgebra.proof_3",
   "Prop.heytingAlgebra.proof_1",
   "Prop.heytingAlgebra.proof_2",
   "BoundedOrder.toOrderTop",
   "DistribLattice.toLattice",
   "OrderTop.toTop",
   "DistribLattice",
   "HImp.mk",
   "OrderBot.toBot",
   "HeytingAlgebra.mk",
   "Prop.heytingAlgebra.proof_4",
   "Prop.le",
   "Prop.boundedOrder",
   "BoundedOrder.toOrderBot",
   "Prop.hasCompl",
   "BoundedOrder",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Prop.heytingAlgebra",
  "constType": "HeytingAlgebra Prop",
  "constCategory": "Definition"},
 {"references": ["Top", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.mk",
  "constType":
  "{Î± : Type u} â†’ [inst : LE Î±] â†’ [toTop : Top Î±] â†’ (âˆ€ (a : Î±), a â‰¤ âŠ¤) â†’ OrderTop Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "GaloisInsertion.gc",
   "Set",
   "LE.le.trans",
   "Monotone.mem_lowerBounds_image",
   "Preorder",
   "GaloisConnection.monotone_u",
   "And.left",
   "GaloisInsertion",
   "Set.instMembershipSet",
   "GaloisConnection.l_le",
   "And.right",
   "upperBounds",
   "GaloisInsertion.le_l_u",
   "GaloisConnection.monotone_l",
   "lowerBounds",
   "And.intro",
   "Set.image",
   "Set.mem_image_of_mem"],
  "name": "GaloisInsertion.isGLB_of_u_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : Preorder Î±] [inst_1 : Preorder Î²],\n  GaloisInsertion l u â†’ âˆ€ {s : Set Î²} {a : Î±}, IsGLB (u '' s) a â†’ IsGLB s (l a)",
  "constCategory": "Theorem"},
 {"references": ["MonadWithReaderOf", "semiOutParam"],
  "name": "MonadWithReaderOf.withReader",
  "constType":
  "{Ï : semiOutParam (Type u)} â†’\n  {m : Type u â†’ Type v} â†’ [self : MonadWithReaderOf Ï m] â†’ {Î± : Type u} â†’ (Ï â†’ Ï) â†’ m Î± â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsGLB",
   "PartialOrder.toPreorder",
   "isGLB_sInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "isGLB_iInf",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±}, IsGLB (Set.range f) (â¨… j, f j)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_9"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Topology.WithUpper",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithUpper.instTopologicalSpaceWithUpper._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4034",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "List.instMembershipList",
   "HAdd.hAdd",
   "List.Sublist",
   "Eq.refl",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "Exists.intro",
   "Std.Data.Fin.Lemmas._auxLemma.15",
   "Std.Data.List.Lemmas._auxLemma.12",
   "Exists.casesOn",
   "implies_congr",
   "instLTNat",
   "True",
   "Std.Data.List.Basic._auxLemma.2",
   "Eq",
   "Std.Data.List.Basic._auxLemma.3",
   "Eq.mpr",
   "forall_congr",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Std.Data.List.Pairwise._auxLemma.18",
   "Eq.trans",
   "Nat.succ",
   "Fin.mk",
   "id",
   "Std.Logic._auxLemma.29",
   "Membership.mem",
   "eq_self",
   "List.map_map",
   "funext",
   "List.cons",
   "instAddNat",
   "Std.Data.Fin.Lemmas._auxLemma.17",
   "instHAdd",
   "Function.comp",
   "Std.Data.List.Pairwise._auxLemma.19",
   "implies_true",
   "List.length",
   "Std.Logic._auxLemma.23",
   "instLTFin",
   "List.Sublist.rec",
   "Std.Logic._auxLemma.57",
   "List.Pairwise",
   "And",
   "eq_true",
   "List.sublist_eq_map_get.match_1",
   "of_eq_true",
   "List",
   "LT.lt",
   "congr",
   "List.map",
   "List.get",
   "congrArg",
   "Fin.succ",
   "Fin",
   "and_self",
   "congrFun"],
  "name": "List.sublist_eq_map_get",
  "constType":
  "âˆ€ {Î± : Type u_1} {l' l : List Î±},\n  List.Sublist l' l â†’ âˆƒ is, l' = List.map (List.get l) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Monotone.comp",
   "Function.comp",
   "OrderHom.mono",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.comp.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : Preorder Î³]\n  (g : Î² â†’o Î³) (f : Î± â†’o Î²), Monotone (â†‘g âˆ˜ â†‘f)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsLower",
  "constType":
  "(Î± : Type u_1) â†’ [t : TopologicalSpace Î±] â†’ [inst : Preorder Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_7",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_8"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "instLENat", "Nat", "Nat.succ", "LE.le", "Nat.casesOn"],
  "name": "Nat.eq_or_lt_of_le.match_2",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ x â‰¤ x_1 â†’ Prop) (x x_1 : â„•) (x_2 : x â‰¤ x_1),\n  (âˆ€ (x : Nat.zero â‰¤ Nat.zero), motive Nat.zero Nat.zero x) â†’\n    (âˆ€ (n : â„•) (x : Nat.zero â‰¤ Nat.succ n), motive Nat.zero (Nat.succ n) x) â†’\n      (âˆ€ (n : â„•) (h : Nat.succ n â‰¤ Nat.zero), motive (Nat.succ n) Nat.zero h) â†’\n        (âˆ€ (n m : â„•) (h : Nat.succ n â‰¤ Nat.succ m), motive (Nat.succ n) (Nat.succ m) h) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "UInt8",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet.toLowerSet_le_iff",
   "Topology.WithLowerSet",
   "propext",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.11",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±},\n  (â†‘Topology.WithLowerSet.toLowerSet a â‰¤ â†‘Topology.WithLowerSet.toLowerSet b) = (a â‰¤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeSup",
   "le_sSup",
   "iSup",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "rfl",
   "CompleteLattice.toSupSet",
   "Preorder.toLE",
   "Eq"],
  "name": "le_iSup",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] (f : Î¹ â†’ Î±) (i : Î¹), f i â‰¤ iSup f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.termÏ€_._closed_4",
   "Topology.termÏ€_._closed_2"],
  "name": "Topology.termÏ€_._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpperSet", "Nonempty"],
  "name": "Topology.WithUpperSet.instNonemptyWithUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Nonempty Î±], Nonempty (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references": ["Min", "LE", "Min.mk", "LE.le", "ite", "DecidableRel"],
  "name": "minOfLe",
  "constType":
  "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ [inst : DecidableRel LE.le] â†’ Min Î±",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{Î± : Type u_2} â†’\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring Î±] â†’\n    [toMin : Min Î±] â†’\n      [toMax : Max Î±] â†’\n        [toOrd : Ord Î±] â†’\n          (âˆ€ (a b : Î±), a â‰¤ b âˆ¨ b â‰¤ a) â†’\n            (decidableLE : DecidableRel fun x x_1 â†¦ x â‰¤ x_1) â†’\n              (decidableEq : DecidableEq Î±) â†’\n                (decidableLT : DecidableRel fun x x_1 â†¦ x < x_1) â†’\n                  autoParam (âˆ€ (a b : Î±), min a b = if a â‰¤ b then a else b) _autoâœ â†’\n                    autoParam (âˆ€ (a b : Î±), max a b = if a â‰¤ b then b else a) _autoâœÂ¹ â†’\n                      autoParam (âˆ€ (a b : Î±), compare a b = compareOfLessAndEq a b) _autoâœÂ² â†’\n                        LinearOrderedCommSemiring Î±",
  "constCategory": "Other"},
 {"references":
  ["Nat.gt_of_not_le.match_1",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "absurd",
   "instLTNat",
   "LE.le",
   "GT.gt"],
  "name": "Nat.gt_of_not_le",
  "constType": "âˆ€ {n m : â„•}, Â¬n â‰¤ m â†’ n > m",
  "constCategory": "Theorem"},
 {"references": ["Unit", "SeqLeft"],
  "name": "SeqLeft.mk",
  "constType":
  "{f : Type u â†’ Type v} â†’ ({Î± Î² : Type u} â†’ f Î± â†’ (Unit â†’ f Î²) â†’ f Î±) â†’ SeqLeft f",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_1",
  "constType": "127 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "Iff.rfl",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "Preorder",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Eq",
   "Iff.symm",
   "isLowerSet_compl",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Topology.IsUpperSet.isOpen_iff_isUpperSet",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpperSet.isClosed_iff_isLower",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±] {s : Set Î±},\n  IsClosed s â†” IsLowerSet s",
  "constCategory": "Theorem"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{Î± : Type u} â†’ [self : Sup Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_iInf",
   "iInf_le_of_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf_mono",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f g : Î¹ â†’ Î±}, (âˆ€ (i : Î¹), f i â‰¤ g i) â†’ iInf f â‰¤ iInf g",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_5"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "SetLike",
   "SetLike.mk",
   "LowerSet.instSetLikeLowerSet.proof_1",
   "LE",
   "LowerSet.carrier"],
  "name": "LowerSet.instSetLikeLowerSet",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ SetLike (LowerSet Î±) Î±",
  "constCategory": "Definition"},
 {"references":
  ["And", "Exists", "exists_and_right", "propext", "Eq.symm", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.106",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, ((âˆƒ x, p x) âˆ§ b) = âˆƒ x, p x âˆ§ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Subtype.val",
   "nhds",
   "Set",
   "Subtype.ext",
   "Eq.refl",
   "wrapped._@.Mathlib.Topology.Basic._hyg.10536",
   "rfl",
   "ConditionallyCompleteLattice.toInfSet",
   "Eq",
   "Set.instMembershipSet",
   "Subtype.property",
   "And",
   "Filter.principal",
   "definition._@.Mathlib.Topology.Basic._hyg.10536",
   "Eq.mpr",
   "Eq.ndrec",
   "iInf",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Filter",
   "Eq.symm",
   "IsOpen",
   "Subtype",
   "Subtype.mk",
   "id",
   "Filter.instCompleteLatticeFilter"],
  "name": "nhds_def",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (a : Î±), nhds a = â¨… s âˆˆ {s | a âˆˆ s âˆ§ IsOpen s}, Filter.principal s",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpperSet.toDualHomeomorph._lambda_1",
   "_obj",
   "Function.comp._rarg",
   "Topology.WithUpperSet.map._elambda_1",
   "_neutral"],
  "name": "Topology.WithUpperSet.map._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "âˆ€ {Î± : Type u} [self : NonAssocSemiring Î±] (n : â„•), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Nat.noConfusion",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.propIntro",
   "Eq"],
  "name": "Nat.succ.injEq",
  "constType": "âˆ€ (n n_1 : â„•), (Nat.succ n = Nat.succ n_1) = (n = n_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.eq",
   "List.Nodup.map",
   "List.instMembershipList",
   "Subtype.val",
   "List.Nodup.of_map",
   "List.attach",
   "Iff.mpr",
   "Eq",
   "Iff.intro",
   "List.Nodup",
   "List",
   "Eq.rec",
   "List.attach_map_val",
   "List.map",
   "Eq.symm",
   "Subtype"],
  "name": "List.Nodup.attach",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±}, List.Nodup l â†’ List.Nodup (List.attach l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.isOpen_sUnion",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "isOpen_sUnion",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set (Set Î±)}, (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹ƒâ‚€ s)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "Multiset.zero", "Multiset", "Zero.mk"],
  "name": "Multiset.instZeroMultiset",
  "constType": "{Î± : Type u_1} â†’ Zero (Multiset Î±)",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{Î± : Type u} â†’ [self : Top Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["CoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Top.top",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "top_sdiff'",
   "Eq.symm",
   "CoheytingAlgebra.toHNot",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.27",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] (a : Î±), ï¿¢a = âŠ¤ \\ a",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} â†’ [toAdd : Add G] â†’ (âˆ€ (a b c : G), a + b + c = a + (b + c)) â†’ AddSemigroup G",
  "constCategory": "Other"},
 {"references": ["Exists", "Classical.skolem", "propext", "Eq"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.5",
  "constType":
  "âˆ€ {Î± : Sort u} {b : Î± â†’ Sort v} {p : (x : Î±) â†’ b x â†’ Prop}, (âˆ€ (x : Î±), âˆƒ y, p x y) = âˆƒ f, âˆ€ (x : Î±), p x (f x)",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.toLowerSet._cstage1",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithLowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "Decidable", "Not", "Decidable.byCases"],
  "name": "Decidable.em",
  "constType": "âˆ€ (p : Prop) [inst : Decidable p], p âˆ¨ Â¬p",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Or", "Iff.mp", "Iff", "Iff.mpr", "Or.imp"],
  "name": "or_congr",
  "constType": "âˆ€ {a c b d : Prop}, (a â†” c) â†’ (b â†” d) â†’ (a âˆ¨ b â†” c âˆ¨ d)",
  "constCategory": "Theorem"},
 {"references":
  ["List.nil_sublist",
   "eq_true",
   "List",
   "List.Sublist",
   "List.nil",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.29",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), List.Sublist [] l = True",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "Eq.rec", "HasSubset.Subset", "HasSubset", "subset_rfl", "Eq"],
  "name": "subset_of_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1], a = b â†’ a âŠ† b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "HasSubset.Subset",
   "Mathlib.Order.Filter.Basic._auxLemma.130",
   "Pure.pure",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Set.instMembershipSet",
   "Filter.principal",
   "Mathlib.Order.Filter.Basic._auxLemma.132",
   "Set.instHasSubsetSet",
   "Set.instSingletonSet",
   "Filter.instPureFilter",
   "Iff",
   "of_eq_true",
   "congr",
   "Singleton.singleton",
   "Filter",
   "Filter.ext",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter"],
  "name": "Filter.principal_singleton",
  "constType": "âˆ€ {Î± : Type u} (a : Î±), Filter.principal {a} = pure a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.indexOf_get",
   "List.indexOf_lt_length",
   "List.instMembershipList",
   "instBEq",
   "List.indexOf",
   "List.length",
   "instLTNat",
   "True",
   "Iff.mpr",
   "Eq",
   "DecidableEq",
   "of_eq_true",
   "List",
   "LT.lt",
   "List.get",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin.mk",
   "congrFun"],
  "name": "List.Nodup.getEquivOfForallMemList.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±) (h : âˆ€ (x : Î±), x âˆˆ l) (a : Î±),\n  List.get l { val := List.indexOf a l, isLt := (_ : List.indexOf a l < List.length l) } = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.refl",
   "eq_true_of_decide",
   "True",
   "Eq",
   "Nat.rec",
   "Nat.zero",
   "of_eq_true",
   "Bool.true",
   "Bool",
   "Nat.beq",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "congrFun"],
  "name": "Nat.beq_refl",
  "constType": "âˆ€ (a : â„•), Nat.beq a a = true",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{Î± : Type u} â†’ [self : Lattice Î±] â†’ SemilatticeSup Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.union_right",
   "List.instUnionList",
   "List.Perm",
   "DecidableEq",
   "List",
   "Union.union",
   "List.Perm.union_left",
   "List.Perm.trans"],
  "name": "List.Perm.union",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] {lâ‚ lâ‚‚ tâ‚ tâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ tâ‚ ~ tâ‚‚ â†’ lâ‚ âˆª tâ‚ ~ lâ‚‚ âˆª tâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Prop) â†’ HasSubset Î±",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Nat.zero_add",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.mul_one",
  "constType": "âˆ€ (n : â„•), n * 1 = n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "instHPow",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_succ",
  "constType": "âˆ€ (n m : â„•), n ^ Nat.succ m = n ^ m * n",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "And",
   "And.right",
   "Iff.mp",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "Continuous",
   "continuous_prod_mk",
   "TopologicalSpace",
   "Prod",
   "Prod.fst"],
  "name": "continuous_snd",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], Continuous Prod.snd",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "le_inf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b c : Î±}, a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.comm",
   "Lean.Data.AC.sort.loop",
   "Lean.Data.AC.insert_nonEmpty",
   "Eq.refl",
   "List.casesOn",
   "Lean.Data.AC.sort",
   "Lean.Data.AC.ContextInformation.isComm",
   "True",
   "Eq",
   "Lean.Data.AC.Context.evalList_sort_cons",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Option.none",
   "Lean.Data.AC.List.two_step_induction",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Option.some",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Option.toBool.match_1",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "instDecidableEqBool",
   "Option",
   "id",
   "eq_self",
   "List.cons",
   "False",
   "Lean.Data.AC.insert",
   "Unit",
   "Option.casesOn",
   "eq_false_of_decide",
   "Lean.Data.AC.Context.op",
   "False.elim",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Lean.Data.AC.Context.sort_loop_nonEmpty",
   "of_eq_true",
   "Bool.false",
   "List",
   "Lean.IsCommutative",
   "Eq.mp",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±),\n  Lean.Data.AC.ContextInformation.isComm ctx = true â†’\n    âˆ€ (e : List â„•), Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.sort e) = Lean.Data.AC.evalList Î± ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "And.intro",
   "Nat",
   "And.casesOn",
   "instLTNat",
   "LE.le"],
  "name": "List.mem_range'_1.match_2",
  "constType":
  "âˆ€ {m s n : â„•} (motive : s â‰¤ m âˆ§ m < s + n â†’ Prop) (x : s â‰¤ m âˆ§ m < s + n),\n  (âˆ€ (hâ‚ : s â‰¤ m) (hâ‚‚ : m < s + n), motive (_ : s â‰¤ m âˆ§ m < s + n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["MonadWithReaderOf", "Monad", "ReaderT", "MonadWithReaderOf.mk"],
  "name": "instMonadWithReaderOfReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ MonadWithReaderOf Ï (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Iff",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Iff.not_right",
   "Set.not_nonempty_iff_eq_empty",
   "Set.instEmptyCollectionSet",
   "Eq"],
  "name": "Set.nonempty_iff_ne_empty",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Nonempty s â†” s â‰  âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Not",
   "List.not_mem_nil",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.not_mem_zero",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), Â¬a âˆˆ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Char.val",
   "UInt32",
   "Char",
   "DecidableEq",
   "Decidable.isFalse",
   "Decidable",
   "Char.eq_of_val_eq",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqChar.match_1",
   "decEq",
   "Char.ne_of_val_ne",
   "instDecidableEqUInt32",
   "Eq"],
  "name": "instDecidableEqChar",
  "constType": "DecidableEq Char",
  "constCategory": "Definition"},
 {"references":
  ["instIsIdempotentInfToInf.proof_1",
   "SemilatticeInf.toInf",
   "IsIdempotent",
   "Inf.inf",
   "SemilatticeInf"],
  "name": "instIsIdempotentInfToInf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±], IsIdempotent Î± fun x x_1 â†¦ x âŠ“ x_1",
  "constCategory": "Definition"},
 {"references":
  ["definition._@.Mathlib.Topology.Basic._hyg.10536",
   "TopologicalSpace",
   "Filter",
   "Subtype",
   "Eq"],
  "name": "wrapped._@.Mathlib.Topology.Basic._hyg.10536",
  "constType": "Subtype (Eq @definitionâœ)",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro", "Iff", "Subtype.forall.match_1", "Subtype.mk", "Subtype"],
  "name": "Subtype.forall",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop},\n  (âˆ€ (x : { a // p a }), q x) â†” âˆ€ (a : Î±) (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen"],
  "name": "IsClosed.mk",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen sá¶œ â†’ IsClosed s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "propext",
   "List.mem_singleton",
   "List.nil",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.3",
  "constType": "âˆ€ {Î± : Type u_1} {a b : Î±}, (a âˆˆ [b]) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "Set.preimage",
   "TopologicalSpace.ext",
   "Function.comp",
   "Set",
   "Exists.intro",
   "rfl",
   "induced_compose.match_2",
   "Eq",
   "Iff.intro",
   "And",
   "propext",
   "Eq.rec",
   "TopologicalSpace",
   "induced_compose.match_1",
   "And.intro",
   "TopologicalSpace.induced",
   "IsOpen"],
  "name": "induced_compose",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  TopologicalSpace.induced f (TopologicalSpace.induced g tÎ³) = TopologicalSpace.induced (g âˆ˜ f) tÎ³",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.IsOpen_of._closed_6", "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SizeOf",
  "constType": "Sort u â†’ Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Functor"],
  "name": "Functor.map",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : Functor f] â†’ {Î± Î² : Type u} â†’ (Î± â†’ Î²) â†’ f Î± â†’ f Î²",
  "constCategory": "Definition"},
 {"references":
  ["List",
   "List.Sublist",
   "List.nil",
   "List.Sublist.slnil",
   "List.Sublist.below"],
  "name": "List.Sublist.below.slnil",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop}, List.Sublist.below (_ : List.Sublist [] [])",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "LE.le.trans",
   "iInfâ‚‚_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInfâ‚‚_le_of_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {Îº : Î¹ â†’ Sort u_7} [inst : CompleteLattice Î±] {a : Î±} {f : (i : Î¹) â†’ Îº i â†’ Î±} (i : Î¹)\n  (j : Îº i), f i j â‰¤ a â†’ â¨… i, â¨… j, f i j â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_trans.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (motive : (x x_1 x_2 : Î±) â†’ x < x_1 â†’ x_1 < x_2 â†’ Prop) (x x_1 x_2 : Î±)\n  (x_3 : x < x_1) (x_4 : x_1 < x_2),\n  (âˆ€ (_a _b _c : Î±) (hab : _a < _b) (hbc : _b < _c), motive _a _b _c hab hbc) â†’ motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "le_iInf",
   "CompleteLattice.toInfSet",
   "le_trans",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iSup_le",
   "iInf_le",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice.toSupSet"],
  "name": "le_iInf_iSup",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} {Îº : Î¹ â†’ Sort w'} [inst : CompleteLattice Î±] {f : (a : Î¹) â†’ Îº a â†’ Î±},\n  â¨† g, â¨… a, f a (g a) â‰¤ â¨… a, â¨† b, f a b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "And.intro", "And.left"],
  "name": "And.imp",
  "constType": "âˆ€ {a c b d : Prop}, (a â†’ c) â†’ (b â†’ d) â†’ a âˆ§ b â†’ c âˆ§ d",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "compl_compl",
   "Function.comp",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra",
   "Eq",
   "id"],
  "name": "compl_comp_compl",
  "constType": "âˆ€ {Î± : Type u} [inst : BooleanAlgebra Î±], compl âˆ˜ compl = id",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Multiset.cons",
   "Finset.cons",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Not",
   "rfl",
   "Eq"],
  "name": "Finset.cons_val",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Finset Î±} {a : Î±} (h : Â¬a âˆˆ s), (Finset.cons a s h).val = a ::â‚˜ s.val",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Subtype.val",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "And.casesOn",
   "Exists.casesOn",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Subtype.coe_image.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {s : Set (Subtype p)} (a : Î±) (motive : a âˆˆ Subtype.val '' s â†’ Prop)\n  (x : a âˆˆ Subtype.val '' s),\n  (âˆ€ (val : Î±) (ha' : p val) (in_s : { val := val, property := ha' } âˆˆ s) (h_eq : â†‘{ val := val, property := ha' } = a),\n      motive (_ : âˆƒ a_1 âˆˆ s, â†‘a_1 = a)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references": ["Prod.mk", "Prod.rec", "Prod"],
  "name": "Prod.casesOn",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’ {motive : Î± Ã— Î² â†’ Sort u_1} â†’ (t : Î± Ã— Î²) â†’ ((fst : Î±) â†’ (snd : Î²) â†’ motive (fst, snd)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "propext",
   "Set",
   "Set.mem_compl_iff",
   "HasCompl.compl",
   "Not",
   "BooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.78",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±) (x : Î±), (x âˆˆ sá¶œ) = Â¬x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ DecidableRel fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Pi.generalizedHeytingAlgebra.proof_3",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "SemilatticeInf.toPartialOrder",
   "Pi.instHImpForAll",
   "Lattice.mk",
   "Pi.generalizedHeytingAlgebra.proof_5",
   "Preorder.toLE",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Pi.generalizedHeytingAlgebra.proof_1",
   "Pi.generalizedHeytingAlgebra.proof_2",
   "Pi.generalizedHeytingAlgebra.proof_4",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "OrderTop",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "Lattice",
   "GeneralizedHeytingAlgebra",
   "Pi.hasLe",
   "Lattice.toSemilatticeSup",
   "Pi.orderTop",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Pi.generalizedHeytingAlgebra",
  "constType":
  "{Î¹ : Type u_1} â†’\n  {Î± : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ GeneralizedHeytingAlgebra (Î± i)] â†’ GeneralizedHeytingAlgebra ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Append",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["propext", "imp_self", "True", "Eq"],
  "name": "Std.Logic._auxLemma.5",
  "constType": "âˆ€ {a : Prop}, (a â†’ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "LE.le",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "instLENat",
   "List.rec",
   "Nat.le_of_succ_le_succ",
   "List",
   "Option.none",
   "PUnit",
   "List.get?_len_le.match_1",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.get?",
   "Option"],
  "name": "List.get?_len_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {n : â„•}, List.length l â‰¤ n â†’ List.get? l n = none",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name": "_private.Std.Data.List.Lemmas.0.List.erase.match_1.splitter",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ motive true â†’ motive false â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "Setoid",
   "Equivalence.refl",
   "HasEquiv.Equiv",
   "Setoid.iseqv"],
  "name": "Setoid.refl",
  "constType": "âˆ€ {Î± : Sort u} [inst : Setoid Î±] (a : Î±), a â‰ˆ a",
  "constCategory": "Theorem"},
 {"references": ["Union", "Union.mk", "DecidableEq", "List", "List.union"],
  "name": "List.instUnionList",
  "constType": "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ Union (List Î±)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "inf_le_inf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_inf_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] (a : Î±) {b c : Î±}, b â‰¤ c â†’ b âŠ“ a â‰¤ c âŠ“ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsCommutative",
  "constType": "(Î± : Type u) â†’ (Î± â†’ Î± â†’ Î±) â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "âˆ€ {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {r : N â†’ N â†’ Prop}, Covariant M N Î¼ r â†’ CovariantClass M N Î¼ r",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.mem_cons_self",
   "List.nil"],
  "name": "List.mem_singleton_self",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), a âˆˆ [a]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "RelIso",
  "constType":
  "{Î± : Type u_5} â†’ {Î² : Type u_6} â†’ (Î± â†’ Î± â†’ Prop) â†’ (Î² â†’ Î² â†’ Prop) â†’ Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["Array.foldl",
   "Array",
   "OfNat.ofNat",
   "Array.push",
   "instOfNatNat",
   "Nat",
   "Array.size"],
  "name": "Array.append",
  "constType": "{Î± : Type u} â†’ Array Î± â†’ Array Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "âˆ€ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Subtype", "Set.instMembershipSet"],
  "name": "Set.Elem",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Type u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Filter.le_principal_iff",
   "propext",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.61",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {f : Filter Î±}, (s âˆˆ f) = (f â‰¤ Filter.principal s)",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "and_assoc.match_2",
  "constType":
  "âˆ€ {a b c : Prop} (motive : a âˆ§ b âˆ§ c â†’ Prop) (x : a âˆ§ b âˆ§ c),\n  (âˆ€ (ha : a) (hb : b) (hc : c), motive (_ : a âˆ§ b âˆ§ c)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "BooleanAlgebra",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["List.Pairwise", "eq_true", "List.Pairwise.nil", "List.nil", "True", "Eq"],
  "name": "Std.Data.List.Basic._auxLemma.2",
  "constType": "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R [] = True",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Finite.intro", "Finite", "Nat", "Fin"],
  "name": "Finite.rec",
  "constType":
  "âˆ€ {Î± : Sort u_1} {motive : Finite Î± â†’ Prop},\n  (âˆ€ {n : â„•} (a : Î± â‰ƒ Fin n), motive (_ : Finite Î±)) â†’ âˆ€ (t : Finite Î±), motive t",
  "constCategory": "Other"},
 {"references": ["UpperSet.carrier", "LE", "IsUpperSet", "UpperSet"],
  "name": "UpperSet.upper'",
  "constType":
  "âˆ€ {Î± : Type u_6} [inst : LE Î±] (self : UpperSet Î±), IsUpperSet self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "InfSet",
   "iSup",
   "SupSet.sSup",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "iInf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteBooleanAlgebra.mk",
  "constType":
  "{Î± : Type u_1} â†’\n  [toBooleanAlgebra : BooleanAlgebra Î±] â†’\n    [toSupSet : SupSet Î±] â†’\n      (âˆ€ (s : Set Î±), âˆ€ a âˆˆ s, a â‰¤ sSup s) â†’\n        (âˆ€ (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a) â†’\n          [toInfSet : InfSet Î±] â†’\n            (âˆ€ (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a) â†’\n              (âˆ€ (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s) â†’\n                (âˆ€ (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b) â†’\n                  (âˆ€ (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s) â†’ CompleteBooleanAlgebra Î±",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "DistribLattice.ofInfSupLe.proof_1",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "DistribLattice.mk",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "DistribLattice.ofInfSupLe",
  "constType":
  "{Î± : Type u} â†’ [inst : Lattice Î±] â†’ (âˆ€ (a b c : Î±), a âŠ“ (b âŠ” c) â‰¤ a âŠ“ b âŠ” a âŠ“ c) â†’ DistribLattice Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.sInf",
  "constType": "{Î± : Type u_9} â†’ [self : InfSet Î±] â†’ Set Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "sInf_empty",
   "Set.univ",
   "Set.sInter",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_empty",
  "constType": "âˆ€ {Î± : Type u_1}, â‹‚â‚€ âˆ… = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "OrderBot.toBot",
   "OrderBot.bot_le",
   "Prop.le",
   "LE.le",
   "Prop.boundedOrder",
   "BoundedOrder.toOrderBot"],
  "name": "Prop.heytingAlgebra.proof_3",
  "constType": "âˆ€ (a : Prop), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsIdempotent", "Eq"],
  "name": "Lean.IsIdempotent.mk",
  "constType":
  "{Î± : Sort u} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ (âˆ€ (x : Î±), op x x = x) â†’ Lean.IsIdempotent op",
  "constCategory": "Other"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {Î³ : Sort u_3} â†’\n      {r : Î± â†’ Î² â†’ Sort u} â†’\n        {s : Î² â†’ Î³ â†’ Sort v} â†’\n          {t : outParam (Î± â†’ Î³ â†’ Sort w)} â†’ [self : Trans r s t] â†’ {a : Î±} â†’ {b : Î²} â†’ {c : Î³} â†’ r a b â†’ s b c â†’ t a c",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "IsTrans",
   "Set.instIsTransSetSubsetInstHasSubsetSet.proof_1"],
  "name": "Set.instIsTransSetSubsetInstHasSubsetSet",
  "constType": "âˆ€ {Î± : Type u}, IsTrans (Set Î±) fun x x_1 â†¦ x âŠ† x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsClosed_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLower.toLower",
   "Iff.rfl",
   "Topology.WithLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLower.toLower_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±}, â†‘Topology.WithLower.toLower a = â†‘Topology.WithLower.toLower b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "LinearOrder.decidableLE",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Or.elim",
   "le_total",
   "Eq"],
  "name": "lt_trichotomy",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] (a b : Î±), a < b âˆ¨ a = b âˆ¨ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instLENat",
   "Iff.rfl",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.succ_le",
  "constType": "âˆ€ {n m : â„•}, Nat.succ n â‰¤ m â†” n < m",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.toLowerSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_right_comm",
  "constType": "âˆ€ (n m k : â„•), n + m + k = n + k + m",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Not", "Bool", "Eq"],
  "name": "Bool.of_not_eq_true.match_1",
  "constType":
  "âˆ€ (motive : (x : Bool) â†’ Â¬x = true â†’ Prop) (x : Bool) (x_1 : Â¬x = true),\n  (âˆ€ (h : Â¬true = true), motive true h) â†’ (âˆ€ (x : Â¬false = true), motive false x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "trueSetoid",
   "Setoid.r",
   "Trunc.induction_onâ‚‚",
   "Trunc",
   "Quot.sound",
   "Eq"],
  "name": "Trunc.eq",
  "constType": "âˆ€ {Î± : Sort u_1} (a b : Trunc Î±), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "UpperSet.Ici",
   "Topology.IsLowerSet.closure_eq_upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "upperClosure_singleton",
   "Preorder",
   "Topology.IsLowerSet",
   "Set.Ici",
   "UpperSet",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "upperClosure",
   "TopologicalSpace",
   "Singleton.singleton",
   "SetLike.coe",
   "id"],
  "name": "Topology.IsLowerSet.closure_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±] {a : Î±},\n  closure {a} = Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "âˆ€ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b â†’ a = c",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Mathlib.Topology.Basic._auxLemma.13",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "Mathlib.Topology.Basic._auxLemma.12",
   "TopologicalSpace",
   "congr",
   "Set.sUnion",
   "Mathlib.Topology.Basic._auxLemma.11",
   "congrArg",
   "interior",
   "IsOpen",
   "Eq.trans"],
  "name": "mem_interior",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {x : Î±}, x âˆˆ interior s â†” âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Topology.upperSet.proof_1",
   "Topology.upperSet.proof_3",
   "TopologicalSpace",
   "Topology.upperSet.proof_2",
   "IsUpperSet",
   "Preorder",
   "Preorder.toLE"],
  "name": "Topology.upperSet",
  "constType": "(Î± : Type u_4) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.ext.match_1", "Subtype.val", "rfl", "Subtype.mk", "Subtype", "Eq"],
  "name": "Subtype.ext",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a1 a2 : { x // p x }}, â†‘a1 = â†‘a2 â†’ a1 = a2",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "Preorder.le_trans",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b c : TopologicalSpace Î±), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "Or",
   "List.mem_cons.match_1",
   "HEq",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "or_true",
   "True",
   "Eq",
   "Iff.intro",
   "eq_true",
   "Iff",
   "Eq.ndrec",
   "HEq.refl",
   "of_eq_true",
   "List",
   "true_or",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.noConfusion",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.mem_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {l : List Î±}, a âˆˆ b :: l â†” a = b âˆ¨ a âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HSub Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "inferInstance",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsRefl",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "instIsReflLeToLE",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.instIsReflSetSubsetInstHasSubsetSet.proof_1",
  "constType": "âˆ€ {Î± : Type u_1}, IsRefl (Set Î±) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.Range._hyg.49",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "sInf_image",
   "Set",
   "Set.iInter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.image",
   "Set.sInter",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Set Î²) (s : Set Î±), â‹‚â‚€ (f '' s) = â‹‚ x âˆˆ s, f x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Topology.IsLower",
   "TopologicalSpace",
   "T0Space",
   "Topology.IsLower.t0Space.proof_1",
   "PartialOrder"],
  "name": "Topology.IsLower.t0Space",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsLower Î±], T0Space Î±",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.id",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.map",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "ContinuousMap.id",
   "Eq",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map_id",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.WithUpperSet.map OrderHom.id = ContinuousMap.id (Topology.WithUpperSet Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.closure_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.WithUpperSet.map._elambda_1._rarg", "_neutral"],
  "name": "Topology.WithUpperSet.map._elambda_1._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "instMonadReaderOfReaderT",
   "Unit",
   "Lean.MonadQuotation.mk",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "MonadReader.read",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "instMonadWithReaderOfReaderT",
   "instMonadWithReader",
   "instMonadReader",
   "Lean.MonadRef.mk",
   "Lean.PrettyPrinter.UnexpandM",
   "instOfNatNat",
   "Lean.Name",
   "Lean.MonadQuotation",
   "MonadWithReader.withReader",
   "Applicative.toPure",
   "id"],
  "name": "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
  "constType": "Lean.MonadQuotation Lean.PrettyPrinter.UnexpandM",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "EStateM.dummyRestore",
  "constType": "{Ïƒ : Type u} â†’ Ïƒ â†’ PUnit.{u_1} â†’ Ïƒ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ContravariantClass",
  "constType":
  "(M : Type u_1) â†’ (N : Type u_2) â†’ (M â†’ N â†’ N) â†’ (N â†’ N â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_sUnion",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.sUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.11",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {S : Set (Set Î±)}, (x âˆˆ â‹ƒâ‚€ S) = âˆƒ t âˆˆ S, x âˆˆ t",
  "constCategory": "Theorem"},
 {"references": ["Seq", "Unit"],
  "name": "Seq.mk",
  "constType":
  "{f : Type u â†’ Type v} â†’ ({Î± Î² : Type u} â†’ f (Î± â†’ Î²) â†’ (Unit â†’ f Î±) â†’ f Î²) â†’ Seq f",
  "constCategory": "Other"},
 {"references": ["rfl", "Eq", "id"],
  "name": "Equiv.refl.proof_1",
  "constType": "âˆ€ (Î± : Sort u_1) (x : Î±), id (id x) = id (id x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Iff",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.induction_on",
   "List.mem_dedup",
   "Multiset.instMembershipMultiset",
   "Multiset.dedup"],
  "name": "Multiset.mem_dedup",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {s : Multiset Î±}, a âˆˆ Multiset.dedup s â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Set.instSProd",
   "Prod.snd",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Set.univ",
   "True",
   "Eq",
   "of_eq_true",
   "SProd.sprod",
   "Prod",
   "Set.univ_inter",
   "congrArg",
   "Eq.trans",
   "Set.instInterSet",
   "congrFun"],
  "name": "Set.univ_prod",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {t : Set Î²}, Set.univ Ã—Ë¢ t = Prod.snd â»Â¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT", "LT.lt", "lt_trans", "IsTrans", "IsTrans.mk", "Preorder"],
  "name": "instIsTransLtToLT.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], IsTrans Î± fun x x_1 â†¦ x < x_1",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.instUnionList",
   "List.insert",
   "List.perm_insert_swap",
   "List.Perm.insert",
   "Union.union",
   "List.Perm.rec",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "True",
   "Eq",
   "List.nil_union",
   "List.cons_union",
   "Eq.mpr",
   "List.Perm",
   "DecidableEq",
   "of_eq_true",
   "List",
   "congr",
   "List.Perm.trans",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "List.Perm.union_right",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±} (tâ‚ : List Î±), lâ‚ ~ lâ‚‚ â†’ lâ‚ âˆª tâ‚ ~ lâ‚‚ âˆª tâ‚",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.add.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.add",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["Quot.lift", "Quot", "Eq"],
  "name": "Quot.liftOn",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ Quot r â†’ (f : Î± â†’ Î²) â†’ (âˆ€ (a b : Î±), r a b â†’ f a = f b) â†’ Î²",
  "constCategory": "Definition"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{Î± : Type u} â†’ [self : Lattice Î±] â†’ Inf Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.inter_subset_left",
   "True",
   "Eq",
   "Set.instInterSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.26",
  "constType": "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆ© t âŠ† s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "inf_of_le_right",
   "OrderBot.toBot",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "bot_le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_bot_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a : Î±}, a âŠ“ âŠ¥ = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List.Perm", "List"],
  "name": "List.Perm.swap",
  "constType":
  "âˆ€ {Î± : Type uu} (x y : Î±) (l : List Î±), y :: x :: l ~ x :: y :: l",
  "constCategory": "Other"},
 {"references":
  ["continuous_iff_isClosed",
   "Iff.mp",
   "Set.preimage",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsClosed"],
  "name": "IsClosed.preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ âˆ€ {s : Set Î²}, IsClosed s â†’ IsClosed (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.map._elambda_1",
  "constType":
  "(Î± : Type u_1) â†’\n  (Î² : Type u_2) â†’\n    ((a : Î²) â†’ (fun x â†¦ Topology.WithUpperSet Î²) a) â†’\n      (Topology.WithUpperSet Î± â†’ Î²) â†’ Topology.WithUpperSet Î± â†’ Topology.WithUpperSet Î²",
  "constCategory": "Axiom"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Array.appendCore.loop.match_1",
  "constType":
  "(motive : â„• â†’ Sort u_1) â†’ (i : â„•) â†’ (Unit â†’ motive 0) â†’ ((i' : â„•) â†’ motive (Nat.succ i')) â†’ motive i",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "propext",
   "Multiset.mem_dedup",
   "Multiset",
   "Multiset.instMembershipMultiset",
   "Eq",
   "Multiset.dedup"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.23",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {s : Multiset Î±}, (a âˆˆ Multiset.dedup s) = (a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "BiheytingAlgebra",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_GenLoop_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp",
   "Iff",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "decidable_of_decidable_of_iff.proof_1"],
  "name": "decidable_of_decidable_of_iff",
  "constType": "{p q : Prop} â†’ [inst : Decidable p] â†’ (p â†” q) â†’ Decidable q",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Topology.IsLower.rec",
   "Preorder",
   "Topology.IsLower.mk",
   "Eq"],
  "name": "Topology.IsLower.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsLower Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsLower Î±) â†’\n          ((topology_eq_lowerTopology : t = Topology.lower Î±) â†’ motive (_ : Topology.IsLower Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_iInf",
   "Function.comp",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf_const_mono",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {Î¹' : Sort u_6} [inst : CompleteLattice Î±] {a : Î±}, (Î¹' â†’ Î¹) â†’ â¨… x, a â‰¤ â¨… x, a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.instSupSetSet", "SupSet.sSup"],
  "name": "Set.sUnion",
  "constType": "{Î± : Type u_1} â†’ Set (Set Î±) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq", "id"],
  "name": "Equiv.refl.proof_2",
  "constType": "âˆ€ (Î± : Sort u_1) (x : Î±), id (id x) = id (id x)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "Set.preimage_mono",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.map.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (m : Î± â†’ Î²) (f : Filter Î±) {x y : Set Î²},\n  x âˆˆ Set.preimage m â»Â¹' f.sets â†’ x âŠ† y â†’ m â»Â¹' y âˆˆ f",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "le_not_le_of_lt.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (motive : (x x_1 : Î±) â†’ x < x_1 â†’ Prop) (x x_1 : Î±) (x_2 : x < x_1),\n  (âˆ€ (_a _b : Î±) (hab : _a < _b), motive _a _b hab) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Lean.IsAssociative.mk",
   "instIsAssociative.proof_1",
   "IsAssociative",
   "Lean.IsAssociative"],
  "name": "instIsAssociative",
  "constType":
  "{Î± : Type u_1} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ [inst : IsAssociative Î± op] â†’ Lean.IsAssociative op",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Mathlib.Data.List.Pairwise._auxLemma.8",
   "Eq.refl",
   "Std.Logic._auxLemma.45",
   "List.pmap._sunfold.proof_1",
   "rfl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "forall_congr",
   "List.nil",
   "Mathlib.Data.List.Pairwise._auxLemma.2",
   "And.casesOn",
   "Eq.trans",
   "id",
   "Membership.mem",
   "List.cons",
   "Or",
   "List.pmap",
   "Mathlib.Data.List.Pairwise._auxLemma.10",
   "List.pmap._sunfold.proof_2",
   "Iff.intro",
   "List.Pairwise",
   "And",
   "Eq.ndrec",
   "Mathlib.Data.List.Pairwise._auxLemma.9",
   "of_eq_true",
   "propext",
   "List",
   "Eq.mp",
   "congr",
   "congrArg"],
  "name": "List.pairwise_pmap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {R : Î± â†’ Î± â†’ Prop} {p : Î² â†’ Prop} {f : (b : Î²) â†’ p b â†’ Î±} {l : List Î²}\n  (h : âˆ€ x âˆˆ l, p x),\n  List.Pairwise R (List.pmap f l h) â†” List.Pairwise (fun bâ‚ bâ‚‚ â†¦ âˆ€ (hâ‚ : p bâ‚) (hâ‚‚ : p bâ‚‚), R (f bâ‚ hâ‚) (f bâ‚‚ hâ‚‚)) l",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "âˆ€ {a b : Prop} {motive : a âˆ¨ b â†’ Prop} (t : a âˆ¨ b),\n  (âˆ€ (h : a), motive (_ : a âˆ¨ b)) â†’ (âˆ€ (h : b), motive (_ : a âˆ¨ b)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "eq_false",
   "False",
   "of_decide_eq_false",
   "Bool.false",
   "Decidable",
   "Bool",
   "Eq"],
  "name": "eq_false_of_decide",
  "constType": "âˆ€ {p : Prop} {x : Decidable p}, decide p = false â†’ p = False",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff", "iff_true_intro", "True"],
  "name": "imp_true_iff",
  "constType": "âˆ€ (Î± : Sort u), Î± â†’ True â†” True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "cond",
   "List.findIdx.go.match_1",
   "List.below",
   "List.brecOn",
   "Nat.succ_eq_add_one",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "List.findIdx.go",
   "Eq",
   "PProd",
   "Eq.mpr",
   "List.rec",
   "_private.Std.Data.List.Lemmas.0.List.findIdx.go._unfold",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Eq.symm",
   "id",
   "eq_self",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "PProd.fst",
   "Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "List",
   "Bool.false",
   "congr",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.findIdx_cons.findIdx_go_succ",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (l : List Î±) (n : â„•), List.findIdx.go p l (n + 1) = List.findIdx.go p l n + 1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "InfSet", "sInfHomClass"],
  "name": "sInfHomClass.toFunLike",
  "constType":
  "{F : Type u_8} â†’\n  {Î± : outParam (Type u_9)} â†’\n    {Î² : outParam (Type u_10)} â†’\n      [inst : InfSet Î±] â†’ [inst_1 : InfSet Î²] â†’ [self : sInfHomClass F Î± Î²] â†’ FunLike F Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "rfl",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.zero",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "Nat.eq_of_beq_eq_true.match_1",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ"],
  "name": "Nat.eq_of_beq_eq_true",
  "constType": "âˆ€ {n m : â„•}, Nat.beq n m = true â†’ n = m",
  "constCategory": "Theorem"},
 {"references":
  ["cond",
   "Bool.casesOn",
   "Set.Elem",
   "Bool.false",
   "Bool.true",
   "Set",
   "PUnit",
   "Bool"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (s : Set Î±) â†’\n    (motive : (x : Bool) â†’ (bif x then PUnit.{u_1 + 1} else â†‘s) â†’ Sort u_2) â†’\n      (x : Bool) â†’\n        (y : bif x then PUnit.{u_1 + 1} else â†‘s) â†’\n          ((y : bif true then PUnit.{u_1 + 1} else â†‘s) â†’ motive true y) â†’\n            ((y : bif false then PUnit.{u_1 + 1} else â†‘s) â†’ motive false y) â†’ motive x y",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Set.Ici",
   "Preorder",
   "Set.Ici_subset_Ici",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.10",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, (Set.Ici a âŠ† Set.Ici b) = (b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "propext",
   "SProd.sprod",
   "Prod",
   "Filter",
   "Filter.instSProd",
   "Filter.prod_neBot",
   "Filter.NeBot",
   "Eq"],
  "name": "Mathlib.Topology.Constructions._auxLemma.28",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Filter Î±} {g : Filter Î²}, Filter.NeBot (f Ã—Ë¢ g) = (Filter.NeBot f âˆ§ Filter.NeBot g)",
  "constCategory": "Theorem"},
 {"references":
  ["BEq.beq",
   "BEq",
   "List",
   "Eq.refl",
   "List.countP",
   "Nat",
   "List.count",
   "Eq"],
  "name": "_private.Std.Data.List.Count.0.List.count._eq_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] (a : Î±), List.count a = List.countP fun x â†¦ x == a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.instBEqName",
   "BEq.beq",
   "Lean.Syntax.getKind",
   "Lean.SyntaxNodeKind",
   "Bool",
   "Lean.Syntax"],
  "name": "Lean.Syntax.isOfKind",
  "constType": "Lean.Syntax â†’ Lean.SyntaxNodeKind â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "Subtype.val",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "List.Nodup.pmap.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {l : List Î±} {H : âˆ€ a âˆˆ l, p a} (a : Î±)\n  (ha : a âˆˆ l)\n  (motive :\n    (x : { x // x âˆˆ l }) â†’\n      f â†‘{ val := a, property := ha } (_ : p â†‘{ val := a, property := ha }) = f â†‘x (_ : p â†‘x) â†’ Prop)\n  (x : { x // x âˆˆ l }) (h : f â†‘{ val := a, property := ha } (_ : p â†‘{ val := a, property := ha }) = f â†‘x (_ : p â†‘x)),\n  (âˆ€ (b : Î±) (hb : b âˆˆ l)\n      (h :\n        f â†‘{ val := a, property := ha } (_ : p â†‘{ val := a, property := ha }) =\n          f â†‘{ val := b, property := hb } (_ : p â†‘{ val := b, property := hb })),\n      motive { val := b, property := hb } h) â†’\n    motive x h",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Classical.propDecidable",
   "Finite",
   "Eq.refl",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Eq.ndrec",
   "Set.Elem",
   "Set.fintypeImage",
   "Set.image",
   "Eq.symm",
   "Finite.of_fintype",
   "nonempty_fintype"],
  "name": "Finite.Set.finite_image.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (s : Set Î±) (f : Î± â†’ Î²) [inst : Finite â†‘s], Finite â†‘(f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.getArgs",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_1",
   "Lean.Name.mkStr4",
   "Lean.Syntax.getNumArgs",
   "Lean.Syntax.atom",
   "Nat.sub",
   "Array.extract._rarg",
   "_neutral",
   "Lean.Syntax.node4",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_2",
   "Lean.Name.mkStr2",
   "UInt8",
   "PUnit.unit",
   "Lean.SourceInfo.none",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef",
   "Nat.decLe"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le.proof_1",
   "Quotient.liftOnâ‚‚",
   "List",
   "List.Subperm",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Le",
  "constType": "{Î± : Type u_1} â†’ Multiset Î± â†’ Multiset Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "instLENat",
   "Nat.lt_of_lt_of_le",
   "LT.lt",
   "Nat",
   "Array.size",
   "instLTNat",
   "LE.le"],
  "name": "Array.foldlM.loop.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (as : Array Î±), âˆ€ stop â‰¤ Array.size as, âˆ€ j < stop, j < Array.size as",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "interior_subset",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "interior",
   "True",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.16",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (interior s âŠ† s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Set.sUnion",
   "IsOpen"],
  "name": "interior",
  "constType": "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name": "_private.Std.Data.List.Lemmas.0.List.find?_cons.match_1.splitter",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ motive true â†’ motive false â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "TopologicalSpace.gciGenerateFrom.proof_1",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "TopologicalSpace.gciGenerateFrom.proof_2",
   "Function.comp",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "LE.le",
   "TopologicalSpace.gc_generateFrom",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.gciGenerateFrom.proof_3",
   "OrderDual.ofDual",
   "GaloisCoinsertion",
   "TopologicalSpace.mkOfClosure",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisCoinsertion.mk",
   "IsOpen"],
  "name": "TopologicalSpace.gciGenerateFrom",
  "constType":
  "(Î± : Type u_1) â†’\n  GaloisCoinsertion (fun t â†¦ â†‘OrderDual.toDual {s | IsOpen s}) (TopologicalSpace.generateFrom âˆ˜ â†‘OrderDual.ofDual)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_5",
   "List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_7",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "Set.biUnion_range",
   "Eq.refl",
   "Set.iUnion_exists",
   "Eq",
   "Set.instMembershipSet",
   "Iff.of_eq",
   "Set.range",
   "Set.iUnion",
   "Eq.mp",
   "Set.iUnion_congr_Prop",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion_iUnion_eq'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {g : Î± â†’ Set Î²},\n  â‹ƒ x, â‹ƒ y, â‹ƒ (_ : f y = x), g x = â‹ƒ y, g (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "EquivLike.toEmbeddingLike.proof_1",
   "EmbeddingLike.mk",
   "FunLike.mk",
   "EmbeddingLike",
   "EquivLike.toEmbeddingLike.proof_2"],
  "name": "EquivLike.toEmbeddingLike",
  "constType":
  "{E : Sort u_1} â†’ {Î± : Sort u_3} â†’ {Î² : Sort u_4} â†’ [iE : EquivLike E Î± Î²] â†’ EmbeddingLike E Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.IsClosed_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SemilatticeSup.toSup",
   "hnot_inf_distrib",
   "Inf.inf",
   "HasCompl.compl",
   "Sup.sup",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toHasCompl",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq"],
  "name": "compl_inf",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : BooleanAlgebra Î±], (x âŠ“ y)á¶œ = xá¶œ âŠ” yá¶œ",
  "constCategory": "Theorem"},
 {"references": ["WellFoundedRelation"],
  "name": "WellFoundedRelation.rel",
  "constType": "{Î± : Sort u} â†’ [self : WellFoundedRelation Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "Or", "propext", "exists_or", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.9",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆƒ x, p x âˆ¨ q x) = ((âˆƒ x, p x) âˆ¨ âˆƒ x, q x)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.RightInverse", "Function.Surjective", "Exists.intro", "Eq"],
  "name": "Function.RightInverse.surjective",
  "constType":
  "âˆ€ {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.RightInverse g f â†’ Function.Surjective f",
  "constCategory": "Theorem"},
 {"references": ["HImp"],
  "name": "HImp.himp",
  "constType": "{Î± : Type u_4} â†’ [self : HImp Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Trunc.mk", "Trunc", "Trunc.ind"],
  "name": "Trunc.induction_on",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Trunc Î± â†’ Prop} (q : Trunc Î±), (âˆ€ (a : Î±), Î² (Trunc.mk a)) â†’ Î² q",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "sup_comm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Iff",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "sdiff_le_iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "sdiff_le_iff'",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] {a b c : Î±}, a \\ b â‰¤ c â†” a â‰¤ c âŠ” b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mod",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["OrderTop", "LE", "BoundedOrder"],
  "name": "BoundedOrder.toOrderTop",
  "constType":
  "{Î± : Type u} â†’ [inst : LE Î±] â†’ [self : BoundedOrder Î±] â†’ OrderTop Î±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "Eq.to_iff.match_1",
  "constType":
  "âˆ€ {a : Prop} (motive : (b : Prop) â†’ a = b â†’ Prop) (b : Prop) (x : a = b), (Unit â†’ motive a (_ : a = a)) â†’ motive b x",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "Inhabited", "PUnit", "Inhabited.mk"],
  "name": "instInhabitedPUnit",
  "constType": "Inhabited PUnit.{u_1}",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.IsUpper",
   "Topology.instIsUpperWithUpperInstTopologicalSpaceWithUpperInstPreorderWithUpper.proof_1",
   "Topology.WithUpper.instPreorderWithUpper",
   "Preorder"],
  "name":
  "Topology.instIsUpperWithUpperInstTopologicalSpaceWithUpperInstPreorderWithUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsUpper (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references":
  ["OrderHomClass.mono",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "InfSet.sInf",
   "OrderHom",
   "CompleteLattice.toBot",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "sInfHomClass.toInfTopHomClass",
   "Eq.mpr",
   "Topology.IsLower",
   "Continuous",
   "le_trans",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Set.image",
   "sInfHom.instSInfHomClassSInfHom",
   "Eq.trans",
   "sInfHomClass.map_sInf",
   "isClosed_Ici",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "eq_of_heq",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "bot_nonempty",
   "Std.Logic._auxLemma.5",
   "sInfHomClass.toFunLike",
   "Std.Logic._auxLemma.23",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "Std.Logic._auxLemma.57",
   "And",
   "HEq.refl",
   "of_eq_true",
   "IsClosed",
   "congrArg",
   "congrFun",
   "sInfHom",
   "Exists",
   "HEq",
   "Topology.IsLower.instClosedIciTopology",
   "Eq.ge",
   "Set",
   "Eq.refl",
   "InfHomClass.toOrderHomClass",
   "Set.Ici",
   "True",
   "Std.Logic._auxLemma.33",
   "CompleteLattice.toConditionallyCompleteLattice",
   "forall_congr",
   "InfTopHomClass.toInfHomClass",
   "TopologicalSpace",
   "OrderHomClass.toOrderHom",
   "Eq.symm",
   "Set.Subset.antisymm",
   "id",
   "Membership.mem",
   "Std.Logic._auxLemma.29",
   "funext",
   "Set.image_congr",
   "Set.preimage",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "LE.le.trans",
   "ConditionallyCompleteLattice.toLattice",
   "FunLike.coe",
   "Topology.IsLower.continuous_of_Ici",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "sInf_le",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toTop",
   "Eq.casesOn",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Mathlib.Order.CompleteLattice._auxLemma.3"],
  "name": "sInfHom.continuous",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : Topology.IsLower Î±] [inst_4 : TopologicalSpace Î²] [inst_5 : Topology.IsLower Î²] (f : sInfHom Î± Î²),\n  Continuous â†‘f",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Topology.Basic._auxLemma.49",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "True",
   "Eq",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Topology.Basic._auxLemma.18",
   "Set.ext",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "congr",
   "TopologicalSpace",
   "Filter",
   "congrArg",
   "IsOpen",
   "interior",
   "Eq.trans",
   "instMembershipSetFilter"],
  "name": "interior_eq_nhds'",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, interior s = {a | s âˆˆ nhds a}",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "False.rec",
  "constType": "(motive : False â†’ Sort u) â†’ (t : False) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_succ",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.zero_mul",
  "constType": "âˆ€ (n : â„•), 0 * n = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 â†’ Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "sSup_eq_iSup",
   "Set",
   "InfSet.sInf",
   "OrderDual",
   "Set.instMembershipSet",
   "Eq"],
  "name": "sInf_eq_iInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {s : Set Î±}, sInf s = â¨… a âˆˆ s, a",
  "constCategory": "Theorem"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{Î± : Type u_1} â†’ HasSubset (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.antisymm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLower", "Preorder"],
  "name": "Topology.WithLower.instPreorderWithLower._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "ContinuousMap"],
  "name": "ContinuousMap.toFun",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : TopologicalSpace Î±] â†’ [inst_1 : TopologicalSpace Î²] â†’ C(Î±, Î²) â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring Î±] â†’\n    [toOne : One Î±] â†’\n      (âˆ€ (a : Î±), 1 * a = a) â†’\n        (âˆ€ (a : Î±), a * 1 = a) â†’\n          [toNatCast : NatCast Î±] â†’\n            autoParam (NatCast.natCast 0 = 0) _autoâœ â†’\n              autoParam (âˆ€ (n : â„•), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _autoâœÂ¹ â†’ NonAssocSemiring Î±",
  "constCategory": "Other"},
 {"references": ["SupSet", "InfSet.sInf", "OrderDual", "SupSet.mk", "InfSet"],
  "name": "OrderDual.supSet",
  "constType": "(Î± : Type u_9) â†’ [inst : InfSet Î±] â†’ SupSet Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Iff", "not_congr", "Not"],
  "name": "Iff.not",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ (Â¬a â†” Â¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Bot.bot",
   "propext",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.neBot_iff",
   "Filter.NeBot",
   "Eq",
   "Filter.instCompleteLatticeFilter"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.30",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±}, Filter.NeBot f = (f â‰  âŠ¥)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasSubset",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["Lean.TSyntax", "Lean.SyntaxNodeKinds", "Lean.Syntax"],
  "name": "Lean.TSyntax.raw",
  "constType": "{ks : Lean.SyntaxNodeKinds} â†’ Lean.TSyntax ks â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["MonadLiftT", "MonadLiftT.monadLift"],
  "name": "liftM",
  "constType":
  "{m : Type u_1 â†’ Type u_2} â†’ {n : Type u_1 â†’ Type u_3} â†’ [self : MonadLiftT m n] â†’ {Î± : Type u_1} â†’ m Î± â†’ n Î±",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.ofLowerSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "HEq.refl",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.mem_split",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {l : List Î±}, a âˆˆ l â†’ âˆƒ s, âˆƒ t, l = s ++ a :: t",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.ofUpperSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.finite_empty",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set.Finite.isOpen_sInter",
   "Set.sInter_empty",
   "Set",
   "Eq.refl",
   "Set.union_subset",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Iff.mpr",
   "Set.Subset.rfl",
   "Eq",
   "Set.instSingletonSet",
   "Set.sInter_union",
   "Eq.mpr",
   "TopologicalSpace.IsTopologicalBasis.mk",
   "Set.iUnion",
   "Eq.substr",
   "Set.sUnion_image",
   "le_generateFrom",
   "TopologicalSpace",
   "Set.Finite.union",
   "Set.image",
   "Eq.symm",
   "And.casesOn",
   "IsOpen",
   "id",
   "TopologicalSpace.IsTopologicalBasis",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "Set.singleton_subset_iff",
   "TopologicalSpace.GenerateOpen.basic",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "Union.union",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.iUnionâ‚‚_eq_univ_iff",
   "Set.univ",
   "Set.Finite",
   "Set.instMembershipSet",
   "TopologicalSpace.generateFrom_anti",
   "And",
   "Set.instHasSubsetSet",
   "Set.finite_singleton",
   "Eq.ndrec",
   "propext",
   "Set.empty_subset",
   "Singleton.singleton",
   "Set.sUnion",
   "And.intro",
   "le_antisymm",
   "Set.sInter",
   "Set.sInter_singleton",
   "Set.mem_univ",
   "Set.instUnionSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.isTopologicalBasis_of_subbasis",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  t = TopologicalSpace.generateFrom s â†’\n    TopologicalSpace.IsTopologicalBasis ((fun f â†¦ â‹‚â‚€ f) '' {f | Set.Finite f âˆ§ f âŠ† s})",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "False",
   "Iff",
   "EmptyCollection.emptyCollection",
   "Iff.rfl",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_empty_iff_false",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), x âˆˆ âˆ… â†” False",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "InfSet.sInf",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "OrderDual.completeLattice",
   "OrderDual",
   "Set.image",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²],\n  GaloisCoinsertion l u â†’\n    âˆ€ (s : Set Î±),\n      (â†‘OrderDual.toDual âˆ˜ l âˆ˜ â†‘OrderDual.ofDual)\n          ((â†‘OrderDual.toDual âˆ˜ u âˆ˜ â†‘OrderDual.ofDual) (sInf (â†‘OrderDual.toDual âˆ˜ l âˆ˜ â†‘OrderDual.ofDual '' s))) â‰¤\n        sInf (â†‘OrderDual.toDual âˆ˜ l âˆ˜ â†‘OrderDual.ofDual '' s)",
  "constCategory": "Theorem"},
 {"references": ["Quot", "Eq"],
  "name": "Quot.lift",
  "constType":
  "{Î± : Sort u} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ {Î² : Sort v} â†’ (f : Î± â†’ Î²) â†’ (âˆ€ (a b : Î±), r a b â†’ f a = f b) â†’ Quot r â†’ Î²",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step", "instLENat", "Nat.le.refl", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ",
  "constType": "âˆ€ (n : â„•), n â‰¤ Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCommSemigroup.toAddSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) â†’ [inst : AddCancelCommMonoid M] â†’ AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Nonempty", "Subtype"],
  "name": "NonemptyType",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SupSet",
   "CompleteSemilatticeSup",
   "PartialOrder.toPreorder",
   "Set",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "CompleteSemilatticeSup.mk",
  "constType":
  "{Î± : Type u_9} â†’\n  [toPartialOrder : PartialOrder Î±] â†’\n    [toSupSet : SupSet Î±] â†’\n      (âˆ€ (s : Set Î±), âˆ€ a âˆˆ s, a â‰¤ sSup s) â†’\n        (âˆ€ (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a) â†’ CompleteSemilatticeSup Î±",
  "constCategory": "Other"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{Î± : Type u} â†’ [self : NonAssocSemiring Î±] â†’ One Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_9",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Î± â†’ Prop), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false",
   "Lean.replaceRef.match_1",
   "Lean.Syntax",
   "Lean.Syntax.getPos?",
   "String.Pos",
   "Option"],
  "name": "Lean.replaceRef",
  "constType": "Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.substr",
  "constType": "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {a b : Î±}, b = a â†’ p a â†’ p b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_le_succ",
   "dite",
   "List.indexOf",
   "ite",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "List.rec",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.indexOf_cons",
   "Nat.succ",
   "if_neg",
   "Nat.strictOrderedSemiring",
   "id",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "instBEq",
   "List.length",
   "LE.le",
   "if_pos",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "List",
   "le_refl",
   "Not",
   "Nat.zero_le",
   "congrArg",
   "congrFun"],
  "name": "List.indexOf_le_length",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, List.indexOf a l â‰¤ List.length l",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "âˆ€ {Î± : Type u_2} [self : LinearOrderedCommSemiring Î±] (a b : Î±), a â‰¤ b âˆ¨ b â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.beq.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ List Î± â†’ Sort u_2) â†’\n    (x x_1 : List Î±) â†’\n      (Unit â†’ motive [] []) â†’\n        ((a : Î±) â†’ (as : List Î±) â†’ (b : Î±) â†’ (bs : List Î±) â†’ motive (a :: as) (b :: bs)) â†’\n          ((x x_2 : List Î±) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "Filter.NeBot.mk",
   "Set",
   "Set.Nonempty",
   "Set.not_nonempty_empty",
   "Set.instEmptyCollectionSet",
   "Filter.nonempty_of_mem",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.rec",
   "Filter",
   "Filter.mem_bot",
   "Eq.symm",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.forall_mem_nonempty_iff_neBot",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±}, (âˆ€ s âˆˆ f, Set.Nonempty s) â†” Filter.NeBot f",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp", "Set.finite_coe_iff", "Set.Elem", "Set", "Finite", "Set.Finite"],
  "name": "Set.toFinite",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±) [inst : Finite â†‘s], Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sInter",
   "IsOpen",
   "AlexandrovDiscrete",
   "Set.instMembershipSet"],
  "name": "AlexandrovDiscrete.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±],\n  (âˆ€ (S : Set (Set Î±)), (âˆ€ s âˆˆ S, IsOpen s) â†’ IsOpen (â‹‚â‚€ S)) â†’ AlexandrovDiscrete Î±",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "Set",
   "Set.Iic",
   "Preorder.toLE",
   "True",
   "SetLike.instMembership",
   "iff_self",
   "Eq",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.instSingletonSet",
   "Iff",
   "Mathlib.Order.UpperLower.Basic._auxLemma.95",
   "lowerClosure",
   "Eq.trans",
   "LowerSet.ext",
   "Membership.mem",
   "funext",
   "LowerSet.Iic",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.38",
   "LowerSet",
   "And",
   "of_eq_true",
   "LowerSet.instSetLikeLowerSet",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "SetLike.coe",
   "congrFun"],
  "name": "lowerClosure_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), lowerClosure {a} = LowerSet.Iic a",
  "constCategory": "Theorem"},
 {"references": ["And", "False", "propext", "and_not_self_iff", "Not", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.85",
  "constType": "âˆ€ (a : Prop), (a âˆ§ Â¬a) = False",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_HomotopyGroup_Pi_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.65",
  "constType": "âˆ€ {Î± : Sort u_1} {a b : Î±}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Or",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Classical.em",
   "Classical.propDecidable.match_1",
   "Nonempty"],
  "name": "Classical.propDecidable.proof_1",
  "constType": "âˆ€ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} â†’ {N : Type u_4} â†’ [inst : Zero M] â†’ [inst_1 : Zero N] â†’ ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references":
  ["IsCommutative.mk",
   "Set",
   "Set.inter_comm",
   "Inter.inter",
   "IsCommutative",
   "Set.instInterSet"],
  "name": "Set.inter_isComm.proof_1",
  "constType": "âˆ€ {Î± : Type u_1}, IsCommutative (Set Î±) fun x x_1 â†¦ x âˆ© x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Set.instMembershipSet"],
  "name": "Filter.sets_of_superset",
  "constType":
  "âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ x âŠ† y â†’ y âˆˆ self.sets",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "or_and_left", "Iff.mpr"],
  "name": "Prop.distribLattice.proof_3",
  "constType": "âˆ€ (x x_1 x_2 : Prop), (x âˆ¨ x_1) âˆ§ (x âˆ¨ x_2) â†’ x âˆ¨ x_1 âˆ§ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.zero_add",
  "constType":
  "âˆ€ {M : Type u} [self : AddRightCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Exists",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Order.Coframe", "CompleteLattice"],
  "name": "Order.Coframe.toCompleteLattice",
  "constType": "{Î± : Type u_1} â†’ [self : Order.Coframe Î±] â†’ CompleteLattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "CompleteLattice.le_sSup",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "SupSet.sSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²]\n  (gi : GaloisCoinsertion l u) (s : Set Î±áµ’áµˆáµ’áµˆ), âˆ€ a âˆˆ s, a â‰¤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "Eq.ndrec",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "Eq.symm",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Eq.subset",
  "constType": "âˆ€ {Î± : Type u_1} {s t : Set Î±}, s = t â†’ s âŠ† t",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "propext",
   "Sup.sup",
   "sup_le_iff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.7",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, (a âŠ” b â‰¤ c) = (a â‰¤ c âˆ§ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "Classical.em.match_2",
  "constType":
  "âˆ€ (p u v : Prop) (motive : u â‰  v âˆ¨ p â†’ Prop) (not_uv_or_p : u â‰  v âˆ¨ p),\n  (âˆ€ (hne : u â‰  v), motive (_ : u â‰  v âˆ¨ p)) â†’ (âˆ€ (h : p), motive (_ : u â‰  v âˆ¨ p)) â†’ motive not_uv_or_p",
  "constCategory": "Definition"},
 {"references": ["PLift"],
  "name": "PLift.down",
  "constType": "{Î± : Sort u} â†’ PLift Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Or", "propext", "Not", "imp_iff_not_or", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.64",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) = (Â¬a âˆ¨ b)",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Nonempty.some",
  "constType": "{Î± : Sort u_2} â†’ Nonempty Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Multiset.map.proof_1",
   "Setoid.r",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.map",
   "Multiset.ofList"],
  "name": "Multiset.map",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Multiset Î± â†’ Multiset Î²",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithUpper",
   "Exists",
   "Equiv.toHomeomorphOfInducing",
   "setOf",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Topology.IsUpper",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "Equiv.refl",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.IsUpper.WithUpperHomeomorph._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsUpper Î±] â†’ Topology.WithUpper Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name": "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["PProd", "Lean.Data.AC.Expr", "PUnit", "Lean.Data.AC.Expr.rec", "Nat"],
  "name": "Lean.Data.AC.Expr.below",
  "constType":
  "{motive : Lean.Data.AC.Expr â†’ Sort u} â†’ Lean.Data.AC.Expr â†’ Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Functor"],
  "name": "Functor.mapConst",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : Functor f] â†’ {Î± Î² : Type u} â†’ Î± â†’ f Î² â†’ f Î±",
  "constCategory": "Definition"},
 {"references": ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.bot_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [self : OrderBot Î±] (a : Î±), âŠ¥ â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "And.comm.match_1",
   "And.intro",
   "And.comm.match_2"],
  "name": "And.comm",
  "constType": "âˆ€ {a b : Prop}, a âˆ§ b â†” b âˆ§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet.mk",
   "Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Topology.IsUpperSet.rec",
   "Eq"],
  "name": "Topology.IsUpperSet.recOn",
  "constType":
  "{Î± : Type u_4} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsUpperSet Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsUpperSet Î±) â†’\n          ((topology_eq_upperSetTopology : t = Topology.upperSet Î±) â†’ motive (_ : Topology.IsUpperSet Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references": ["cast", "HEq", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "âˆ€ {Î± : Sort u} {a a' : Î±}, HEq a a' â†’ a = a'",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam"],
  "name": "ZeroHomClass",
  "constType":
  "Type u_9 â†’\n  (M : outParam (Type u_10)) â†’\n    (N : outParam (Type u_11)) â†’ [inst : Zero M] â†’ [inst : Zero N] â†’ Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["Inf", "SemilatticeInf"],
  "name": "SemilatticeInf.toInf",
  "constType": "{Î± : Type u} â†’ [self : SemilatticeInf Î±] â†’ Inf Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Inf.inf",
   "InfSet.sInf",
   "Eq.refl",
   "Insert.insert",
   "True",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Set.image",
   "Eq.symm",
   "Eq.trans",
   "id",
   "eq_self",
   "sInfHomClass.map_sInf",
   "Set.image_pair",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sInfHomClass",
   "sInf_insert",
   "sInf_singleton",
   "CompleteLattice",
   "Eq.ndrec",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "Singleton.singleton",
   "sInf_pair",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Set.instInsertSet",
   "congrFun"],
  "name": "sInfHomClass.toInfTopHomClass.proof_1",
  "constType":
  "âˆ€ {F : Type u_3} {Î± : Type u_2} {Î² : Type u_1} [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²]\n  [inst_2 : sInfHomClass F Î± Î²] (f : F) (a b : Î±), â†‘f (a âŠ“ b) = â†‘f a âŠ“ â†‘f b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "le_sup_inf"],
  "name": "Pi.distribLattice.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ DistribLattice (Î±' i)] (x x_1 x_2 : (i : Î¹) â†’ Î±' i) (x_3 : Î¹),\n  (x x_3 âŠ” x_1 x_3) âŠ“ (x x_3 âŠ” x_2 x_3) â‰¤ x x_3 âŠ” x_1 x_3 âŠ“ x_2 x_3",
  "constCategory": "Theorem"},
 {"references": ["LE", "OrderBot", "BoundedOrder"],
  "name": "BoundedOrder.toOrderBot",
  "constType":
  "{Î± : Type u} â†’ [inst : LE Î±] â†’ [self : BoundedOrder Î±] â†’ OrderBot Î±",
  "constCategory": "Definition"},
 {"references": ["Nat.isValidChar", "UInt32", "UInt32.toNat"],
  "name": "UInt32.isValidChar",
  "constType": "UInt32 â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "GaloisConnection.u_inf",
   "Filter.gc_map_comap",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "Filter.map",
   "Filter.instInfFilter",
   "Filter.comap",
   "Filter",
   "Eq",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.comap_inf",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {gâ‚ gâ‚‚ : Filter Î²} {m : Î± â†’ Î²},\n  Filter.comap m (gâ‚ âŠ“ gâ‚‚) = Filter.comap m gâ‚ âŠ“ Filter.comap m gâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.isEmpty.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ Sort u_2) â†’\n    (x : List Î±) â†’ (Unit â†’ motive []) â†’ ((head : Î±) â†’ (tail : List Î±) â†’ motive (head :: tail)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "And",
   "Exists",
   "setOf",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "lowerClosure",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Set.Finite",
   "SetLike.coe",
   "Eq"],
  "name": "Topology.IsUpper.upperBasis",
  "constType": "(Î± : Type u_1) â†’ [inst : Preorder Î±] â†’ Set (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "HImp.himp",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "HeytingAlgebra.toHasCompl",
   "HeytingAlgebra.himp_bot",
   "Eq"],
  "name": "himp_bot",
  "constType": "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] (a : Î±), a â‡¨ âŠ¥ = aá¶œ",
  "constCategory": "Theorem"},
 {"references": ["UInt32", "UInt32.size", "Fin"],
  "name": "UInt32.val",
  "constType": "UInt32 â†’ Fin UInt32.size",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "outParam",
   "Function.Injective",
   "EmbeddingLike",
   "FunLike.coe"],
  "name": "EmbeddingLike.injective'",
  "constType":
  "âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EmbeddingLike F Î± Î²] (f : F),\n  Function.Injective â†‘f",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "true_and_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.Chain._auxLemma.9",
  "constType": "âˆ€ (p : Prop), (True âˆ§ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_coe",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.4",
  "constType": "âˆ€ {Î± : Type u_1} {a : Î±} {s : Finset Î±}, (a âˆˆ â†‘s) = (a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets", "Filter.filter_eq_iff", "propext", "Set", "Filter", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.3",
  "constType": "âˆ€ {Î± : Type u} {f g : Filter Î±}, (f = g) = (f.sets = g.sets)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EStateM.Result",
  "constType": "Type u â†’ Type u â†’ Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Nat.pred",
   "instSubNat",
   "HSub.hSub",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.sub_succ",
  "constType": "âˆ€ (n m : â„•), n - Nat.succ m = Nat.pred (n - m)",
  "constCategory": "Theorem"},
 {"references": ["Preorder"],
  "name": "OrderHom",
  "constType":
  "(Î± : Type u_6) â†’ (Î² : Type u_7) â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ Type (max u_6 u_7)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Iff.rfl",
   "antitone_comp_ofDual_iff",
   "Function.comp",
   "Eq.refl",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "monotone_toDual_comp_iff",
   "Monotone",
   "OrderDual",
   "Antitone",
   "id"],
  "name": "monotone_dual_iff",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Monotone (â†‘OrderDual.toDual âˆ˜ f âˆ˜ â†‘OrderDual.ofDual) â†” Monotone f",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Sublist"],
  "name": "List.Sublist.cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (a : Î±), List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist lâ‚ (a :: lâ‚‚)",
  "constCategory": "Other"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.ilast'.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : Î± â†’ List Î± â†’ Sort u_2) â†’\n    (x : Î±) â†’ (x_1 : List Î±) â†’ ((a : Î±) â†’ motive a []) â†’ ((x b : Î±) â†’ (l : List Î±) â†’ motive x (b :: l)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Option.none",
   "Bool.false",
   "Option.some",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.getPos?.match_1",
   "optParam",
   "Substring",
   "String.Pos",
   "Option"],
  "name": "Lean.SourceInfo.getPos?",
  "constType": "Lean.SourceInfo â†’ optParam Bool false â†’ Option String.Pos",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.IsClosed_of._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.IsClosed_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8577",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 â†’ Sort u_2 â†’ Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Or",
   "Iff",
   "Iff.rfl",
   "Union.union",
   "Set",
   "Set.instUnionSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_union",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), x âˆˆ a âˆª b â†” x âˆˆ a âˆ¨ x âˆˆ b",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "OrderTop.toTop",
   "PartialOrder.toPreorder",
   "Top.top",
   "le_top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "top_unique",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] {a : Î±}, âŠ¤ â‰¤ a â†’ a = âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.mul.match_1",
  "constType":
  "(motive : â„• â†’ â„• â†’ Sort u_1) â†’\n  (x x_1 : â„•) â†’ ((x : â„•) â†’ motive x 0) â†’ ((a : â„•) â†’ (b : â„•) â†’ motive a (Nat.succ b)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r", "Setoid", "Quotient", "Quot.inductionOn", "Quotient.mk"],
  "name": "Quotient.inductionOn",
  "constType":
  "âˆ€ {Î± : Sort u} {s : Setoid Î±} {motive : Quotient s â†’ Prop} (q : Quotient s),\n  (âˆ€ (a : Î±), motive (Quotient.mk s a)) â†’ motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_1",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length",
   "instLTNat",
   "List.get.proof_1",
   "PProd",
   "PProd.fst",
   "List.get.match_1",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Fin.mk",
   "Fin"],
  "name": "List.get",
  "constType": "{Î± : Type u} â†’ (as : List Î±) â†’ Fin (List.length as) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.Subset.trans",
  "constType": "âˆ€ {Î± : Type u} {a b c : Set Î±}, a âŠ† b â†’ b âŠ† c â†’ a âŠ† c",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.Perm.refl.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : List Î± â†’ Prop) (x : List Î±),\n  (Unit â†’ motive []) â†’ (âˆ€ (x : Î±) (xs : List Î±), motive (x :: xs)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Inter.inter", "TopologicalSpace.GenerateOpen", "Set.instInterSet"],
  "name": "TopologicalSpace.GenerateOpen.inter",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} (s t : Set Î±),\n  TopologicalSpace.GenerateOpen g s â†’ TopologicalSpace.GenerateOpen g t â†’ TopologicalSpace.GenerateOpen g (s âˆ© t)",
  "constCategory": "Other"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{Î± : Type u} â†’ Array Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "Iff.intro",
   "And",
   "List.pairwise_cons.match_1",
   "List.cons",
   "Iff",
   "List.pairwise_cons.match_2",
   "List.instMembershipList",
   "List",
   "And.intro",
   "List.Pairwise.cons"],
  "name": "List.pairwise_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±},\n  List.Pairwise R (a :: l) â†” (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«termð“[_]_Â»._closed_10",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“[_]_Â»._closed_2"],
  "name": "Topology.Â«termð“[_]_Â»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Finite.Set.finite_image.proof_1", "Set.Elem", "Set", "Finite", "Set.image"],
  "name": "Finite.Set.finite_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (s : Set Î±) (f : Î± â†’ Î²) [inst : Finite â†‘s], Finite â†‘(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.preimage",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "Set.Ici",
   "Exists.casesOn",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Topology.IsLower.topology_eq",
   "Set.instMembershipSet",
   "Eq",
   "continuous_generateFrom",
   "Eq.ndrec",
   "IsClosed.isOpen_compl",
   "Topology.IsLower",
   "Topology.lower",
   "Continuous",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen"],
  "name": "Topology.IsLower.continuous_of_Ici",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±]\n  [inst_3 : TopologicalSpace Î²] {f : Î² â†’ Î±}, (âˆ€ (a : Î±), IsClosed (f â»Â¹' Set.Ici a)) â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.toHomeomorphOfInducing._at.Topology.IsUpperSet.WithUpperSetHomeomorph._spec_1",
   "Equiv.refl",
   "_obj",
   "_neutral"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "ContinuousMap",
  "constType":
  "(Î± : Type u_1) â†’ (Î² : Type u_2) â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references":
  ["instHasEquiv", "Setoid", "Quotient", "HasEquiv.Equiv", "Quot.lift", "Eq"],
  "name": "Quotient.lift",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {s : Setoid Î±} â†’ (f : Î± â†’ Î²) â†’ (âˆ€ (a b : Î±), a â‰ˆ b â†’ f a = f b) â†’ Quotient s â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
  "constType":
  "âˆ€ {Î± : Type u} [self : OrderedCancelAddCommMonoid Î±] (a b c : Î±), a + b â‰¤ a + c â†’ b â‰¤ c",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î± : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (x : (i : Î¹) â†’ Î± i) (x_1 : Î¹),\n  âŠ¤ â‰¤ x x_1 âŠ” (x x_1)á¶œ",
  "constCategory": "Theorem"},
 {"references": ["Monotone", "Preorder", "LE.le", "Preorder.toLE", "id"],
  "name": "monotone_id",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±], Monotone id",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.getPos?",
   "Bool.false",
   "Bool",
   "optParam",
   "Lean.Syntax",
   "Lean.Syntax.getHeadInfo",
   "String.Pos",
   "Option"],
  "name": "Lean.Syntax.getPos?",
  "constType": "Lean.Syntax â†’ optParam Bool false â†’ Option String.Pos",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet.topology_eq_lowerSetTopology",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLowerSet.topology_eq",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±],\n  inst_1 = Topology.lowerSet Î±",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "le_compl_comm",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "le_compl_compl",
   "LE.le.trans",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "Antitone",
   "HeytingAlgebra.toHasCompl",
   "LE.le",
   "Preorder.toLE"],
  "name": "compl_anti",
  "constType": "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±], Antitone compl",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.decidableBAll.match_3",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "List.decidableBAll.proof_4",
   "Decidable.isTrue",
   "dite",
   "List.decidableBAll.proof_2",
   "List.decidableBAll.proof_1",
   "DecidablePred",
   "PProd",
   "List.decidableBEx.match_5",
   "PProd.fst",
   "List.rec",
   "Decidable.isFalse",
   "List",
   "PUnit",
   "Decidable",
   "Not",
   "List.nil",
   "List.decidableBAll.proof_3"],
  "name": "List.decidableBAll",
  "constType":
  "{Î± : Type u_1} â†’ (p : Î± â†’ Prop) â†’ [inst : DecidablePred p] â†’ (l : List Î±) â†’ Decidable (âˆ€ x âˆˆ l, p x)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.str"],
  "name": "Lean.Name.rec",
  "constType":
  "{motive : Lean.Name â†’ Sort u} â†’\n  motive Lean.Name.anonymous â†’\n    ((pre : Lean.Name) â†’ (str : String) â†’ motive pre â†’ motive (Lean.Name.str pre str)) â†’\n      ((pre : Lean.Name) â†’ (i : â„•) â†’ motive pre â†’ motive (Lean.Name.num pre i)) â†’ (t : Lean.Name) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["forall_eq'", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.35",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a' = a â†’ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "âˆ€ {Î± : Type u} [self : Semiring Î±] (a : Î±), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“Ë¢Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a < b â†’ a â‰  b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "Set",
   "OrderDual",
   "TopologicalSpace",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "TopologicalSpace.gciGenerateFrom.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (x : TopologicalSpace Î±) (s : Set Î±),\n  IsOpen s â†’ TopologicalSpace.GenerateOpen (â†‘OrderDual.ofDual (â†‘OrderDual.toDual {s | IsOpen s})) s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "BEq",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Function.Bijective",
   "Function.Surjective",
   "Fintype.ofBijective.match_1",
   "Finset.instMembershipFinset",
   "And.left",
   "Eq",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "And.right",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "Finset",
   "Finset.mem_univ",
   "Finset.mem_map_of_mem"],
  "name": "Fintype.ofBijective.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Fintype Î±] (f : Î± â†’ Î²) (H : Function.Bijective f) (b : Î²),\n  b âˆˆ Finset.map { toFun := f, inj' := (_ : Function.Injective f) } Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike",
   "Function.Injective",
   "Set",
   "SetLike.coe_injective'",
   "SetLike.coe",
   "Eq"],
  "name": "SetLike.coe_injective",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[<]_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.upper._cstage1",
  "constType": "(Î± : Type u_1) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Finite.casesOn",
   "Eq.ndrec",
   "Finite.intro",
   "Finite",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "Equiv.trans",
   "Fin",
   "Equiv.symm",
   "Eq"],
  "name": "Finite.of_equiv",
  "constType":
  "âˆ€ {Î² : Sort u_2} (Î± : Sort u_3) [h : Finite Î±], Î± â‰ƒ Î² â†’ Finite Î²",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "propext",
   "LE.le",
   "le_antisymm_iff",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.36",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, (a = b) = (a â‰¤ b âˆ§ b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{Î± : Type u} â†’ [self : NonUnitalSemiring Î±] â†’ NonUnitalNonAssocSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.get",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "instLTNat",
   "Fin.mk",
   "Eq"],
  "name": "List.get?_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {n : â„•} {a : Î±}\n  (motive : (âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a) â†’ Prop)\n  (x : âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a),\n  (âˆ€ (w : n < List.length l) (e : List.get l { val := n, isLt := w } = a),\n      motive (_ : âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Exists.intro",
   "Exists.casesOn",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn"],
  "name": "Subtype.exists.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop} (motive : (âˆƒ x, q x) â†’ Prop) (x : âˆƒ x, q x),\n  (âˆ€ (a : Î±) (b : p a) (h : q { val := a, property := b }), motive (_ : âˆƒ x, q x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.List.Perm._auxLemma.2",
   "List.cons",
   "Or",
   "List.instMembershipList",
   "Iff.rfl",
   "List.Perm.rec",
   "True",
   "iff_self",
   "Eq",
   "List.Perm",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.List.Perm._auxLemma.3",
   "propext",
   "List",
   "congr",
   "Iff.trans",
   "List.nil",
   "congrArg",
   "Eq.trans"],
  "name": "List.Perm.mem_iff",
  "constType":
  "âˆ€ {Î± : Type uu} {a : Î±} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (a âˆˆ lâ‚ â†” a âˆˆ lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["Monotone", "OrderHom", "OrderHom.toFun", "Preorder"],
  "name": "OrderHom.monotone'",
  "constType":
  "âˆ€ {Î± : Type u_6} {Î² : Type u_7} [inst : Preorder Î±] [inst_1 : Preorder Î²] (self : Î± â†’o Î²), Monotone self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_trans.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (_a _b _c : Î±) (motive : _a â‰¤ _b âˆ§ Â¬_b â‰¤ _a â†’ _b â‰¤ _c âˆ§ Â¬_c â‰¤ _b â†’ Prop)\n  (x : _a â‰¤ _b âˆ§ Â¬_b â‰¤ _a) (x_1 : _b â‰¤ _c âˆ§ Â¬_c â‰¤ _b),\n  (âˆ€ (hab : _a â‰¤ _b) (_hba : Â¬_b â‰¤ _a) (hbc : _b â‰¤ _c) (hcb : Â¬_c â‰¤ _b),\n      motive (_ : _a â‰¤ _b âˆ§ Â¬_b â‰¤ _a) (_ : _b â‰¤ _c âˆ§ Â¬_c â‰¤ _b)) â†’\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Fin.veq_of_eq.match_1",
   "Fin.val",
   "LT.lt",
   "Nat",
   "rfl",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Eq"],
  "name": "Fin.veq_of_eq",
  "constType": "âˆ€ {n : â„•} {i j : Fin n}, i = j â†’ â†‘i = â†‘j",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.IsOpen_of._closed_4"],
  "name": "Topology.IsOpen_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.seq",
  "constType": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ Set (Î± â†’ Î²) â†’ Set Î± â†’ Set Î²",
  "constCategory": "Definition"},
 {"references":
  ["List.filter",
   "funext",
   "Eq.refl",
   "instBEq",
   "List.filter_eq'",
   "Subsingleton.elim",
   "Eq",
   "Decidable.decide",
   "Eq.mpr",
   "Eq.ndrec",
   "DecidableEq",
   "List",
   "Eq.rec",
   "Decidable",
   "List.replicate",
   "Eq.mp",
   "Std.Data.List.Count._auxLemma.10",
   "Bool",
   "List.count",
   "congrArg",
   "Eq.trans",
   "instSubsingletonDecidable",
   "id",
   "congrFun"],
  "name": "List.filter_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±) (a : Î±),\n  List.filter (fun x â†¦ decide (a = x)) l = List.replicate (List.count a l) a",
  "constCategory": "Theorem"},
 {"references":
  ["And", "Or", "Iff", "Iff.trans", "forall_and", "or_imp", "forall_congr'"],
  "name": "ball_or_left",
  "constType":
  "âˆ€ {Î± : Sort u_1} {r p q : Î± â†’ Prop}, (âˆ€ (x : Î±), p x âˆ¨ q x â†’ r x) â†” (âˆ€ (x : Î±), p x â†’ r x) âˆ§ âˆ€ (x : Î±), q x â†’ r x",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "iSup_exists",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.iUnion_exists",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {p : Î¹ â†’ Prop} {f : Exists p â†’ Set Î±},\n  â‹ƒ (x : Exists p), f x = â‹ƒ i, â‹ƒ (h : p i), f (_ : Exists p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.insert",
   "List.instMembershipList",
   "dite",
   "List.Perm.cons",
   "mt",
   "Iff.mpr",
   "True",
   "Eq",
   "List.Perm.subset",
   "eq_false",
   "Eq.mpr",
   "eq_true",
   "List.Perm",
   "List.insert_of_not_mem",
   "DecidableEq",
   "of_eq_true",
   "List",
   "List.Perm.mem_iff",
   "List.instDecidableMemListInstMembershipList",
   "Eq.mp",
   "Mathlib.Data.List.Perm._auxLemma.18",
   "congr",
   "Not",
   "not_false_eq_true",
   "congrArg",
   "List.insert_of_mem",
   "Eq.trans",
   "id"],
  "name": "List.Perm.insert",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] (a : Î±) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.insert a lâ‚ ~ List.insert a lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.iUnion",
   "Set",
   "TopologicalSpace",
   "IsOpen",
   "isOpen_iUnion",
   "Set.instMembershipSet"],
  "name": "isOpen_biUnion",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] {s : Set Î²} {f : Î² â†’ Set Î±},\n  (âˆ€ i âˆˆ s, IsOpen (f i)) â†’ IsOpen (â‹ƒ i âˆˆ s, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLowerSet.isLowerSet_toLowerSet_preimage",
   "Equiv",
   "Iff.symm",
   "Iff",
   "Topology.WithLowerSet",
   "IsLowerSet",
   "Set.preimage",
   "Set",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.isOpen_ofLowerSet_preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, IsOpen (â†‘Topology.WithLowerSet.ofLowerSet â»Â¹' s) â†” IsLowerSet s",
  "constCategory": "Theorem"},
 {"references": ["PUnit", "Prod", "semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.mk",
  "constType":
  "{Ïƒ : semiOutParam (Type u)} â†’\n  {m : Type u â†’ Type v} â†’ m Ïƒ â†’ (Ïƒ â†’ m PUnit.{u + 1}) â†’ ({Î± : Type u} â†’ (Ïƒ â†’ Î± Ã— Ïƒ) â†’ m Î±) â†’ MonadStateOf Ïƒ m",
  "constCategory": "Other"},
 {"references": ["semiOutParam", "MonadExceptOf"],
  "name": "MonadExceptOf.mk",
  "constType":
  "{Îµ : semiOutParam (Type u)} â†’\n  {m : Type v â†’ Type w} â†’ ({Î± : Type v} â†’ Îµ â†’ m Î±) â†’ ({Î± : Type v} â†’ m Î± â†’ (Îµ â†’ m Î±) â†’ m Î±) â†’ MonadExceptOf Îµ m",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "bot_unique",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toDistribLattice",
   "BoundedOrder.toOrderBot"],
  "name": "inf_compl_eq_bot'",
  "constType": "âˆ€ {Î± : Type u} {x : Î±} [inst : BooleanAlgebra Î±], x âŠ“ xá¶œ = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Set.preimage",
   "IsLowerSet.preimage",
   "OrderHom.monotone",
   "Function.comp",
   "Set",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "Topology.WithLowerSet.toLowerSet",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Topology.WithLowerSet",
   "Continuous",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithLowerSet.ofLowerSet",
   "IsOpen",
   "continuous_def"],
  "name": "Topology.WithLowerSet.map.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : Preorder Î²] (f : Î± â†’o Î²),\n  Continuous (â†‘Topology.WithLowerSet.toLowerSet âˆ˜ â†‘f âˆ˜ â†‘Topology.WithLowerSet.ofLowerSet)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.RightInverse", "Function.comp", "Function.LeftInverse.comp"],
  "name": "Function.RightInverse.comp",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {Î³ : Sort u_3} {f : Î± â†’ Î²} {g : Î² â†’ Î±} {h : Î² â†’ Î³} {i : Î³ â†’ Î²},\n  Function.RightInverse f g â†’ Function.RightInverse h i â†’ Function.RightInverse (h âˆ˜ f) (g âˆ˜ i)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Or", "Iff", "Classical.propDecidable", "Not", "Decidable.imp_iff_not_or"],
  "name": "imp_iff_not_or",
  "constType": "âˆ€ {a b : Prop}, a â†’ b â†” Â¬a âˆ¨ b",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Std.Data.List.Count._auxLemma.10",
  "constType": "âˆ€ {Î± : Sort u_1} {a b : Î±}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.mem_Ici",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a x : Î±}, x âˆˆ Set.Ici a â†” a â‰¤ x",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Or", "eq_true", "Or.inl", "True", "Eq"],
  "name": "true_or",
  "constType": "âˆ€ (p : Prop), (True âˆ¨ p) = True",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Lean.Name", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.cat",
  "constType": "Lean.Name â†’ â„• â†’ Lean.ParserDescr",
  "constCategory": "Other"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ a â†’ b",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "readThe", "MonadReader", "MonadReader.mk"],
  "name": "instMonadReader",
  "constType":
  "(Ï : Type u) â†’ (m : Type u â†’ Type v) â†’ [inst : MonadReaderOf Ï m] â†’ MonadReader Ï m",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_6",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "List.casesOn",
   "Classical.em",
   "Lean.Data.AC.mergeIdem.loop",
   "instDecidableEqNat",
   "ite",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.List.two_step_induction",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Nat",
   "Lean.IsIdempotent.idempotent",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "Or",
   "Lean.Data.AC.Context.idem",
   "eq_false_of_decide",
   "Or.casesOn",
   "instDecidableTrue",
   "Lean.Data.AC.Context.op",
   "_private.Init.Data.AC.0.Lean.Data.AC.evalList._eq_3",
   "Lean.Data.AC.Context.mergeIdem_head2",
   "False.elim",
   "of_eq_true",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Eq.mp",
   "congr",
   "Not",
   "congrArg",
   "congrFun",
   "Eq.refl",
   "Lean.Data.AC.Context.mergeIdem_nonEmpty",
   "Lean.Data.AC.ContextInformation.isIdem",
   "True",
   "Lean.Data.AC.Context.assoc",
   "Lean.Data.AC.Context",
   "eq_false'",
   "Option.some",
   "List.nil",
   "Eq.symm",
   "absurd",
   "Option.toBool.match_1",
   "if_neg",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "Option",
   "eq_self",
   "List.cons",
   "False",
   "Or.inr",
   "Unit",
   "Option.casesOn",
   "Lean.IsIdempotent",
   "ite_congr",
   "if_pos",
   "eq_false",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "Or.inl",
   "Bool.false",
   "List",
   "Lean.Data.AC.mergeIdem",
   "Lean.Data.AC.Context.mergeIdem_head",
   "Bool",
   "List.noConfusion"],
  "name": "Lean.Data.AC.Context.evalList_mergeIdem",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±),\n  Lean.Data.AC.ContextInformation.isIdem ctx = true â†’\n    âˆ€ (e : List â„•), Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.mergeIdem e) = Lean.Data.AC.evalList Î± ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{Î± : Type u} â†’ [self : Semiring Î±] â†’ NonAssocSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "IsOpen.mem_nhds",
   "Exists.intro",
   "TopologicalSpace.IsTopologicalBasis.isOpen",
   "Exists.casesOn",
   "Eq",
   "Iff.mp",
   "Filter.HasBasis.prod_nhds",
   "TopologicalSpace.IsTopologicalBasis.nhds_hasBasis",
   "SProd.sprod",
   "TopologicalSpace",
   "Filter",
   "And.casesOn",
   "IsOpen",
   "TopologicalSpace.IsTopologicalBasis",
   "instMembershipSetFilter",
   "Membership.mem",
   "Set.instSProd",
   "Set.image2",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "TopologicalSpace.isTopologicalBasis_of_open_of_nhds",
   "IsOpen.prod",
   "nhds",
   "HasSubset.Subset",
   "Prod.fst",
   "Filter.HasBasis.mem_iff",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.mem_image2_of_mem",
   "Prod.casesOn",
   "Prod.mk",
   "Prod",
   "And.intro"],
  "name": "TopologicalSpace.IsTopologicalBasis.prod",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²] {Bâ‚ : Set (Set Î±)}\n  {Bâ‚‚ : Set (Set Î²)},\n  TopologicalSpace.IsTopologicalBasis Bâ‚ â†’\n    TopologicalSpace.IsTopologicalBasis Bâ‚‚ â†’\n      TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x x_1 â†¦ x Ã—Ë¢ x_1) Bâ‚ Bâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLower.to_WithLower_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithLower.toLower.symm = Topology.WithLower.ofLower",
  "constCategory": "Theorem"},
 {"references": ["IsAntisymm", "Eq"],
  "name": "IsAntisymm.antisymm",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [self : IsAntisymm Î± r] (a b : Î±), r a b â†’ r b a â†’ a = b",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.finRange.proof_1",
   "List.Nodup",
   "LT.lt",
   "List.finRange",
   "List.Pairwise.pmap",
   "Fin.ne_of_vne",
   "List.nodup_range",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.nodup_finRange",
  "constType": "âˆ€ (n : â„•), List.Nodup (List.finRange n)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{Î± : Type u} â†’ [self : StrictOrderedCommSemiring Î±] â†’ StrictOrderedSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.37",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_1"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["instLENat", "LT.lt", "Nat", "instLTNat", "Nat.succ", "LE.le"],
  "name": "Nat.lt_of_succ_le",
  "constType": "âˆ€ {n m : â„•}, Nat.succ n â‰¤ m â†’ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.add_zero",
  "constType":
  "âˆ€ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "ZeroHom.mk",
   "Multiset.card.proof_2",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Quot.liftOn",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Multiset.card.proof_1",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat",
   "AddMonoidHom",
   "AddMonoidHom.mk"],
  "name": "Multiset.card",
  "constType": "{Î± : Type u_1} â†’ Multiset Î± â†’+ â„•",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsAssociative",
   "Sup.sup",
   "instIsAssociativeSupToSup.proof_1"],
  "name": "instIsAssociativeSupToSup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±], IsAssociative Î± fun x x_1 â†¦ x âŠ” x_1",
  "constCategory": "Definition"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.10",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆƒ x, p x) = âˆ€ (x : Î±), Â¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "sInfHom.toFun",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "Set.image",
   "Eq"],
  "name": "sInfHom.map_sInf'",
  "constType":
  "âˆ€ {Î± : Type u_8} {Î² : Type u_9} [inst : InfSet Î±] [inst_1 : InfSet Î²] (self : sInfHom Î± Î²) (s : Set Î±),\n  sInfHom.toFun self (sInf s) = sInf (self.toFun '' s)",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "instIsAntisymmLeToLEToPreorder",
   "inferInstance",
   "IsAntisymm",
   "Set.instBooleanAlgebraSet",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.instIsAntisymmSetSubsetInstHasSubsetSet.proof_1",
  "constType": "âˆ€ {Î± : Type u_1}, IsAntisymm (Set Î±) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references": ["Bool.false", "Bool.true", "Bool.rec", "Bool"],
  "name": "Bool.casesOn",
  "constType":
  "{motive : Bool â†’ Sort u} â†’ (t : Bool) â†’ motive false â†’ motive true â†’ motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "imp_intro",
  "constType": "âˆ€ {Î± Î² : Prop}, Î± â†’ Î² â†’ Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Nat.right_distrib",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "id",
   "Add.mk"],
  "name": "Nat.commSemiring.proof_1",
  "constType":
  "âˆ€ (x x_1 : â„•), (fun m n â†¦ m * n) (x + 1) x_1 = x_1 + (fun m n â†¦ m * n) x x_1",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet.rec._rarg", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.rec._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "List.range_loop_range'",
   "Nat.zero_add",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.range.loop",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "List.range",
   "id"],
  "name": "List.range_eq_range'",
  "constType": "âˆ€ (n : â„•), List.range n = List.range' 0 n",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "continuous_fst",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "continuous_snd",
   "IsOpen.inter",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "IsOpen.preimage",
   "IsOpen"],
  "name": "IsOpen.prod",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²},\n  IsOpen s â†’ IsOpen t â†’ IsOpen (s Ã—Ë¢ t)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name",
   "Lean.Syntax.node3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "InfSet.sInf",
   "CompleteLattice.sInf_le",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²]\n  (gi : GaloisCoinsertion l u) (s : Set Î±áµ’áµˆáµ’áµˆ), âˆ€ a âˆˆ s, sInf s â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Function.RightInverse",
   "Equiv.invFun",
   "Function.comp",
   "Equiv.right_inv",
   "FunLike.coe",
   "Function.RightInverse.comp",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans.proof_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_3} {Î³ : Sort u_2} (eâ‚ : Î± â‰ƒ Î²) (eâ‚‚ : Î² â‰ƒ Î³),\n  Function.RightInverse (â†‘eâ‚.symm âˆ˜ eâ‚‚.invFun) (eâ‚‚.toFun âˆ˜ â†‘eâ‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "List.length",
   "Nat",
   "And.casesOn",
   "Eq"],
  "name": "List.eq_replicate.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {n : â„•} {l : List Î±} (motive : (List.length l = n âˆ§ âˆ€ b âˆˆ l, b = a) â†’ Prop)\n  (x : List.length l = n âˆ§ âˆ€ b âˆˆ l, b = a),\n  (âˆ€ (e : List.length l = n) (al : âˆ€ b âˆˆ l, b = a), motive (_ : List.length l = n âˆ§ âˆ€ b âˆˆ l, b = a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.symm",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†’ b âˆ¨ a",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.bot_le",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.heytingAlgebra",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_5",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (a : (i : Î¹) â†’ Î± i), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references": ["outParam", "EStateM.Backtrackable"],
  "name": "EStateM.Backtrackable.save",
  "constType":
  "{Î´ : outParam (Type u)} â†’ {Ïƒ : Type u} â†’ [self : EStateM.Backtrackable Î´ Ïƒ] â†’ Ïƒ â†’ Î´",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_idem",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_idem",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a : Î±}, a âŠ“ a = a",
  "constCategory": "Theorem"},
 {"references": ["Array.mkEmpty", "_obj", "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Finite.intro", "Finite", "Nat", "Finite.rec", "Fin"],
  "name": "Finite.casesOn",
  "constType":
  "âˆ€ {Î± : Sort u_1} {motive : Finite Î± â†’ Prop} (t : Finite Î±),\n  (âˆ€ {n : â„•} (a : Î± â‰ƒ Fin n), motive (_ : Finite Î±)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.State", "Lean.MacroScope"],
  "name": "Lean.Macro.State.macroScope",
  "constType": "Lean.Macro.State â†’ Lean.MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "OrderDual",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "OrderDual.toDual_ofDual",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±áµ’áµˆ), â†‘OrderDual.toDual (â†‘OrderDual.ofDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.left",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_left",
  "constType": "âˆ€ {Î± : Type u} (s t : Set Î±), s âˆ© t âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["UInt64.size", "LT.lt", "UInt64", "UInt64.mk", "Nat", "instLTNat", "Fin.mk"],
  "name": "UInt64.ofNatCore",
  "constType": "(n : â„•) â†’ n < UInt64.size â†’ UInt64",
  "constCategory": "Definition"},
 {"references":
  ["isLUB_pair",
   "SemilatticeSup",
   "Set.instSingletonSet",
   "eq_true",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set",
   "Sup.sup",
   "Singleton.singleton",
   "Insert.insert",
   "True",
   "SemilatticeSup.toPartialOrder",
   "IsLUB",
   "Eq",
   "Set.instInsertSet"],
  "name": "Mathlib.Order.GaloisConnection._auxLemma.1",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {a b : Î³}, IsLUB {a, b} (a âŠ” b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "HEq",
   "List.instMembershipList",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "List.indexOf",
   "rfl",
   "Eq",
   "ite",
   "Nat.add",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Eq.symm",
   "List.indexOf_cons",
   "Eq.trans",
   "Nat.succ",
   "if_neg",
   "Mathlib.Data.List.Basic._auxLemma.33",
   "id",
   "Membership.mem",
   "Nat.succ_inj'",
   "List.cons",
   "Or",
   "False",
   "instAddNat",
   "instHAdd",
   "iff_of_true",
   "instBEq",
   "List.not_mem_nil",
   "List.length",
   "Mathlib.Data.List.Basic._auxLemma.12",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "Or.inl",
   "HEq.refl",
   "DecidableEq",
   "propext",
   "Nat.noConfusion",
   "List",
   "congr",
   "Not",
   "Eq.casesOn",
   "iff_of_false",
   "congrArg",
   "congrFun"],
  "name": "List.indexOf_eq_length",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, List.indexOf a l = List.length l â†” Â¬a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype.val",
   "Set",
   "Set.Nonempty",
   "GE.ge",
   "Eq.refl",
   "Directed",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Filter.HasBasis",
   "Filter.principal",
   "Eq.mpr",
   "Filter",
   "Eq.symm",
   "Directed.mono_comp",
   "Subtype",
   "Filter.instCompleteLatticeFilter",
   "id",
   "Membership.mem",
   "Function.comp",
   "Filter.principal_mono",
   "HasSubset.Subset",
   "DirectedOn",
   "directedOn_iff_directed",
   "directed_comp",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Order.Preimage",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "iInf",
   "CompleteLattice.toInfSet",
   "propext",
   "Eq.mp",
   "Filter.instPartialOrderFilter",
   "Filter.mem_biInf_of_directed",
   "Filter.HasBasis.mk"],
  "name": "Filter.hasBasis_biInf_principal",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Î² â†’ Set Î±} {S : Set Î²},\n  DirectedOn (s â»Â¹'o fun x x_1 â†¦ x â‰¥ x_1) S â†’\n    Set.Nonempty S â†’ Filter.HasBasis (â¨… i âˆˆ S, Filter.principal (s i)) (fun i â†¦ i âˆˆ S) s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Filter.principal",
   "Iff",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Set.Subset.rfl",
   "Preorder.toLE",
   "instMembershipSetFilter"],
  "name": "Filter.le_principal_iff",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {f : Filter Î±}, f â‰¤ Filter.principal s â†” s âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "False",
   "GE.ge",
   "instLTNat",
   "LE.le",
   "GT.gt",
   "Eq",
   "Nat.le_total.match_1",
   "instLENat",
   "Eq.subst",
   "LT.lt",
   "Nat.lt_trans",
   "Nat.lt_irrefl",
   "Not",
   "Nat.lt_or_ge",
   "Nat",
   "Nat.le_antisymm",
   "absurd"],
  "name": "Nat.not_le_of_gt",
  "constType": "âˆ€ {n m : â„•}, n > m â†’ Â¬n â‰¤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop â†’ Prop â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Lattice._auxLemma.27",
   "Set",
   "Set.univ",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "iff_self",
   "Iff",
   "Set.iUnion",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion_eq_univ_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Set Î±}, â‹ƒ i, f i = Set.univ â†” âˆ€ (x : Î±), âˆƒ i, x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "mem_interior",
   "IsOpen",
   "interior",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.18",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {x : Î±}, (x âˆˆ interior s) = âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousMap.rec",
   "Continuous",
   "TopologicalSpace",
   "ContinuousMap",
   "ContinuousMap.mk"],
  "name": "ContinuousMap.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : TopologicalSpace Î±] â†’\n      [inst_1 : TopologicalSpace Î²] â†’\n        {motive : C(Î±, Î²) â†’ Sort u} â†’\n          (t : C(Î±, Î²)) â†’\n            ((toFun : Î± â†’ Î²) â†’ (continuous_toFun : Continuous toFun) â†’ motive (ContinuousMap.mk toFun)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpper.instPreorderWithUpper._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "IsAntisymm",
   "propext",
   "IsRefl",
   "HasSubset.Subset",
   "subset_antisymm_iff",
   "HasSubset",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.19",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1]\n  [inst_2 : IsAntisymm Î± fun x x_1 â†¦ x âŠ† x_1], (a âŠ† b âˆ§ b âŠ† a) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ HMod Î± Î² Î³",
  "constCategory": "Other"},
 {"references": ["and_or_left", "And", "Or", "propext", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.8",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ (b âˆ¨ c)) = (a âˆ§ b âˆ¨ a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot.proof_1",
   "GeneralizedBooleanAlgebra",
   "Bot.mk",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "OrderBot",
   "OrderBot.mk",
   "Preorder.toLE",
   "GeneralizedBooleanAlgebra.toBot"],
  "name": "GeneralizedBooleanAlgebra.toOrderBot",
  "constType":
  "{Î± : Type u} â†’ [inst : GeneralizedBooleanAlgebra Î±] â†’ OrderBot Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Std.Data.List.Lemmas._auxLemma.108",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.112",
   "HAdd.hAdd",
   "List.range_eq_range'",
   "instLTNat",
   "LE.le",
   "True",
   "iff_self",
   "Nat.zero_add",
   "And",
   "Iff",
   "instLENat",
   "of_eq_true",
   "List",
   "LT.lt",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "List.range",
   "congrFun"],
  "name": "List.mem_range",
  "constType": "âˆ€ {m n : â„•}, m âˆˆ List.range n â†” m < n",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "Iff", "And.intro", "And.left"],
  "name": "and_iff_left_of_imp",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (a âˆ§ b â†” a)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "List",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "List.hasDecEq.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (as bs : List Î±) â†’\n    (motive : Decidable (as = bs) â†’ Sort u_2) â†’\n      (x : Decidable (as = bs)) â†’\n        ((habs : as = bs) â†’ motive (isTrue habs)) â†’ ((nabs : Â¬as = bs) â†’ motive (isFalse nabs)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_singleton",
   "Iff",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Finset.mem_singleton",
  "constType": "âˆ€ {Î± : Type u_1} {a b : Î±}, b âˆˆ {a} â†” b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithLowerSet",
   "IsLowerSet",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "List.cons",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GeneralizedHeytingAlgebra",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{Î± : Type u_4} â†’ Finset Î± â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{Î± : Type u_1} â†’ Î± â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "Eq.mpr",
   "Eq.ndrec",
   "Function.comp",
   "Eq.refl",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.comp",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {Î³ : Sort u_3} {f : Î± â†’ Î²} {g : Î² â†’ Î±} {h : Î² â†’ Î³} {i : Î³ â†’ Î²},\n  Function.LeftInverse f g â†’ Function.LeftInverse h i â†’ Function.LeftInverse (h âˆ˜ f) (g âˆ˜ i)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "le_top",
   "CompleteLattice.toBoundedOrder",
   "Eq.refl",
   "biInf_mono",
   "Inter.inter",
   "And.left",
   "BoundedOrder.toOrderTop",
   "Iff.mpr",
   "Preorder.toLE",
   "Set.subset_sUnion_of_mem",
   "Eq",
   "OrderTop.toTop",
   "Filter.principal",
   "And.right",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Filter.instTopFilter",
   "le_inf",
   "Filter",
   "Filter.inf_principal",
   "iInfâ‚‚_le",
   "Eq.symm",
   "IsOpen",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.GenerateOpen.rec",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Top.top",
   "nhds",
   "LE.le.trans",
   "Filter.principal_mono",
   "HasSubset.Subset",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace.GenerateOpen",
   "TopologicalSpace.nhds_generateFrom.match_3",
   "Set.univ",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Set.instMembershipSet",
   "nhds_def",
   "le_iInfâ‚‚",
   "Filter.principal_univ",
   "And",
   "TopologicalSpace.nhds_generateFrom.match_1",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "iInf",
   "Filter.instPartialOrderFilter",
   "Set.sUnion",
   "And.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "LE.le.trans_eq",
   "TopologicalSpace.nhds_generateFrom.match_2",
   "Set.instInterSet"],
  "name": "TopologicalSpace.nhds_generateFrom",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {a : Î±}, nhds a = â¨… s âˆˆ {s | a âˆˆ s âˆ§ s âˆˆ g}, Filter.principal s",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble",
  "constType": "â„• â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["CompleteBooleanAlgebra", "InfSet"],
  "name": "CompleteBooleanAlgebra.toInfSet",
  "constType": "{Î± : Type u_1} â†’ [self : CompleteBooleanAlgebra Î±] â†’ InfSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Nat.eq_of_beq_eq_true",
   "Decidable",
   "Nat.ne_of_beq_eq_false",
   "Decidable.isTrue",
   "Nat.beq",
   "Bool",
   "Nat.decEq.match_1",
   "Nat",
   "Eq"],
  "name": "Nat.decEq",
  "constType": "(n m : â„•) â†’ Decidable (n = m)",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "HImp.himp",
   "Eq.ndrec",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "propext",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "id"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BooleanAlgebra Î±] (a b c : Î±), a â‰¤ b â‡¨ c â†” a âŠ“ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Setoid", "Quot"],
  "name": "Quotient",
  "constType": "{Î± : Sort u} â†’ Setoid Î± â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Or.imp_left",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "Or.imp_right",
   "Or.rec"],
  "name": "or_assoc",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ¨ b) âˆ¨ c â†” a âˆ¨ b âˆ¨ c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "inseparable_iff_specializes_and",
   "Specializes",
   "propext",
   "TopologicalSpace",
   "Inseparable",
   "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.9",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y = (x â¤³ y âˆ§ y â¤³ x)",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "rfl", "Eq"],
  "name": "forall_apply_eq_imp_iffâ‚‚",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  (âˆ€ (b : Î²) (a : Î±), p a â†’ f a = b â†’ q b) â†” âˆ€ (a : Î±), p a â†’ q (f a)",
  "constCategory": "Theorem"},
 {"references": ["Id"],
  "name": "Id.run",
  "constType": "{Î± : Type u_1} â†’ Id Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "cond.match_1",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (c : Bool) â†’ (Unit â†’ motive true) â†’ (Unit â†’ motive false) â†’ motive c",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "Quotient.liftOnâ‚‚",
   "HAppend.hAppend",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ofList",
   "Multiset.add.proof_1"],
  "name": "Multiset.add",
  "constType": "{Î± : Type u_1} â†’ Multiset Î± â†’ Multiset Î± â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet"],
  "name": "Topology.WithLowerSet.map._elambda_1._cstage1",
  "constType":
  "(Î± : Type u_1) â†’\n  (Î² : Type u_2) â†’\n    ((a : Î²) â†’ (fun x â†¦ Topology.WithLowerSet Î²) a) â†’\n      (Topology.WithLowerSet Î± â†’ Î²) â†’ Topology.WithLowerSet Î± â†’ Topology.WithLowerSet Î²",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "Std.Logic._auxLemma.34",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.8",
   "Eq.refl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Std.Data.List.Lemmas._auxLemma.11",
   "Std.Data.List.Basic._auxLemma.3",
   "Iff",
   "List.rec",
   "forall_congr",
   "List.nil",
   "Eq.trans",
   "Membership.mem",
   "List.cons",
   "Or",
   "False",
   "Std.Data.List.Lemmas._auxLemma.18",
   "implies_true",
   "Std.Data.List.Lemmas._auxLemma.70",
   "and_true",
   "Std.Data.List.Lemmas._auxLemma.19",
   "List.Pairwise",
   "And",
   "instHAppend",
   "List.instAppendList",
   "of_eq_true",
   "propext",
   "HAppend.hAppend",
   "List",
   "congr",
   "congrArg",
   "congrFun"],
  "name": "List.pairwise_append",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {lâ‚ lâ‚‚ : List Î±},\n  List.Pairwise R (lâ‚ ++ lâ‚‚) â†” List.Pairwise R lâ‚ âˆ§ List.Pairwise R lâ‚‚ âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelMonoid", "Nat"],
  "name": "AddRightCancelMonoid.nsmul",
  "constType": "{M : Type u} â†’ [self : AddRightCancelMonoid M] â†’ â„• â†’ M â†’ M",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike.coe",
   "EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.RightInverse.surjective",
   "Function.Surjective",
   "EquivLike.toEmbeddingLike",
   "FunLike.coe",
   "EquivLike.right_inv",
   "EquivLike.inv"],
  "name": "EquivLike.surjective",
  "constType":
  "âˆ€ {E : Sort u_1} {Î± : Sort u_3} {Î² : Sort u_4} [iE : EquivLike E Î± Î²] (e : E), Function.Surjective â†‘e",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "UInt32.val",
   "UInt32",
   "LE",
   "instLEFin",
   "UInt32.size",
   "LE.le",
   "Fin"],
  "name": "instLEUInt32",
  "constType": "LE UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Prod.fst",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "InfSet.mk",
   "And",
   "sInf_le",
   "Prod.infSet",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Prod",
   "And.intro",
   "Set.image",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Set.mem_image_of_mem"],
  "name": "Prod.completeLattice.proof_6",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (x : Set (Î± Ã— Î²)),\n  âˆ€ x_1 âˆˆ x, (sInf x).1 â‰¤ x_1.1 âˆ§ (sInf x).2 â‰¤ x_1.2",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{Î± : Type u} â†’ [self : Max Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Set.instMembershipSet"],
  "name": "Set.Subset",
  "constType": "{Î± : Type u_1} â†’ Set Î± â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["IsCommutative.comm", "Eq", "IsCommutative"],
  "name": "instIsCommutative.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {op : Î± â†’ Î± â†’ Î±} [inst : IsCommutative Î± op] (a b : Î±), op a b = op b a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.instMembershipList",
   "List.get?_eq_some",
   "List.length",
   "instLTNat",
   "Eq",
   "Iff.mp",
   "List",
   "Eq.rec",
   "LT.lt",
   "List.get_mem",
   "Option.some",
   "Nat",
   "List.get?",
   "List.get",
   "List.get?_mem.match_1",
   "Fin.mk",
   "Option"],
  "name": "List.get?_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {n : â„•} {a : Î±}, List.get? l n = some a â†’ a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Subtype.exists.match_2",
   "Exists.intro",
   "Subtype.exists.match_1",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.exists",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) â†” âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "inf_sup_left",
   "True",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "inf_comm",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans"],
  "name": "inf_sup_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DistribLattice Î±] {x y z : Î±}, (y âŠ” z) âŠ“ x = y âŠ“ x âŠ” z âŠ“ x",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "Equiv.pprodEquivProd",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Prod.fst",
   "PProd.snd",
   "Filter.HasBasis",
   "PProd",
   "And",
   "PProd.fst",
   "Filter.HasBasis.comp_equiv",
   "Filter.instInfFilter",
   "Filter.HasBasis.inf'",
   "Filter",
   "Prod",
   "Set.instInterSet",
   "Equiv.symm"],
  "name": "Filter.HasBasis.inf",
  "constType":
  "âˆ€ {Î± : Type u_1} {l l' : Filter Î±} {Î¹ : Type u_6} {Î¹' : Type u_7} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {p' : Î¹' â†’ Prop}\n  {s' : Î¹' â†’ Set Î±},\n  Filter.HasBasis l p s â†’\n    Filter.HasBasis l' p' s' â†’ Filter.HasBasis (l âŠ“ l') (fun i â†¦ p i.1 âˆ§ p' i.2) fun i â†¦ s i.1 âˆ© s' i.2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Or",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.mem_cons",
   "Multiset.cons",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.mem_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {s : Multiset Î±}, a âˆˆ b ::â‚˜ s â†” a = b âˆ¨ a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "Lattice.mk",
   "And.left",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "And.right",
   "upperBounds",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.isGLB_of_u_image",
   "id",
   "Membership.mem",
   "isGLB_sInf",
   "Monotone.mem_lowerBounds_image",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "GaloisInsertion.choice",
   "Set.instMembershipSet",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.choice_eq",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_5",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±]\n  (gi : GaloisInsertion l u) (s : Set Î²) (a : Î²), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "propext",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : GeneralizedHeytingAlgebra Î±] (a b c : Î±), (a â‰¤ b â‡¨ c) = (a âŠ“ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_4",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ne", "DecidableEq", "List", "instDecidableNot", "List.pwFilter", "Eq"],
  "name": "List.dedup",
  "constType": "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["not_le_of_gt",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "Preorder",
   "Preorder.toLE"],
  "name": "not_lt_of_ge",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a â‰¥ b â†’ Â¬a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x}, (âˆ€ (x : Î±), f x = g x) â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Iff", "Nat.succ.inj", "Nat", "congrArg", "Nat.succ", "Eq"],
  "name": "Nat.succ_inj'",
  "constType": "âˆ€ {n m : â„•}, Nat.succ n = Nat.succ m â†” n = m",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "HEq",
   "eq_of_heq",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "Inter.inter",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "HEq.refl",
   "Filter.casesOn",
   "Filter.mk",
   "Filter",
   "Eq.casesOn",
   "Eq.symm",
   "Set.instInterSet"],
  "name": "Filter.filter_eq.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x x_1 : Filter Î±) â†’ x.sets = x_1.sets â†’ Prop) (x x_1 : Filter Î±) (x_2 : x.sets = x_1.sets),\n  (âˆ€ (sets : Set (Set Î±)) (univ_sets : Set.univ âˆˆ sets)\n      (sets_of_superset : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets)\n      (inter_sets : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets) (univ_sets_1 : Set.univ âˆˆ sets)\n      (sets_of_superset_1 : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets)\n      (inter_sets_1 : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets),\n      motive { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }\n        { sets := sets, univ_sets := univ_sets_1, sets_of_superset := sets_of_superset_1, inter_sets := inter_sets_1 }\n        (_ :\n          { sets := sets, univ_sets := (_ : Set.univ âˆˆ sets),\n                sets_of_superset := (_ : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets),\n                inter_sets := (_ : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets) }.sets =\n            { sets := sets, univ_sets := (_ : Set.univ âˆˆ sets),\n                sets_of_superset := (_ : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets),\n                inter_sets := (_ : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets) }.sets)) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Prod.lattice",
   "Prod",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (a b : Î± Ã— Î²), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«termð“[<]_Â»._closed_2",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“[<]_Â»._closed_5"],
  "name": "Topology.Â«termð“[<]_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{Î± : Type u} â†’ [self : Preorder Î±] â†’ LT Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_right",
   "Lattice",
   "LE.le",
   "Pi.semilatticeInf",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.lattice.proof_5",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î±' i)] (a b : (i : Î¹) â†’ Î±' i), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.inter_sets",
   "Membership.mem",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Filter.inter_mem",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s t : Set Î±}, s âˆˆ f â†’ t âˆˆ f â†’ s âˆ© t âˆˆ f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Macro.State",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_6"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "And",
   "Bot.bot",
   "Prod.snd",
   "OrderBot.toBot",
   "inferInstanceAs",
   "Bot.mk",
   "LE",
   "Prod",
   "Prod.fst",
   "And.intro",
   "OrderBot",
   "bot_le",
   "LE.le",
   "Prod.bot"],
  "name": "Prod.orderBot.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LE Î±] [inst_1 : LE Î²] [inst_2 : OrderBot Î±] [inst_3 : OrderBot Î²] (x : Î± Ã— Î²),\n  âŠ¥.1 â‰¤ x.1 âˆ§ âŠ¥.2 â‰¤ x.2",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "Union.union",
   "Set",
   "sInf_union",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.sInter",
   "Set.instUnionSet",
   "Set.instInterSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_union",
  "constType": "âˆ€ {Î± : Type u_1} (S T : Set (Set Î±)), â‹‚â‚€ (S âˆª T) = â‹‚â‚€ S âˆ© â‹‚â‚€ T",
  "constCategory": "Theorem"},
 {"references": ["Char", "UInt32", "UInt32.isValidChar"],
  "name": "Char.mk",
  "constType": "(val : UInt32) â†’ UInt32.isValidChar val â†’ Char",
  "constCategory": "Other"},
 {"references": ["Set", "Filter"],
  "name": "Filter.HasBasis",
  "constType":
  "{Î± : Type u_1} â†’ {Î¹ : Sort u_4} â†’ Filter Î± â†’ (Î¹ â†’ Prop) â†’ (Î¹ â†’ Set Î±) â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Function.LeftInverse",
  "constType": "{Î± : Sort uâ‚} â†’ {Î² : Sort uâ‚‚} â†’ (Î² â†’ Î±) â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "_private.Std.Data.List.Count.0.List.countP.go._unfold",
   "True",
   "Eq",
   "Bool.of_not_eq_true",
   "Eq.mpr",
   "List.rec",
   "Bool.true",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Eq.trans",
   "id",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List.countP.go",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.countP_go_eq_add",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {n : â„•} (l : List Î±), List.countP.go p l n = n + List.countP.go p l 0",
  "constCategory": "Theorem"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{Î± : Type u_1} â†’ [inst : Zero Î±] â†’ OfNat Î± 0",
  "constCategory": "Definition"},
 {"references":
  ["Codisjoint",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "Codisjoint_comm",
   "OrderTop",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Codisjoint.symm",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] â¦ƒa b : Î±â¦„, Codisjoint a b â†’ Codisjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq", "LawfulBEq", "instBEq", "instLawfulBEqInstBEq.proof_1"],
  "name": "instLawfulBEqInstBEq",
  "constType": "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±], LawfulBEq Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Exists",
   "OfNat.ofNat",
   "Iff",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.length",
   "Nat",
   "instLTNat",
   "List.exists_mem_of_length_pos",
   "List.length_pos_of_mem",
   "List.length_pos_iff_exists_mem.match_1"],
  "name": "List.length_pos_iff_exists_mem",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, 0 < List.length l â†” âˆƒ a, a âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["UInt64.size", "UInt64", "Fin"],
  "name": "UInt64.mk",
  "constType": "Fin UInt64.size â†’ UInt64",
  "constCategory": "Other"},
 {"references": ["Nat.le", "Nat"],
  "name": "Nat.le.refl",
  "constType": "âˆ€ {n : â„•}, Nat.le n n",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_sUnion",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.sUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {S : Set (Set Î±)}, (x âˆˆ â‹ƒâ‚€ S) = âˆƒ t âˆˆ S, x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra.proof_2",
  "constType": "âˆ€ {Î± : Type u_1} [inst : BiheytingAlgebra Î±] (a : Î±), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "Filter.le_generate_iff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "Filter.instPartialOrderFilter",
   "Filter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm"],
  "name": "Filter.giGenerate.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (s : Set (Set Î±)), (Filter.generate s).sets â‰¤ s â†’ (Filter.generate s).sets = s",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Topology.IsUpperSet.closure_eq_lowerClosure",
   "OrderDual.instPreorder",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "OrderDual.instIsUpperSet",
   "Topology.IsLowerSet",
   "Preorder",
   "UpperSet",
   "Preorder.toLE",
   "SetLike.coe",
   "Eq"],
  "name": "Topology.IsLowerSet.closure_eq_upperClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±] {s : Set Î±},\n  closure s = â†‘(upperClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "eq_self",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "True",
   "Eq",
   "Nat.zero_add",
   "instHAppend",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans"],
  "name": "List.length_append",
  "constType":
  "âˆ€ {Î± : Type u} (as bs : List Î±), List.length (as ++ bs) = List.length as + List.length bs",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "Multiset.attach",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.nodup_attach",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "Iff.mpr"],
  "name": "Finset.attach.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Finset Î±), Multiset.Nodup (Multiset.attach s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "TopologicalSpace",
   "OrderDual",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b : TopologicalSpace Î±), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Set.mem_Iic",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {b x : Î±}, (x âˆˆ Set.Iic b) = (x â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": ["Char", "String.rec", "List", "String.mk", "String"],
  "name": "String.casesOn",
  "constType":
  "{motive : String â†’ Sort u} â†’ (t : String) â†’ ((data : List Char) â†’ motive { data := data }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "SemilatticeSup.sup_le",
  "constType":
  "âˆ€ {Î± : Type u} [self : SemilatticeSup Î±] (a b c : Î±), a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "funext",
   "Prod.snd",
   "Set",
   "Prod.fst",
   "SupSet.sSup",
   "iSup",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "sSup_image",
   "CompleteLattice",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "Prod.supSet",
   "Prod",
   "Sup.sup",
   "iSup_sup_eq",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "supsSupHom.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] (s : Set (Î± Ã— Î±)),\n  (fun x â†¦ x.1 âŠ” x.2) (sSup s) = sSup ((fun x â†¦ x.1 âŠ” x.2) '' s)",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ (a â†” b)",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "Eq.ndrec",
   "Set.preimage",
   "Set",
   "IsOpen.inter",
   "TopologicalSpace",
   "Inter.inter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Set.preimage_inter",
   "Set.instInterSet",
   "Eq"],
  "name": "TopologicalSpace.induced.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (t : TopologicalSpace Î²) (sâ‚ sâ‚‚ : Set Î±),\n  (âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = sâ‚) â†’\n    (fun s â†¦ âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = s) sâ‚‚ â†’ (fun s â†¦ âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = s) (sâ‚ âˆ© sâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_6",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsUpper",
  "constType":
  "(Î± : Type u_1) â†’ [t : TopologicalSpace Î±] â†’ [inst : Preorder Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "List.Perm",
   "List",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.exists_perm_sublist.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚‚ lâ‚ : List Î±} (motive : (âˆƒ lâ‚', âˆƒ (_ : lâ‚' ~ lâ‚), List.Sublist lâ‚' lâ‚‚) â†’ Prop)\n  (x : âˆƒ lâ‚', âˆƒ (_ : lâ‚' ~ lâ‚), List.Sublist lâ‚' lâ‚‚),\n  (âˆ€ (lâ‚' : List Î±) (p' : lâ‚' ~ lâ‚) (s' : List.Sublist lâ‚' lâ‚‚),\n      motive (_ : âˆƒ lâ‚', âˆƒ (_ : lâ‚' ~ lâ‚), List.Sublist lâ‚' lâ‚‚)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Topology.WithUpperSet",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Definition"},
 {"references": ["Nat", "Fin"],
  "name": "Fin.val",
  "constType": "{n : â„•} â†’ Fin n â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Nodup.pmap.match_1",
   "List.pmap",
   "List.Nodup.map",
   "List.Nodup.pmap.match_2",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "List.Nodup.attach",
   "List.pmap_eq_map_attach",
   "List.attach",
   "Eq",
   "Subtype.property",
   "Eq.mpr",
   "List.Nodup",
   "Eq.ndrec",
   "List",
   "Eq.rec",
   "List.map",
   "Subtype.mk",
   "Subtype",
   "id"],
  "name": "List.Nodup.pmap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {l : List Î±} {H : âˆ€ a âˆˆ l, p a},\n  (âˆ€ (a : Î±) (ha : p a) (b : Î±) (hb : p b), f a ha = f b hb â†’ a = b) â†’ List.Nodup l â†’ List.Nodup (List.pmap f l H)",
  "constCategory": "Theorem"},
 {"references":
  ["List.filterMap",
   "Eq.refl",
   "dite",
   "List.filter_cons_of_pos",
   "True",
   "Eq",
   "ite",
   "Bool.of_not_eq_true",
   "List.rec",
   "List.filterMap_cons.match_1",
   "Option.none",
   "Bool.true",
   "Option.some",
   "List.nil",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "Option",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "List.filter",
   "funext",
   "False",
   "List.filter_cons_of_neg",
   "Unit",
   "eq_false_of_decide",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "of_eq_true",
   "Bool.false",
   "List",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "Option.guard",
   "congrFun"],
  "name": "List.filterMap_eq_filter",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool), List.filterMap (Option.guard fun x â†¦ p x = true) = List.filter p",
  "constCategory": "Theorem"},
 {"references":
  ["LowerSet",
   "LowerSet.mk",
   "Set.Iic",
   "Preorder",
   "isLowerSet_Iic",
   "Preorder.toLE"],
  "name": "LowerSet.Iic",
  "constType": "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â†’ LowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "LE.mk",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_3",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_1",
   "Set",
   "TopologicalSpace.ext",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_2",
   "FunLike.coe",
   "Prop.partialOrder",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "Preorder.mk",
   "Preorder.toLT",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_4",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace",
  "constType": "{Î± : Type u} â†’ PartialOrder (TopologicalSpace Î±)",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "inferInstanceAs",
   "OrderDual",
   "OrderDual.instPartialOrder.proof_3",
   "OrderDual.instPartialOrder.proof_1",
   "Preorder",
   "le_antisymm",
   "LE.le",
   "OrderDual.instPartialOrder.proof_2",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(Î± : Type u_3) â†’ [inst : PartialOrder Î±] â†’ PartialOrder Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "isUpperSet_sInter",
   "Eq.refl",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
   "IsUpperSet",
   "Preorder",
   "implies_congr",
   "AlexandrovDiscrete",
   "AlexandrovDiscrete.mk",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "forall_congr",
   "TopologicalSpace",
   "Set.sInter",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpperSet.toAlexandrovDiscrete.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsUpperSet Î±], AlexandrovDiscrete Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "or_false.match_1",
  "constType":
  "âˆ€ (p : Prop) (motive : p âˆ¨ False â†’ Prop) (x : p âˆ¨ False), (âˆ€ (h : p), motive (_ : p âˆ¨ False)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "PartialOrder.toPreorder",
   "Prop.heytingAlgebra",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "Prop.booleanAlgebra.proof_2",
  "constType": "âˆ€ (a : Prop), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Ne",
   "OfNat.ofNat",
   "And.right",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.replicate",
   "List.mem_replicate",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "List.eq_of_mem_replicate",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {n : â„•}, b âˆˆ List.replicate n a â†’ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Function.Surjective.exists",
   "Iff",
   "PLift.up",
   "PLift",
   "PLift.up_surjective"],
  "name": "PLift.exists",
  "constType":
  "âˆ€ {Î± : Sort u} {p : PLift Î± â†’ Prop}, (âˆƒ x, p x) â†” âˆƒ x, p { down := x }",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHAppend",
   "Or",
   "List.instAppendList",
   "HAppend.hAppend",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_append",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.11",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {s t : List Î±}, (a âˆˆ s ++ t) = (a âˆˆ s âˆ¨ a âˆˆ t)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "semiOutParam",
  "constType": "Sort u â†’ Sort u",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT â„•",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLowerSet.to_WithLowerSet_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithLowerSet.toLowerSet.symm = Topology.WithLowerSet.ofLowerSet",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax.Preresolved", "Lean.Name"],
  "name": "Lean.Syntax.Preresolved.namespace",
  "constType": "Lean.Name â†’ Lean.Syntax.Preresolved",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_range",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {x : Î±}, x âˆˆ Set.range f â†” âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "instHAdd",
   "HAdd.hAdd",
   "PUnit",
   "Nat",
   "Add",
   "Nat.succ",
   "npowRec.match_1"],
  "name": "nsmulRec",
  "constType": "{M : Type u} â†’ [inst : Zero M] â†’ [inst : Add M] â†’ â„• â†’ M â†’ M",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "Inf.inf",
   "Function.comp",
   "ConditionallyCompleteLattice.toLattice",
   "Prod.fst",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "And",
   "Iff",
   "continuous_induced_rng",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Prod.mk",
   "Continuous",
   "TopologicalSpace",
   "Iff.trans",
   "Prod",
   "TopologicalSpace.induced",
   "continuous_inf_rng",
   "Iff.and"],
  "name": "continuous_prod_mk",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î± â†’ Î³}, (Continuous fun x â†¦ (f x, g x)) â†” Continuous f âˆ§ Continuous g",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "Iff.mp",
   "IsClosed.isOpen_compl",
   "isUpperSet_compl",
   "Set",
   "Topology.IsUpper",
   "HasCompl.compl",
   "TopologicalSpace",
   "Topology.IsUpper.isUpperSet_of_isOpen",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsUpperSet",
   "IsClosed",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE"],
  "name": "Topology.IsUpper.isLowerSet_of_isClosed",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±] {s : Set Î±},\n  IsClosed s â†’ IsLowerSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "Set.eq_univ_of_forall",
   "Or",
   "Bool.false",
   "Bool.dichotomy",
   "Bool.true",
   "Set",
   "Singleton.singleton",
   "Bool",
   "Insert.insert",
   "Set.univ",
   "Eq.symm",
   "Set.instInsertSet",
   "Eq"],
  "name": "Bool.univ_eq",
  "constType": "Set.univ = {false, true}",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.succ_le_succ",
   "Nat.le_trans",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_of_le_of_lt",
  "constType": "âˆ€ {n m k : â„•}, n â‰¤ m â†’ m < k â†’ n < k",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.sublist_append_left.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : List Î± â†’ List Î± â†’ Prop) (x x_1 : List Î±),\n  (âˆ€ (x : List Î±), motive [] x) â†’ (âˆ€ (head : Î±) (lâ‚ lâ‚‚ : List Î±), motive (head :: lâ‚) lâ‚‚) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Pi.distribLattice",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (x y z : (i : Î¹) â†’ Î± i),\n  (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteBooleanAlgebra",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_8",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Option.getD.match_1", "Option"],
  "name": "Option.getD",
  "constType": "{Î± : Type u_1} â†’ Option Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "sup_inf_le",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "le_antisymm",
   "Eq",
   "le_sup_inf"],
  "name": "sup_inf_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DistribLattice Î±] {x y z : Î±}, x âŠ” y âŠ“ z = (x âŠ” y) âŠ“ (x âŠ” z)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.map._elambda_1._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Add",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin.mk", "Fin"],
  "name": "Fin.rec",
  "constType":
  "{n : â„•} â†’\n  {motive : Fin n â†’ Sort u} â†’\n    ((val : â„•) â†’ (isLt : val < n) â†’ motive { val := val, isLt := isLt }) â†’ (t : Fin n) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Set.Finite.intro",
   "Exists",
   "Fintype",
   "Set.coe_toFinset",
   "Eq.ndrec",
   "Set.Elem",
   "Set.toFinset",
   "Finset.toSet",
   "Set",
   "Finset",
   "Eq.refl",
   "Exists.intro",
   "Eq.symm",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.exists_finset_coe",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ âˆƒ s', â†‘s' = s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.take_append_drop.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : â„• â†’ List Î± â†’ Prop) (x : â„•) (x_1 : List Î±),\n  (âˆ€ (x : List Î±), motive 0 x) â†’\n    (âˆ€ (n : â„•), motive (Nat.succ n) []) â†’\n      (âˆ€ (n : â„•) (x : Î±) (xs : List Î±), motive (Nat.succ n) (x :: xs)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Nonempty.elim", "Iff", "Nonempty"],
  "name": "forall_const",
  "constType": "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], Î± â†’ b â†” b",
  "constCategory": "Theorem"},
 {"references":
  ["IsUpperSet", "ge_trans", "Set.Ici", "Preorder", "Preorder.toLE"],
  "name": "isUpperSet_Ici",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), IsUpperSet (Set.Ici a)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.inter_mem_inf",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s t : Set Î±}, s âˆˆ f â†’ t âˆˆ g â†’ s âˆ© t âˆˆ f âŠ“ g",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Perm",
  "constType": "{Î± : Type uu} â†’ List Î± â†’ List Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.Pairwise",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Î± â†’ Prop) â†’ List Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "npowRec.match_1",
  "constType":
  "{M : Type u_2} â†’\n  (motive : â„• â†’ M â†’ Sort u_1) â†’\n    (x : â„•) â†’ (x_1 : M) â†’ ((x : M) â†’ motive 0 x) â†’ ((n : â„•) â†’ (a : M) â†’ motive (Nat.succ n) a) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.decidableBAll",
   "List.instMembershipList",
   "List",
   "List.foldr",
   "List.pwFilter",
   "Not",
   "List.nil",
   "if_neg",
   "Eq",
   "ite",
   "DecidableRel"],
  "name": "List.pwFilter_cons_of_neg",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [inst : DecidableRel R] {a : Î±} {l : List Î±},\n  (Â¬âˆ€ b âˆˆ List.pwFilter R l, R a b) â†’ List.pwFilter R (a :: l) = List.pwFilter R l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpper.instInhabitedWithUpper._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Acc.rec", "Eq.ndrec", "Acc.intro", "InvImage", "Acc", "rfl", "Eq"],
  "name": "_private.Init.WF.0.InvImage.accAux.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {r : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²) {b : Î²},\n  Acc r b â†’ âˆ€ (x : Î±), f x = b â†’ Acc (InvImage r f) x",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "Iff", "And.symm.match_1", "And.intro"],
  "name": "and_imp",
  "constType": "âˆ€ {a b c : Prop}, a âˆ§ b â†’ c â†” a â†’ b â†’ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.count_pos_iff_mem",
   "OfNat.ofNat",
   "Nat.pos_of_ne_zero",
   "List.instMembershipList",
   "instBEq",
   "instLTNat",
   "instDecidableEqNat",
   "Eq",
   "Iff.mp",
   "DecidableEq",
   "List",
   "LT.lt",
   "Not",
   "instOfNatNat",
   "Nat",
   "Decidable.byContradiction",
   "List.count"],
  "name": "List.count_eq_zero_of_not_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, Â¬a âˆˆ l â†’ List.count a l = 0",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.append",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.drop",
   "List.take",
   "rfl",
   "Eq",
   "PProd",
   "instHAppend",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "List.take_append_drop.match_1",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "List.take_append_drop",
  "constType":
  "âˆ€ {Î± : Type u_1} (n : â„•) (l : List Î±), List.take n l ++ List.drop n l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_7",
  "constType": "âˆ€ {Î± : Type u_1} (x : Set Î±), x âŠ“ xá¶œ â‰¤ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "Nat.linearOrderedCommSemiring.proof_3",
  "constType": "âˆ€ (a b : â„•), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toDistribLattice",
  "constType": "{Î± : Type u} â†’ [self : BooleanAlgebra Î±] â†’ DistribLattice Î±",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.foldl.match_1",
  "constType":
  "{Î± : Type u_3} â†’\n  {Î² : Type u_1} â†’\n    (motive : Î± â†’ List Î² â†’ Sort u_2) â†’\n      (x : Î±) â†’\n        (x_1 : List Î²) â†’ ((a : Î±) â†’ motive a []) â†’ ((a : Î±) â†’ (b : Î²) â†’ (l : List Î²) â†’ motive a (b :: l)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "Set.instHasSubsetSet",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "LE.le",
   "IsOpen",
   "Preorder.toLE",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "le_generateFrom",
  "constType":
  "âˆ€ {Î± : Type u} {t : TopologicalSpace Î±} {g : Set (Set Î±)}, (âˆ€ s âˆˆ g, IsOpen s) â†’ t â‰¤ TopologicalSpace.generateFrom g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop â†’ Type",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "eq_false",
   "False",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.not_lt_zero",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.103",
  "constType": "âˆ€ (n : â„•), (n < 0) = False",
  "constCategory": "Theorem"},
 {"references": ["monotone_id", "OrderHom.mk", "OrderHom", "Preorder", "id"],
  "name": "OrderHom.id",
  "constType": "{Î± : Type u_2} â†’ [inst : Preorder Î±] â†’ Î± â†’o Î±",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} (self : Subtype p), p â†‘self",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "rfl",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "List",
   "PUnit",
   "List.range.loop",
   "instOfNatNat",
   "Nat",
   "List.range_loop_range'.match_1",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "List.range_loop_range'",
  "constType":
  "âˆ€ (s n : â„•), List.range.loop s (List.range' s n) = List.range' 0 (n + s)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "RelHomClass", "LE", "LE.le"],
  "name": "OrderHomClass",
  "constType":
  "Type u_6 â†’\n  (Î± : outParam (Type u_7)) â†’ (Î² : outParam (Type u_8)) â†’ [inst : LE Î±] â†’ [inst : LE Î²] â†’ Type (max (max u_6 u_7) u_8)",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.map._elambda_1._cstage1",
  "constType":
  "(Î± : Type u_1) â†’\n  (Î² : Type u_2) â†’\n    ((a : Î²) â†’ (fun x â†¦ Topology.WithUpperSet Î²) a) â†’\n      (Topology.WithUpperSet Î± â†’ Î²) â†’ Topology.WithUpperSet Î± â†’ Topology.WithUpperSet Î²",
  "constCategory": "Definition"},
 {"references":
  ["Inf.mk", "Prod.snd", "Prod.mk", "Inf", "Inf.inf", "Prod", "Prod.fst"],
  "name": "Prod.instInfProd",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : Inf Î±] â†’ [inst : Inf Î²] â†’ Inf (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "Or",
   "not_and_or",
   "List.instMembershipList",
   "List.dedup",
   "And.left",
   "mt",
   "Eq",
   "And",
   "Mathlib.Data.List.Dedup._auxLemma.1",
   "And.right",
   "Iff.mp",
   "Iff",
   "DecidableEq",
   "List.forall_mem_pwFilter",
   "not_congr",
   "List",
   "instDecidableNot",
   "Eq.mp",
   "congr",
   "Not",
   "List.pwFilter",
   "congrArg",
   "Mathlib.Data.List.Dedup._auxLemma.2",
   "Eq.trans",
   "id"],
  "name": "List.mem_dedup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, a âˆˆ List.dedup l â†” a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{Î± : Type u_9} â†’\n  [toLattice : Lattice Î±] â†’\n    [toSupSet : SupSet Î±] â†’\n      (âˆ€ (s : Set Î±), âˆ€ a âˆˆ s, a â‰¤ sSup s) â†’\n        (âˆ€ (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a) â†’\n          [toInfSet : InfSet Î±] â†’\n            (âˆ€ (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a) â†’\n              (âˆ€ (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s) â†’\n                [toTop : Top Î±] â†’ [toBot : Bot Î±] â†’ (âˆ€ (x : Î±), x â‰¤ âŠ¤) â†’ (âˆ€ (x : Î±), âŠ¥ â‰¤ x) â†’ CompleteLattice Î±",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "List.cons",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "List.length",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Fin",
   "Fin.mk",
   "Fin.casesOn"],
  "name": "List.get_cons_drop.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x : List Î±) â†’ Fin (List.length x) â†’ Prop) (x : List Î±) (x_1 : Fin (List.length x)),\n  (âˆ€ (head : Î±) (tail : List Î±) (isLt : 0 < List.length (head :: tail)),\n      motive (head :: tail) { val := 0, isLt := isLt }) â†’\n    (âˆ€ (head : Î±) (tail : List Î±) (i : â„•) (isLt : i + 1 < List.length (head :: tail)),\n        motive (head :: tail) { val := Nat.succ i, isLt := isLt }) â†’\n      motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "â„• â†’ Type",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_irrefl.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (motive : (x : Î±) â†’ x < x â†’ Prop) (x : Î±) (x_1 : x < x),\n  (âˆ€ (_a : Î±) (haa : _a < _a), motive _a haa) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.induction_on",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {Î² : Quot r â†’ Prop} (q : Quot r), (âˆ€ (a : Î±), Î² (Quot.mk r a)) â†’ Î² q",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.beq",
  "constType": "â„• â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.mk", "Monotone", "OrderHom", "Preorder", "OrderHom.rec"],
  "name": "OrderHom.casesOn",
  "constType":
  "{Î± : Type u_6} â†’\n  {Î² : Type u_7} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’\n        {motive : (Î± â†’o Î²) â†’ Sort u} â†’\n          (t : Î± â†’o Î²) â†’\n            ((toFun : Î± â†’ Î²) â†’ (monotone' : Monotone toFun) â†’ motive { toFun := toFun, monotone' := monotone' }) â†’\n              motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.removeNeutrals",
   "Lean.Data.AC.Expr",
   "Eq.refl",
   "eq_true_of_decide",
   "Lean.Data.AC.sort",
   "Lean.Data.AC.ContextInformation.isComm",
   "Lean.Data.AC.ContextInformation.isIdem",
   "True",
   "ite",
   "Eq",
   "Lean.Data.AC.Context.evalList_mergeIdem",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.Context.evalList_sort",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Lean.Data.AC.norm",
   "Nat",
   "Eq.symm",
   "Lean.Data.AC.Expr.toList",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "eq_self",
   "False",
   "Lean.Data.AC.eval",
   "Lean.Data.AC.Context.evalList_removeNeutrals",
   "eq_false_of_decide",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "Bool.casesOn",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "Lean.Data.AC.Context.eval_toList",
   "List",
   "Bool.false",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.eval_norm",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±) (e : Lean.Data.AC.Expr),\n  Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.norm ctx e) = Lean.Data.AC.eval Î± ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.intro",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.subset_inter",
  "constType": "âˆ€ {Î± : Type u} {s t r : Set Î±}, r âŠ† s â†’ r âŠ† t â†’ r âŠ† s âˆ© t",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.termð“._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "GaloisConnection.liftOrderBot.proof_1",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "Bot.mk",
   "OrderBot.mk",
   "OrderBot",
   "Preorder",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisConnection.liftOrderBot",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : OrderBot Î±] â†’ [inst_2 : PartialOrder Î²] â†’ {l : Î± â†’ Î²} â†’ {u : Î² â†’ Î±} â†’ GaloisConnection l u â†’ OrderBot Î²",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "Lattice.toSemilatticeInf",
   "GeneralizedCoheytingAlgebra",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "GeneralizedCoheytingAlgebra.sdiff_le_iff"],
  "name": "sdiff_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] {a b c : Î±}, a \\ b â‰¤ c â†” a â‰¤ b âŠ” c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.mpr",
   "Eq.ndrec",
   "IsLowerSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "Topology.lowerSet",
   "Eq.refl",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.topology_eq",
   "IsOpen",
   "Preorder.toLE",
   "Eq",
   "id"],
  "name": "Topology.IsLowerSet.isOpen_iff_isLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±] {s : Set Î±},\n  IsOpen s â†” IsLowerSet s",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Context"],
  "name": "Lean.Data.AC.Context.arbitrary",
  "constType": "{Î± : Sort u} â†’ Lean.Data.AC.Context Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "List.cons",
   "HEq",
   "eq_of_heq",
   "List.Sublist",
   "List.Sublist.cons",
   "Eq.refl",
   "List.Sublist.rec",
   "Eq",
   "List.Sublist.trans.match_1",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Eq.rec",
   "List.Sublist.consâ‚‚",
   "List.nil",
   "Eq.casesOn",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.Sublist.trans",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ lâ‚ƒ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist lâ‚‚ lâ‚ƒ â†’ List.Sublist lâ‚ lâ‚ƒ",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_eq_left", "Eq"],
  "name": "Std.Logic._auxLemma.38",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, a = a' âˆ§ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["IsAntisymm",
   "PartialOrder.toPreorder",
   "le_antisymm",
   "LE.le",
   "IsAntisymm.mk",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "instIsAntisymmLeToLEToPreorder.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±], IsAntisymm Î± fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma",
   "PSigma.casesOn",
   "invImage",
   "SizeOf.sizeOf",
   "WellFounded",
   "instSizeOfNat",
   "Nat",
   "instWellFoundedRelation"],
  "name": "Nat.modCore._unary.proof_1",
  "constType":
  "WellFounded (invImage (fun a â†¦ PSigma.casesOn a fun x snd â†¦ sizeOf x) instWellFoundedRelation).1",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Prod.mk",
   "eq_of_heq",
   "Eq.refl",
   "Prod",
   "Eq.casesOn",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Eq.propIntro",
   "Prod.noConfusion",
   "Eq"],
  "name": "Prod.mk.injEq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (fst : Î±) (snd : Î²) (fst_1 : Î±) (snd_1 : Î²),\n  ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 âˆ§ snd = snd_1)",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet", "sSupHom.mk", "sSupHom", "Set", "SupSet.sSup", "Set.image", "Eq"],
  "name": "sSupHom.rec",
  "constType":
  "{Î± : Type u_8} â†’\n  {Î² : Type u_9} â†’\n    [inst : SupSet Î±] â†’\n      [inst_1 : SupSet Î²] â†’\n        {motive : sSupHom Î± Î² â†’ Sort u} â†’\n          ((toFun : Î± â†’ Î²) â†’\n              (map_sSup' : âˆ€ (s : Set Î±), toFun (sSup s) = sSup (toFun '' s)) â†’\n                motive { toFun := toFun, map_sSup' := map_sSup' }) â†’\n            (t : sSupHom Î± Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mem_sets",
   "Filter.sets",
   "Membership.mem",
   "propext",
   "Set",
   "Filter",
   "Eq.symm",
   "Eq",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.13",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s : Set Î±}, (s âˆˆ f) = (s âˆˆ f.sets)",
  "constCategory": "Theorem"},
 {"references":
  ["IsLUB.sSup_eq",
   "Set.instSingletonSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "isLUB_singleton",
   "Singleton.singleton",
   "SupSet.sSup",
   "CompleteSemilatticeSup.toSupSet",
   "Eq"],
  "name": "sSup_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeSup Î±] {a : Î±}, sSup {a} = a",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "One",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} â†’\n  [toNatCast : NatCast R] â†’\n    [toAddMonoid : AddMonoid R] â†’\n      [toOne : One R] â†’\n        autoParam (NatCast.natCast 0 = 0) _autoâœ â†’\n          autoParam (âˆ€ (n : â„•), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _autoâœÂ¹ â†’ AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "lowerClosure.proof_1",
   "Set",
   "LowerSet.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerClosure",
  "constType": "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ LowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "Eq.mpr",
   "Function.RightInverse.comp_eq_id",
   "Eq.ndrec",
   "Trans.trans",
   "Function.RightInverse",
   "Function.comp.right_id",
   "Function.comp",
   "Function.comp.left_id",
   "Function.comp.assoc",
   "Eq.refl",
   "instTransEq",
   "Function.LeftInverse.comp_eq_id",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.eq_rightInverse",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} {gâ‚ gâ‚‚ : Î² â†’ Î±},\n  Function.LeftInverse gâ‚ f â†’ Function.RightInverse gâ‚‚ f â†’ gâ‚ = gâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_irrefl.match_1",
   "False",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "lt_irrefl.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] (a : Î±), Â¬a < a",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Prod.casesOn", "Prod.mk", "LE", "Prod", "LE.le"],
  "name": "Prod.instPreorderProd.match_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) (src : LE (Î± Ã— Î²)) (c : Î±) (d : Î²) (motive : (x : Î± Ã— Î²) â†’ (c, d) â‰¤ x â†’ Prop)\n  (x : Î± Ã— Î²) (x_1 : (c, d) â‰¤ x), (âˆ€ (e : Î±) (f : Î²) (x : (c, d) â‰¤ (e, f)), motive (e, f) x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "funext",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.le_top",
   "SemilatticeInf.toPartialOrder",
   "Pi.generalizedHeytingAlgebra",
   "Preorder.toLE",
   "Eq",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HImp.himp",
   "himp_bot",
   "Pi.hasCompl",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "Pi.orderBot",
   "HeytingAlgebra.toBoundedOrder",
   "OrderBot.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.hasLe",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Pi.heytingAlgebra.proof_4",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ HeytingAlgebra (Î± i)] (f : (i : Î¹) â†’ Î± i), f â‡¨ âŠ¥ = fá¶œ",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LT", "OrderDual", "LT.mk"],
  "name": "OrderDual.instLTOrderDual",
  "constType": "(Î± : Type u_3) â†’ [inst : LT Î±] â†’ LT Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring â„•",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom.toFun", "ZeroHom", "Eq"],
  "name": "ZeroHom.map_zero'",
  "constType":
  "âˆ€ {M : Type u_9} {N : Type u_10} [inst : Zero M] [inst_1 : Zero N] (self : ZeroHom M N), ZeroHom.toFun self 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet.mk",
   "Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Topology.IsUpperSet.rec",
   "Eq"],
  "name": "Topology.IsUpperSet.casesOn",
  "constType":
  "{Î± : Type u_4} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsUpperSet Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsUpperSet Î±) â†’\n          ((topology_eq_upperSetTopology : t = Topology.upperSet Î±) â†’ motive (_ : Topology.IsUpperSet Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat"],
  "name": "UInt32.size",
  "constType": "â„•",
  "constCategory": "Definition"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul â„•",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.lowerSet._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Sup",
   "Prod.instSupProd",
   "Prod.fst",
   "And.left",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "SemilatticeSup",
   "And",
   "And.right",
   "SemilatticeSup.toSup",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "sup_le",
   "Prod",
   "Sup.sup",
   "And.intro",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup.proof_4",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeSup Î±] [inst_1 : SemilatticeSup Î²] (x x_1 x_2 : Î± Ã— Î²),\n  x â‰¤ x_2 â†’ x_1 â‰¤ x_2 â†’ (x âŠ” x_1).1 â‰¤ x_2.1 âˆ§ (x âŠ” x_1).2 â‰¤ x_2.2",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.Â«termð“[â‰¤]_Â»._closed_4",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[_]_Â»._closed_9"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.mem_comap'.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {l : Filter Î²} {s : Set Î±} (motive : s âˆˆ Filter.comap f l â†’ Prop)\n  (x : s âˆˆ Filter.comap f l),\n  (âˆ€ (t : Set Î²) (ht : t âˆˆ l) (hts : f â»Â¹' t âŠ† s), motive (_ : âˆƒ t âˆˆ l, f â»Â¹' t âŠ† s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Filter.map_comap_le", "Filter.comap", "Filter.Tendsto", "Filter"],
  "name": "Filter.tendsto_comap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {x : Filter Î²}, Filter.Tendsto f (Filter.comap f x) x",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Bot",
   "Bot.bot",
   "le_top",
   "Bot.mk",
   "inferInstanceAs",
   "OrderDual",
   "OrderTop",
   "LE",
   "OrderBot",
   "OrderBot.mk",
   "OrderDual.bot",
   "OrderDual.instLEOrderDual"],
  "name": "OrderDual.orderBot",
  "constType":
  "(Î± : Type u) â†’ [inst : LE Î±] â†’ [inst_1 : OrderTop Î±] â†’ OrderBot Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Lean.Name.mkStr",
   "Lean.Name.num",
   "List.brecOn",
   "List.below",
   "String",
   "Lean.instInhabitedName",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "Lean.Name.mkNum",
   "panic",
   "List.nil",
   "Lean.Name",
   "_private.Init.Prelude.0.Lean.assembleParts.match_1",
   "Nat",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.assembleParts",
  "constType": "List Lean.Name â†’ Lean.Name â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_9",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["InvImage.wf.proof_1", "WellFounded", "InvImage"],
  "name": "InvImage.wf",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {r : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²), WellFounded r â†’ WellFounded (InvImage r f)",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«termð“[â‰ ]_Â»._closed_1",
   "Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î³ : Type v} â†’ [self : Membership Î± Î³] â†’ Î± â†’ Î³ â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_6",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Î± â†’ Prop), b â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder",
   "OrderDual.instIsUpperSet.proof_1"],
  "name": "OrderDual.instIsUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±],\n  Topology.IsUpperSet Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Acc"],
  "name": "Acc.intro",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} (x : Î±), (âˆ€ (y : Î±), r y x â†’ Acc r y) â†’ Acc r x",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.mk",
   "Prod.boundedOrder.proof_1",
   "Prod.boundedOrder.proof_2",
   "Prod.orderBot",
   "Prod.instLEProd",
   "OrderBot",
   "Prod.orderTop",
   "BoundedOrder.toOrderTop",
   "OrderTop.toTop",
   "BoundedOrder.mk",
   "OrderBot.toBot",
   "LE",
   "OrderTop",
   "inferInstanceAs",
   "Prod",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "Prod.boundedOrder",
  "constType":
  "(Î± : Type u) â†’\n  (Î² : Type v) â†’\n    [inst : LE Î±] â†’ [inst_1 : LE Î²] â†’ [inst_2 : BoundedOrder Î±] â†’ [inst_3 : BoundedOrder Î²] â†’ BoundedOrder (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references": ["Acc.inv.proof_1", "Acc"],
  "name": "Acc.inv",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {x y : Î±}, Acc r x â†’ r y x â†’ Acc r y",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "List.Sublist",
   "HasSubset.Subset",
   "List.Mem",
   "List.Mem.head",
   "List.nil",
   "List.Sublist.subset.match_1._@.Std.Data.List.Lemmas._hyg.8578",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Sublist.subset",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ lâ‚ âŠ† lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "GaloisConnection",
   "OrderDual.toDual",
   "TopologicalSpace.generateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Iff.symm",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsOpen"],
  "name": "TopologicalSpace.gc_generateFrom",
  "constType":
  "âˆ€ (Î± : Type u_1),\n  GaloisConnection (fun t â†¦ â†‘OrderDual.toDual {s | IsOpen s}) (TopologicalSpace.generateFrom âˆ˜ â†‘OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["InfHomClass.toOrderHomClass.proof_1",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "InfHomClass.toFunLike",
   "SemilatticeInf.toPartialOrder",
   "RelHomClass.mk",
   "LE.le",
   "OrderHomClass",
   "Preorder.toLE",
   "SemilatticeInf",
   "InfHomClass"],
  "name": "InfHomClass.toOrderHomClass",
  "constType":
  "{F : Type u_1} â†’\n  {Î± : Type u_3} â†’\n    {Î² : Type u_4} â†’\n      [inst : SemilatticeInf Î±] â†’ [inst_1 : SemilatticeInf Î²] â†’ [inst_2 : InfHomClass F Î± Î²] â†’ OrderHomClass F Î± Î²",
  "constCategory": "Definition"},
 {"references": ["List", "Lean.Data.AC.sort.loop", "List.nil", "Nat"],
  "name": "Lean.Data.AC.sort",
  "constType": "List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references": ["HNot"],
  "name": "HNot.hnot",
  "constType": "{Î± : Type u_4} â†’ [self : HNot Î±] â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HNot",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references": [],
  "name": "Monad",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references": ["IsAssociative", "Eq"],
  "name": "IsAssociative.mk",
  "constType":
  "âˆ€ {Î± : Type u} {op : Î± â†’ Î± â†’ Î±}, (âˆ€ (a b c : Î±), op (op a b) c = op a (op b c)) â†’ IsAssociative Î± op",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Preorder.lt_iff_le_not_le",
  "constType":
  "âˆ€ {Î± : Type u} [self : Preorder Î±] (a b : Î±), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Definition"},
 {"references": ["Append"],
  "name": "Append.append",
  "constType": "{Î± : Type u} â†’ [self : Append Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["IsLowerSet", "le_trans", "Set.Iic", "Preorder", "Preorder.toLE"],
  "name": "isLowerSet_Iic",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), IsLowerSet (Set.Iic a)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.46",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "propext",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "BooleanAlgebra.toHasCompl",
   "Set.compl_subset_compl",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.23",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, (sá¶œ âŠ† tá¶œ) = (t âŠ† s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And.right",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "IsLeast",
   "And.left",
   "le_antisymm",
   "Eq",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "IsLeast.unique",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {s : Set Î±} {a b : Î±}, IsLeast s a â†’ IsLeast s b â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Multiset.instAddMultiset",
   "Eq",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
  "constType":
  "âˆ€ {Î± : Type u_1} (n : â„•) (x : Multiset Î±), nsmulRec (n + 1) x = nsmulRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.topology_eq",
   "Exists",
   "setOf",
   "Iff.rfl",
   "Set",
   "Topology.IsUpper",
   "Eq.refl",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Topology.upper",
   "TopologicalSpace",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpper.isOpen_iff_generate_Iic_compl",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±] {s : Set Î±},\n  IsOpen s â†” TopologicalSpace.GenerateOpen {t | âˆƒ a, (Set.Iic a)á¶œ = t} s",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "sSupHom.instSSupHomClassSSupHom",
   "sSupHomClass.toFunLike",
   "sSupHom",
   "FunLike.ext",
   "FunLike.coe",
   "Eq"],
  "name": "sSupHom.ext",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : SupSet Î±] [inst_1 : SupSet Î²] {f g : sSupHom Î± Î²},\n  (âˆ€ (a : Î±), â†‘f a = â†‘g a) â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.mem_iUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹ƒ i, s i) = âˆƒ i, x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Array.mkArray6",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node6",
  "constType":
  "Lean.SourceInfo â†’\n  Lean.SyntaxNodeKind â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpperSet.map._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.map._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.range'",
   "Nat.decLt",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "Eq.refl",
   "Mathlib.Data.List.Range._auxLemma.2",
   "eq_true_of_decide",
   "List.range_eq_range'",
   "autoParam",
   "optParam",
   "instDecidableTrue",
   "Lean.Syntax",
   "instLTNat",
   "True",
   "List.Nodup",
   "of_eq_true",
   "List",
   "Bool.true",
   "LT.lt",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "List.range"],
  "name": "List.nodup_range",
  "constType": "âˆ€ (n : â„•), List.Nodup (List.range n)",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false", "Bool", "optParam", "Lean.Syntax", "String.Pos", "Option"],
  "name": "Lean.Syntax.getTailPos?",
  "constType": "Lean.Syntax â†’ optParam Bool false â†’ Option String.Pos",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "List.range'",
   "instHAdd",
   "HAdd.hAdd",
   "List.map_add_range'.match_1",
   "optParam",
   "rfl",
   "Eq",
   "List.Chain.cons",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "PUnit",
   "List.Chain.nil",
   "instOfNatNat",
   "Nat",
   "List.Chain",
   "Nat.succ"],
  "name": "List.chain_succ_range'",
  "constType":
  "âˆ€ (s n step : â„•), List.Chain (fun a b â†¦ b = a + step) s (List.range' (s + step) n step)",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Nonempty.some", "Finite", "nonempty_fintype"],
  "name": "Fintype.ofFinite",
  "constType": "(Î± : Type u_4) â†’ [inst : Finite Î±] â†’ Fintype Î±",
  "constCategory": "Definition"},
 {"references":
  ["inf_inf_sdiff",
   "OfNat.ofNat",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "instIsCommutativeSupToSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "inf_sup_left",
   "Preorder.toLE",
   "Eq",
   "inf_comm",
   "Eq.mpr",
   "Lean.Data.AC.Variable",
   "SemilatticeSup.toSup",
   "Option.none",
   "Lean.Data.AC.Context.eq_of_norm",
   "Bool.true",
   "instIsIdempotent",
   "Nat",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "instIsIdempotentSupToSup",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Lean.Data.AC.eval",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "SDiff.sdiff",
   "DistribLattice.toLattice",
   "instIsAssociative",
   "bot_sup_eq",
   "OrderBot.toBot",
   "congr",
   "instTransEq",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Lean.Data.AC.Context.mk",
   "congrArg",
   "Lean.Data.AC.Expr.var",
   "congrFun",
   "Lean.Data.AC.Expr.op",
   "inf_of_le_right",
   "inf_idem",
   "Eq.refl",
   "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_le'",
   "Lean.IsNeutral",
   "instIsIdempotentInfToInf",
   "Lattice.toInf",
   "instIsAssociativeInfToInf",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Context",
   "Option.some",
   "instOfNatNat",
   "List.nil",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GeneralizedBooleanAlgebra.toBot",
   "id",
   "Bot.bot",
   "List.cons",
   "instIsCommutative",
   "instIsCommutativeInfToInf",
   "Lean.IsIdempotent",
   "sup_inf_sdiff",
   "inf_sup_right",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Lean.IsCommutative",
   "GeneralizedBooleanAlgebra",
   "Sup.sup",
   "Bool",
   "instIsAssociativeSupToSup"],
  "name": "sdiff_inf_sdiff",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : GeneralizedBooleanAlgebra Î±], x \\ y âŠ“ y \\ x = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Equiv",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.3",
   "Set",
   "Topology.WithLowerSet.toLowerSet",
   "Set.Ici",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.11",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff",
   "Eq.trans",
   "id",
   "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.10",
   "HasSubset.Subset",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Topology.IsLowerSet.closure_singleton",
   "Equiv.instFunLikeEquiv",
   "Set.instHasSubsetSet",
   "Topology.WithLowerSet",
   "of_eq_true",
   "Specializes",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "congr",
   "Singleton.singleton",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "congrArg",
   "congrFun"],
  "name": "Topology.WithLowerSet.toLowerSet_specializes_toLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±},\n  â†‘Topology.WithLowerSet.toLowerSet a â¤³ â†‘Topology.WithLowerSet.toLowerSet b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "MonadExcept",
  "constType":
  "outParam (Type u) â†’ (Type v â†’ Type w) â†’ Type (max (max u (v + 1)) w)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Filter",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.univ_mem'",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s : Set Î±}, (âˆ€ (a : Î±), a âˆˆ s) â†’ s âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["CoheytingAlgebra",
   "BiheytingAlgebra.sdiff_le_iff",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "BiheytingAlgebra.toCoheytingAlgebra.proof_1",
   "BiheytingAlgebra.toCoheytingAlgebra.proof_2",
   "HeytingAlgebra.toBot",
   "GeneralizedCoheytingAlgebra.mk",
   "BiheytingAlgebra.top_sdiff",
   "GeneralizedHeytingAlgebra.toLattice",
   "CoheytingAlgebra.mk",
   "BiheytingAlgebra.toSDiff",
   "BiheytingAlgebra.toHNot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra",
  "constType":
  "{Î± : Type u_2} â†’ [inst : BiheytingAlgebra Î±] â†’ CoheytingAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSet_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Topology.WithLowerSet Î±},\n  â†‘Topology.WithLowerSet.ofLowerSet a â‰¤ â†‘Topology.WithLowerSet.ofLowerSet b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Iff.rfl",
   "Set",
   "HasCompl.compl",
   "Not",
   "BooleanAlgebra.toHasCompl",
   "Set.instMembershipSet"],
  "name": "Set.mem_compl_iff",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±) (x : Î±), x âˆˆ sá¶œ â†” Â¬x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_comm.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {p : Î± â†’ Î² â†’ Prop} (motive : (âˆƒ b, âˆƒ a, p a b) â†’ Prop) (x : âˆƒ b, âˆƒ a, p a b),\n  (âˆ€ (b : Î²) (a : Î±) (h : p a b), motive (_ : âˆƒ b, âˆƒ a, p a b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Pi.partialOrder.proof_2",
   "Pi.partialOrder.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Pi.partialOrder.proof_3",
   "Preorder.toLT",
   "Pi.preorder",
   "Pi.partialOrder.proof_1",
   "Preorder",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder",
  "constType":
  "{Î¹ : Type u_1} â†’ {Ï€ : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ PartialOrder (Ï€ i)] â†’ PartialOrder ((i : Î¹) â†’ Ï€ i)",
  "constCategory": "Definition"},
 {"references": ["And", "And.imp", "id"],
  "name": "And.imp_right",
  "constType": "âˆ€ {a b c : Prop}, (a â†’ b) â†’ c âˆ§ a â†’ c âˆ§ b",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "Nat.succ_le_succ_iff",
   "propext",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Std.Data.Nat.Lemmas._auxLemma.5",
  "constType": "âˆ€ {a b : â„•}, (Nat.succ a â‰¤ Nat.succ b) = (a â‰¤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "ClosedIicTopology.mk",
   "Set",
   "Topology.IsUpper",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "rfl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "isOpen_compl_iff",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Topology.IsUpper.isOpen_iff_generate_Iic_compl",
   "Iff.mp",
   "ClosedIicTopology",
   "TopologicalSpace",
   "IsClosed",
   "IsOpen"],
  "name": "Topology.IsUpper.instClosedIicTopology.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±], ClosedIicTopology Î±",
  "constCategory": "Theorem"},
 {"references": ["False", "Iff", "Iff.rfl", "Eq.rec", "Not", "Eq"],
  "name": "instDecidableEqProp.proof_1",
  "constType": "âˆ€ {p q : Prop}, Â¬(p â†” q) â†’ p = q â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "List",
   "List.decidableBAll.match_1",
   "List.nil"],
  "name": "List.decidableBAll.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (p : Î± â†’ Prop), âˆ€ a âˆˆ [], p a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.semilatticeSup",
   "SemilatticeSup.le_sup_right",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.lattice.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î±' i)] (a b : (i : Î¹) â†’ Î±' i), b â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Classical.skolem.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {b : Î± â†’ Sort u_2} {p : (x : Î±) â†’ b x â†’ Prop} (motive : (âˆƒ f, âˆ€ (x : Î±), p x (f x)) â†’ Prop)\n  (x : âˆƒ f, âˆ€ (x : Î±), p x (f x)),\n  (âˆ€ (f : (x : Î±) â†’ b x) (hw : âˆ€ (x : Î±), p x (f x)), motive (_ : âˆƒ f, âˆ€ (x : Î±), p x (f x))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "False",
   "instLENat",
   "Bool.true",
   "Not",
   "Bool",
   "Nat",
   "Nat.ble_eq_true_of_le",
   "absurd",
   "LE.le",
   "Eq"],
  "name": "Nat.not_le_of_not_ble_eq_true",
  "constType": "âˆ€ {n m : â„•}, Â¬Nat.ble n m = true â†’ Â¬n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Classical.choose_spec",
   "Classical.choose",
   "Eq.refl",
   "Exists.intro",
   "eq_true_of_decide",
   "rfl",
   "True",
   "Eq",
   "Eq.mpr",
   "instDecidableNot",
   "Bool.true",
   "Classical.em.match_1",
   "Eq.trans",
   "instDecidableEqProp",
   "id",
   "Ne",
   "funext",
   "Or",
   "False",
   "Or.inr",
   "mt",
   "instDecidableIff",
   "instDecidableTrue",
   "Iff.intro",
   "instDecidableFalse",
   "Eq.ndrec",
   "Or.inl",
   "of_eq_true",
   "propext",
   "Classical.em.match_2",
   "congr",
   "Not",
   "Bool",
   "congrArg"],
  "name": "Classical.em",
  "constType": "âˆ€ (p : Prop), p âˆ¨ Â¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons",
   "And.left"],
  "name": "List.pmap.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (a : Î±) (l : List Î±), (âˆ€ a_1 âˆˆ a :: l, p a_1) â†’ p a",
  "constCategory": "Theorem"},
 {"references":
  ["List.instBEqList",
   "BEq",
   "List",
   "LawfulBEq",
   "List.instLawfulBEqListInstBEqList.proof_1"],
  "name": "List.instLawfulBEqListInstBEqList",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BEq Î±] [inst_1 : LawfulBEq Î±], LawfulBEq (List Î±)",
  "constCategory": "Definition"},
 {"references": ["Append"],
  "name": "Append.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Append Î±",
  "constCategory": "Other"},
 {"references":
  ["Filter.mem_top",
   "Membership.mem",
   "Iff.mp",
   "Filter.instTopFilter",
   "Top.top",
   "Eq.rec",
   "Set",
   "Filter",
   "Eq.symm",
   "Set.univ",
   "Top.mk",
   "Filter.univ_mem",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instCompleteLatticeFilter.proof_11",
  "constType": "âˆ€ {Î± : Type u_1} (x : Filter Î±), âˆ€ _s âˆˆ âŠ¤, _s âˆˆ x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_10",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Filter Î±)áµ’áµˆáµ’áµˆ) (a : (Filter Î±)áµ’áµˆáµ’áµˆ), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsAntisymm",
  "constType": "(Î± : Type u) â†’ (Î± â†’ Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.refl",
   "dite",
   "beq_self_eq_true",
   "List.erase",
   "True",
   "Iff.mpr",
   "ite",
   "Eq",
   "instLawfulBEqInstBEq",
   "BEq.beq",
   "Bool.true",
   "beq_eq_false_iff_ne",
   "List.erase.match_1",
   "Eq.trans",
   "eq_self",
   "Ne",
   "List.cons",
   "funext",
   "False",
   "Unit",
   "instBEq",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "eq_false",
   "of_eq_true",
   "DecidableEq",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.erase_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a b : Î±) (l : List Î±),\n  List.erase (b :: l) a = if b = a then l else b :: List.erase l a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HeytingAlgebra",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "List.Mem.tail",
   "List.Mem",
   "Eq.refl",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.decidableBAll.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (x : Î±) (xs : List Î±) (motive : (x_1 : Î±) â†’ x_1 âˆˆ x :: xs â†’ Prop) (x_1 : Î±) (x_2 : x_1 âˆˆ x :: xs),\n  (âˆ€ (y : Î±) (h : List.Mem y xs), motive y (_ : List.Mem y (x :: xs))) â†’\n    (Unit â†’ motive x (_ : List.Mem x (x :: xs))) â†’ motive x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec", "Prod.casesOn", "Eq.refl", "Prod.noConfusionType", "Prod", "Eq"],
  "name": "Prod.noConfusion",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {P : Sort u_1} â†’ {v1 v2 : Î± Ã— Î²} â†’ v1 = v2 â†’ Prod.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Preorder", "le_of_le_of_eq", "LE.le", "Preorder.toLE", "Eq"],
  "name": "LE.le.trans_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b = c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "AlexandrovDiscrete",
   "Topology.IsLowerSet.toAlexandrovDiscrete.proof_1"],
  "name": "Topology.IsLowerSet.toAlexandrovDiscrete",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsLowerSet Î±], AlexandrovDiscrete Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sInf",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "InfSet.sInf",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_5",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²]\n  (gi : GaloisCoinsertion l u) (s : Set Î±áµ’áµˆáµ’áµˆ) (a : Î±áµ’áµˆáµ’áµˆ), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Membership.mem",
   "Iff",
   "Set",
   "TopologicalSpace",
   "nhdsWithin",
   "Filter.NeBot",
   "mem_closure_iff_clusterPt",
   "Set.instMembershipSet"],
  "name": "mem_closure_iff_nhdsWithin_neBot",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {x : Î±}, x âˆˆ closure s â†” Filter.NeBot (nhdsWithin x s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.GenerateOpen.basic",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "TopologicalSpace.GenerateOpen.recOn",
   "isOpen_sUnion",
   "Set",
   "IsOpen.inter",
   "HasSubset.Subset",
   "TopologicalSpace.GenerateOpen",
   "LE.le",
   "isOpen_univ",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "IsOpen"],
  "name": "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {t : TopologicalSpace Î±}, t â‰¤ TopologicalSpace.generateFrom g â†” g âŠ† {s | IsOpen s}",
  "constCategory": "Theorem"},
 {"references": ["Or", "False", "false_or_iff", "propext", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.12",
  "constType": "âˆ€ (p : Prop), (False âˆ¨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.succ_le_succ.match_1",
  "constType":
  "âˆ€ {n : â„•} (motive : (m : â„•) â†’ n â‰¤ m â†’ Prop) (m : â„•) (x : n â‰¤ m),\n  (Unit â†’ motive n (_ : Nat.le n n)) â†’\n    (âˆ€ (m : â„•) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) â†’ motive m x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "Bool.false",
   "and",
   "Bool.true",
   "Eq.refl",
   "Bool",
   "Eq.symm",
   "Eq"],
  "name": "Bool.true_and",
  "constType": "âˆ€ (b : Bool), (true && b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "Set.instEmptyCollectionSet",
   "isGLB_empty",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "sInf_empty",
  "constType": "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±], sInf âˆ… = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termð“[<]_Â»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Â«termð“[<]_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.IsAssociative",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Type",
  "constCategory": "Other"},
 {"references":
  ["UInt32.mk",
   "UInt32",
   "False",
   "UInt32.noConfusion",
   "Not",
   "UInt32.size",
   "absurd",
   "Fin",
   "Eq"],
  "name": "UInt32.decEq.proof_2",
  "constType":
  "âˆ€ (n m : Fin UInt32.size), Â¬n = m â†’ { val := n } = { val := m } â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "Prod.snd",
   "Prod.mk",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Set.Nonempty.prod.match_1",
   "Prod",
   "Prod.fst",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.prod",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, Set.Nonempty s â†’ Set.Nonempty t â†’ Set.Nonempty (s Ã—Ë¢ t)",
  "constCategory": "Theorem"},
 {"references": ["SupSet"],
  "name": "sSupHom",
  "constType":
  "(Î± : Type u_8) â†’ (Î² : Type u_9) â†’ [inst : SupSet Î±] â†’ [inst : SupSet Î²] â†’ Type (max u_8 u_9)",
  "constCategory": "Other"},
 {"references":
  ["Fin.succ_lt_succ_iff",
   "propext",
   "LT.lt",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "Nat.succ",
   "Fin",
   "Eq"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.17",
  "constType": "âˆ€ {n : â„•} {a b : Fin n}, (Fin.succ a < Fin.succ b) = (a < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.imp",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_inter",
  "constType":
  "âˆ€ {Î± : Type u} {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : Set Î±}, sâ‚ âŠ† tâ‚ â†’ sâ‚‚ âŠ† tâ‚‚ â†’ sâ‚ âˆ© sâ‚‚ âŠ† tâ‚ âˆ© tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "List.mem_map.match_1",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.nil",
   "List.Sublist.slnil"],
  "name": "List.Sublist.refl",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), List.Sublist l l",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet"],
  "name": "Topology.WithLowerSet.map._elambda_1",
  "constType":
  "(Î± : Type u_1) â†’\n  (Î² : Type u_2) â†’\n    ((a : Î²) â†’ (fun x â†¦ Topology.WithLowerSet Î²) a) â†’\n      (Topology.WithLowerSet Î± â†’ Î²) â†’ Topology.WithLowerSet Î± â†’ Topology.WithLowerSet Î²",
  "constCategory": "Axiom"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Or",
   "False",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "True",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "instHAppend",
   "Iff",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "propext",
   "List",
   "HAppend.hAppend",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "false_or",
   "Std.Data.List.Lemmas._auxLemma.10",
   "congrFun"],
  "name": "List.mem_append",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {s t : List Î±}, a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "constCategory": "Theorem"},
 {"references": ["List.insert", "DecidableEq", "List", "List.foldr"],
  "name": "List.union",
  "constType":
  "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ List Î± â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references": ["False", "Iff", "Not", "absurd", "Iff.mpr"],
  "name": "decidable_of_decidable_of_iff.proof_1",
  "constType": "âˆ€ {p q : Prop}, (p â†” q) â†’ Â¬p â†’ q â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.termÏ€_._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.termÏ€_._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "DecidableEq",
   "Finset.mem_union",
   "propext",
   "Union.union",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.instUnionFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.73",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {s t : Finset Î±} {a : Î±}, (a âˆˆ s âˆª t) = (a âˆˆ s âˆ¨ a âˆˆ t)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{Î± : Type u} â†’ [self : LinearOrderedSemiring Î±] â†’ StrictOrderedSemiring Î±",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "List.cons",
   "Lean.mkNode",
   "Array.empty",
   "Lean.SyntaxNodeKind",
   "Lean.TSyntax.raw",
   "List.nil",
   "Lean.nullKind",
   "optParam",
   "Lean.Syntax"],
  "name": "Lean.mkNullNode",
  "constType": "optParam (Array Lean.Syntax) #[] â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "forall_imp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (a : Î±), p a â†’ q a) â†’ (âˆ€ (a : Î±), p a) â†’ âˆ€ (a : Î±), q a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Mathlib.Data.List.Nodup._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±},\n  List.Pairwise R (a :: l) = ((âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["And", "and_iff_left_of_imp", "Iff"],
  "name": "and_iff_left",
  "constType": "âˆ€ {b a : Prop}, b â†’ (a âˆ§ b â†” a)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "Filter.iInf_sets_eq.match_1",
   "GE.ge",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Mathlib.Order.Filter.Basic._auxLemma.47",
   "Directed",
   "implies_congr",
   "Iff.mpr",
   "Nonempty",
   "Preorder.toLE",
   "Filter.univ_mem",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "Filter.inter_mem",
   "Filter.mk",
   "forall_congr",
   "Filter",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter",
   "id",
   "eq_self",
   "Filter.sets",
   "Membership.mem",
   "congr_arg",
   "HasSubset.Subset",
   "Mathlib.Order.Filter.Basic._auxLemma.48",
   "Set.univ",
   "Set.mem_iUnion",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "Filter.eq_iInf_of_mem_iff_exists_mem",
   "Set.instInterSet"],
  "name": "Filter.iInf_sets_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ Filter Î±},\n  Directed (fun x x_1 â†¦ x â‰¥ x_1) f â†’ âˆ€ [ne : Nonempty Î¹], (iInf f).sets = â‹ƒ i, (f i).sets",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteAtomicBooleanAlgebra",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toSDiff",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq"],
  "name": "CompleteAtomicBooleanAlgebra.sdiff_eq",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (x y : Î±), x \\ y = x âŠ“ yá¶œ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.map._elambda_1._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace"],
  "name": "TopologicalSpace.IsOpen",
  "constType": "{Î± : Type u} â†’ [self : TopologicalSpace Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_left_cancel",
   "Exists",
   "Nat.le_of_add_le_add_left.match_1",
   "Eq.ndrec",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.mp",
   "Eq.refl",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left",
  "constType": "âˆ€ {a b c : â„•}, a + b â‰¤ a + c â†’ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "congr_arg",
   "HAppend.hAppend",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset",
   "List.append_assoc",
   "Quotient.inductionOnâ‚ƒ",
   "Multiset.instAddMultiset",
   "Quot.mk",
   "Add.mk",
   "Eq"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (sâ‚ sâ‚‚ sâ‚ƒ : Multiset Î±), sâ‚ + sâ‚‚ + sâ‚ƒ = sâ‚ + (sâ‚‚ + sâ‚ƒ)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instIsTransLtToLT.proof_1",
   "Preorder.toLT",
   "LT.lt",
   "IsTrans",
   "Preorder"],
  "name": "instIsTransLtToLT",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±], IsTrans Î± fun x x_1 â†¦ x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.Â«termð“Ë¢Â»._closed_4", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“Ë¢Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["le_iSup_of_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice.toSupSet"],
  "name": "le_iSupâ‚‚",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {Îº : Î¹ â†’ Sort u_7} [inst : CompleteLattice Î±] {f : (i : Î¹) â†’ Îº i â†’ Î±} (i : Î¹) (j : Îº i),\n  f i j â‰¤ â¨† i, â¨† j, f i j",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq",
   "PartialOrder"],
  "name": "OrderDual.semilatticeSup.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : SemilatticeInf Î±] (a b : Î±áµ’áµˆ), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.preimage",
   "Set",
   "Topology.IsUpper",
   "Eq.refl",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
   "IsUpperSet",
   "Preorder",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "forall_congr",
   "Continuous",
   "IsUpperSet.preimage",
   "TopologicalSpace",
   "Monotone",
   "Topology.IsUpper.isUpperSet_of_isOpen",
   "IsOpen",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.2",
   "id"],
  "name": "Topology.IsUpperSet.monotone_to_upperTopology_continuous",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Topology.IsUpperSet Î±] [inst_5 : Topology.IsUpper Î²] {f : Î± â†’ Î²},\n  Monotone f â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.Nonempty",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.prod.match_1",
  "constType":
  "âˆ€ {Î² : Type u_1} {t : Set Î²} (motive : Set.Nonempty t â†’ Prop) (x : Set.Nonempty t),\n  (âˆ€ (y : Î²) (hy : y âˆˆ t), motive (_ : âˆƒ x, x âˆˆ t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Equiv.mk",
   "Topology.WithUpperSet.toDualHomeomorph._closed_1",
   "_neutral"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And", "Iff", "propext", "Eq.symm", "and_congr_right_iff", "Eq"],
  "name": "Std.Logic._auxLemma.13",
  "constType": "âˆ€ {a b c : Prop}, (a â†’ (b â†” c)) = (a âˆ§ b â†” a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ DecidableEq Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff", "Iff.rfl", "Function.comp", "Directed", "Order.Preimage"],
  "name": "directed_comp",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {r : Î± â†’ Î± â†’ Prop} {Î¹ : Sort u_1} {f : Î¹ â†’ Î²} {g : Î² â†’ Î±},\n  Directed r (g âˆ˜ f) â†” Directed (g â»Â¹'o r) f",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "outParam"],
  "name": "sSupHomClass",
  "constType":
  "Type u_8 â†’\n  (Î± : outParam (Type u_9)) â†’\n    (Î² : outParam (Type u_10)) â†’ [inst : SupSet Î±] â†’ [inst : SupSet Î²] â†’ Type (max (max u_10 u_8) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "False",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.not_nonempty_empty.match_1",
   "Set.instMembershipSet"],
  "name": "Set.not_nonempty_empty",
  "constType": "âˆ€ {Î± : Type u}, Â¬Set.Nonempty âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Lean.Data.AC.Expr.op",
   "PProd.fst",
   "Lean.Data.AC.Expr",
   "Lean.Data.AC.EvalInformation",
   "PUnit",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Lean.Data.AC.Expr.rec",
   "Lean.Data.AC.Expr.below",
   "Lean.Data.AC.Expr.brecOn",
   "PProd.snd",
   "Nat",
   "Lean.Data.AC.Expr.var",
   "Lean.Data.AC.EvalInformation.evalOp",
   "_private.Init.Data.AC.0.Lean.Data.AC.reprExpr.match_1._@.Init.Data.AC._hyg.40"],
  "name": "Lean.Data.AC.eval",
  "constType":
  "{Î± : Sort u_1} â†’ (Î² : Sort u) â†’ [inst : Lean.Data.AC.EvalInformation Î± Î²] â†’ Î± â†’ Lean.Data.AC.Expr â†’ Î²",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadRef", "Lean.Syntax"],
  "name": "Lean.MonadRef.withRef",
  "constType":
  "{m : Type â†’ Type} â†’ [self : Lean.MonadRef m] â†’ {Î± : Type} â†’ Lean.Syntax â†’ m Î± â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_3",
  "constType": "âˆ€ (n : â„•), NatCast.natCast (n + 1) = NatCast.natCast (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "False", "Or.inr", "false_or.match_1", "propext", "Eq"],
  "name": "false_or",
  "constType": "âˆ€ (p : Prop), (False âˆ¨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "IsGLB",
   "isGLB_sInf",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "IsGLB.unique",
   "CompleteSemilatticeInf",
   "Eq"],
  "name": "IsGLB.sInf_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {s : Set Î±} {a : Î±}, IsGLB s a â†’ sInf s = a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_union",
   "Membership.mem",
   "Or",
   "propext",
   "Union.union",
   "Set",
   "Set.instUnionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.17",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), (x âˆˆ a âˆª b) = (x âˆˆ a âˆ¨ x âˆˆ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Equiv",
   "AddZeroClass.toAdd",
   "Multiset.card",
   "List.instMembershipList",
   "Finset.mem_univ_val",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Multiset.instMembershipMultiset",
   "Quot.recOnSubsingleton'",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Fintype",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Nat.addMonoid",
   "Trunc.mk",
   "Fintype.truncEquivFin.proof_2",
   "Multiset",
   "Finset.val",
   "Trunc",
   "Nat",
   "Equiv.symm",
   "id",
   "Membership.mem",
   "AddHomClass.toFunLike",
   "Multiset.Nodup",
   "Fintype.card",
   "FunLike.coe",
   "List.length",
   "Setoid.r",
   "Finset.univ",
   "List.Nodup",
   "DecidableEq",
   "List",
   "Fintype.truncEquivFin.proof_1",
   "AddMonoidHomClass.toAddHomClass",
   "List.Nodup.getEquivOfForallMemList",
   "AddMonoidHom.addMonoidHomClass",
   "Fin",
   "AddMonoidHom",
   "Quot.mk"],
  "name": "Fintype.truncEquivFin",
  "constType":
  "(Î± : Type u_4) â†’ [inst : DecidableEq Î±] â†’ [inst : Fintype Î±] â†’ Trunc (Î± â‰ƒ Fin (Fintype.card Î±))",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_comm",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_comm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, a âŠ“ b = b âŠ“ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name",
   "Substring"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Monad", "Bind"],
  "name": "Monad.toBind",
  "constType": "{m : Type u â†’ Type v} â†’ [self : Monad m] â†’ Bind m",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Lean.Data.AC.Expr",
   "Lean.Data.AC.Expr.rec",
   "Nat",
   "Lean.Data.AC.Expr.var"],
  "name": "Lean.Data.AC.Expr.casesOn",
  "constType":
  "{motive : Lean.Data.AC.Expr â†’ Sort u} â†’\n  (t : Lean.Data.AC.Expr) â†’\n    ((x : â„•) â†’ motive (Lean.Data.AC.Expr.var x)) â†’\n      ((lhs rhs : Lean.Data.AC.Expr) â†’ motive (Lean.Data.AC.Expr.op lhs rhs)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["HImp.himp", "HImp.mk", "HImp"],
  "name": "Pi.instHImpForAll",
  "constType":
  "{Î¹ : Type u_1} â†’ {Ï€ : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ HImp (Ï€ i)] â†’ HImp ((i : Î¹) â†’ Ï€ i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_iff'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ âˆ€ (t : Set Î±), t âˆˆ l â†” âˆƒ i, p i âˆ§ s i âŠ† t",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadLiftT"],
  "name": "MonadLiftT.mk",
  "constType":
  "{m : Type u â†’ Type v} â†’ {n : Type u â†’ Type w} â†’ ({Î± : Type u} â†’ m Î± â†’ n Î±) â†’ MonadLiftT m n",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "Multiset", "Multiset.instMembershipMultiset", "id"],
  "name": "Multiset.attach.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (s : Multiset Î±), âˆ€ _a âˆˆ s, _a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Function.LeftInverse",
   "congr_arg",
   "Trans.trans",
   "Function.Injective",
   "instTransEq",
   "Eq.symm",
   "Eq"],
  "name": "Function.LeftInverse.injective",
  "constType":
  "âˆ€ {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} {g : Î² â†’ Î±} {f : Î± â†’ Î²}, Function.LeftInverse g f â†’ Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Preorder.le_refl",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a : (Filter Î±)áµ’áµˆáµ’áµˆ), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Equiv",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.3",
   "Set",
   "Set.Iic",
   "Topology.WithUpperSet.toUpperSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.5",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff",
   "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.4",
   "Eq.trans",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "id",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "HasSubset.Subset",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Equiv.instFunLikeEquiv",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "Specializes",
   "congr",
   "Singleton.singleton",
   "Topology.IsUpperSet.closure_singleton",
   "congrArg",
   "congrFun"],
  "name": "Topology.WithUpperSet.toUpperSet_specializes_toUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±},\n  â†‘Topology.WithUpperSet.toUpperSet a â¤³ â†‘Topology.WithUpperSet.toUpperSet b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Not.elim", "Iff", "Not"],
  "name": "iff_of_false",
  "constType": "âˆ€ {a b : Prop}, Â¬a â†’ Â¬b â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references": ["PSigma"],
  "name": "PSigma.mk",
  "constType": "{Î± : Sort u} â†’ {Î² : Î± â†’ Sort v} â†’ (fst : Î±) â†’ Î² fst â†’ PSigma Î²",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "Top.top",
   "le_top",
   "OrderTop",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "GaloisInsertion.liftOrderTop.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : Preorder Î±] [inst_1 : OrderTop Î±], u (l âŠ¤) â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.removeNeutrals.loop.match_2",
   "PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "Lean.Data.AC.removeNeutrals.loop.match_1",
   "List.nil",
   "Bool",
   "Lean.Data.AC.ContextInformation",
   "Nat",
   "Lean.Data.AC.ContextInformation.isNeutral"],
  "name": "Lean.Data.AC.removeNeutrals.loop",
  "constType":
  "{Î± : Sort u_1} â†’ [info : Lean.Data.AC.ContextInformation Î±] â†’ Î± â†’ List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.antisymm",
   "funext",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Pi.preorder",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "LE.le",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_4",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ PartialOrder (Ï€ i)] (x x_1 : (i : Î¹) â†’ Ï€ i),\n  x â‰¤ x_1 â†’ x_1 â‰¤ x â†’ x = x_1",
  "constCategory": "Theorem"},
 {"references": ["Array", "List.nil", "Nat", "Array.mk"],
  "name": "Array.mkEmpty",
  "constType": "{Î± : Type u} â†’ â„• â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "CompleteLattice.toBoundedOrder",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "Filter.principal",
   "of_eq_true",
   "Filter.instTopFilter",
   "Filter.instPartialOrderFilter",
   "Filter",
   "Mathlib.Order.Filter.Basic._auxLemma.18",
   "Eq.trans",
   "instMembershipSetFilter",
   "top_unique",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.principal_univ",
  "constType": "âˆ€ {Î± : Type u}, Filter.principal Set.univ = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "AddHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.mk",
  "constType":
  "{F : Type u_9} â†’\n  {M : outParam (Type u_10)} â†’\n    {N : outParam (Type u_11)} â†’\n      [inst : Add M] â†’\n        [inst_1 : Add N] â†’\n          [toFunLike : FunLike F M fun x â†¦ N] â†’ (âˆ€ (f : F) (x y : M), â†‘f (x + y) = â†‘f x + â†‘f y) â†’ AddHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "List.cons",
   "OfNat.ofNat",
   "instAddNat",
   "List.count_cons",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instBEq",
   "instDecidableTrue",
   "ite_congr",
   "True",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "List.count",
   "Eq.trans",
   "congrFun"],
  "name": "List.count_cons_self",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (l : List Î±), List.count a (a :: l) = List.count a l + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "PProd",
   "PUnit.unit",
   "Lean.Data.AC.Expr",
   "PUnit",
   "Lean.Data.AC.Expr.rec",
   "Lean.Data.AC.Expr.below",
   "Nat",
   "Lean.Data.AC.Expr.var",
   "PProd.mk"],
  "name": "Lean.Data.AC.Expr.brecOn",
  "constType":
  "{motive : Lean.Data.AC.Expr â†’ Sort u} â†’\n  (t : Lean.Data.AC.Expr) â†’ ((t : Lean.Data.AC.Expr) â†’ Lean.Data.AC.Expr.below t â†’ motive t) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Set",
   "Set.iInter",
   "Set.instInfSetSet",
   "Iff.mpr",
   "iInf_congr_Prop",
   "Eq"],
  "name": "Set.iInter_congr_Prop",
  "constType":
  "âˆ€ {Î± : Type u_1} {p q : Prop} {fâ‚ : p â†’ Set Î±} {fâ‚‚ : q â†’ Set Î±} (pq : p â†” q),\n  (âˆ€ (x : q), fâ‚ (_ : p) = fâ‚‚ x) â†’ Set.iInter fâ‚ = Set.iInter fâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "propext", "or_imp", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.18",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ¨ b â†’ c) = ((a â†’ c) âˆ§ (b â†’ c))",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Decidable", "Not", "dite"],
  "name": "Decidable.not_or_of_imp",
  "constType": "âˆ€ {a b : Prop} [inst : Decidable a], (a â†’ b) â†’ Â¬a âˆ¨ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "sInf_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "rfl",
   "Preorder.toLE",
   "Eq"],
  "name": "iInf_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] (f : Î¹ â†’ Î±) (i : Î¹), iInf f â‰¤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.brecOn",
   "List.below",
   "List.perm_middle.match_1",
   "List.Perm.cons",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "True",
   "List.Perm.symm",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "List.Perm",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "List.perm_middle",
   "PUnit",
   "List.Perm.trans",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "List.append_nil"],
  "name": "List.perm_append_comm",
  "constType": "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ++ lâ‚‚ ~ lâ‚‚ ++ lâ‚",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.mk",
   "Membership.mem",
   "IsLowerSet",
   "Set",
   "Function.comp",
   "OrderHom",
   "FunLike.coe",
   "ContinuousMap",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "Equiv.instFunLikeEquiv",
   "ContinuousMap.mk",
   "Set.instMembershipSet",
   "Topology.WithLowerSet",
   "lcProof",
   "Continuous",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Set.sUnion",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.map._elambda_1",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithLowerSet.map._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â†’ C(Topology.WithLowerSet Î±, Topology.WithLowerSet Î²)",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ Min Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_zero",
  "constType":
  "âˆ€ {M : Type u} [self : AddLeftCancelMonoid M] (x : M), AddLeftCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "IsLowerSet",
   "LowerSet.instSetLikeLowerSet",
   "LE",
   "LowerSet.lower'",
   "SetLike.coe"],
  "name": "LowerSet.lower",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] (s : LowerSet Î±), IsLowerSet â†‘s",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.casesOn",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "Eq.symm",
   "Eq"],
  "name": "List.Sublist.trans.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚‚ : List Î±} (a : Î±)\n  (motive : (lâ‚‚' lâ‚ : List Î±) â†’ List.Sublist lâ‚ lâ‚‚' â†’ List.Sublist lâ‚ (a :: lâ‚‚) â†’ a :: lâ‚‚ = lâ‚‚' â†’ Prop)\n  (lâ‚‚' lâ‚ : List Î±) (x : List.Sublist lâ‚ lâ‚‚') (hâ‚ : List.Sublist lâ‚ (a :: lâ‚‚)) (e : a :: lâ‚‚ = lâ‚‚'),\n  (âˆ€ (hâ‚ : List.Sublist [] (a :: lâ‚‚)) (e : a :: lâ‚‚ = []), motive [] [] (_ : List.Sublist [] []) hâ‚ e) â†’\n    (âˆ€ (lâ‚ lâ‚‚_1 : List Î±) (a' : Î±) (hâ‚' : List.Sublist lâ‚ lâ‚‚_1) (hâ‚ : List.Sublist lâ‚ (a :: lâ‚‚))\n        (e : a :: lâ‚‚ = a' :: lâ‚‚_1), motive (a' :: lâ‚‚_1) lâ‚ (_ : List.Sublist lâ‚ (a' :: lâ‚‚_1)) hâ‚ e) â†’\n      (âˆ€ (lâ‚ lâ‚‚_1 : List Î±) (a' : Î±) (hâ‚' : List.Sublist lâ‚ lâ‚‚_1) (hâ‚ : List.Sublist (a' :: lâ‚) (a :: lâ‚‚))\n          (e : a :: lâ‚‚ = a' :: lâ‚‚_1), motive (a' :: lâ‚‚_1) (a' :: lâ‚) (_ : List.Sublist (a' :: lâ‚) (a' :: lâ‚‚_1)) hâ‚ e) â†’\n        motive lâ‚‚' lâ‚ x hâ‚ e",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.symm",
   "List.Perm.subperm_left.match_1",
   "Iff.intro",
   "Exists",
   "Iff",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "List.Perm.trans",
   "Exists.intro"],
  "name": "List.Perm.subperm_right",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ l : List Î±}, lâ‚ ~ lâ‚‚ â†’ (lâ‚ <+~ l â†” lâ‚‚ <+~ l)",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddRightCancelSemigroup.mk",
  "constType":
  "{G : Type u} â†’ [toAddSemigroup : AddSemigroup G] â†’ (âˆ€ (a b c : G), a + b = c + b â†’ a = c) â†’ AddRightCancelSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "UInt8",
   "Lean.Name.mkStr2",
   "Lean.Syntax.isOfKind",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.SourceInfo.fromRef",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node3",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.Result.error"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) â†’ Type v â†’ Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "List.cons",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.drop.match_1",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.take",
  "constType": "{Î± : Type u} â†’ â„• â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["Ne", "List.Pairwise.sublist", "List.Nodup", "List", "List.Sublist"],
  "name": "List.Nodup.sublist",
  "constType":
  "âˆ€ {Î± : Type u} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.Nodup lâ‚‚ â†’ List.Nodup lâ‚",
  "constCategory": "Theorem"},
 {"references": ["SizeOf", "Nat"],
  "name": "SizeOf.mk",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ â„•) â†’ SizeOf Î±",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ", "Nat.le.rec"],
  "name": "Nat.le.casesOn",
  "constType":
  "âˆ€ {n : â„•} {motive : (a : â„•) â†’ Nat.le n a â†’ Prop} {a : â„•} (t : Nat.le n a),\n  motive n (_ : Nat.le n n) â†’ (âˆ€ {m : â„•} (a : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) â†’ motive a t",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "List.find?_cons.match_1",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ (Unit â†’ motive true) â†’ (Unit â†’ motive false) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "OrderDual.distribLattice.proof_3",
   "OrderDual.distribLattice.proof_1",
   "DistribLattice",
   "OrderDual.distribLattice.proof_2",
   "OrderDual.distribLattice.proof_4",
   "DistribLattice.mk",
   "inferInstanceAs",
   "OrderDual",
   "Lattice.mk",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice"],
  "name": "OrderDual.distribLattice",
  "constType":
  "(Î± : Type u_1) â†’ [inst : DistribLattice Î±] â†’ DistribLattice Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termÏ€_._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.mkArray0",
  "constType": "{Î± : Type u} â†’ Array Î±",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusionType",
  "constType": "Sort u â†’ â„• â†’ â„• â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_add.match_1",
   "Eq",
   "PProd",
   "Nat.zero_add",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.add_comm",
  "constType": "âˆ€ (n m : â„•), n + m = m + n",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Nat.addMonoid",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "AddHomClass.toFunLike",
   "Multiset",
   "Finset",
   "Finset.val",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "Nat",
   "AddMonoidHom",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{Î± : Type u_1} â†’ Finset Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["exists_prop_congr", "Exists", "Iff", "propext", "Iff.mpr", "Eq"],
  "name": "exists_prop_congr'",
  "constType":
  "âˆ€ {p p' : Prop} {q q' : p â†’ Prop}, (âˆ€ (h : p), q h â†” q' h) â†’ âˆ€ (hp : p â†” p'), Exists q = âˆƒ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "Filter.sets",
   "Filter.filter_eq",
   "Iff.rfl",
   "Set",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Set.Subset.rfl",
   "Eq",
   "Preorder.mk",
   "And",
   "LT.lt",
   "Filter",
   "Not",
   "Set.Subset.trans",
   "Set.Subset.antisymm",
   "instMembershipSetFilter"],
  "name": "Filter.instPartialOrderFilter.proof_4",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Filter Î±), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Filter.instTopFilter",
   "Top.top",
   "Iff.rfl",
   "Set",
   "Filter",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_top_iff_forall",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s âˆˆ âŠ¤ â†” âˆ€ (x : Î±), x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype.subtype.proof_1",
   "Membership.mem",
   "Fintype",
   "Fintype.subtype.proof_3",
   "Fintype.mk",
   "Iff",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Finset.instMembershipFinset",
   "Finset.mk",
   "Fintype.subtype.proof_2",
   "Subtype.mk",
   "Subtype"],
  "name": "Fintype.subtype",
  "constType":
  "{Î± : Type u_1} â†’ {p : Î± â†’ Prop} â†’ (s : Finset Î±) â†’ (âˆ€ (x : Î±), x âˆˆ s â†” p x) â†’ Fintype { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["namedPattern",
   "Lean.Name.num",
   "List",
   "String",
   "Eq.refl",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str",
   "Eq"],
  "name": "_private.Init.Prelude.0.Lean.extractImported.match_1",
  "constType":
  "(motive : Lean.Name â†’ List Lean.Name â†’ Sort u_1) â†’\n  (x : Lean.Name) â†’\n    (x_1 : List Lean.Name) â†’\n      ((n p : Lean.Name) â†’\n          (str : String) â†’\n            (h : n = Lean.Name.str p str) â†’\n              (parts : List Lean.Name) â†’ motive (namedPattern n (Lean.Name.str p str) h) parts) â†’\n        ((n p : Lean.Name) â†’\n            (i : â„•) â†’\n              (h : n = Lean.Name.num p i) â†’\n                (parts : List Lean.Name) â†’ motive (namedPattern n (Lean.Name.num p i) h) parts) â†’\n          ((x : Lean.Name) â†’ (x_2 : List Lean.Name) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace"],
  "name": "IsClosed",
  "constType": "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "List.dedup",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_dedup",
   "Eq"],
  "name": "Mathlib.Data.List.Dedup._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, (a âˆˆ List.dedup l) = (a âˆˆ l)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“[â‰¤]_Â»._closed_2",
   "Topology.Â«termð“[â‰¤]_Â»._closed_5"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Specializes",
   "propext",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Singleton.singleton",
   "specializes_iff_closure_subset",
   "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.18",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x â¤³ y = (closure {y} âŠ† closure {x})",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "propext", "or_imp", "Eq"],
  "name": "Std.Logic._auxLemma.43",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ¨ b â†’ c) = ((a â†’ c) âˆ§ (b â†’ c))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "HEq",
   "List.Pairwise.below",
   "List.instMembershipList",
   "eq_of_heq",
   "Unit",
   "Eq.refl",
   "List.Pairwise.below.nil",
   "List.Pairwise.cons",
   "Eq",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "List.Pairwise.below.casesOn",
   "List.nil",
   "Eq.symm"],
  "name": "List.Pairwise.imp.match_1._@.Std.Data.List.Lemmas._hyg.29208",
  "constType":
  "âˆ€ {Î± : Type u_1} {R S : Î± â†’ Î± â†’ Prop}\n  (motive : (x : List Î±) â†’ (x_1 : List.Pairwise R x) â†’ List.Pairwise.below x_1 â†’ Prop) (x : List Î±)\n  (x_1 : List.Pairwise R x) (h_below : List.Pairwise.below x_1),\n  (Unit â†’ motive [] (_ : List.Pairwise R []) (_ : List.Pairwise.below (_ : List.Pairwise R []))) â†’\n    (âˆ€ (a : Î±) (l : List Î±) (hâ‚ : âˆ€ a' âˆˆ l, R a a') (hâ‚‚ : List.Pairwise R l) (h : List.Pairwise.below hâ‚‚)\n        (a_1 : List.Pairwise S l),\n        motive (a :: l) (_ : List.Pairwise R (a :: l)) (_ : List.Pairwise.below (_ : List.Pairwise R (a :: l)))) â†’\n      motive x x_1 h_below",
  "constCategory": "Definition"},
 {"references":
  ["Filter.univ_sets",
   "Filter.sets",
   "Membership.mem",
   "eq_true",
   "Set",
   "Filter",
   "Set.univ",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.12",
  "constType":
  "âˆ€ {Î± : Type u_1} (self : Filter Î±), (Set.univ âˆˆ self.sets) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "DistribLattice",
   "CompleteLattice",
   "Filter.instDistribLatticeFilter.proof_1",
   "DistribLattice.mk",
   "Filter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.instDistribLatticeFilter",
  "constType": "{Î± : Type u} â†’ DistribLattice (Filter Î±)",
  "constCategory": "Definition"},
 {"references": ["Equivalence"],
  "name": "Equivalence.mk",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (x : Î±), r x x) â†’ (âˆ€ {x y : Î±}, r x y â†’ r y x) â†’ (âˆ€ {x y z : Î±}, r x y â†’ r y z â†’ r x z) â†’ Equivalence r",
  "constCategory": "Other"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{Î± : Type u_1} â†’ [self : DistribLattice Î±] â†’ Lattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Monad",
   "Monad.toApplicative",
   "Bool.false",
   "Lean.MonadRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bind.bind",
   "Pure.pure",
   "Lean.MonadRef.getRef",
   "Lean.Syntax",
   "Monad.toBind",
   "Applicative.toPure"],
  "name": "Lean.MonadRef.mkInfoFromRefPos",
  "constType":
  "{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadRef m] â†’ m Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.WithLower.instInhabitedWithLower._rarg", "_neutral"],
  "name": "Topology.WithLower.instInhabitedWithLower._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "nonempty_subtype",
   "Exists",
   "Set.Elem",
   "Set",
   "Set.Nonempty",
   "Subtype",
   "Nonempty",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.to_subtype",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Nonempty s â†’ Nonempty â†‘s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeInf.le_sInf",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteSemilatticeInf Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List.Perm.nil",
   "List",
   "List.Perm.trans",
   "List.nil",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.rec",
  "constType":
  "âˆ€ {Î± : Type uu} {motive : (a a_1 : List Î±) â†’ a ~ a_1 â†’ Prop},\n  motive [] [] (_ : [] ~ []) â†’\n    (âˆ€ (x : Î±) {lâ‚ lâ‚‚ : List Î±} (a : lâ‚ ~ lâ‚‚), motive lâ‚ lâ‚‚ a â†’ motive (x :: lâ‚) (x :: lâ‚‚) (_ : x :: lâ‚ ~ x :: lâ‚‚)) â†’\n      (âˆ€ (x y : Î±) (l : List Î±), motive (y :: x :: l) (x :: y :: l) (_ : y :: x :: l ~ x :: y :: l)) â†’\n        (âˆ€ {lâ‚ lâ‚‚ lâ‚ƒ : List Î±} (a : lâ‚ ~ lâ‚‚) (a_1 : lâ‚‚ ~ lâ‚ƒ),\n            motive lâ‚ lâ‚‚ a â†’ motive lâ‚‚ lâ‚ƒ a_1 â†’ motive lâ‚ lâ‚ƒ (_ : lâ‚ ~ lâ‚ƒ)) â†’\n          âˆ€ {a a_1 : List Î±} (t : a ~ a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references": ["Exists", "False", "Not", "exists_false.match_1"],
  "name": "exists_false",
  "constType": "âˆ€ {Î± : Sort u_1}, Â¬âˆƒ _a, False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finite",
  "constType": "Sort u_1 â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "rfl",
   "TopologicalSpace.ext.match_1",
   "IsOpen",
   "Set.instMembershipSet",
   "Set.instInterSet",
   "Eq"],
  "name": "TopologicalSpace.ext",
  "constType":
  "âˆ€ {Î± : Type u} {f g : TopologicalSpace Î±}, IsOpen = IsOpen â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "ClosedIicTopology",
   "TopologicalSpace",
   "IsClosed",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "ClosedIicTopology.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±],\n  (âˆ€ (a : Î±), IsClosed {b | b â‰¤ a}) â†’ ClosedIicTopology Î±",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "TopologicalSpace.induced"],
  "name": "instTopologicalSpaceProd",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [tâ‚ : TopologicalSpace Î±] â†’ [tâ‚‚ : TopologicalSpace Î²] â†’ TopologicalSpace (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "instTopologicalSpaceProd",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "Eq.refl",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "TopologicalSpace.induced",
   "Eq"],
  "name":
  "_private.Mathlib.Topology.Constructions.0.instTopologicalSpaceProd._eq_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [tâ‚ : TopologicalSpace Î±] [tâ‚‚ : TopologicalSpace Î²],\n  instTopologicalSpaceProd = TopologicalSpace.induced Prod.fst tâ‚ âŠ“ TopologicalSpace.induced Prod.snd tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Iff",
   "Equiv.refl",
   "Topology.WithLowerSet",
   "lcProof",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.toLowerSetOrderIso._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â‰ƒo Topology.WithLowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Â«termð“[<]_Â»._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[_]_Â»._closed_9"],
  "name": "Topology.Â«termð“[<]_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "propext", "or_self.match_1", "Eq"],
  "name": "or_self",
  "constType": "âˆ€ (p : Prop), (p âˆ¨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["UInt32", "Decidable", "instLEUInt32", "UInt32.decLe", "LE.le"],
  "name": "instDecidableLeUInt32InstLEUInt32",
  "constType": "(a b : UInt32) â†’ Decidable (a â‰¤ b)",
  "constCategory": "Definition"},
 {"references": ["And", "And.right", "False", "Not"],
  "name": "instDecidableAnd.proof_1",
  "constType": "âˆ€ {p q : Prop}, Â¬q â†’ p âˆ§ q â†’ False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_refl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î± â†’ Prop), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["InfTopHomClass",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "sInfHomClass.toInfTopHomClass.proof_1",
   "InfHomClass.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "sInfHomClass.toInfTopHomClass.proof_2",
   "CompleteLattice.toTop",
   "sInfHomClass.toFunLike",
   "InfTopHomClass.mk",
   "sInfHomClass"],
  "name": "sInfHomClass.toInfTopHomClass",
  "constType":
  "{F : Type u_1} â†’\n  {Î± : Type u_2} â†’\n    {Î² : Type u_3} â†’\n      [inst : CompleteLattice Î±] â†’ [inst_1 : CompleteLattice Î²] â†’ [inst_2 : sInfHomClass F Î± Î²] â†’ InfTopHomClass F Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "Eq.refl",
   "instOfNatNat",
   "List.length",
   "Nat",
   "Eq"],
  "name": "_private.Std.Data.List.Count.0.List.length._eq_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (head : Î±) (as : List Î±), List.length (head :: as) = List.length as + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "âˆ€ {Î± : Type u} [self : StrictOrderedSemiring Î±] (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c + a â‰¤ c + b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvImage",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ (Î² â†’ Î² â†’ Prop) â†’ (Î± â†’ Î²) â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.succ_eq_add_one",
  "constType": "âˆ€ (n : â„•), Nat.succ n = n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Bot.bot",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot",
   "GeneralizedBooleanAlgebra.inf_inf_sdiff",
   "Eq"],
  "name": "inf_inf_sdiff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : GeneralizedBooleanAlgebra Î±] (x y : Î±), x âŠ“ y âŠ“ x \\ y = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["And", "False", "Not", "And.left"],
  "name": "instDecidableAnd.proof_2",
  "constType": "âˆ€ {p q : Prop}, Â¬p â†’ p âˆ§ q â†’ False",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) â†’ [inst : Add G] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["GaloisConnection",
   "GaloisCoinsertion",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisCoinsertion.mk",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’\n        {l : Î± â†’ Î²} â†’\n          {u : Î² â†’ Î±} â†’\n            (choice : (x : Î²) â†’ x â‰¤ l (u x) â†’ Î±) â†’\n              GaloisConnection l u â†’\n                (âˆ€ (x : Î±), u (l x) â‰¤ x) â†’ (âˆ€ (a : Î²) (h : a â‰¤ l (u a)), choice a h = u a) â†’ GaloisCoinsertion l u",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "iSup",
   "le_iSup",
   "iSup_le",
   "le_sup_left",
   "Eq",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "SemilatticeSup.toSup",
   "iSup_mono",
   "Sup.sup",
   "sup_le",
   "le_sup_right",
   "sup_le_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "le_antisymm",
   "CompleteLattice.toSupSet"],
  "name": "iSup_sup_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f g : Î¹ â†’ Î±}, â¨† x, f x âŠ” g x = (â¨† x, f x) âŠ” â¨† x, g x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.preimage_mono",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s t : Set Î²}, s âŠ† t â†’ f â»Â¹' s âŠ† f â»Â¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} â†’\n  {M : outParam (Type u_10)} â†’\n    {N : outParam (Type u_11)} â†’\n      [inst : AddZeroClass M] â†’ [inst_1 : AddZeroClass N] â†’ [self : AddMonoidHomClass F M N] â†’ AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.drop.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : â„• â†’ List Î± â†’ Sort u_2) â†’\n    (x : â„•) â†’\n      (x_1 : List Î±) â†’\n        ((a : List Î±) â†’ motive 0 a) â†’\n          ((n : â„•) â†’ motive (Nat.succ n) []) â†’\n            ((n : â„•) â†’ (head : Î±) â†’ (as : List Î±) â†’ motive (Nat.succ n) (head :: as)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GeneralizedBooleanAlgebra",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.le_top",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_14",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î± â†’ Prop), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["Nat", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.nsmul",
  "constType": "{M : Type u} â†’ [self : AddLeftCancelMonoid M] â†’ â„• â†’ M â†’ M",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ Î± â†’ Î² â†’ Î± Ã— Î²",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Iff",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableEqProp.match_1",
  "constType":
  "{p q : Prop} â†’\n  (motive : Decidable (p â†” q) â†’ Sort u_1) â†’\n    (d : Decidable (p â†” q)) â†’ ((h : p â†” q) â†’ motive (isTrue h)) â†’ ((h : Â¬(p â†” q)) â†’ motive (isFalse h)) â†’ motive d",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Image._auxLemma.23",
   "Exists",
   "funext",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "True",
   "iff_self",
   "Eq",
   "Multiset.map",
   "And",
   "Mathlib.Data.Finset.Image._auxLemma.8",
   "Mathlib.Data.Finset.Image._auxLemma.22",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.image",
   "Finset",
   "Multiset",
   "Finset.val",
   "congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Finset.mem_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DecidableEq Î²] {f : Î± â†’ Î²} {s : Finset Î±} {b : Î²},\n  b âˆˆ Finset.image f s â†” âˆƒ a âˆˆ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.mk",
   "OrderHom.comp.proof_1",
   "Function.comp",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.comp",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    {Î³ : Type u_4} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ [inst_2 : Preorder Î³] â†’ (Î² â†’o Î³) â†’ (Î± â†’o Î²) â†’ Î± â†’o Î³",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "DecidableEq", "Classical.propDecidable", "Eq"],
  "name": "Classical.decEq",
  "constType": "(Î± : Sort u) â†’ DecidableEq Î±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "Set.instSingletonSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "Singleton.singleton",
   "IsGLB.sInf_eq",
   "CompleteSemilatticeInf",
   "Eq",
   "isGLB_singleton"],
  "name": "sInf_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {a : Î±}, sInf {a} = a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "EStateM.Backtrackable"],
  "name": "EStateM.Backtrackable.mk",
  "constType":
  "{Î´ : outParam (Type u)} â†’ {Ïƒ : Type u} â†’ (Ïƒ â†’ Î´) â†’ (Ïƒ â†’ Î´ â†’ Ïƒ) â†’ EStateM.Backtrackable Î´ Ïƒ",
  "constCategory": "Other"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Set.Finite.rec",
   "Set.Finite"],
  "name": "Set.Finite.casesOn",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {motive : Set.Finite s â†’ Prop} (t : Set.Finite s),\n  (âˆ€ (a : Fintype â†‘s), motive (_ : Set.Finite s)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.ofUpper",
  "constType": "{Î± : Type u_1} â†’ Topology.WithUpper Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable", "Not", "Decidable.byContradiction"],
  "name": "Decidable.by_contradiction",
  "constType": "âˆ€ {p : Prop} [dec : Decidable p], (Â¬p â†’ False) â†’ p",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "List.pairwise_lt_range'",
   "List.Pairwise.imp",
   "List.range'",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "ne_of_lt",
   "optParam",
   "autoParam",
   "instLTNat",
   "List.Nodup",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.strictOrderedSemiring"],
  "name": "List.nodup_range'",
  "constType":
  "âˆ€ (s n : â„•) (step : optParam â„• 1), autoParam (0 < step) _autoâœ â†’ List.Nodup (List.range' s n step)",
  "constCategory": "Theorem"},
 {"references":
  ["List.instMembershipList",
   "Std.Data.List.Count._auxLemma.7",
   "Eq.refl",
   "implies_congr",
   "True",
   "Eq",
   "instLawfulBEqInstBEq",
   "trivial",
   "And.right",
   "BEq.beq",
   "Eq.mpr",
   "forall_congr",
   "Bool.true",
   "Nat",
   "List.countP",
   "Eq.trans",
   "id",
   "Membership.mem",
   "eq_self",
   "List.filter",
   "Std.Data.List.Count._auxLemma.9",
   "instBEq",
   "Std.Data.List.Count._auxLemma.2",
   "List.length",
   "And",
   "DecidableEq",
   "List",
   "List.replicate",
   "congr",
   "Bool",
   "And.intro",
   "List.count",
   "congrArg",
   "congrFun",
   "List.countP_eq_length_filter"],
  "name": "List.filter_beq'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±) (a : Î±),\n  List.filter (fun x â†¦ x == a) l = List.replicate (List.count a l) a",
  "constCategory": "Theorem"},
 {"references":
  ["nhds",
   "Inf.inf",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter",
   "Filter.NeBot"],
  "name": "ClusterPt",
  "constType":
  "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Î± â†’ Filter Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.toDualHomeomorph.proof_2",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toDualHomeomorph.proof_3",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Topology.WithLowerSet",
   "Homeomorph",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderDual",
   "Equiv.mk",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual",
   "Topology.WithUpperSet.toDualHomeomorph.proof_1",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.toDualHomeomorph",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithUpperSet Î± â‰ƒâ‚œ Topology.WithLowerSet Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Option.none", "Option.rec", "Option.some", "Option"],
  "name": "Option.casesOn",
  "constType":
  "{Î± : Type u} â†’\n  {motive : Option Î± â†’ Sort u_1} â†’ (t : Option Î±) â†’ motive none â†’ ((val : Î±) â†’ motive (some val)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Name.mkStr1"],
  "name": "Lean.nullKind",
  "constType": "Lean.SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} â†’ [toZero : Zero M] â†’ [toAdd : Add M] â†’ (âˆ€ (a : M), 0 + a = a) â†’ (âˆ€ (a : M), a + 0 = a) â†’ AddZeroClass M",
  "constCategory": "Other"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{Î± : Type u_5} â†’ [self : ConditionallyCompleteLattice Î±] â†’ Lattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike.mem_coe",
   "SetLike",
   "propext",
   "Set",
   "SetLike.instMembership",
   "Eq",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.SetLike.Basic._auxLemma.3",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} â†’\n  {M : outParam (Type u_10)} â†’\n    {N : outParam (Type u_11)} â†’ [inst : Add M] â†’ [inst_1 : Add N] â†’ [self : AddHomClass F M N] â†’ FunLike F M fun x â†¦ N",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lower", "Topology.IsLower", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsLower.topology_eq_lowerTopology",
  "constType":
  "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±] [inst : Preorder Î±] [self : Topology.IsLower Î±], t = Topology.lower Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Iff",
   "Fin.val",
   "LT.lt",
   "Nat.succ_lt_succ_iff",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "Nat.succ",
   "Fin"],
  "name": "Fin.succ_lt_succ_iff",
  "constType": "âˆ€ {n : â„•} {a b : Fin n}, Fin.succ a < Fin.succ b â†” a < b",
  "constCategory": "Theorem"},
 {"references":
  ["IsLUB.unique",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "isLUB_sSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "CompleteSemilatticeSup.toSupSet",
   "IsLUB",
   "Eq"],
  "name": "IsLUB.sSup_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeSup Î±] {s : Set Î±} {a : Î±}, IsLUB s a â†’ sSup s = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "supsSupHom.proof_1",
   "sSupHom.mk",
   "Prod.snd",
   "SemilatticeSup.toSup",
   "CompleteLattice",
   "sSupHom",
   "Prod.supSet",
   "Sup.sup",
   "Prod",
   "Prod.fst",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet"],
  "name": "supsSupHom",
  "constType":
  "{Î± : Type u_2} â†’ [inst : CompleteLattice Î±] â†’ sSupHom (Î± Ã— Î±) Î±",
  "constCategory": "Definition"},
 {"references":
  ["Union",
   "Union.mk",
   "Multiset.ndunion",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Finset.mk",
   "Finset.instUnionFinset.proof_1"],
  "name": "Finset.instUnionFinset",
  "constType": "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ Union (Finset Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.comp",
   "Equiv.mk",
   "Equiv.trans.proof_2",
   "FunLike.coe",
   "Equiv.trans.proof_1",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {Î³ : Sort w} â†’ Î± â‰ƒ Î² â†’ Î² â‰ƒ Î³ â†’ Î± â‰ƒ Î³",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.removeNeutrals",
   "Lean.Data.AC.Expr",
   "List",
   "Bool.true",
   "Lean.Data.AC.mergeIdem",
   "Lean.Data.AC.sort",
   "Bool",
   "Lean.Data.AC.ContextInformation",
   "Lean.Data.AC.ContextInformation.isComm",
   "Nat",
   "Lean.Data.AC.Expr.toList",
   "Lean.Data.AC.ContextInformation.isIdem",
   "instDecidableEqBool",
   "Eq",
   "ite"],
  "name": "Lean.Data.AC.norm",
  "constType":
  "{Î± : Sort u_1} â†’ [info : Lean.Data.AC.ContextInformation Î±] â†’ Î± â†’ Lean.Data.AC.Expr â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Sublist.trans",
   "List",
   "List.Sublist",
   "List.sublist_cons"],
  "name": "List.sublist_of_cons_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {lâ‚ lâ‚‚ : List Î±}, List.Sublist (a :: lâ‚) lâ‚‚ â†’ List.Sublist lâ‚ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Function.comp", "rfl", "Eq"],
  "name": "Function.comp.assoc",
  "constType":
  "âˆ€ {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} {Ï† : Sort uâ‚ƒ} {Î´ : Sort uâ‚„} (f : Ï† â†’ Î´) (g : Î² â†’ Ï†) (h : Î± â†’ Î²), (f âˆ˜ g) âˆ˜ h = f âˆ˜ g âˆ˜ h",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.sprod",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : SProd Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Filter.sets_of_superset",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "rfl",
   "implies_congr",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "forall_congr",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "Set.inter_subset_right",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "Mathlib.Order.Filter.Basic._auxLemma.25",
   "Mathlib.Order.Filter.Basic._auxLemma.49",
   "Mathlib.Order.Filter.Basic._auxLemma.48",
   "Mathlib.Order.Filter.Basic._auxLemma.50",
   "And",
   "Eq.ndrec",
   "Filter.instInfFilter",
   "congr",
   "Sup.sup",
   "And.intro",
   "Set.inter_subset_left",
   "congrArg",
   "Mathlib.Order.Filter.Basic._auxLemma.42",
   "Set.instInterSet",
   "congrFun"],
  "name": "Filter.instDistribLatticeFilter.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (x y z : Filter Î±) â¦ƒs : Set Î±â¦„, s âˆˆ x âŠ” y âŠ“ z â†’ s âˆˆ (x âŠ” y) âŠ“ (x âŠ” z)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Order.Frame",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Order.Frame.toCompleteLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "CompleteLattice.toInfSet",
   "Sup.sup",
   "CompleteDistribLattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteDistribLattice.mk",
  "constType":
  "{Î± : Type u_1} â†’\n  [toFrame : Order.Frame Î±] â†’ (âˆ€ (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s) â†’ CompleteDistribLattice Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Function.LeftInverse",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.preimage_subset_image_of_inverse",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.LeftInverse g f â†’ âˆ€ (s : Set Î²), f â»Â¹' s âŠ† g '' s",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsUpperSet",
  "constType":
  "(Î± : Type u_4) â†’ [t : TopologicalSpace Î±] â†’ [inst : Preorder Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Exists",
   "OfNat.ofNat",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "Nat.le.dest",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.sub_self_add",
   "id"],
  "name": "Nat.sub_eq_zero_of_le",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ n - m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_left_comm",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_left_comm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] (a b c : Î±), a âŠ“ (b âŠ“ c) = b âŠ“ (a âŠ“ c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} â†’ [self : AddMonoid M] â†’ AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["BEq.beq", "BEq", "LawfulBEq.rfl", "Bool.true", "LawfulBEq", "Bool", "Eq"],
  "name": "beq_self_eq_true",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] (a : Î±), (a == a) = true",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Eq.refl",
   "Option.casesOn",
   "Option.noConfusionType",
   "Eq",
   "Option"],
  "name": "Option.noConfusion",
  "constType":
  "{Î± : Type u} â†’ {P : Sort u_1} â†’ {v1 v2 : Option Î±} â†’ v1 = v2 â†’ Option.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "List.nil",
   "rfl",
   "Eq"],
  "name": "List.nil_append",
  "constType": "âˆ€ {Î± : Type u} (as : List Î±), [] ++ as = as",
  "constCategory": "Theorem"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{Î± : Type u} â†’ Array Î± â†’ Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.8",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ§ b) âˆ§ c) = (a âˆ§ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Expr"],
  "name": "Lean.Data.AC.Expr.op",
  "constType": "Lean.Data.AC.Expr â†’ Lean.Data.AC.Expr â†’ Lean.Data.AC.Expr",
  "constCategory": "Other"},
 {"references": ["UInt32", "Char"],
  "name": "Char.val",
  "constType": "Char â†’ UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.le_sup_right",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_6",
  "constType": "âˆ€ {Î± : Type u_1} (a b : (Filter Î±)áµ’áµˆáµ’áµˆ), b â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Set",
   "Set.Nonempty",
   "GE.ge",
   "Eq.refl",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Iff.of_eq",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Filter",
   "Eq.trans",
   "Subtype",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "DirectedOn.directed_val",
   "DirectedOn",
   "Set.Nonempty.to_subtype",
   "Filter.mem_iInf_of_directed",
   "Set.instMembershipSet",
   "Order.Preimage",
   "And",
   "of_eq_true",
   "iInf",
   "iInf_subtype'",
   "CompleteLattice.toInfSet",
   "propext",
   "Filter.instPartialOrderFilter",
   "Mathlib.Order.Filter.Basic._auxLemma.46",
   "congrArg",
   "Mathlib.Order.Filter.Basic._auxLemma.17",
   "Subtype.mk",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Filter.mem_biInf_of_directed",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î² â†’ Filter Î±} {s : Set Î²},\n  DirectedOn (f â»Â¹'o fun x x_1 â†¦ x â‰¥ x_1) s â†’ Set.Nonempty s â†’ âˆ€ {t : Set Î±}, t âˆˆ â¨… i âˆˆ s, f i â†” âˆƒ i âˆˆ s, t âˆˆ f i",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.rec",
  "constType":
  "{M : Type u_9} â†’\n  {N : Type u_10} â†’\n    [inst : AddZeroClass M] â†’\n      [inst_1 : AddZeroClass N] â†’\n        {motive : (M â†’+ N) â†’ Sort u} â†’\n          ((toZeroHom : ZeroHom M N) â†’\n              (map_add' :\n                  âˆ€ (x y : M),\n                    ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) â†’\n                motive { toZeroHom := toZeroHom, map_add' := map_add' }) â†’\n            (t : M â†’+ N) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Eq"],
  "name": "List.eq_replicate_of_mem.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (b : Î±) (l : List Î±) (motive : (a : Î±) â†’ (b = a âˆ§ âˆ€ x âˆˆ l, x = a) â†’ (âˆ€ b_1 âˆˆ b :: l, b_1 = a) â†’ Prop)\n  (a : Î±) (x : b = a âˆ§ âˆ€ x âˆˆ l, x = a) (H : âˆ€ b_1 âˆˆ b :: l, b_1 = a),\n  (âˆ€ (Hâ‚‚ : âˆ€ x âˆˆ l, x = b) (H : âˆ€ b_1 âˆˆ b :: l, b_1 = b), motive b (_ : b = b âˆ§ âˆ€ x âˆˆ l, x = b) H) â†’ motive a x H",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.map_id",
   "Subtype.val",
   "List.instMembershipList",
   "List",
   "List.map",
   "List.attach_map_coe'",
   "List.attach",
   "Eq.trans",
   "Subtype",
   "Eq",
   "id"],
  "name": "List.attach_map_val",
  "constType":
  "âˆ€ {Î± : Type u} (l : List Î±), List.map Subtype.val (List.attach l) = l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_singleton_iff",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, a âˆˆ {b} â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Eq.refl",
   "IsCompl",
   "le_rfl",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Lattice.toSemilatticeSup",
   "IsCompl.symm",
   "BoundedOrder.toOrderBot",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder",
   "id",
   "sup_bot_eq",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "inf_le_inf",
   "instTransLeToLE",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "inf_sup_right",
   "Eq.ndrec",
   "OrderBot.toBot",
   "Sup.sup",
   "IsCompl.inf_eq_bot"],
  "name": "IsCompl.inf_left_le_of_le_sup_right",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {a b x y : Î±}, IsCompl x y â†’ a â‰¤ b âŠ” y â†’ a âŠ“ x â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "OrderDual.orderTop",
   "OrderBot",
   "OrderDual.boundedOrder.proof_1",
   "BoundedOrder.toOrderTop",
   "OrderDual.instLEOrderDual",
   "OrderTop.toTop",
   "OrderDual.orderBot",
   "BoundedOrder.mk",
   "OrderDual.boundedOrder.proof_2",
   "OrderBot.toBot",
   "LE",
   "OrderTop",
   "OrderDual",
   "inferInstanceAs",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "OrderDual.boundedOrder",
  "constType":
  "(Î± : Type u) â†’ [inst : LE Î±] â†’ [inst_1 : BoundedOrder Î±] â†’ BoundedOrder Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["le_trans", "IsTrans", "IsTrans.mk", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "instIsTransLeToLE.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], IsTrans Î± fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Subsingleton",
   "Quot",
   "Eq",
   "Quot.sound",
   "Subsingleton.elim",
   "Quot.mk"],
  "name": "Quot.recOnSubsingleton'.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_2} {r : Î± â†’ Î± â†’ Prop} {motive : Quot r â†’ Sort u_1} [h : âˆ€ (a : Î±), Subsingleton (motive (Quot.mk r a))]\n  (f : (a : Î±) â†’ motive (Quot.mk r a)) (a b : Î±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) â–¸ f a = f b",
  "constCategory": "Theorem"},
 {"references": ["SDiff"],
  "name": "SDiff.sdiff",
  "constType": "{Î± : Type u} â†’ [self : SDiff Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.lower._cstage1",
  "constType": "(Î± : Type u_1) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "iSup_range",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.biUnion_range",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {g : Î± â†’ Set Î²}, â‹ƒ x âˆˆ Set.range f, g x = â‹ƒ y, g (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis.ge_iff",
   "PartialOrder.toPreorder",
   "setOf",
   "Set",
   "Eq.refl",
   "Filter.Eventually",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "propext",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.Tendsto",
   "Filter",
   "Mathlib.Order.Filter.Bases._auxLemma.61",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "congrFun"],
  "name": "Filter.HasBasis.tendsto_right_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹' : Sort u_5} {la : Filter Î±} {lb : Filter Î²} {pb : Î¹' â†’ Prop} {sb : Î¹' â†’ Set Î²}\n  {f : Î± â†’ Î²}, Filter.HasBasis lb pb sb â†’ (Filter.Tendsto f la lb â†” âˆ€ (i : Î¹'), pb i â†’ âˆ€á¶  (x : Î±) in la, f x âˆˆ sb i)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "True",
   "Eq",
   "Nat.succ_pos"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.14",
  "constType": "âˆ€ (n : â„•), (0 < Nat.succ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.1",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Function.comp", "Monotone", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone.comp",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : Preorder Î³] {g : Î² â†’ Î³}\n  {f : Î± â†’ Î²}, Monotone g â†’ Monotone f â†’ Monotone (g âˆ˜ f)",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "Equiv.toHomeomorphOfInducing",
   "IsLowerSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLowerSet",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Equiv.refl",
   "Topology.WithLowerSet",
   "lcProof",
   "Homeomorph",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Set.sUnion",
   "Topology.WithLowerSet.ofLowerSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsLowerSet Î±] â†’ Topology.WithLowerSet Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsClosed_of._closed_5",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_13"],
  "name": "Topology.IsClosed_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_6"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SupSet", "sSupHom"],
  "name": "sSupHom.toFun",
  "constType":
  "{Î± : Type u_8} â†’ {Î² : Type u_9} â†’ [inst : SupSet Î±] â†’ [inst_1 : SupSet Î²] â†’ sSupHom Î± Î² â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "SupSet.mk",
   "Set.instMembershipSet"],
  "name": "Set.instSupSetSet",
  "constType": "{Î± : Type u_1} â†’ SupSet (Set Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.add_right_cancel",
  "constType":
  "âˆ€ {G : Type u} [inst : Add G] [self : IsRightCancelAdd G] (a b c : G), a + b = c + b â†’ a = c",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Topology.IsUpperSet.casesOn",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.noConfusionType",
  "constType":
  "{Î± : Type u_4} â†’\n  {t : TopologicalSpace Î±} â†’ {inst : Preorder Î±} â†’ Sort u â†’ Topology.IsUpperSet Î± â†’ Topology.IsUpperSet Î± â†’ Sort u",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.sSup",
   "GaloisInsertion.isLUB_of_u_image",
   "And.left",
   "GaloisInsertion",
   "CompleteSemilatticeSup.toSupSet",
   "PartialOrder",
   "Set.instMembershipSet",
   "upperBounds",
   "CompleteLattice",
   "isLUB_sSup",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±],\n  GaloisInsertion l u â†’ âˆ€ (s : Set Î²), l (sSup (u '' s)) âˆˆ upperBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.instHasSubsetSet",
   "Filter.comap.match_1",
   "setOf",
   "Set.preimage",
   "HasSubset.Subset.trans",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.comap.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (m : Î± â†’ Î²) (f : Filter Î²) {x y : Set Î±},\n  x âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s} â†’ x âŠ† y â†’ y âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "Lean.Data.AC.sort.loop",
   "Eq.refl",
   "Lean.Data.AC.Context.evalList_sort_congr",
   "List.casesOn",
   "Lean.Data.AC.sort",
   "True",
   "Eq",
   "Lean.Data.AC.Context.assoc",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "List.rec",
   "Lean.Data.AC.Context",
   "Init.Data.AC._auxLemma.1",
   "eq_false'",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "eq_self",
   "List.cons",
   "False",
   "Lean.Data.AC.insert",
   "Lean.Data.AC.Context.evalList_sort_loop_swap",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.evalList_insert",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Lean.IsCommutative",
   "Lean.Data.AC.EvalInformation.evalVar",
   "congr",
   "Not",
   "List.noConfusion",
   "Lean.IsCommutative.comm",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort_cons",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±),\n  Lean.IsCommutative ctx.op â†’\n    âˆ€ (x : â„•) (xs : List â„•),\n      Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.sort (x :: xs)) =\n        Lean.Data.AC.evalList Î± ctx (x :: Lean.Data.AC.sort xs)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "instOfNatNat",
   "Nat",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_zero",
  "constType": "âˆ€ (n : â„•), n ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.preimage",
   "Set",
   "IsOpen.inter",
   "TopologicalSpace",
   "Inter.inter",
   "IsOpen",
   "Set.instInterSet"],
  "name": "TopologicalSpace.coinduced.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (f : Î± â†’ Î²) (t : TopologicalSpace Î±) (sâ‚ sâ‚‚ : Set Î²),\n  IsOpen (f â»Â¹' sâ‚) â†’ IsOpen (f â»Â¹' sâ‚‚) â†’ IsOpen (f â»Â¹' sâ‚ âˆ© fun x â†¦ sâ‚‚ (f x))",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Topology.WithLower.toLower",
   "Set.preimage",
   "Topology.lower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Iff.rfl",
   "Topology.WithLower",
   "Set",
   "FunLike.coe",
   "Preorder",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.isOpen_def",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (T : Set (Topology.WithLower Î±)),\n  IsOpen T â†” TopologicalSpace.IsOpen (â†‘Topology.WithLower.toLower â»Â¹' T)",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "List.filterMap",
   "List.filterMap_eq_filter",
   "List.Sublist",
   "Eq.refl",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "Bool.true",
   "Bool",
   "Eq.symm",
   "Option.guard",
   "instDecidableEqBool",
   "id",
   "Option",
   "List.Sublist.filterMap"],
  "name": "List.Sublist.filter",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {lâ‚ lâ‚‚ : List Î±},\n  List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist (List.filter p lâ‚) (List.filter p lâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "Set.Nonempty",
   "HasSubset.Subset",
   "Exists.imp",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.mono",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, s âŠ† t â†’ Set.Nonempty s â†’ Set.Nonempty t",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "HEq",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Sublist.slnil",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "HEq.refl",
   "List",
   "HAppend.hAppend",
   "List.Sublist.below.consâ‚‚",
   "List.Sublist.consâ‚‚",
   "List.nil",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Sublist.append_right.match_1._@.Std.Data.List.Lemmas._hyg.7596",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (lâ‚‚ lâ‚ : List Î±) â†’ (x : List.Sublist lâ‚ lâ‚‚) â†’ List Î± â†’ List.Sublist.below x â†’ Prop)\n  (lâ‚‚ lâ‚ : List Î±) (x : List.Sublist lâ‚ lâ‚‚) (x_1 : List Î±) (h_below : List.Sublist.below x),\n  (âˆ€ (x : List Î±), motive [] [] (_ : List.Sublist [] []) x (_ : List.Sublist.below (_ : List.Sublist [] []))) â†’\n    (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (h : List.Sublist lâ‚ lâ‚‚) (x : List Î±) (h_2 : List.Sublist.below h)\n        (a_1 : âˆ€ (x : List Î±), List.Sublist (lâ‚ ++ x) (lâ‚‚ ++ x)),\n        motive (a :: lâ‚‚) lâ‚ (_ : List.Sublist lâ‚ (a :: lâ‚‚)) x\n          (_ : List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚)))) â†’\n      (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (h : List.Sublist lâ‚ lâ‚‚) (x : List Î±) (h_3 : List.Sublist.below h)\n          (a_1 : âˆ€ (x : List Î±), List.Sublist (lâ‚ ++ x) (lâ‚‚ ++ x)),\n          motive (a :: lâ‚‚) (a :: lâ‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)) x\n            (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n        motive lâ‚‚ lâ‚ x x_1 h_below",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Equiv",
   "IsLowerSet",
   "Set",
   "Preorder.toLE",
   "Eq",
   "lcProof",
   "Continuous",
   "Homeomorph",
   "TopologicalSpace",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Membership.mem",
   "OrderDual.toDual",
   "Equiv.toFun",
   "OrderDual.instPreorder",
   "Topology.WithUpperSet",
   "IsUpperSet",
   "FunLike.coe",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.coinduced",
   "OrderDual.ofDual",
   "Equiv.invFun",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderDual",
   "Equiv.mk",
   "Set.sUnion",
   "OrderDual.ofDual_toDual",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithUpperSet Î± â‰ƒâ‚œ Topology.WithLowerSet Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{Î± : Type u} â†’ [self : NonAssocSemiring Î±] â†’ AddCommMonoidWithOne Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView",
   "Inhabited",
   "List",
   "Lean.instInhabitedName",
   "Lean.MacroScopesView.mk",
   "instInhabitedList",
   "Lean.Name",
   "Inhabited.mk",
   "Lean.MacroScope",
   "Inhabited.default"],
  "name": "Lean.instInhabitedMacroScopesView",
  "constType": "Inhabited Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.iUnion",
   "isOpen_sUnion",
   "Set",
   "TopologicalSpace",
   "Set.forall_range_iff",
   "IsOpen",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "isOpen_iUnion",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} [inst : TopologicalSpace Î±] {f : Î¹ â†’ Set Î±}, (âˆ€ (i : Î¹), IsOpen (f i)) â†’ IsOpen (â‹ƒ i, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Eq.refl",
   "Sup.sup",
   "sup_sup_sup_comm",
   "sup_idem",
   "id",
   "Eq"],
  "name": "sup_sup_distrib_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] (a b c : Î±), a âŠ” (b âŠ” c) = a âŠ” b âŠ” (a âŠ” c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice",
   "le_iSupâ‚‚",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "le_sSup",
   "iSup",
   "SupSet.sSup",
   "sSup_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "iSupâ‚‚_le",
   "CompleteLattice.toSupSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "sSup_eq_iSup",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {s : Set Î±}, sSup s = â¨† a âˆˆ s, a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "iInf",
   "Bool.false",
   "CompleteLattice.toInfSet",
   "Bool.true",
   "Inf.inf",
   "OrderDual.completeLattice",
   "OrderDual",
   "Bool",
   "Eq",
   "iSup_bool_eq"],
  "name": "iInf_bool_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {f : Bool â†’ Î±}, â¨… b, f b = f true âŠ“ f false",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "Bool.decEq.match_1",
  "constType":
  "(motive : Bool â†’ Bool â†’ Sort u_1) â†’\n  (a b : Bool) â†’\n    (Unit â†’ motive false false) â†’\n      (Unit â†’ motive false true) â†’ (Unit â†’ motive true false) â†’ (Unit â†’ motive true true) â†’ motive a b",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Mathlib.Order.Filter.Bases._auxLemma.37",
   "Inter.inter",
   "implies_congr",
   "True",
   "iff_self",
   "Filter.principal",
   "Filter.HasBasis",
   "Iff",
   "forall_congr",
   "Filter",
   "Eq.trans",
   "instMembershipSetFilter",
   "Mathlib.Order.Filter.Bases._auxLemma.35",
   "Membership.mem",
   "funext",
   "setOf",
   "HasSubset.Subset",
   "Mathlib.Order.Filter.Bases._auxLemma.36",
   "Filter.HasBasis.mem_iff",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "propext",
   "Filter.instInfFilter",
   "congr",
   "congrArg",
   "Filter.HasBasis.mk",
   "Set.instInterSet"],
  "name": "Filter.HasBasis.inf_principal",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ âˆ€ (s' : Set Î±), Filter.HasBasis (l âŠ“ Filter.principal s') p fun i â†¦ s i âˆ© s'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "instAddNat",
   "Nat.sub_le",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.lt_succ_of_le",
   "instLTNat",
   "Eq",
   "Nat.sub_lt.match_1",
   "LT.lt",
   "Eq.rec",
   "Nat.lt_irrefl",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ_sub_succ_eq_sub",
   "absurd",
   "Nat.succ"],
  "name": "Nat.sub_lt",
  "constType": "âˆ€ {n m : â„•}, 0 < n â†’ 0 < m â†’ n - m < n",
  "constCategory": "Theorem"},
 {"references": ["Top", "Top.top", "Prod.mk", "Prod", "Top.mk"],
  "name": "Prod.top",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : Top Î±] â†’ [inst : Top Î²] â†’ Top (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Iff.rfl",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLower.ofLower_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Topology.WithLower Î±}, â†‘Topology.WithLower.ofLower a = â†‘Topology.WithLower.ofLower b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["List.attach.proof_1",
   "Membership.mem",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype"],
  "name": "List.attach",
  "constType": "{Î± : Type u_1} â†’ (l : List Î±) â†’ List { x // x âˆˆ l }",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "LE.le",
   "sdiff_le_iff'",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Iff",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "sdiff_le_iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "sdiff_le_comm",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] {a b c : Î±}, a \\ b â‰¤ c â†” a \\ c â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_7",
  "constType": "4 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.termÎ©._closed_4", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termÎ©._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_8"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "imp_congr_right",
  "constType": "âˆ€ {a : Sort u_1} {b c : Prop}, (a â†’ (b â†” c)) â†’ (a â†’ b â†” a â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Inf.mk",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instCompleteLatticeFilter.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (x x_1 : Filter Î±) (_s : Set Î±) (motive : _s âˆˆ x âŠ“ x_1 â†’ Prop) (x_2 : _s âˆˆ x âŠ“ x_1),\n  (âˆ€ (_a : Set Î±) (ha : _a âˆˆ x) (_b : Set Î±) (hb : _b âˆˆ x_1) (hs : _s = _a âˆ© _b),\n      motive (_ : âˆƒ a âˆˆ x, âˆƒ b âˆˆ x_1, _s = a âˆ© b)) â†’\n    motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Set.preimage",
   "Continuous.mk",
   "Set",
   "Continuous",
   "Continuous.isOpen_preimage",
   "TopologicalSpace",
   "IsOpen"],
  "name": "continuous_def",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : TopologicalSpace Î±} {x_1 : TopologicalSpace Î²} {f : Î± â†’ Î²},\n  Continuous f â†” âˆ€ (s : Set Î²), IsOpen s â†’ IsOpen (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.rec",
   "Lean.Name.num",
   "String",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.str"],
  "name": "Lean.Name.casesOn",
  "constType":
  "{motive : Lean.Name â†’ Sort u} â†’\n  (t : Lean.Name) â†’\n    motive Lean.Name.anonymous â†’\n      ((pre : Lean.Name) â†’ (str : String) â†’ motive (Lean.Name.str pre str)) â†’\n        ((pre : Lean.Name) â†’ (i : â„•) â†’ motive (Lean.Name.num pre i)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.EvalInformation"],
  "name": "Lean.Data.AC.EvalInformation.evalOp",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ [self : Lean.Data.AC.EvalInformation Î± Î²] â†’ Î± â†’ Î² â†’ Î² â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_4",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.pmap._eq_2",
   "List.instMembershipList",
   "List.mem_cons_of_mem",
   "Eq.refl",
   "List.forall_mem_cons",
   "And.left",
   "Eq",
   "And",
   "Eq.mpr",
   "And.right",
   "Iff.mp",
   "Eq.ndrec",
   "List.rec",
   "List",
   "List.mem_cons_self",
   "List.nil",
   "id"],
  "name": "List.pmap_congr",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {p q : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {g : (a : Î±) â†’ q a â†’ Î²} (l : List Î±)\n  {Hâ‚ : âˆ€ a âˆˆ l, p a} {Hâ‚‚ : âˆ€ a âˆˆ l, q a},\n  (âˆ€ a âˆˆ l, âˆ€ (hâ‚ : p a) (hâ‚‚ : q a), f a hâ‚ = g a hâ‚‚) â†’ List.pmap f l Hâ‚ = List.pmap g l Hâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "DecidableEq", "Finset", "Finset.val", "Multiset.toFinset"],
  "name": "Finset.image",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : DecidableEq Î²] â†’ (Î± â†’ Î²) â†’ Finset Î± â†’ Finset Î²",
  "constCategory": "Definition"},
 {"references": ["eq_false", "False", "Eq"],
  "name": "eq_false'",
  "constType": "âˆ€ {p : Prop}, (p â†’ False) â†’ p = False",
  "constCategory": "Theorem"},
 {"references":
  ["_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8577",
   "PartialOrder.toPreorder",
   "HasCompl",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "CompleteLattice.toBot",
   "iSup",
   "autoParam",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "HasCompl.compl",
   "SDiff.sdiff",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "Sup.sup",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8611"],
  "name": "CompleteAtomicBooleanAlgebra.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toCompletelyDistribLattice : CompletelyDistribLattice Î±] â†’\n    (âˆ€ (x y z : Î±), (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z) â†’\n      [toHasCompl : HasCompl Î±] â†’\n        [toSDiff : SDiff Î±] â†’\n          [toHImp : HImp Î±] â†’\n            (âˆ€ (x : Î±), x âŠ“ xá¶œ â‰¤ âŠ¥) â†’\n              (âˆ€ (x : Î±), âŠ¤ â‰¤ x âŠ” xá¶œ) â†’\n                autoParam (âˆ€ (x y : Î±), x \\ y = x âŠ“ yá¶œ) _autoâœ â†’\n                  autoParam (âˆ€ (x y : Î±), x â‡¨ y = y âŠ” xá¶œ) _autoâœÂ¹ â†’\n                    (âˆ€ (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b) â†’\n                      (âˆ€ (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s) â†’ CompleteAtomicBooleanAlgebra Î±",
  "constCategory": "Other"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_2",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_3",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_4",
   "_obj",
   "Lean.Name.mkStr4",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_1"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm",
   "List.Perm.nil",
   "List",
   "List.Perm.trans",
   "List.Perm.rec",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.symm",
  "constType": "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ lâ‚‚ ~ lâ‚",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.succ_add.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ â„• â†’ Prop) (x x_1 : â„•), (âˆ€ (x : â„•), motive x 0) â†’ (âˆ€ (n m : â„•), motive n (Nat.succ m)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.countP.go",
   "Eq",
   "Eq.ndrec",
   "List",
   "instOfNatNat",
   "_private.Std.Data.List.Count.0.List.countP.go._eq_1",
   "Bool",
   "List.nil",
   "Nat",
   "Eq.symm",
   "_private.Std.Data.List.Count.0.List.findIdx.go.match_1.splitter",
   "id"],
  "name": "_private.Std.Data.List.Count.0.List.countP.go._unfold",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (x : List Î±) (x_1 : â„•),\n  List.countP.go p x x_1 =\n    match x, x_1 with\n    | [], acc => acc\n    | x :: xs, acc => bif p x then List.countP.go p xs (acc + 1) else List.countP.go p xs acc",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.monotone'",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.monotone",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] (f : Î± â†’o Î²), Monotone â†‘f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Macro.Context",
   "Nat",
   "Lean.Name",
   "Lean.Syntax",
   "Lean.MacroScope",
   "_private.Init.Prelude.0.Lean.Macro.MethodsRef"],
  "name": "Lean.Macro.Context.mk",
  "constType":
  "Lean.Macro.MethodsRef â†’ Lean.Name â†’ Lean.MacroScope â†’ â„• â†’ â„• â†’ Lean.Syntax â†’ Lean.Macro.Context",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid.zero_add",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] (a : Î±), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Classical.choose",
   "Classical.indefiniteDescription"],
  "name": "Classical.choose_spec",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} (h : âˆƒ x, p x), p (Classical.choose h)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "iSup_subtype",
   "OrderDual",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "iInf_subtype",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {p : Î¹ â†’ Prop} {f : Subtype p â†’ Î±},\n  iInf f = â¨… i, â¨… (h : p i), f { val := i, property := h }",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Not", "Bool", "Eq"],
  "name": "eq_false_of_ne_true.match_1",
  "constType":
  "âˆ€ (motive : (x : Bool) â†’ Â¬x = true â†’ Prop) (x : Bool) (x_1 : Â¬x = true),\n  (âˆ€ (h : Â¬true = true), motive true h) â†’ (âˆ€ (x : Â¬false = true), motive false x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["funext", "Subsingleton.intro", "Subsingleton", "Subsingleton.elim"],
  "name": "instSubsingletonForAll.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Î± â†’ Sort u_2} [inst : âˆ€ (a : Î±), Subsingleton (Î² a)], Subsingleton ((a : Î±) â†’ Î² a)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "IsIdempotent.mk",
   "SemilatticeSup.toSup",
   "IsIdempotent",
   "Sup.sup",
   "sup_idem"],
  "name": "instIsIdempotentSupToSup.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±], IsIdempotent Î± fun x x_1 â†¦ x âŠ” x_1",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "âˆ€ {p : Prop}, p = True â†’ p",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB.insert",
   "isGLB_sInf",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Insert.insert",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instInsertSet"],
  "name": "sInf_insert",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {a : Î±} {s : Set Î±}, sInf (insert a s) = a âŠ“ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["IsAntisymm",
   "PartialOrder.toPreorder",
   "instIsAntisymmLeToLEToPreorder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "instIsAntisymmLeToLEToPreorder",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±], IsAntisymm Î± fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references": ["Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Nonempty.elim.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (motive : Nonempty Î± â†’ Prop) (hâ‚ : Nonempty Î±), (âˆ€ (a : Î±), motive (_ : Nonempty Î±)) â†’ motive hâ‚",
  "constCategory": "Definition"},
 {"references":
  ["Function.Embedding.toFun", "Function.Injective", "Function.Embedding"],
  "name": "Function.Embedding.inj'",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (self : Î± â†ª Î²), Function.Injective self.toFun",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Chain"],
  "name": "List.Chain.cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a b : Î±} {l : List Î±}, R a b â†’ List.Chain R b l â†’ List.Chain R a (b :: l)",
  "constCategory": "Other"},
 {"references":
  ["OrderIso",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.ofUpperSet_le_iff",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Topology.WithUpperSet.ofUpperSetOrderIso",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithUpperSet Î± â‰ƒo Î±",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{Î± : Sort u} â†’ [self : Inhabited Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "OrderBot.toBot",
   "GeneralizedBooleanAlgebra",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.bot_le",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : GeneralizedBooleanAlgebra Î±] (a : Î±), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "List.brecOn",
   "List.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat"],
  "name": "List.countP.go",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Bool) â†’ List Î± â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Array", "Lean.SyntaxNodeKinds", "Lean.TSyntaxArray", "Lean.Syntax"],
  "name": "Lean.TSyntaxArray.mk",
  "constType":
  "{ks : Lean.SyntaxNodeKinds} â†’ Array Lean.Syntax â†’ Lean.TSyntaxArray ks",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Subtype.val",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "Subtype.eq.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (motive : (x x_1 : { x // p x }) â†’ â†‘x = â†‘x_1 â†’ Prop) (x x_1 : { x // p x })\n  (x_2 : â†‘x = â†‘x_1),\n  (âˆ€ (val : Î±) (property property_1 : p val),\n      motive { val := val, property := property } { val := val, property := property_1 }\n        (_ : â†‘{ val := val, property := (_ : p val) } = â†‘{ val := val, property := (_ : p val) })) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.Subperm.trans.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ lâ‚ƒ : List Î±} (motive : lâ‚ <+~ lâ‚‚ â†’ lâ‚‚ <+~ lâ‚ƒ â†’ Prop) (x : lâ‚ <+~ lâ‚‚) (x_1 : lâ‚‚ <+~ lâ‚ƒ),\n  (âˆ€ (s : lâ‚ <+~ lâ‚‚) (_lâ‚‚' : List Î±) (pâ‚‚ : _lâ‚‚' ~ lâ‚‚) (sâ‚‚ : List.Sublist _lâ‚‚' lâ‚ƒ),\n      motive s (_ : âˆƒ l, âˆƒ (_ : l ~ lâ‚‚), List.Sublist l lâ‚ƒ)) â†’\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Filter.NeBot.ne'",
   "Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "Filter.empty_mem_iff_bot",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "mt",
   "Eq",
   "Iff.mp",
   "Eq.rec",
   "Filter",
   "Not",
   "Set.eq_empty_or_nonempty",
   "Eq.symm",
   "absurd",
   "Or.elim",
   "id",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.nonempty_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} [hf : Filter.NeBot f] {s : Set Î±}, s âˆˆ f â†’ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{Î± : Type u} â†’ [self : HasSubset Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "Iff.rfl", "and_congr"],
  "name": "and_congr_left'",
  "constType": "âˆ€ {a b c : Prop}, (a â†” b) â†’ (a âˆ§ c â†” b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "exists_and_left.match_1",
   "Exists.intro",
   "And.intro",
   "exists_and_left.match_2"],
  "name": "exists_and_left",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, b âˆ§ p x) â†” b âˆ§ âˆƒ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termÏ€_",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Bool.false", "Bool.true", "Unit", "Bool"],
  "name": "not",
  "constType": "Bool â†’ Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u â†’ Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Heyting.Basic._auxLemma.6",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Heyting.Basic._auxLemma.8",
   "LE.le",
   "Preorder.toLE",
   "Mathlib.Order.Heyting.Basic._auxLemma.9",
   "Eq",
   "inf_comm",
   "Lattice.toInf",
   "And",
   "HImp.himp",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "le_refl",
   "GeneralizedHeytingAlgebra.toLattice",
   "congr",
   "Sup.sup",
   "Mathlib.Order.Heyting.Basic._auxLemma.7",
   "GeneralizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "SemilatticeSup.toPartialOrder",
   "id"],
  "name": "GeneralizedHeytingAlgebra.toDistribLattice.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : GeneralizedHeytingAlgebra Î±] (a b c : Î±), a âŠ“ (b âŠ” c) â‰¤ a âŠ“ b âŠ” a âŠ“ c",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "true_implies",
  "constType": "âˆ€ (p : Prop), (True â†’ p) = p",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Add Î±",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "Topology.WithLowerSet",
   "OrderDual",
   "OrderDual.ofDual_toDual",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpperSet.toDualHomeomorph.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Topology.WithLowerSet Î±áµ’áµˆ), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "Prod",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "PartialOrder"],
  "name": "Prod.semilatticeSup.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeSup Î±] [inst_1 : SemilatticeSup Î²] (a b : Î± Ã— Î²),\n  a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "String.decEq", "String"],
  "name": "instDecidableEqString",
  "constType": "DecidableEq String",
  "constCategory": "Definition"},
 {"references": ["WellFounded.rec", "WellFounded", "Acc"],
  "name": "WellFounded.apply.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {r : Î± â†’ Î± â†’ Prop}, WellFounded r â†’ âˆ€ (a : Î±), Acc r a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "False", "propext", "or_false.match_1", "Eq"],
  "name": "or_false",
  "constType": "âˆ€ (p : Prop), (p âˆ¨ False) = p",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_eq_left'", "Eq"],
  "name": "Std.Logic._auxLemma.42",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, a' = a âˆ§ p a) = p a'",
  "constCategory": "Theorem"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} â†’ [self : AddCommSemigroup G] â†’ AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpperSet.toDualHomeomorph._lambda_1",
   "_obj",
   "Equiv.mk",
   "_neutral"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "Pi.instSupForAll",
   "Pi.semilatticeSup.proof_2",
   "Pi.partialOrder",
   "Pi.semilatticeSup.proof_1",
   "SemilatticeSup.mk",
   "Pi.semilatticeSup.proof_3",
   "SemilatticeSup.toPartialOrder"],
  "name": "Pi.semilatticeSup",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î±' : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ SemilatticeSup (Î±' i)] â†’ SemilatticeSup ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 â†’ outParam (Type u_2) â†’ Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["And", "Or", "or_and_right", "propext", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.14",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ¨ b) âˆ§ c) = (a âˆ§ c âˆ¨ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "eq_false",
   "False",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Std.Data.Nat.Lemmas._auxLemma.3",
  "constType": "âˆ€ (n : â„•), (Nat.succ n = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "Sup.sup",
   "instIsCommutativeSupToSup.proof_1",
   "IsCommutative"],
  "name": "instIsCommutativeSupToSup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±], IsCommutative Î± fun x x_1 â†¦ x âŠ” x_1",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4034",
   "HMul.hMul",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3995",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toNonUnitalSemiring : NonUnitalSemiring Î±] â†’\n    [toOne : One Î±] â†’\n      (âˆ€ (a : Î±), 1 * a = a) â†’\n        (âˆ€ (a : Î±), a * 1 = a) â†’\n          [toNatCast : NatCast Î±] â†’\n            autoParam (NatCast.natCast 0 = 0) _autoâœ â†’\n              autoParam (âˆ€ (n : â„•), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _autoâœÂ¹ â†’\n                (npow : â„• â†’ Î± â†’ Î±) â†’\n                  autoParam (âˆ€ (x : Î±), npow 0 x = 1) _autoâœÂ² â†’\n                    autoParam (âˆ€ (n : â„•) (x : Î±), npow (n + 1) x = x * npow n x) _autoâœÂ³ â†’ Semiring Î±",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{Î± : Sort u} â†’ {p : Î± â†’ Prop} â†’ (val : Î±) â†’ p val â†’ Subtype p",
  "constCategory": "Other"},
 {"references": ["Exists", "Or", "propext", "exists_or", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.25",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆƒ x, p x âˆ¨ q x) = ((âˆƒ x, p x) âˆ¨ âˆƒ x, q x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {Î³ : Sort u_3} â†’\n      {r : Î± â†’ Î² â†’ Sort u} â†’\n        {s : Î² â†’ Î³ â†’ Sort v} â†’\n          {t : outParam (Î± â†’ Î³ â†’ Sort w)} â†’ ({a : Î±} â†’ {b : Î²} â†’ {c : Î³} â†’ r a b â†’ s b c â†’ t a c) â†’ Trans r s t",
  "constCategory": "Other"},
 {"references": ["eq_self", "And", "of_eq_true", "Not", "Eq"],
  "name": "Prop.booleanAlgebra.proof_3",
  "constType": "âˆ€ (x_1 y_1 : Prop), (x_1 âˆ§ Â¬y_1) = (x_1 âˆ§ Â¬y_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.le_inf",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.completeLattice.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : CompleteLattice Î±] (a b c : Î±áµ’áµˆ), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "Or.elim.match_1",
  "constType":
  "âˆ€ {a b : Prop} (motive : a âˆ¨ b â†’ Prop) (h : a âˆ¨ b),\n  (âˆ€ (h : a), motive (_ : a âˆ¨ b)) â†’ (âˆ€ (h : b), motive (_ : a âˆ¨ b)) â†’ motive h",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "propext", "exists_const", "Nonempty", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.26",
  "constType": "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆƒ x, b) = b",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.50",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.iUnion",
   "isUpperSet_sUnion",
   "Set",
   "LE",
   "Set.forall_range_iff",
   "IsUpperSet",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "isUpperSet_iUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : LE Î±] {f : Î¹ â†’ Set Î±}, (âˆ€ (i : Î¹), IsUpperSet (f i)) â†’ IsUpperSet (â‹ƒ i, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "LE",
   "IsUpperSet",
   "Set.univ",
   "LE.le",
   "Set.instMembershipSet",
   "id"],
  "name": "isUpperSet_univ",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±], IsUpperSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "Set.preimage",
   "Set",
   "Monotone",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "IsLowerSet.preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] {s : Set Î±},\n  IsLowerSet s â†’ âˆ€ {f : Î² â†’ Î±}, Monotone f â†’ IsLowerSet (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadState", "PUnit", "Prod"],
  "name": "MonadState.mk",
  "constType":
  "{Ïƒ : outParam (Type u)} â†’\n  {m : Type u â†’ Type v} â†’ m Ïƒ â†’ (Ïƒ â†’ m PUnit.{u + 1}) â†’ ({Î± : Type u} â†’ (Ïƒ â†’ Î± Ã— Ïƒ) â†’ m Î±) â†’ MonadState Ïƒ m",
  "constCategory": "Other"},
 {"references": ["False", "Decidable", "if_neg", "ite", "Eq", "id"],
  "name": "if_false",
  "constType":
  "âˆ€ {Î± : Sort u_1} {h : Decidable False} (t e : Î±), (if False then t else e) = e",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "or_assoc",
   "Eq.symm",
   "or_comm",
   "Eq",
   "id"],
  "name": "or_left_comm",
  "constType": "âˆ€ {a b c : Prop}, a âˆ¨ b âˆ¨ c â†” b âˆ¨ a âˆ¨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termÎ©._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.liftOnâ‚‚",
   "DecidableEq",
   "List",
   "Multiset.ndunion.proof_1",
   "List.isSetoid",
   "Multiset",
   "Multiset.ofList",
   "List.union"],
  "name": "Multiset.ndunion",
  "constType":
  "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ Multiset Î± â†’ Multiset Î± â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "Eq",
   "GaloisConnection.l_le",
   "PartialOrder",
   "Inf.mk",
   "Eq.mpr",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "le_inf",
   "PartialOrder.le_antisymm",
   "congrArg",
   "SemilatticeInf",
   "congrFun",
   "id"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeInf Î±]\n  (gi : GaloisInsertion l u) (a b : Î²), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsLeftCancelAdd.add_left_cancel",
   "Add",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "add_left_cancel",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] {a b c : G}, a + b = a + c â†’ b = c",
  "constCategory": "Theorem"},
 {"references": ["Monad", "Applicative", "Bind"],
  "name": "Monad.mk",
  "constType":
  "{m : Type u â†’ Type v} â†’ [toApplicative : Applicative m] â†’ [toBind : Bind m] â†’ Monad m",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.instPureFilter",
   "propext",
   "Set",
   "Filter.mem_pure",
   "Filter",
   "Pure.pure",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.130",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {s : Set Î±}, (s âˆˆ pure a) = (a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{Î± : Type u} â†’ [inst : LE Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "List.Perm.length_eq",
   "OfNat.ofNat",
   "Quotient.inductionOnâ‚‚",
   "List.length_append",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "rfl",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Zero.toOfNat0",
   "Quot.liftOn",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat"],
  "name": "Multiset.card.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (s t : Multiset Î±),\n  ZeroHom.toFun\n      {\n        toFun := fun s â†¦\n          Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚),\n        map_zero' :=\n          (_ :\n            (fun s â†¦\n                  Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚))\n                0 =\n              (fun s â†¦\n                  Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚))\n                0) }\n      (s + t) =\n    ZeroHom.toFun\n        {\n          toFun := fun s â†¦\n            Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚),\n          map_zero' :=\n            (_ :\n              (fun s â†¦\n                    Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚))\n                  0 =\n                (fun s â†¦\n                    Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚))\n                  0) }\n        s +\n      ZeroHom.toFun\n        {\n          toFun := fun s â†¦\n            Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚),\n          map_zero' :=\n            (_ :\n              (fun s â†¦\n                    Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚))\n                  0 =\n                (fun s â†¦\n                    Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚))\n                  0) }\n        t",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set.Elem",
   "Bool.true",
   "Set",
   "Exists.intro",
   "Bool",
   "Exists.casesOn",
   "Eq"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set Î±) (f : â†‘s â†’ Bool) (motive : (âˆƒ i, f i = true) â†’ Prop) (x : âˆƒ i, f i = true),\n  (âˆ€ (i : â†‘s) (h : f i = true), motive (_ : âˆƒ i, f i = true)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ SemilatticeInf (Î±' i)] (x x_1 : (i : Î¹) â†’ Î±' i) (x_2 : Î¹),\n  x x_2 âŠ“ x_1 x_2 â‰¤ x x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Or",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Mathlib.Data.Set.Image._auxLemma.8",
   "Mathlib.Data.Set.Image._auxLemma.11",
   "Insert.insert",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.32",
   "Mathlib.Data.Set.Image._auxLemma.9",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.42",
   "Mathlib.Data.Set.Image._auxLemma.4",
   "congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Set.instInsertSet"],
  "name": "Set.image_insert_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {a : Î±} {s : Set Î±}, f '' insert a s = insert (f a) (f '' s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTrans",
  "constType": "(Î± : Type u) â†’ (Î± â†’ Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteBooleanAlgebra.toInfSet",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteBooleanAlgebra.iInf_sup_le_sup_sInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["le_bot_iff",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "DistribLattice",
   "Iff",
   "bot_sup_eq",
   "propext",
   "OrderBot.toBot",
   "Sup.sup",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder.toOrderBot",
   "id",
   "BoundedOrder"],
  "name": "IsCompl.inf_left_eq_bot_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y z : Î±}, IsCompl y z â†’ (x âŠ“ y = âŠ¥ â†” x â‰¤ z)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Lattice.toSemilatticeSup",
   "sup_eq_right",
   "Set.instUnionSet",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.union_eq_right",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, s âˆª t = t â†” s âŠ† t",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.WithUpperSet.instPreorderWithUpperSet._rarg", "_neutral"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Filter.filter_eq",
   "funext",
   "Set",
   "Filter.map",
   "Function.comp",
   "Filter",
   "rfl",
   "Eq"],
  "name": "Filter.map_compose",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {m : Î± â†’ Î²} {m' : Î² â†’ Î³}, Filter.map m' âˆ˜ Filter.map m = Filter.map (m' âˆ˜ m)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Topology.WithLowerSet Î± â†’ Sort u_4} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithLowerSet.toLowerSet a)) â†’ (a : Topology.WithLowerSet Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "Function.Involutive.leftInverse",
   "Function.LeftInverse.injective",
   "Function.Involutive"],
  "name": "Function.Involutive.injective",
  "constType":
  "âˆ€ {Î± : Sort u} {f : Î± â†’ Î±}, Function.Involutive f â†’ Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} â†’ [toSemiring : Semiring R] â†’ (âˆ€ (a b : R), a * b = b * a) â†’ CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.univ",
   "Eq",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)}, TopologicalSpace.IsTopologicalBasis s â†’ â‹ƒâ‚€ s = Set.univ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Eq.refl",
   "IsOpen.inter",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "isOpen_univ",
   "Iff.mpr",
   "Set.sUnion_eq_univ_iff",
   "Preorder.toLE",
   "Eq",
   "trivial",
   "Filter.principal",
   "TopologicalSpace.nhds_generateFrom",
   "Eq.mpr",
   "TopologicalSpace.IsTopologicalBasis.mk",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "le_generateFrom",
   "Filter",
   "And.casesOn",
   "IsOpen",
   "TopologicalSpace.IsTopologicalBasis",
   "instMembershipSetFilter",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "nhds",
   "HasSubset.Subset",
   "Set.univ",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Set.instMembershipSet",
   "LE.le.antisymm",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Filter.le_principal_iff",
   "iInf",
   "isOpen_iff_nhds",
   "Filter.instPartialOrderFilter",
   "Set.sUnion",
   "And.intro",
   "iInfâ‚‚_le_of_le",
   "Set.instInterSet"],
  "name": "TopologicalSpace.isTopologicalBasis_of_open_of_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  (âˆ€ u âˆˆ s, IsOpen u) â†’\n    (âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v âˆˆ s, a âˆˆ v âˆ§ v âŠ† u) â†’ TopologicalSpace.IsTopologicalBasis s",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "Setoid.r",
   "List",
   "List.Nodup.map_on",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.Nodup.map_on",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Multiset Î±} {f : Î± â†’ Î²},\n  (âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y â†’ x = y) â†’ Multiset.Nodup s â†’ Multiset.Nodup (Multiset.map f s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring â„•",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ LinearOrderedSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.forall_mem_cons",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.101",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {a : Î±} {l : List Î±}, (âˆ€ x âˆˆ a :: l, p x) = (p a âˆ§ âˆ€ x âˆˆ l, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "inferInstance",
   "Set.Elem",
   "Fintype.ofFinite",
   "Classical.propDecidable",
   "PLift",
   "Finite",
   "Set.fintypeRange",
   "instFinitePLift",
   "Finite.of_fintype",
   "Eq"],
  "name": "Finite.Set.finite_range.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} (f : Î¹ â†’ Î±) [inst : Finite Î¹], Finite â†‘(Set.range f)",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Eq.refl", "Bool", "Eq"],
  "name": "Nat.decEq.match_1",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ (x = true â†’ motive true) â†’ (x = false â†’ motive false) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.mk",
   "Membership.mem",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Set",
   "Function.comp",
   "Topology.WithUpperSet.map._elambda_1",
   "OrderHom",
   "FunLike.coe",
   "IsUpperSet",
   "ContinuousMap",
   "Preorder",
   "Set.univ",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "Equiv.instFunLikeEquiv",
   "ContinuousMap.mk",
   "Set.instMembershipSet",
   "lcProof",
   "Continuous",
   "TopologicalSpace",
   "Set.sUnion",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithUpperSet.map._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â†’ C(Topology.WithUpperSet Î±, Topology.WithUpperSet Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Function.Injective",
   "Function.Embedding.casesOn",
   "Function.Embedding.toFun",
   "Function.Embedding.mk",
   "Eq.rec",
   "Eq.refl",
   "Function.Embedding",
   "Eq.symm",
   "Eq"],
  "name": "Function.instEmbeddingLikeEmbedding.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} (f g : Î± â†ª Î²), f.toFun = g.toFun â†’ f = g",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._lambda_1._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Lean.Data.AC.EvalInformation",
   "Unit",
   "PUnit",
   "Lean.Data.AC.EvalInformation.evalVar",
   "List.nil",
   "Lean.Data.AC.EvalInformation.arbitrary",
   "Nat",
   "Lean.Data.AC.evalList.match_1",
   "Lean.Data.AC.EvalInformation.evalOp"],
  "name": "Lean.Data.AC.evalList",
  "constType":
  "{Î± : Sort u_1} â†’ (Î² : Sort u) â†’ [inst : Lean.Data.AC.EvalInformation Î± Î²] â†’ Î± â†’ List â„• â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "IsLowerSet",
   "Set",
   "Eq.refl",
   "Topology.IsLower.isLowerSet_of_isOpen",
   "Preorder",
   "Topology.IsLowerSet",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Topology.IsLower",
   "propext",
   "Topology.IsLowerSet.isOpen_iff_isLowerSet",
   "TopologicalSpace",
   "IsOpen",
   "id"],
  "name": "Topology.IsLowerSet.lowerSet_le_lower",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {tâ‚ tâ‚‚ : TopologicalSpace Î±} [inst_1 : Topology.IsLowerSet Î±]\n  [inst : Topology.IsLower Î±], tâ‚ â‰¤ tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Eq",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.ofUpper_toUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±), â†‘Topology.WithUpper.ofUpper (â†‘Topology.WithUpper.toUpper a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Iff",
   "Continuous",
   "TopologicalSpace",
   "LE.le",
   "Preorder.toLE",
   "TopologicalSpace.coinduced",
   "continuous_def"],
  "name": "continuous_iff_coinduced_le",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ : TopologicalSpace Î²},\n  Continuous f â†” TopologicalSpace.coinduced f tâ‚ â‰¤ tâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Not", "Or.casesOn"],
  "name": "Classical.propDecidable.match_1",
  "constType":
  "âˆ€ (a : Prop) (motive : a âˆ¨ Â¬a â†’ Prop) (x : a âˆ¨ Â¬a),\n  (âˆ€ (h : a), motive (_ : a âˆ¨ Â¬a)) â†’ (âˆ€ (h : Â¬a), motive (_ : a âˆ¨ Â¬a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["OrderTop.toTop", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.le_top",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [self : OrderTop Î±] (a : Î±), a â‰¤ âŠ¤",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.mk",
  "constType": "{Î± : Type u} â†’ Î± â†’ EmptyCollection Î±",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Lean.Name.rec",
   "Lean.Name.below",
   "Lean.Name.num",
   "String",
   "PUnit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "PProd.mk",
   "Lean.Name.str"],
  "name": "Lean.Name.brecOn",
  "constType":
  "{motive : Lean.Name â†’ Sort u} â†’ (t : Lean.Name) â†’ ((t : Lean.Name) â†’ Lean.Name.below t â†’ motive t) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "List.cons",
   "List.chain_cons",
   "propext",
   "List",
   "List.Chain",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.5",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a b : Î±} {l : List Î±}, List.Chain R a (b :: l) = (R a b âˆ§ List.Chain R b l)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "congr_arg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset.instAddMultiset",
   "Eq",
   "Zero.toOfNat0",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Multiset",
   "Zero.mk",
   "List.nil",
   "List.append_assoc",
   "Quotient.inductionOnâ‚ƒ",
   "Quotient.inductionOn",
   "List.append_nil",
   "Add.mk",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3",
  "constType": "âˆ€ {Î± : Type u_1} (s : Multiset Î±), s + 0 = s",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.orderTop.proof_1",
   "OrderTop.mk",
   "OrderTop.toTop",
   "Top",
   "Top.top",
   "inferInstanceAs",
   "OrderTop",
   "LE",
   "Pi.instTopForAll",
   "Pi.hasLe",
   "Top.mk"],
  "name": "Pi.orderTop",
  "constType":
  "{Î¹ : Type u_3} â†’\n  {Î±' : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ LE (Î±' i)] â†’ [inst_1 : (i : Î¹) â†’ OrderTop (Î±' i)] â†’ OrderTop ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "Multiset.induction",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "Multiset.instZeroMultiset",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "Multiset.Nodup",
   "Multiset.instMembershipMultiset",
   "Finset.eq_of_veq",
   "Eq",
   "Zero.toOfNat0",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff.mp",
   "Finset.cons_induction.match_1",
   "Finset.cons_val",
   "Finset",
   "Multiset",
   "Finset.val",
   "Finset.cons",
   "Multiset.cons",
   "Multiset.nodup_cons",
   "Not",
   "And.intro",
   "Finset.mk",
   "Eq.symm",
   "And.casesOn",
   "id"],
  "name": "Finset.cons_induction",
  "constType":
  "âˆ€ {Î± : Type u_4} {p : Finset Î± â†’ Prop},\n  p âˆ… â†’ (âˆ€ â¦ƒa : Î±â¦„ {s : Finset Î±} (h : Â¬a âˆˆ s), p s â†’ p (Finset.cons a s h)) â†’ âˆ€ (s : Finset Î±), p s",
  "constCategory": "Theorem"},
 {"references": ["Decidable.byCases.match_1", "Decidable", "Not"],
  "name": "Decidable.byCases",
  "constType":
  "{p : Prop} â†’ {q : Sort u} â†’ [dec : Decidable p] â†’ (p â†’ q) â†’ (Â¬p â†’ q) â†’ q",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "GaloisConnection.u_inf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "gc_nhds",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "nhds",
   "Inf.inf",
   "Filter.instInfFilter",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "nhdsAdjoint",
   "Filter",
   "Eq",
   "Filter.instCompleteLatticeFilter"],
  "name": "nhds_inf",
  "constType":
  "âˆ€ {Î± : Type u} {tâ‚ tâ‚‚ : TopologicalSpace Î±} {a : Î±}, nhds a = nhds a âŠ“ nhds a",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "List.nil", "Bool", "Nat", "List.countP.go", "Eq"],
  "name": "_private.Std.Data.List.Count.0.List.countP.go._eq_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (x : â„•), List.countP.go p [] x = x",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "OrderTop",
   "GeneralizedHeytingAlgebra.le_top",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "GeneralizedHeytingAlgebra.toOrderTop",
  "constType":
  "{Î± : Type u_2} â†’ [inst : GeneralizedHeytingAlgebra Î±] â†’ OrderTop Î±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "âˆ€ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring Î±] â†’\n    (âˆ€ (a b c : Î±), a * b * c = a * (b * c)) â†’ NonUnitalSemiring Î±",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_zero",
  "constType":
  "âˆ€ {M : Type u} [self : AddMonoid M] (x : M), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "And",
   "Iff",
   "SemilatticeSup.toSup",
   "Iff.rfl",
   "Set",
   "Sup.sup",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_sup",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, s âˆˆ f âŠ” g â†” s âˆˆ f âˆ§ s âˆˆ g",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.toUpperSet_ofUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Topology.WithUpperSet Î±),\n  â†‘Topology.WithUpperSet.toUpperSet (â†‘Topology.WithUpperSet.ofUpperSet a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EmbeddingLike.toFunLike",
   "FunLike",
   "EquivLike.toEmbeddingLike",
   "Equiv.instEquivLikeEquiv"],
  "name": "Equiv.instFunLikeEquiv",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ FunLike (Î± â‰ƒ Î²) Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.le_total",
  "constType": "âˆ€ (m n : â„•), m â‰¤ n âˆ¨ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "Iff",
   "Iff.rfl",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "mem_upperBounds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, a âˆˆ upperBounds s â†” âˆ€ x âˆˆ s, x â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MonadLiftT",
  "constType":
  "(Type u â†’ Type v) â†’ (Type u â†’ Type w) â†’ Type (max (max (u + 1) v) w)",
  "constCategory": "Other"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc.mk", "Quot.ind", "Trunc"],
  "name": "Trunc.ind",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Trunc Î± â†’ Prop}, (âˆ€ (a : Î±), Î² (Trunc.mk a)) â†’ âˆ€ (q : Trunc Î±), Î² q",
  "constCategory": "Theorem"},
 {"references": ["SProd", "SProd.mk", "Filter.prod", "Prod", "Filter"],
  "name": "Filter.instSProd",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ SProd (Filter Î±) (Filter Î²) (Filter (Î± Ã— Î²))",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper.instPreorderWithUpper._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpper.instPreorderWithUpper._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["AddCancelCommMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelCommMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} â†’ [self : AddCancelCommMonoid M] â†’ AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Finset.card", "Finset.univ", "Fintype", "Nat"],
  "name": "Fintype.card",
  "constType": "(Î± : Type u_4) â†’ [inst : Fintype Î±] â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["Decidable.decide", "BEq", "DecidableEq", "BEq.mk", "Eq"],
  "name": "instBEq",
  "constType": "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ BEq Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.sort.loop",
   "Lean.Data.AC.Context.evalList_sort_congr",
   "List.casesOn",
   "Eq.refl",
   "True",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "List.rec",
   "Lean.Data.AC.Context",
   "Init.Data.AC._auxLemma.1",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "eq_self",
   "List.cons",
   "False",
   "Lean.Data.AC.insert",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.evalList_insert",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Lean.IsCommutative",
   "Lean.Data.AC.EvalInformation.evalVar",
   "congr",
   "Not",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort_loop_swap",
  "constType":
  "âˆ€ {Î± : Sort u_1} {y : â„•} (ctx : Lean.Data.AC.Context Î±),\n  Lean.IsCommutative ctx.op â†’\n    âˆ€ (xs ys : List â„•),\n      Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.sort.loop xs (y :: ys)) =\n        Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.sort.loop (y :: xs) ys)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And", "iff_false_intro", "False", "Iff", "Not", "and_not_self"],
  "name": "and_not_self_iff",
  "constType": "âˆ€ (a : Prop), a âˆ§ Â¬a â†” False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "em",
   "Union.union",
   "Set",
   "HasCompl.compl",
   "Set.eq_univ_iff_forall",
   "BooleanAlgebra.toHasCompl",
   "Set.univ",
   "Set.instUnionSet",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.union_compl_self",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±), s âˆª sá¶œ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Iff",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "IsCompl.disjoint_left_iff",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "IsCompl.symm",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "IsCompl.disjoint_right_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y z : Î±}, IsCompl y z â†’ (Disjoint x z â†” x â‰¤ y)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.casesOn",
   "Eq.ndrec",
   "Topology.upper",
   "Topology.IsUpper.noConfusionType",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.noConfusion",
  "constType":
  "{Î± : Type u_1} â†’\n  {t : TopologicalSpace Î±} â†’\n    {inst : Preorder Î±} â†’\n      {P : Sort u} â†’ {v1 v2 : Topology.IsUpper Î±} â†’ v1 = v2 â†’ Topology.IsUpper.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "OfNat.ofNat",
   "Nat.zero",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "LE.le",
   "instLTNat"],
  "name": "Nat.modCore_eq_mod.match_1",
  "constType":
  "âˆ€ (y : â„•) (motive : 0 < y âˆ§ y â‰¤ Nat.zero â†’ Prop) (x : 0 < y âˆ§ y â‰¤ Nat.zero),\n  (âˆ€ (hlt : 0 < y) (hle : y â‰¤ Nat.zero), motive (_ : 0 < y âˆ§ y â‰¤ Nat.zero)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["Lean.Name._impl", "String", "UInt64", "Lean.Name"],
  "name": "Lean.Name.str._impl",
  "constType": "UInt64 â†’ Lean.Name â†’ String â†’ Lean.Name._impl",
  "constCategory": "Other"},
 {"references": ["Or", "propext", "or_left_comm", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.3",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ¨ b âˆ¨ c) = (b âˆ¨ a âˆ¨ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "âˆ€ {Î± : Type u_2} [self : LinearOrderedCommSemiring Î±] (a b : Î±), min a b = if a â‰¤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeSup.le_sup_right",
   "OrderDual",
   "Sup.sup",
   "OrderDual.semilatticeSup",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_2",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Lattice Î±] (a b : Î±áµ’áµˆ), b â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.forall_mem_cons",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.14",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {a : Î±} {l : List Î±}, (âˆ€ x âˆˆ a :: l, p x) = (p a âˆ§ âˆ€ x âˆˆ l, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8577",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl",
   "Top.top",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "autoParam",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Top",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Sup.sup",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8611",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "HImp",
   "SemilatticeSup.toPartialOrder"],
  "name": "BooleanAlgebra.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toDistribLattice : DistribLattice Î±] â†’\n    [toHasCompl : HasCompl Î±] â†’\n      [toSDiff : SDiff Î±] â†’\n        [toHImp : HImp Î±] â†’\n          [toTop : Top Î±] â†’\n            [toBot : Bot Î±] â†’\n              (âˆ€ (x : Î±), x âŠ“ xá¶œ â‰¤ âŠ¥) â†’\n                (âˆ€ (x : Î±), âŠ¤ â‰¤ x âŠ” xá¶œ) â†’\n                  (âˆ€ (a : Î±), a â‰¤ âŠ¤) â†’\n                    (âˆ€ (a : Î±), âŠ¥ â‰¤ a) â†’\n                      autoParam (âˆ€ (x y : Î±), x \\ y = x âŠ“ yá¶œ) _autoâœ â†’\n                        autoParam (âˆ€ (x y : Î±), x â‡¨ y = y âŠ” xá¶œ) _autoâœÂ¹ â†’ BooleanAlgebra Î±",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.isOpen_univ", "TopologicalSpace", "Set.univ", "IsOpen"],
  "name": "isOpen_univ",
  "constType": "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], IsOpen Set.univ",
  "constCategory": "Theorem"},
 {"references": ["UInt32.mk", "UInt32", "UInt32.casesOn", "UInt32.size", "Fin"],
  "name": "UInt32.decEq.match_1",
  "constType":
  "(motive : UInt32 â†’ UInt32 â†’ Sort u_1) â†’\n  (a b : UInt32) â†’ ((n m : Fin UInt32.size) â†’ motive { val := n } { val := m }) â†’ motive a b",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Eq.mpr", "propext", "Eq.mp", "Eq"],
  "name": "implies_dep_congr_ctx",
  "constType":
  "âˆ€ {pâ‚ pâ‚‚ qâ‚ : Prop}, pâ‚ = pâ‚‚ â†’ âˆ€ {qâ‚‚ : pâ‚‚ â†’ Prop}, (âˆ€ (h : pâ‚‚), qâ‚ = qâ‚‚ h) â†’ (pâ‚ â†’ qâ‚) = âˆ€ (h : pâ‚‚), qâ‚‚ h",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "GaloisConnection",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "GaloisConnection.dual",
   "GaloisCoinsertion",
   "Function.comp",
   "OrderDual",
   "GaloisCoinsertion.gc",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisCoinsertion.dual.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisCoinsertion l u â†’\n    GaloisConnection (â†‘OrderDual.toDual âˆ˜ u âˆ˜ â†‘OrderDual.ofDual) (â†‘OrderDual.toDual âˆ˜ l âˆ˜ â†‘OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.bot_le",
   "Function.comp",
   "CompleteLattice.toBot",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_7",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²]\n  (gi : GaloisCoinsertion l u) (x : Î±áµ’áµˆáµ’áµˆ), âŠ¥ â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "Set.iUnion",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "InfSet",
   "UpperSet.instInfSetUpperSet.proof_1",
   "LE",
   "UpperSet.mk",
   "UpperSet",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "UpperSet.instInfSetUpperSet",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ InfSet (UpperSet Î±)",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String.mk", "String"],
  "name": "String.rec",
  "constType":
  "{motive : String â†’ Sort u} â†’ ((data : List Char) â†’ motive { data := data }) â†’ (t : String) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["Setoid.r", "Setoid", "HasEquiv", "HasEquiv.mk"],
  "name": "instHasEquiv",
  "constType": "{Î± : Sort u} â†’ [inst : Setoid Î±] â†’ HasEquiv Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Option.some.injEq",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "List.Mem.tail",
   "dite",
   "Eq",
   "PProd",
   "List.find?",
   "Bool.of_not_eq_true",
   "PProd.fst",
   "List.rec",
   "Bool.false",
   "List",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "Eq.mp",
   "List.find?_some.match_1",
   "List.Mem.head",
   "Not",
   "Option.some",
   "List.erase.match_1",
   "Bool",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option",
   "instDecidableEqBool"],
  "name": "List.mem_of_find?_eq_some",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {a : Î±} {l : List Î±}, List.find? p l = some a â†’ a âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.toUpper._cstage1",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithUpper Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "List.Nodup.getEquivOfForallMemList.proof_2",
   "Membership.mem",
   "List.Nodup",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Equiv.mk",
   "instBEq",
   "List.indexOf",
   "List.get",
   "List.length",
   "List.Nodup.getEquivOfForallMemList.proof_3",
   "List.Nodup.getEquivOfForallMemList.proof_1",
   "Fin.mk",
   "Fin"],
  "name": "List.Nodup.getEquivOfForallMemList",
  "constType":
  "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ (l : List Î±) â†’ List.Nodup l â†’ (âˆ€ (x : Î±), x âˆˆ l) â†’ Fin (List.length l) â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.pairwise_pmap",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "List.Pairwise.imp_of_mem",
   "Iff.mpr"],
  "name": "List.Pairwise.pmap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {R : Î± â†’ Î± â†’ Prop} {l : List Î±},\n  List.Pairwise R l â†’\n    âˆ€ {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} (h : âˆ€ x âˆˆ l, p x) {S : Î² â†’ Î² â†’ Prop},\n      (âˆ€ â¦ƒx : Î±â¦„ (hx : p x) â¦ƒy : Î±â¦„ (hy : p y), R x y â†’ S (f x hx) (f y hy)) â†’ List.Pairwise S (List.pmap f l h)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.cons",
   "Exists.intro",
   "List.length",
   "Exists.casesOn",
   "instLTFin",
   "Eq",
   "List.Pairwise",
   "And",
   "List",
   "LT.lt",
   "List.nil",
   "List.map",
   "And.intro",
   "List.get",
   "And.casesOn",
   "Fin"],
  "name": "List.pairwise_iff_get.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {a b : Î±}\n  (motive : (âˆƒ is, [a, b] = List.map (List.get l) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is) â†’ Prop)\n  (x : âˆƒ is, [a, b] = List.map (List.get l) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is),\n  (âˆ€ (is : List (Fin (List.length l))) (h' : [a, b] = List.map (List.get l) is)\n      (hij : List.Pairwise (fun x x_1 â†¦ x < x_1) is),\n      motive (_ : âˆƒ is, [a, b] = List.map (List.get l) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse", "Function.Involutive"],
  "name": "Function.Involutive.leftInverse",
  "constType":
  "âˆ€ {Î± : Sort u} {f : Î± â†’ Î±}, Function.Involutive f â†’ Function.LeftInverse f f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Variable",
   "Lean.Data.AC.Variable.value",
   "Lean.IsNeutral",
   "Option"],
  "name": "Lean.Data.AC.Variable.neutral",
  "constType":
  "{Î± : Sort u} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ (self : Lean.Data.AC.Variable op) â†’ Option (Lean.IsNeutral op self.value)",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "Equiv",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Function.comp",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "GaloisConnection.dual",
   "GaloisConnection.l_sup",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "SemilatticeInf"],
  "name": "GaloisConnection.u_inf",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {bâ‚ bâ‚‚ : Î²} [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ u (bâ‚ âŠ“ bâ‚‚) = u bâ‚ âŠ“ u bâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.symm",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ (b â†” a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Set.Iic",
   "Preorder",
   "IsGLB.lowerBounds_eq",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "lowerBounds",
   "id"],
  "name": "le_isGLB_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a b : Î±}, IsGLB s a â†’ (b â‰¤ a â†” b âˆˆ lowerBounds s)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "Prod",
   "Lattice",
   "Prod.semilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Prod.lattice.proof_6",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Lattice Î±] [inst_1 : Lattice Î²] (a b c : Î± Ã— Î²), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "setOf",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.Subset.antisymm",
   "IsOpen"],
  "name": "TopologicalSpace.gciGenerateFrom.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1), âˆ€ g â‰¤ â†‘OrderDual.toDual {s | IsOpen s}, {u | TopologicalSpace.GenerateOpen g u} = g",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{Î± : Sort u} â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "Iff", "False", "Not", "exists_imp"],
  "name": "not_exists",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆƒ x, p x) â†” âˆ€ (x : Î±), Â¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "Iff",
   "isGLB_sInf",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "le_isGLB_iff",
   "Set.instMembershipSet"],
  "name": "le_sInf_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {s : Set Î±} {a : Î±}, a â‰¤ sInf s â†” âˆ€ b âˆˆ s, a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "Iff.rfl",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.toUpperSet_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±},\n  â†‘Topology.WithUpperSet.toUpperSet a â‰¤ â†‘Topology.WithUpperSet.toUpperSet b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.IsOpen", "Set", "TopologicalSpace"],
  "name": "IsOpen",
  "constType": "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "Iff.rfl", "LT.lt", "Not", "LT.mk", "Preorder"],
  "name": "Pi.preorder.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Preorder (Î± i)] (a b : (i : Î¹) â†’ Î± i), a < b â†” a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "HMod.hMod",
   "instOfNatNat",
   "Nat.mod_lt",
   "Nat.zero_lt_succ",
   "Nat",
   "instLTNat"],
  "name": "Fin.ofNat.proof_1",
  "constType": "âˆ€ {n : â„•} (a : â„•), a % (n + 1) < n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«termð“[_]_Â»._closed_1",
   "Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Â«termð“[_]_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "isUpperSet_sUnion",
   "Set",
   "Set.sUnion",
   "IsUpperSet",
   "Preorder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Topology.upperSet.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] (x : Set (Set Î±)), (âˆ€ s âˆˆ x, IsUpperSet s) â†’ IsUpperSet (â‹ƒâ‚€ x)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn", "Eq"],
  "name": "Function.Surjective.forall.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} (y : Î²) (motive : (âˆƒ a, f a = y) â†’ Prop) (x : âˆƒ a, f a = y),\n  (âˆ€ (x : Î±) (hx : f x = y), motive (_ : âˆƒ a, f a = y)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sSup_le",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteLattice Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a",
  "constCategory": "Definition"},
 {"references": ["propext", "Subtype.forall", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.Subtype._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop},\n  (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ [self : Pow Î± Î²] â†’ Î± â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_4",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "OrderDual.orderTop",
   "Top.top",
   "OrderTop.le_top",
   "OrderTop",
   "inferInstanceAs",
   "OrderDual",
   "LE",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "OrderDual.boundedOrder.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : LE Î±] [inst_1 : BoundedOrder Î±] (a : Î±áµ’áµˆ), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat", "List", "List.findIdx.go", "instOfNatNat", "Bool", "Nat"],
  "name": "List.findIdx",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Bool) â†’ List Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "List.eq_replicate_of_mem",
   "List.length_replicate",
   "List.length",
   "Eq",
   "Iff.intro",
   "And",
   "Iff",
   "List",
   "Eq.rec",
   "List.replicate",
   "List.eq_of_mem_replicate",
   "List.eq_replicate.match_1",
   "And.intro",
   "Nat",
   "Eq.symm"],
  "name": "List.eq_replicate",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {n : â„•} {l : List Î±}, l = List.replicate n a â†” List.length l = n âˆ§ âˆ€ b âˆˆ l, b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteLattice Î±] (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "MonadState",
  "constType": "outParam (Type u) â†’ (Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Array.mkArray0",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node6",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context",
   "ReaderT",
   "Lean.Macro.State",
   "Lean.Macro.Exception"],
  "name": "Lean.MacroM",
  "constType": "Type â†’ Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Data.AC.Expr",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.GenerateOpen.rec",
   "TopologicalSpace.GenerateOpen.basic",
   "TopologicalSpace.GenerateOpen.univ",
   "TopologicalSpace.GenerateOpen.inter",
   "Set",
   "TopologicalSpace.GenerateOpen.sUnion",
   "Set.sUnion",
   "Inter.inter",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.recOn",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {motive : (a : Set Î±) â†’ TopologicalSpace.GenerateOpen g a â†’ Prop} {a : Set Î±}\n  (t : TopologicalSpace.GenerateOpen g a),\n  (âˆ€ (s : Set Î±) (a : s âˆˆ g), motive s (_ : TopologicalSpace.GenerateOpen g s)) â†’\n    motive Set.univ (_ : TopologicalSpace.GenerateOpen g Set.univ) â†’\n      (âˆ€ (s t : Set Î±) (a : TopologicalSpace.GenerateOpen g s) (a_1 : TopologicalSpace.GenerateOpen g t),\n          motive s a â†’ motive t a_1 â†’ motive (s âˆ© t) (_ : TopologicalSpace.GenerateOpen g (s âˆ© t))) â†’\n        (âˆ€ (S : Set (Set Î±)) (a : âˆ€ s âˆˆ S, TopologicalSpace.GenerateOpen g s),\n            (âˆ€ (s : Set Î±) (a_1 : s âˆˆ S), motive s (_ : TopologicalSpace.GenerateOpen g s)) â†’\n              motive (â‹ƒâ‚€ S) (_ : TopologicalSpace.GenerateOpen g (â‹ƒâ‚€ S))) â†’\n          motive a t",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.State", "List", "String", "Prod", "Lean.Name"],
  "name": "Lean.Macro.State.traceMsgs",
  "constType": "Lean.Macro.State â†’ List (Lean.Name Ã— String)",
  "constCategory": "Definition"},
 {"references": ["Iff", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisConnection",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ (Î± â†’ Î²) â†’ (Î² â†’ Î±) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} â†’\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] â†’ (âˆ€ (a b c : M), a + b = c + b â†’ a = c) â†’ AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "Set.Finite.intro",
   "Set.finite_def.match_2",
   "Nonempty.intro",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Set",
   "Set.finite_def.match_1",
   "Nonempty",
   "Set.Finite"],
  "name": "Set.finite_def",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†” Nonempty (Fintype â†‘s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u â†’ Type v â†’ Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Disjoint.le_compl_right",
   "HeytingAlgebra.toHasCompl",
   "LE.le",
   "Preorder.toLE",
   "disjoint_compl_right"],
  "name": "le_compl_compl",
  "constType": "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a : Î±}, a â‰¤ aá¶œá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.mem_empty_iff_false",
   "False",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Set.instEmptyCollectionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.8",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), (x âˆˆ âˆ…) = False",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Exists",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Fin",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "finite_iff_nonempty_fintype.match_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (motive : (âˆƒ n, Nonempty (Î± â‰ƒ Fin n)) â†’ Prop) (x : âˆƒ n, Nonempty (Î± â‰ƒ Fin n)),\n  (âˆ€ (_k : â„•) (e : Î± â‰ƒ Fin _k), motive (_ : âˆƒ n, Nonempty (Î± â‰ƒ Fin n))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "Nat.le.dest.match_2",
   "Exists",
   "Nat.add_comm",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Exists.intro",
   "LE.le",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.zero",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "Nat.succ"],
  "name": "Nat.le.dest",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ âˆƒ k, n + k = m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.one_mul",
  "constType": "âˆ€ (n : â„•), 1 * n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Iff", "Classical.propDecidable", "Not", "Decidable.not_forall"],
  "name": "Classical.not_forall",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆ€ (x : Î±), p x) â†” âˆƒ x, Â¬p x",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Exception"],
  "name": "Lean.Macro.Exception.unsupportedSyntax",
  "constType": "Lean.Macro.Exception",
  "constCategory": "Other"},
 {"references": ["Topology.WithUpper", "Inhabited"],
  "name": "Topology.WithUpper.instInhabitedWithUpper",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "ne_true_of_eq_false.match_1",
   "Eq"],
  "name": "ne_true_of_eq_false",
  "constType": "âˆ€ {b : Bool}, b = false â†’ Â¬b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Disjoint",
  "constType":
  "{Î± : Type u_1} â†’ [inst : PartialOrder Î±] â†’ [inst : OrderBot Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "âˆ€ {Î± : Type u} [self : LinearOrder Î±] (a b : Î±), min a b = if a â‰¤ b then a else b",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "And.comm", "Eq"],
  "name": "Mathlib.Order.Directed._auxLemma.1",
  "constType": "âˆ€ {a b : Prop}, (a âˆ§ b) = (b âˆ§ a)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "List.drop",
   "List.length",
   "LE.le",
   "True",
   "Nat.sub_eq_zero_of_le",
   "Eq",
   "instHAppend",
   "instLENat",
   "List.instAppendList",
   "of_eq_true",
   "List.drop_append_eq_append_drop",
   "List",
   "HAppend.hAppend",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.drop_append_of_le_length",
  "constType":
  "âˆ€ {Î± : Type u_1} {n : â„•} {lâ‚ lâ‚‚ : List Î±}, n â‰¤ List.length lâ‚ â†’ List.drop n (lâ‚ ++ lâ‚‚) = List.drop n lâ‚ ++ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Preorder.mk",
   "Prod.instPreorderProd",
   "Preorder.toLT",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "And.casesOn",
   "Preorder.lt_iff_le_not_le"],
  "name": "Prod.instPartialOrder.match_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (x x_1 : Î± Ã— Î²),\n  let src := inferInstanceAs (Preorder (Î± Ã— Î²));\n  âˆ€ (motive : x â‰¤ x_1 â†’ Prop) (x_2 : x â‰¤ x_1),\n    (âˆ€ (hac : x.1 â‰¤ x_1.1) (hbd : x.2 â‰¤ x_1.2), motive (_ : x.1 â‰¤ x_1.1 âˆ§ x.2 â‰¤ x_1.2)) â†’ motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_6",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_7"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["False", "Function.comp", "Decidable", "Not", "Decidable.byContradiction"],
  "name": "Decidable.not_imp_symm",
  "constType": "âˆ€ {a b : Prop} [inst : Decidable a], (Â¬a â†’ b) â†’ Â¬b â†’ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "TopologicalSpace.generateFrom",
   "setOf",
   "Set",
   "TopologicalSpace",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq"],
  "name": "Topology.upper",
  "constType": "(Î± : Type u_1) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references": ["InfTopHomClass", "Top", "outParam", "Inf", "InfHomClass"],
  "name": "InfTopHomClass.toInfHomClass",
  "constType":
  "{F : Type u_7} â†’\n  {Î± : outParam (Type u_8)} â†’\n    {Î² : outParam (Type u_9)} â†’\n      [inst : Inf Î±] â†’\n        [inst_1 : Inf Î²] â†’ [inst_2 : Top Î±] â†’ [inst_3 : Top Î²] â†’ [self : InfTopHomClass F Î± Î²] â†’ InfHomClass F Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_6",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "lcProof",
  "constType": "âˆ€ {Î± : Prop}, Î±",
  "constCategory": "Axiom"},
 {"references": [],
  "name": "AddRightCancelSemigroup",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["Classical.not_forall", "Exists", "propext", "Not", "Eq"],
  "name": "Std.Logic._auxLemma.65",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆ€ (x : Î±), p x) = âˆƒ x, Â¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "funext",
   "Iff",
   "propext",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.ext",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Set Î±}, (âˆ€ (x : Î±), x âˆˆ a â†” x âˆˆ b) â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.symm",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.subset_empty_iff",
   "EmptyCollection.emptyCollection",
   "Set",
   "HasSubset.Subset",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_empty_iff_forall_not_mem",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s = âˆ… â†” âˆ€ (x : Î±), Â¬x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±), p w â†’ Exists p",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "GaloisInsertion.le_l_u",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "GaloisConnection.monotone_l",
   "LE.le.trans",
   "Sup.sup",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeSup Î±],\n  GaloisInsertion l u â†’ âˆ€ (a x : Î²), a â‰¤ l (u a âŠ” u x)",
  "constCategory": "Theorem"},
 {"references":
  ["MonadLiftT.mk",
   "MonadLift",
   "MonadLiftT",
   "MonadLiftT.monadLift",
   "MonadLift.monadLift"],
  "name": "instMonadLiftT",
  "constType":
  "(m : Type u_1 â†’ Type u_2) â†’\n  (n : Type u_1 â†’ Type u_3) â†’\n    (o : Type u_1 â†’ Type u_4) â†’ [inst : MonadLift n o] â†’ [inst : MonadLiftT m n] â†’ MonadLiftT m o",
  "constCategory": "Definition"},
 {"references": ["Exists", "Not", "Exists.intro", "Exists.casesOn"],
  "name": "not_forall_of_exists_not.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (motive : (âˆƒ x, Â¬p x) â†’ (âˆ€ (x : Î±), p x) â†’ Prop) (x : âˆƒ x, Â¬p x) (x_1 : âˆ€ (x : Î±), p x),\n  (âˆ€ (x : Î±) (hn : Â¬p x) (h : âˆ€ (x : Î±), p x), motive (_ : âˆƒ x, Â¬p x) h) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.sort.loop",
   "instDecidableEqList",
   "Lean.Data.AC.insert_nonEmpty",
   "List.casesOn",
   "Eq.refl",
   "eq_true_of_decide",
   "True",
   "instDecidableEqNat",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "List.rec",
   "Lean.Data.AC.Context",
   "instDecidableNot",
   "Bool.true",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "eq_self",
   "Ne",
   "List.cons",
   "Lean.Data.AC.insert",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.evalList_insert",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Lean.IsCommutative",
   "Lean.Data.AC.EvalInformation.evalVar",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort_congr",
  "constType":
  "âˆ€ {Î± : Sort u_1} {a b c : List â„•} (ctx : Lean.Data.AC.Context Î±),\n  Lean.IsCommutative ctx.op â†’\n    Lean.Data.AC.evalList Î± ctx a = Lean.Data.AC.evalList Î± ctx b â†’\n      a â‰  [] â†’\n        b â‰  [] â†’\n          Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.sort.loop a c) =\n            Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.sort.loop b c)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.Homeomorph._hyg.46",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "Iff",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "OrderDual.instIsUpperSet",
   "OrderDual.instIsLowerSet",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.isUpperSet_orderDual",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±], Topology.IsUpperSet Î±áµ’áµˆ â†” Topology.IsLowerSet Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Function.LeftInverse", "Function.RightInverse", "Equiv.mk"],
  "name": "Equiv.rec",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {motive : Î± â‰ƒ Î² â†’ Sort u} â†’\n      ((toFun : Î± â†’ Î²) â†’\n          (invFun : Î² â†’ Î±) â†’\n            (left_inv : Function.LeftInverse invFun toFun) â†’\n              (right_inv : Function.RightInverse invFun toFun) â†’\n                motive { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) â†’\n        (t : Î± â‰ƒ Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Nat.sub_add_cancel",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.add_sub_cancel'",
  "constType": "âˆ€ {n m : â„•}, m â‰¤ n â†’ m + (n - m) = n",
  "constCategory": "Theorem"},
 {"references":
  ["List.mem_filter.match_1",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "or_congr_left",
   "List.instMembershipList",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.14",
   "dite",
   "List.filter_cons_of_pos",
   "List.mem_filter.match_2",
   "True",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "or_iff_right",
   "Bool.of_not_eq_true",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "Bool.true",
   "List.nil",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "Membership.mem",
   "eq_self",
   "and_iff_left_of_imp",
   "List.filter",
   "List.cons",
   "Or",
   "False",
   "List.filter_cons_of_neg",
   "eq_false_of_decide",
   "Iff.symm",
   "And",
   "of_eq_true",
   "Bool.false",
   "List",
   "propext",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.mem_filter",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {p : Î± â†’ Bool} {as : List Î±}, x âˆˆ List.filter p as â†” x âˆˆ as âˆ§ p x = true",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result"],
  "name": "EStateM.Result.ok",
  "constType": "{Îµ Ïƒ Î± : Type u} â†’ Î± â†’ Ïƒ â†’ EStateM.Result Îµ Ïƒ Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Finset.Basic._auxLemma.18",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Set.fintypeEmpty.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), a âˆˆ âˆ… â†” a âˆˆ âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.closure_of._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.closure_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_4",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_6",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_3",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_5"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["forall_apply_eq_imp_iff", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.55",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆ€ (b : Î²) (a : Î±), f a = b â†’ p b) = âˆ€ (a : Î±), p (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Fintype.Basic._auxLemma.23",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Set.toFinset",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "And",
   "Fintype",
   "Iff",
   "DecidableEq",
   "Set.Elem",
   "of_eq_true",
   "forall_congr",
   "Finset.image",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Image._auxLemma.24",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.fintypeImage.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : DecidableEq Î²] (s : Set Î±) (f : Î± â†’ Î²) [inst_1 : Fintype â†‘s] (a : Î²),\n  a âˆˆ Finset.image f (Set.toFinset s) â†” a âˆˆ f '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "implies_congr",
   "Eq",
   "PProd",
   "Filter.HasBasis",
   "Eq.mpr",
   "Filter",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "Set.inter_subset_inter",
   "funext",
   "Filter.HasBasis.mem_of_mem",
   "HasSubset.Subset",
   "PProd.snd",
   "Filter.HasBasis.mem_iff",
   "Iff.intro",
   "And",
   "PProd.fst",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Mathlib.Order.Filter.Bases._auxLemma.20",
   "Filter.mem_inf_of_inter",
   "propext",
   "Filter.instInfFilter",
   "congr",
   "And.intro",
   "PProd.casesOn",
   "congrArg",
   "PProd.mk",
   "Filter.HasBasis.mk",
   "Set.instInterSet",
   "congrFun"],
  "name": "Filter.HasBasis.inf'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Î¹' : Sort u_5} {l l' : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {p' : Î¹' â†’ Prop}\n  {s' : Î¹' â†’ Set Î±},\n  Filter.HasBasis l p s â†’\n    Filter.HasBasis l' p' s' â†’ Filter.HasBasis (l âŠ“ l') (fun i â†¦ p i.fst âˆ§ p' i.snd) fun i â†¦ s i.fst âˆ© s' i.snd",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ Ord Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Eq.refl", "Not", "Filter", "Filter.Eventually", "Filter.Frequently", "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.Filter.Frequently._eq_1",
  "constType":
  "âˆ€ {Î± : Type u} (p : Î± â†’ Prop) (f : Filter Î±), Filter.Frequently p f = Â¬âˆ€á¶  (x : Î±) in f, Â¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.subtype.proof_1",
   "Subtype.val",
   "Function.Embedding.mk",
   "Function.Embedding",
   "Subtype"],
  "name": "Function.Embedding.subtype",
  "constType": "{Î± : Sort u_1} â†’ (p : Î± â†’ Prop) â†’ Subtype p â†ª Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Set.sUnion",
   "Filter",
   "TopologicalSpace.nhds_generateFrom.match_3",
   "Set.subset_sUnion_of_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (f : Filter Î±) (_k : Set (Set Î±)),\n  (âˆ€ t âˆˆ _k, (fun s â†¦ a âˆˆ s â†’ s âˆˆ f) t) â†’ a âˆˆ â‹ƒâ‚€ _k â†’ â‹ƒâ‚€ _k âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "Or",
   "False",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "True",
   "Eq",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Iff.intro",
   "Iff",
   "of_eq_true",
   "List",
   "congr",
   "or_false",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "List.eq_of_mem_singleton",
   "congrFun"],
  "name": "List.mem_singleton",
  "constType": "âˆ€ {Î± : Type u_1} {a b : Î±}, a âˆˆ [b] â†” a = b",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod"],
  "name": "Prod.rec",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’ {motive : Î± Ã— Î² â†’ Sort u_1} â†’ ((fst : Î±) â†’ (snd : Î²) â†’ motive (fst, snd)) â†’ (t : Î± Ã— Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{Î± : Type u_3} â†’ [self : HasCompl Î±] â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Bot", "bot_nonempty.proof_1", "Nonempty"],
  "name": "bot_nonempty",
  "constType": "âˆ€ (Î± : Type u) [inst : Bot Î±], Nonempty Î±",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "List.hasDecEq.match_2",
  "constType":
  "{Î± : Type u_1} â†’\n  (a b : Î±) â†’\n    (motive : Decidable (a = b) â†’ Sort u_2) â†’\n      (x : Decidable (a = b)) â†’\n        ((hab : a = b) â†’ motive (isTrue hab)) â†’ ((nab : Â¬a = b) â†’ motive (isFalse nab)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.comp",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "Topology.WithLowerSet.toLowerSet",
   "ContinuousMap",
   "LE.le",
   "Preorder.toLE",
   "ContinuousMap.mk",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.map.proof_1"],
  "name": "Topology.WithLowerSet.map",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â†’ C(Topology.WithLowerSet Î±, Topology.WithLowerSet Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Continuous_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.26",
  "constType": "âˆ€ {Î± : Type u_1} {a b : Î±}, (b âˆˆ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "nhds",
   "Function.comp",
   "ContinuousAt",
   "TopologicalSpace",
   "Inducing",
   "Inducing.tendsto_nhds_iff"],
  "name": "Inducing.continuousAt_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³},\n  Inducing g â†’ âˆ€ {x : Î±}, ContinuousAt f x â†” ContinuousAt (g âˆ˜ f) x",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.decidableBAll",
   "List.instMembershipList",
   "List",
   "List.foldr",
   "List.nil",
   "ite",
   "DecidableRel"],
  "name": "List.pwFilter",
  "constType":
  "{Î± : Type u_1} â†’ (R : Î± â†’ Î± â†’ Prop) â†’ [inst : DecidableRel R] â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.completeLattice.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : CompleteLattice Î±] (a b : Î±áµ’áµˆ), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsNeutral", "Eq"],
  "name": "Lean.IsNeutral.left_neutral",
  "constType":
  "âˆ€ {Î± : Sort u} {op : Î± â†’ Î± â†’ Î±} {neutral : Î±} [self : Lean.IsNeutral op neutral] (a : Î±), op neutral a = a",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Not"],
  "name": "Decidable.isFalse",
  "constType": "{p : Prop} â†’ Â¬p â†’ Decidable p",
  "constCategory": "Other"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["List.filter",
   "Eq.mpr",
   "List.Perm.filterMap",
   "Eq.ndrec",
   "List.Perm",
   "List.filterMap_eq_filter",
   "List.filterMap",
   "List",
   "Bool.true",
   "Eq.refl",
   "Bool",
   "Eq.symm",
   "id",
   "instDecidableEqBool",
   "Eq",
   "Option.guard"],
  "name": "List.Perm.filter",
  "constType":
  "âˆ€ {Î± : Type uu} (p : Î± â†’ Bool) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.filter p lâ‚ ~ List.filter p lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["beq_iff_eq",
   "BEq.beq",
   "BEq",
   "propext",
   "Bool.true",
   "LawfulBEq",
   "Bool",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.7",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] (a b : Î±), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "Filter.GenerateSets",
  "constType": "{Î± : Type u} â†’ Set (Set Î±) â†’ Set Î± â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.sUnion_subset",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "interior",
   "IsOpen"],
  "name": "interior_subset",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, interior s âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.casesOn",
   "Equiv.toFun",
   "Eq.ndrec",
   "Function.RightInverse",
   "Equiv.invFun",
   "Eq.rec",
   "Eq.refl",
   "Equiv.mk",
   "Eq.symm",
   "Eq"],
  "name": "Equiv.instEquivLikeEquiv.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (eâ‚ eâ‚‚ : Î± â‰ƒ Î²), eâ‚.toFun = eâ‚‚.toFun â†’ eâ‚.invFun = eâ‚‚.invFun â†’ eâ‚ = eâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
  "constType": "{Î± : Type u} â†’ [self : Inter Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.range", "Set.Elem", "Finite", "Finite.Set.finite_range.proof_1"],
  "name": "Finite.Set.finite_range",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} (f : Î¹ â†’ Î±) [inst : Finite Î¹], Finite â†‘(Set.range f)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "List.subset_nil.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} (motive : (x : List Î±) â†’ l = x â†’ Prop) (x : List Î±) (x_1 : l = x),\n  (Unit â†’ motive l (_ : l = l)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "True.intro",
   "False.elim",
   "False",
   "BoundedOrder.mk",
   "Bot.mk",
   "OrderBot.mk",
   "Prop.le",
   "Top.mk",
   "True",
   "BoundedOrder"],
  "name": "Prop.boundedOrder",
  "constType": "BoundedOrder Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Set.Subset.rfl",
   "Filter.exists_mem_subset_iff.match_1",
   "instMembershipSetFilter"],
  "name": "Filter.exists_mem_subset_iff",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s : Set Î±}, (âˆƒ t âˆˆ f, t âŠ† s) â†” s âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["CoheytingAlgebra",
   "Top",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedCoheytingAlgebra",
   "HNot",
   "HNot.hnot",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "CoheytingAlgebra.mk",
  "constType":
  "{Î± : Type u_4} â†’\n  [toGeneralizedCoheytingAlgebra : GeneralizedCoheytingAlgebra Î±] â†’\n    [toTop : Top Î±] â†’ [toHNot : HNot Î±] â†’ (âˆ€ (a : Î±), a â‰¤ âŠ¤) â†’ (âˆ€ (a : Î±), âŠ¤ \\ a = ï¿¢a) â†’ CoheytingAlgebra Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "EmptyCollection.emptyCollection",
   "Set",
   "HasSubset.Subset",
   "Set.empty_subset.match_1",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet"],
  "name": "Set.empty_subset",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±), âˆ… âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰¥]_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "instBEq",
   "rfl",
   "List.erase",
   "Eq",
   "ite",
   "if_pos",
   "Eq.mpr",
   "List.count_erase",
   "Eq.ndrec",
   "DecidableEq",
   "List",
   "instOfNatNat",
   "Nat",
   "List.count",
   "id"],
  "name": "List.count_erase_self",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (l : List Î±), List.count a (List.erase l a) = List.count a l - 1",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe", "EquivLike", "outParam", "EquivLike.inv", "Eq"],
  "name": "EquivLike.coe_injective'",
  "constType":
  "âˆ€ {E : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EquivLike E Î± Î²] (e g : E),\n  EquivLike.coe e = EquivLike.coe g â†’ EquivLike.inv e = EquivLike.inv g â†’ e = g",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "And.intro",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "le_antisymm_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a b : Î±} (motive : a â‰¤ b âˆ§ b â‰¤ a â†’ Prop) (x : a â‰¤ b âˆ§ b â‰¤ a),\n  (âˆ€ (h1 : a â‰¤ b) (h2 : b â‰¤ a), motive (_ : a â‰¤ b âˆ§ b â‰¤ a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "Iff",
   "And.comm",
   "exists_congr",
   "Iff.trans",
   "exists_eq_left",
   "Eq"],
  "name": "exists_eq_right",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') â†” p a'",
  "constCategory": "Theorem"},
 {"references": ["Inf.mk", "Sup", "Inf", "OrderDual", "Sup.sup"],
  "name": "instInfOrderDual",
  "constType": "(Î± : Type u_1) â†’ [inst : Sup Î±] â†’ Inf Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet", "IsLowerSet", "LowerSet.rec", "Set", "LowerSet.mk", "LE"],
  "name": "LowerSet.casesOn",
  "constType":
  "{Î± : Type u_6} â†’\n  [inst : LE Î±] â†’\n    {motive : LowerSet Î± â†’ Sort u} â†’\n      (t : LowerSet Î±) â†’\n        ((carrier : Set Î±) â†’ (lower' : IsLowerSet carrier) â†’ motive { carrier := carrier, lower' := lower' }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Monad",
   "EmptyCollection.emptyCollection",
   "Monad.toApplicative",
   "Set.monad",
   "Union.union",
   "Unit",
   "Set",
   "Unit.unit",
   "Set.instEmptyCollectionSet",
   "Alternative.mk",
   "Alternative",
   "Set.instUnionSet"],
  "name": "Set.instAlternativeSet",
  "constType": "Alternative Set",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.instInhabitedWithLower._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "Order.Frame.mk",
   "CompleteDistribLattice.mk",
   "CompletelyDistribLattice",
   "CompleteDistribLattice",
   "CompletelyDistribLattice.toCompleteDistribLattice.proof_2",
   "CompletelyDistribLattice.toCompleteDistribLattice.proof_1"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice",
  "constType":
  "{Î± : Type u} â†’ [inst : CompletelyDistribLattice Î±] â†’ CompleteDistribLattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo â†’ Lean.SyntaxNodeKind â†’ Array Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_left_comm",
  "constType": "âˆ€ (n m k : â„•), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "nhds",
   "Set",
   "ContinuousAt",
   "IsOpen.mem_nhds",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Iff.intro",
   "Iff",
   "Continuous",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Continuous.tendsto",
   "continuous_def",
   "instMembershipSetFilter",
   "isOpen_iff_mem_nhds"],
  "name": "continuous_iff_continuousAt",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†” âˆ€ (x : Î±), ContinuousAt f x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Function.comp",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "ContinuousMap",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "ContinuousMap.mk",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Topology.WithUpperSet.map.proof_1",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â†’ C(Topology.WithUpperSet Î±, Topology.WithUpperSet Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Set.Ici",
   "Mathlib.Order.UpperLower.Basic._auxLemma.94",
   "UpperSet",
   "Preorder.toLE",
   "True",
   "SetLike.instMembership",
   "iff_self",
   "Eq",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.instSingletonSet",
   "Iff",
   "upperClosure",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "UpperSet.Ici",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.38",
   "And",
   "of_eq_true",
   "UpperSet.ext",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "SetLike.coe",
   "congrFun"],
  "name": "upperClosure_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), upperClosure {a} = UpperSet.Ici a",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "T0Space", "Inseparable", "Eq"],
  "name": "T0Space.mk",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], (âˆ€ â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y) â†’ T0Space Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Set.Basic._auxLemma.11",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Iff",
   "of_eq_true",
   "congr",
   "Not",
   "congrArg",
   "Mathlib.Data.Set.Basic._auxLemma.10",
   "Eq.trans"],
  "name": "Set.not_nonempty_iff_eq_empty",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Â¬Set.Nonempty s â†” s = âˆ…",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Mem",
  "constType": "{Î± : Type u} â†’ Î± â†’ List Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Classical.indefiniteDescription.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (p : Î± â†’ Prop) (motive : (âˆƒ x, p x) â†’ Prop) (h : âˆƒ x, p x),\n  (âˆ€ (x : Î±) (px : p x), motive (_ : âˆƒ x, p x)) â†’ motive h",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "EStateM.modifyGet.match_1",
  "constType":
  "{Ïƒ Î± : Type u_1} â†’ (motive : Î± Ã— Ïƒ â†’ Sort u_2) â†’ (x : Î± Ã— Ïƒ) â†’ ((a : Î±) â†’ (s : Ïƒ) â†’ motive (a, s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper", "Topology.upper", "TopologicalSpace", "Preorder"],
  "name": "Topology.WithUpper.instTopologicalSpaceWithUpper",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "Eq",
   "iff_self",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_5",
  "constType":
  "âˆ€ {Î± Î¹ : Type u_1} {Îº : Î¹ â†’ Type u_1} (f : (a : Î¹) â†’ Îº a â†’ Set Î±), â¨… a, â¨† b, f a b = â¨† g, â¨… a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "le_inf",
   "Pi.partialOrder",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ SemilatticeInf (Î±' i)] (x x_1 x_2 : (i : Î¹) â†’ Î±' i),\n  x â‰¤ x_1 â†’ x â‰¤ x_2 â†’ âˆ€ (i : Î¹), x i â‰¤ x_1 i âŠ“ x_2 i",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "DecidableEq",
   "Set.toFinset",
   "Union.union",
   "Set",
   "Finset",
   "Set.fintypeUnion.proof_1",
   "Fintype.ofFinset",
   "Finset.instUnionFinset",
   "Set.instUnionSet"],
  "name": "Set.fintypeUnion",
  "constType":
  "{Î± : Type u} â†’ [inst : DecidableEq Î±] â†’ (s t : Set Î±) â†’ [inst : Fintype â†‘s] â†’ [inst : Fintype â†‘t] â†’ Fintype â†‘(s âˆª t)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "le_antisymm_iff.match_1",
   "And.intro",
   "le_antisymm",
   "Eq.symm",
   "le_of_eq",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a = b â†” a â‰¤ b âˆ§ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Fin.val", "LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.isLt",
  "constType": "âˆ€ {n : â„•} (self : Fin n), â†‘self < n",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.inter_subset_inter",
   "setOf",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Exists.intro",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "Filter.comap.match_1",
   "Filter.inter_mem",
   "Filter",
   "And.intro",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.comap.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (m : Î± â†’ Î²) (f : Filter Î²) {x y : Set Î±},\n  x âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s} â†’ y âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s} â†’ x âˆ© y âˆˆ {s | âˆƒ t âˆˆ f, m â»Â¹' t âŠ† s}",
  "constCategory": "Theorem"},
 {"references": ["False", "Iff", "Not", "Iff.mpr"],
  "name": "instDecidableIff.proof_3",
  "constType": "âˆ€ {p q : Prop}, Â¬p â†’ q â†’ (p â†” q) â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Ne",
   "List.cons",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "List.count_cons",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instBEq",
   "ite_congr",
   "True",
   "Eq",
   "ite",
   "instDecidableFalse",
   "eq_false",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "List.count",
   "Eq.trans",
   "congrFun"],
  "name": "List.count_cons_of_ne",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a b : Î±}, a â‰  b â†’ âˆ€ (l : List Î±), List.count a (b :: l) = List.count a l",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.image_congr",
   "of_eq_true",
   "Set.image_id'",
   "Set",
   "Eq.refl",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "True",
   "Set.instMembershipSet",
   "congrFun",
   "id",
   "Eq"],
  "name": "Set.image_id",
  "constType": "âˆ€ {Î± : Type u_1} (s : Set Î±), id '' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "List.cons",
   "List.pmap",
   "List.instMembershipList",
   "Eq.refl",
   "List.pmap._sunfold.proof_2",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.pmap_eq_map",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (p : Î± â†’ Prop) (f : Î± â†’ Î²) (l : List Î±) (H : âˆ€ a âˆˆ l, p a),\n  List.pmap (fun a x â†¦ f a) l H = List.map f l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.iUnion",
   "Set.image_id'",
   "Set",
   "Set.sUnion_image",
   "Eq.refl",
   "Set.sUnion",
   "Set.image",
   "Eq.symm",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.sUnion_eq_biUnion",
  "constType": "âˆ€ {Î± : Type u_1} {s : Set (Set Î±)}, â‹ƒâ‚€ s = â‹ƒ i âˆˆ s, i",
  "constCategory": "Theorem"},
 {"references": ["Lean.MonadQuotation", "Lean.MacroScope"],
  "name": "Lean.MonadQuotation.getCurrMacroScope",
  "constType":
  "{m : Type â†’ Type} â†’ [self : Lean.MonadQuotation m] â†’ m Lean.MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Nat.add_sub_of_le",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.sub_add_cancel",
  "constType": "âˆ€ {n m : â„•}, m â‰¤ n â†’ n - m + m = n",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termð“[>]_Â»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Â«termð“[>]_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntax",
  "constType": "Lean.SyntaxNodeKinds â†’ Type",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_3",
  "constType": "2047 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop", "Top.top", "OrderTop.le_top", "OrderTop", "LE", "LE.le"],
  "name": "le_top",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderTop Î±] {a : Î±}, a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "inf_assoc",
   "LE.le",
   "GeneralizedBooleanAlgebra.inf_inf_sdiff",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "Eq.ndrec",
   "GeneralizedBooleanAlgebra",
   "Bot.mk",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Eq.symm",
   "GeneralizedBooleanAlgebra.toBot",
   "id"],
  "name": "GeneralizedBooleanAlgebra.toOrderBot.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : GeneralizedBooleanAlgebra Î±] (a : Î±), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.List.Basic._auxLemma.62",
   "List.pmap",
   "List.instMembershipList",
   "Subtype.val",
   "Mathlib.Data.List.Basic._auxLemma.9",
   "Mathlib.Data.List.Basic._auxLemma.65",
   "Eq.refl",
   "List.pmap_eq_map_attach",
   "List.attach",
   "Iff.mpr",
   "True",
   "iff_self",
   "Mathlib.Data.List.Basic._auxLemma.64",
   "Eq",
   "Iff.of_eq",
   "Subtype.property",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.List.Basic._auxLemma.63",
   "List",
   "congr",
   "List.map",
   "congrArg",
   "Eq.trans",
   "Subtype",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "List.mem_pmap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {l : List Î±} {H : âˆ€ a âˆˆ l, p a} {b : Î²},\n  b âˆˆ List.pmap f l H â†” âˆƒ a, âˆƒ (h : a âˆˆ l), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "List", "List.hasDecEq"],
  "name": "instDecidableEqList",
  "constType": "{Î± : Type u} â†’ [inst : DecidableEq Î±] â†’ DecidableEq (List Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "_private.Std.Data.List.Count.0.List.count._eq_1",
   "List.instMembershipList",
   "List.countP_eq_length",
   "Eq.refl",
   "instBEq",
   "beq_self_eq_true",
   "List.length",
   "instLawfulBEqInstBEq",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "BEq.beq",
   "Iff",
   "Eq.ndrec",
   "DecidableEq",
   "propext",
   "List",
   "Bool.true",
   "Eq.mp",
   "Init.Core._auxLemma.1",
   "Bool",
   "Nat",
   "List.countP",
   "Eq.symm",
   "List.count",
   "id"],
  "name": "List.count_eq_length",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, List.count a l = List.length l â†” âˆ€ b âˆˆ l, a = b",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name":
  "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.loop.match_1.splitter",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ motive true â†’ motive false â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_right",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_right",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} â†’ {motive : a âˆ§ b â†’ Sort u} â†’ ((left : a) â†’ (right : b) â†’ motive (_ : a âˆ§ b)) â†’ (t : a âˆ§ b) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["PSigma",
   "OfNat.ofNat",
   "instSubNat",
   "WellFounded.fix_eq",
   "Nat.decLt",
   "Eq.refl",
   "instSizeOfNat",
   "dite",
   "instLTNat",
   "ite",
   "Eq",
   "instWellFoundedRelation",
   "instLENat",
   "Nat.div_rec_lemma",
   "SizeOf.sizeOf",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.decLe",
   "id",
   "instHSub",
   "PSigma.casesOn",
   "HSub.hSub",
   "Nat.modCore",
   "instDecidableAnd",
   "Nat.modCore._unary.proof_1",
   "WellFounded.fix",
   "LE.le",
   "And",
   "Nat.modCore._unary",
   "invImage",
   "LT.lt",
   "PSigma.mk",
   "Not"],
  "name": "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
  "constType":
  "âˆ€ (x y : â„•), Nat.modCore x y = if 0 < y âˆ§ y â‰¤ x then Nat.modCore (x - y) y else x",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.closure_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Order.Frame.toCompleteLattice",
   "Order.Coframe",
   "Order.Coframe.mk",
   "CompleteDistribLattice",
   "CompleteDistribLattice.toFrame"],
  "name": "CompleteDistribLattice.toCoframe",
  "constType":
  "{Î± : Type u} â†’ [inst : CompleteDistribLattice Î±] â†’ Order.Coframe Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Top", "Top.top", "Nonempty"],
  "name": "top_nonempty.proof_1",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Top Î±], Nonempty Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Filter.instPartialOrderFilter.proof_3",
   "Membership.mem",
   "LE.mk",
   "And",
   "Filter.instPartialOrderFilter.proof_1",
   "PartialOrder.mk",
   "Set",
   "Not",
   "Filter",
   "LT.mk",
   "Filter.instPartialOrderFilter.proof_2",
   "Filter.instPartialOrderFilter.proof_4",
   "PartialOrder",
   "instMembershipSetFilter",
   "Preorder.mk"],
  "name": "Filter.instPartialOrderFilter",
  "constType": "{Î± : Type u} â†’ PartialOrder (Filter Î±)",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.pairwise_cons.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±} (motive : (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l â†’ Prop)\n  (x : (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l),\n  (âˆ€ (hâ‚ : âˆ€ a' âˆˆ l, R a a') (hâ‚‚ : List.Pairwise R l), motive (_ : (âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "of_eq_true",
   "Inf.inf",
   "congr",
   "Sup.sup",
   "sup_comm",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "True",
   "sup_inf_left",
   "Eq"],
  "name": "sup_inf_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DistribLattice Î±] {x y z : Î±}, y âŠ“ z âŠ” x = (y âŠ” x) âŠ“ (z âŠ” x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Set.preimage",
   "Continuous",
   "Set",
   "le_generateFrom",
   "TopologicalSpace",
   "LE.le",
   "IsOpen",
   "Preorder.toLE",
   "Iff.mpr",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced",
   "Set.instMembershipSet"],
  "name": "continuous_generateFrom",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {t : TopologicalSpace Î±} {b : Set (Set Î²)},\n  (âˆ€ s âˆˆ b, IsOpen (f â»Â¹' s)) â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Context"],
  "name": "Lean.Data.AC.Context.op",
  "constType": "{Î± : Sort u} â†’ Lean.Data.AC.Context Î± â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "Exists",
   "List.cons",
   "List.Sublist.casesOn",
   "List.eq_nil_of_sublist_nil",
   "HEq",
   "List.Perm.refl",
   "eq_of_heq",
   "List.exists_perm_sublist.match_1",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Perm.rec",
   "Exists.intro",
   "List.Perm.swap",
   "List.Sublist.slnil",
   "List.Perm.cons",
   "Eq",
   "List.Perm",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Eq.rec",
   "List.Sublist.consâ‚‚",
   "List.Perm.trans",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.exists_perm_sublist",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ lâ‚‚' : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ lâ‚‚ ~ lâ‚‚' â†’ âˆƒ lâ‚', âˆƒ (_ : lâ‚' ~ lâ‚), List.Sublist lâ‚' lâ‚‚'",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "Option.none",
   "List",
   "Unit",
   "PUnit",
   "Option.some",
   "List.erase.match_1",
   "List.nil",
   "Bool",
   "List.isEmpty.match_1",
   "Option"],
  "name": "List.find?",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Bool) â†’ List Î± â†’ Option Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl", "eq_true", "List", "List.Sublist", "True", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.30",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), List.Sublist l l = True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "LE.le.trans",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "le_iSup_of_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {a : Î±} (i : Î¹), a â‰¤ f i â†’ a â‰¤ iSup f",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_6",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_4",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "semiOutParam"],
  "name": "MonadReaderOf.mk",
  "constType":
  "{Ï : semiOutParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ m Ï â†’ MonadReaderOf Ï m",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.preimage_iUnionâ‚‚",
   "Set.sUnion_eq_biUnion",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.iUnion",
   "Set.preimage",
   "Set",
   "Eq.refl",
   "Set.sUnion",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.preimage_sUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s : Set (Set Î²)}, f â»Â¹' â‹ƒâ‚€ s = â‹ƒ t âˆˆ s, f â»Â¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "Equiv",
   "sSupHom.dual.proof_3",
   "OrderDual.toDual",
   "sSupHom.mk",
   "sSupHom",
   "Function.comp",
   "OrderDual.infSet",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sSupHom.map_sSup'",
   "Equiv.instFunLikeEquiv",
   "SupSet",
   "sSupHomClass.toFunLike",
   "sSupHom.instSSupHomClassSSupHom",
   "OrderDual.ofDual",
   "sSupHom.dual.proof_1",
   "sSupHom.dual.proof_2",
   "Equiv.mk",
   "OrderDual",
   "sInfHom.mk",
   "sInfHom.instSInfHomClassSInfHom"],
  "name": "sSupHom.dual",
  "constType":
  "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : SupSet Î±] â†’ [inst_1 : SupSet Î²] â†’ sSupHom Î± Î² â‰ƒ sInfHom Î±áµ’áµˆ Î²áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.cons",
   "List.instMembershipList",
   "Unit",
   "HasSubset.Subset",
   "List.subset_nil.match_1",
   "rfl",
   "Eq",
   "Iff.intro",
   "Iff.mp",
   "List.Subset.refl",
   "List",
   "List.Mem.head",
   "List.not_mem_nil.match_1",
   "List.nil",
   "List.subset_nil.match_2"],
  "name": "List.eq_nil_of_subset_nil",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, l âŠ† [] â†’ l = []",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "iSup",
   "iSup_subtype''",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "Eq.mpr",
   "CompleteLattice",
   "Eq.ndrec",
   "Set.Elem",
   "iSup_range'",
   "Eq.symm",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "iSup_range",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {g : Î² â†’ Î±} {f : Î¹ â†’ Î²},\n  â¨† b âˆˆ Set.range f, g b = â¨† i, g (f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_5",
   "Lean.Name.str._override"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.toLowerSet_ofLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Topology.WithLowerSet Î±),\n  â†‘Topology.WithLowerSet.toLowerSet (â†‘Topology.WithLowerSet.ofLowerSet a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.count_pos_iff_mem",
   "Membership.mem",
   "OfNat.ofNat",
   "Nat.succ_le_of_lt",
   "List.instMembershipList",
   "instBEq",
   "instLTNat",
   "LE.le",
   "Iff.mpr",
   "Eq",
   "List.Nodup",
   "Iff.mp",
   "instLENat",
   "DecidableEq",
   "StrictOrderedSemiring.toPartialOrder",
   "List",
   "LT.lt",
   "List.nodup_iff_count_le_one",
   "instOfNatNat",
   "Nat",
   "le_antisymm",
   "List.count",
   "Nat.strictOrderedSemiring"],
  "name": "List.count_eq_one_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, List.Nodup l â†’ a âˆˆ l â†’ List.count a l = 1",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "IsTop",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Bind"],
  "name": "Bind.bind",
  "constType":
  "{m : Type u â†’ Type v} â†’ [self : Bind m] â†’ {Î± Î² : Type u} â†’ m Î± â†’ (Î± â†’ m Î²) â†’ m Î²",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ DecidableEq Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage", "Set", "Continuous", "TopologicalSpace", "IsOpen"],
  "name": "Continuous.isOpen_preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ âˆ€ (s : Set Î²), IsOpen s â†’ IsOpen (f â»Â¹' s)",
  "constCategory": "Definition"},
 {"references": ["Option.none", "Option.some", "Option.casesOn", "Option"],
  "name": "Option.getD.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : Option Î± â†’ Î± â†’ Sort u_2) â†’\n    (x : Option Î±) â†’ (x_1 : Î±) â†’ ((x x_2 : Î±) â†’ motive (some x) x_2) â†’ ((e : Î±) â†’ motive none e) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Eq.ndrec", "Eq"],
  "name": "Eq.subst",
  "constType":
  "âˆ€ {Î± : Sort u} {motive : Î± â†’ Prop} {a b : Î±}, a = b â†’ motive a â†’ motive b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.forall_mem_nil.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (a : Î±) â†’ a âˆˆ [] â†’ Prop) (a : Î±) (a_1 : a âˆˆ []), motive a a_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Top.top",
   "Inf.inf",
   "inf_of_le_left",
   "le_top",
   "SemilatticeInf.toPartialOrder",
   "OrderTop",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_top_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : OrderTop Î±] {a : Î±}, a âŠ“ âŠ¤ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "And",
   "Set.preimage_univ",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "Set.univ",
   "isOpen_univ",
   "IsOpen",
   "Eq"],
  "name": "TopologicalSpace.induced.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (f : Î± â†’ Î²) (t : TopologicalSpace Î²), âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "And",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "or_imp.match_1",
   "Function.comp",
   "And.intro",
   "Or.rec"],
  "name": "or_imp",
  "constType": "âˆ€ {a b c : Prop}, a âˆ¨ b â†’ c â†” (a â†’ c) âˆ§ (b â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "LE.mk",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "LE.le",
   "instMembershipSetFilter"],
  "name": "Filter.instPartialOrderFilter.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b c : Filter Î±), a â‰¤ b â†’ b â‰¤ c â†’ c.sets âŠ† a.sets",
  "constCategory": "Theorem"},
 {"references": ["and_comm", "And", "propext", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.11",
  "constType": "âˆ€ {a b : Prop}, (a âˆ§ b) = (b âˆ§ a)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "List.brecOn",
   "List.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat"],
  "name": "List.findIdx.go",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Bool) â†’ List Î± â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "OfNat.ofNat",
   "List.mem_replicate.match_1",
   "Std.Data.List.Lemmas._auxLemma.2",
   "false_and",
   "List.instMembershipList",
   "Std.Data.Nat.Lemmas._auxLemma.3",
   "Eq.refl",
   "implies_congr",
   "True",
   "instDecidableEqNat",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "PProd",
   "Iff",
   "instDecidableNot",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "Nat.succ",
   "Membership.mem",
   "Ne",
   "Or",
   "List.cons",
   "Nat.below",
   "Nat.brecOn",
   "False",
   "Unit",
   "Std.Logic._auxLemma.5",
   "implies_true",
   "eq_false_of_decide",
   "Std.Logic._auxLemma.23",
   "Std.Logic._auxLemma.21",
   "And",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "propext",
   "List",
   "Bool.false",
   "List.replicate",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.mem_replicate",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {n : â„•}, b âˆˆ List.replicate n a â†” n â‰  0 âˆ§ b = a",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quot.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.ind",
  "constType":
  "âˆ€ {Î± : Sort u} {s : Setoid Î±} {motive : Quotient s â†’ Prop},\n  (âˆ€ (a : Î±), motive (Quotient.mk s a)) â†’ âˆ€ (q : Quotient s), motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "OrderBot.toBot",
   "Prod.orderBot",
   "inferInstanceAs",
   "Prod.instLEProd",
   "OrderBot.bot_le",
   "LE",
   "Prod",
   "OrderBot",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "Prod.boundedOrder.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LE Î±] [inst_1 : LE Î²] [inst_2 : BoundedOrder Î±] [inst_3 : BoundedOrder Î²]\n  (a : Î± Ã— Î²), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Fintype.equivFin", "Finite.intro", "Finite", "Fintype.card"],
  "name": "Fintype.finite",
  "constType": "âˆ€ {Î± : Type u_4}, Fintype Î± â†’ Finite Î±",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.binary",
  "constType":
  "Lean.Name â†’ Lean.ParserDescr â†’ Lean.ParserDescr â†’ Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.preimage",
   "Iff.rfl",
   "nhds",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "mem_nhds_induced",
   "Eq",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Iff",
   "propext",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Filter.ext",
   "TopologicalSpace.induced",
   "Filter.mem_comap",
   "instMembershipSetFilter",
   "id"],
  "name": "nhds_induced",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [T : TopologicalSpace Î±] (f : Î² â†’ Î±) (a : Î²), nhds a = Filter.comap f (nhds (f a))",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Set.Elem",
   "Iff.rfl",
   "propext",
   "Set",
   "Finite",
   "Eq.refl",
   "Set.finite_def",
   "finite_iff_nonempty_fintype",
   "Nonempty",
   "Set.Finite",
   "Eq",
   "id"],
  "name": "Set.finite_coe_iff",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Finite â†‘s â†” Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "GeneralizedBooleanAlgebra.sup_inf_sdiff",
   "Eq"],
  "name": "sup_inf_sdiff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : GeneralizedBooleanAlgebra Î±] (x y : Î±), x âŠ“ y âŠ” x \\ y = x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["And", "Or", "Iff", "False", "Not", "or_imp"],
  "name": "not_or",
  "constType": "âˆ€ {p q : Prop}, Â¬(p âˆ¨ q) â†” Â¬p âˆ§ Â¬q",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.univ_sets",
   "Membership.mem",
   "Inhabited",
   "Set",
   "Filter",
   "Set.univ",
   "Inhabited.mk",
   "Subtype.mk",
   "Subtype",
   "instMembershipSetFilter"],
  "name": "Filter.inhabitedMem",
  "constType": "{Î± : Type u} â†’ {f : Filter Î±} â†’ Inhabited { s // s âˆˆ f }",
  "constCategory": "Definition"},
 {"references": ["LowerSet", "IsLowerSet", "LE", "LowerSet.carrier"],
  "name": "LowerSet.lower'",
  "constType":
  "âˆ€ {Î± : Type u_6} [inst : LE Î±] (self : LowerSet Î±), IsLowerSet self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.drop.match_1",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.drop",
  "constType": "{Î± : Type u} â†’ â„• â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1",
   "Topology.IsClosed_of._closed_1"],
  "name": "Topology.IsClosed_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.eq",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references": ["GeneralizedHeytingAlgebra", "HImp"],
  "name": "GeneralizedHeytingAlgebra.toHImp",
  "constType": "{Î± : Type u_4} â†’ [self : GeneralizedHeytingAlgebra Î±] â†’ HImp Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "eq_true",
   "List",
   "List.Sublist",
   "List.Sublist.cons",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.39",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (a : Î±), List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist lâ‚ (a :: lâ‚‚) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.mk",
   "Eq"],
  "name": "Topology.IsLowerSet.rec",
  "constType":
  "{Î± : Type u_4} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsLowerSet Î± â†’ Sort u} â†’\n        ((topology_eq_lowerSetTopology : t = Topology.lowerSet Î±) â†’ motive (_ : Topology.IsLowerSet Î±)) â†’\n          (t : Topology.IsLowerSet Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Iff",
   "Iff.rfl",
   "Set",
   "LT.lt",
   "Not",
   "Filter",
   "LT.mk",
   "instMembershipSetFilter"],
  "name": "Filter.instPartialOrderFilter.proof_3",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Filter Î±), a < b â†” a < b",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_1",
   "String.toSubstring'"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} â†’ {b : Sort v} â†’ a â†’ Â¬a â†’ b",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedSemiring",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedSemiring",
  "constType": "LinearOrderedSemiring â„•",
  "constCategory": "Definition"},
 {"references": ["SeqRight", "Unit"],
  "name": "SeqRight.mk",
  "constType":
  "{f : Type u â†’ Type v} â†’ ({Î± Î² : Type u} â†’ f Î± â†’ (Unit â†’ f Î²) â†’ f Î²) â†’ SeqRight f",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{Î± : Type u} â†’ List Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Mathlib.Logic.Basic._auxLemma.32",
   "Set",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Set.range",
   "And",
   "Iff",
   "of_eq_true",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.exists_range_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {p : Î± â†’ Prop}, (âˆƒ a âˆˆ Set.range f, p a) â†” âˆƒ i, p (f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.iUnion",
   "iSup_congr_Prop",
   "Iff",
   "Set",
   "Set.instSupSetSet",
   "Iff.mpr",
   "Eq"],
  "name": "Set.iUnion_congr_Prop",
  "constType":
  "âˆ€ {Î± : Type u_1} {p q : Prop} {fâ‚ : p â†’ Set Î±} {fâ‚‚ : q â†’ Set Î±} (pq : p â†” q),\n  (âˆ€ (x : q), fâ‚ (_ : p) = fâ‚‚ x) â†’ Set.iUnion fâ‚ = Set.iUnion fâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result.ok", "EStateM"],
  "name": "EStateM.get",
  "constType": "{Îµ Ïƒ : Type u} â†’ EStateM Îµ Ïƒ Ïƒ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "GaloisConnection",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "GaloisConnection.dual",
   "Function.comp",
   "Monotone",
   "OrderDual",
   "FunLike.coe",
   "Monotone.dual",
   "Preorder",
   "GaloisConnection.monotone_u",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisConnection.monotone_l",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ Monotone l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.63",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {b : Î²} {f : Î± â†’ Î²} {l : List Î±}, (b âˆˆ List.map f l) = âˆƒ a âˆˆ l, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Array.mkArray1",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node1",
  "constType":
  "Lean.SourceInfo â†’ Lean.SyntaxNodeKind â†’ Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Std.Data.List.Basic._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±},\n  List.Pairwise R (a :: l) = ((âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.out"],
  "name": "Trunc.out",
  "constType": "{Î± : Sort u_1} â†’ Trunc Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Nonempty"],
  "name": "Classical.choice",
  "constType": "{Î± : Sort u} â†’ Nonempty Î± â†’ Î±",
  "constCategory": "Axiom"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_10",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "GaloisInsertion.gc",
   "Set",
   "LE.le.trans",
   "Monotone.mem_upperBounds_image",
   "Preorder",
   "GaloisConnection.monotone_u",
   "And.left",
   "GaloisInsertion",
   "IsLUB",
   "Set.instMembershipSet",
   "GaloisConnection.l_le",
   "And.right",
   "upperBounds",
   "GaloisInsertion.le_l_u",
   "GaloisConnection.monotone_l",
   "lowerBounds",
   "And.intro",
   "Set.image",
   "Set.mem_image_of_mem"],
  "name": "GaloisInsertion.isLUB_of_u_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : Preorder Î±] [inst_1 : Preorder Î²],\n  GaloisInsertion l u â†’ âˆ€ {s : Set Î²} {a : Î±}, IsLUB (u '' s) a â†’ IsLUB s (l a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termð“[_]_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.Sublist",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ List Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Set",
  "constType": "Type u â†’ Type u",
  "constCategory": "Definition"},
 {"references": ["List", "List.Mem", "Membership.mk", "Membership"],
  "name": "List.instMembershipList",
  "constType": "{Î± : Type u} â†’ Membership Î± (List Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Eq.ndrec", "Bool", "Bool.noConfusionType", "Eq"],
  "name": "Bool.noConfusion",
  "constType":
  "{P : Sort u} â†’ {v1 v2 : Bool} â†’ v1 = v2 â†’ Bool.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ HPow Î± Î² Î³",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.symm",
   "List.Perm",
   "List",
   "List.nil",
   "List.Perm.eq_nil",
   "Eq.symm",
   "Eq"],
  "name": "List.Perm.nil_eq",
  "constType": "âˆ€ {Î± : Type uu} {l : List Î±}, [] ~ l â†’ [] = l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[_]_Â»._closed_4"],
  "name": "Topology.Â«termð“[_]_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Iff",
   "Iff.rfl",
   "Eq.rec",
   "Set",
   "Filter.generate",
   "Filter",
   "Filter.mkOfClosure",
   "Filter.ext",
   "Eq.symm",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure_sets",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set (Set Î±)} {hs : (Filter.generate s).sets = s}, Filter.mkOfClosure s hs = Filter.generate s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Setoid.r",
   "Iff",
   "List",
   "List.mem_pmap",
   "List.isSetoid",
   "Multiset",
   "Multiset.pmap",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Quot.mk",
   "Eq"],
  "name": "Multiset.mem_pmap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type v} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {s : Multiset Î±} {H : âˆ€ a âˆˆ s, p a} {b : Î²},\n  b âˆˆ Multiset.pmap f s H â†” âˆƒ a, âˆƒ (h : a âˆˆ s), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "Bot.bot",
   "IsCompl.disjoint",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "OrderBot.toBot",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "Lattice",
   "Disjoint.eq_bot",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "Eq",
   "BoundedOrder"],
  "name": "IsCompl.inf_eq_bot",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, IsCompl x y â†’ x âŠ“ y = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "not_and_or", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Prod._auxLemma.18",
  "constType": "âˆ€ {a b : Prop}, (Â¬(a âˆ§ b)) = (Â¬a âˆ¨ Â¬b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "And",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Eq",
   "Set.prod_nonempty_iff"],
  "name": "Mathlib.Data.Set.Prod._auxLemma.27",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, Set.Nonempty (s Ã—Ë¢ t) = (Set.Nonempty s âˆ§ Set.Nonempty t)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
  "constCategory": "Axiom"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "List.Mem.head",
   "List.Mem.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "List.append_of_mem.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} (motive : (l : List Î±) â†’ a âˆˆ l â†’ Prop) (l : List Î±) (x : a âˆˆ l),\n  (âˆ€ (l : List Î±), motive (a :: l) (_ : List.Mem a (a :: l))) â†’\n    (âˆ€ (b : Î±) (as : List Î±) (h : List.Mem a as), motive (b :: as) (_ : List.Mem a (b :: as))) â†’ motive l x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.hasMacroScopes.match_1",
  "constType":
  "(motive : Lean.Name â†’ Sort u_1) â†’\n  (x : Lean.Name) â†’\n    ((pre : Lean.Name) â†’ (s : String) â†’ motive (Lean.Name.str pre s)) â†’\n      ((p : Lean.Name) â†’ (i : â„•) â†’ motive (Lean.Name.num p i)) â†’ ((x : Lean.Name) â†’ motive x) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.4",
  "constType": "âˆ€ {Î± : Type u} [inst : LE Î±] {a b : Î±}, (a â‰¥ b) = (b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "List.cons",
   "Iff",
   "List.forall_mem_cons.match_1",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "List.Mem",
   "List.Mem.head",
   "And.intro",
   "List.forall_mem_cons.match_2"],
  "name": "List.forall_mem_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {a : Î±} {l : List Î±}, (âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["UpperSet.instSetLikeUpperSet",
   "LE",
   "IsUpperSet",
   "UpperSet.upper'",
   "UpperSet",
   "SetLike.coe"],
  "name": "UpperSet.upper",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] (s : UpperSet Î±), IsUpperSet â†‘s",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.casesOn",
   "Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.noConfusionType",
  "constType":
  "{Î± : Type u_1} â†’\n  {t : TopologicalSpace Î±} â†’ {inst : Preorder Î±} â†’ Sort u â†’ Topology.IsUpper Î± â†’ Topology.IsUpper Î± â†’ Sort u",
  "constCategory": "Definition"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.allEq",
  "constType": "âˆ€ {Î± : Sort u} [self : Subsingleton Î±] (a b : Î±), a = b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.eq_sInf_of_mem_iff_exists_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {S : Set (Filter Î±)} (x : Set Î±) (motive : (âˆƒ f âˆˆ S, x âˆˆ f) â†’ Prop) (x_1 : âˆƒ f âˆˆ S, x âˆˆ f),\n  (âˆ€ (w : Filter Î±) (hf : w âˆˆ S) (hs : x âˆˆ w), motive (_ : âˆƒ f âˆˆ S, x âˆˆ f)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "Multiset.Nodup.map_on",
   "Function.Injective",
   "Multiset",
   "Multiset.Nodup",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.Nodup.map",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s : Multiset Î±},\n  Function.Injective f â†’ Multiset.Nodup s â†’ Multiset.Nodup (Multiset.map f s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Macro.Context",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.removeNeutrals.loop.match_2",
  "constType":
  "(motive : List â„• â†’ Sort u_1) â†’\n  (x : List â„•) â†’ ((x : â„•) â†’ (xs : List â„•) â†’ motive (x :: xs)) â†’ (Unit â†’ motive []) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.mk",
   "Finset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.Subtype.fintype",
  "constType": "{Î± : Type u_1} â†’ (s : Finset Î±) â†’ Fintype { x // x âˆˆ s }",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "sInfHom.toFun",
   "sInfHomClass.mk",
   "sInfHom.instSInfHomClassSInfHom.proof_1",
   "sInfHom.map_sInf'",
   "FunLike.mk",
   "InfSet",
   "sInfHomClass"],
  "name": "sInfHom.instSInfHomClassSInfHom",
  "constType":
  "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : InfSet Î±] â†’ [inst_1 : InfSet Î²] â†’ sInfHomClass (sInfHom Î± Î²) Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "List.Perm.cons_inv",
   "List.cons",
   "Iff",
   "List.Perm",
   "List",
   "List.Perm.cons"],
  "name": "List.perm_cons",
  "constType":
  "âˆ€ {Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : List Î±}, a :: lâ‚ ~ a :: lâ‚‚ â†” lâ‚ ~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "BEq",
   "LawfulBEq",
   "of_decide_eq_true",
   "Eq.refl",
   "ne_eq",
   "instDecidableIff",
   "Eq",
   "beq_iff_eq",
   "Eq.mpr",
   "BEq.beq",
   "Bool.casesOn",
   "Iff",
   "Eq.ndrec",
   "instDecidableNot",
   "Bool.false",
   "propext",
   "Bool.true",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableEqBool",
   "id"],
  "name": "beq_eq_false_iff_ne",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] (a b : Î±), (a == b) = false â†” a â‰  b",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "Top.top",
   "HNot.hnot",
   "SDiff.sdiff",
   "BiheytingAlgebra.toSDiff",
   "BiheytingAlgebra.toHNot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toTop",
   "Eq"],
  "name": "BiheytingAlgebra.top_sdiff",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : BiheytingAlgebra Î±] (a : Î±), âŠ¤ \\ a = ï¿¢a",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Inhabited",
   "Set",
   "Set.instEmptyCollectionSet",
   "Inhabited.mk"],
  "name": "Set.instInhabitedSet",
  "constType": "{Î± : Type u} â†’ Inhabited (Set Î±)",
  "constCategory": "Definition"},
 {"references": ["outParam", "EStateM.Backtrackable"],
  "name": "EStateM.Backtrackable.restore",
  "constType":
  "{Î´ : outParam (Type u)} â†’ {Ïƒ : Type u} â†’ [self : EStateM.Backtrackable Î´ Ïƒ] â†’ Ïƒ â†’ Î´ â†’ Ïƒ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop â†’ Prop â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["InfSet.mk",
   "Prod.snd",
   "Prod.mk",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "Prod",
   "Prod.fst",
   "Set.image"],
  "name": "Prod.infSet",
  "constType":
  "(Î± : Type u_1) â†’ (Î² : Type u_2) â†’ [inst : InfSet Î±] â†’ [inst : InfSet Î²] â†’ InfSet (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GE.ge",
   "Mathlib.Order.Basic._auxLemma.4",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "sup_of_le_left",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congrFun"],
  "name": "sup_inf_self",
  "constType": "âˆ€ {Î± : Type u} [inst : Lattice Î±] {a b : Î±}, a âŠ” a âŠ“ b = a",
  "constCategory": "Theorem"},
 {"references": ["Char", "List", "String.mk", "String", "congrArg", "Eq"],
  "name": "String.decEq.proof_1",
  "constType":
  "âˆ€ (sâ‚ sâ‚‚ : List Char), sâ‚ = sâ‚‚ â†’ { data := sâ‚ } = { data := sâ‚‚ }",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousMapClass.map_continuous",
   "Function.comp",
   "Continuous",
   "TopologicalSpace",
   "FunLike.coe",
   "Continuous.comp'",
   "ContinuousMap",
   "ContinuousMap.toContinuousMapClass",
   "ContinuousMapClass.toFunLike",
   "id"],
  "name": "ContinuousMap.comp.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] (f : C(Î², Î³)) (g : C(Î±, Î²)), Continuous (â†‘f âˆ˜ â†‘g)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List.rec", "List", "List.nil"],
  "name": "List.casesOn",
  "constType":
  "{Î± : Type u} â†’\n  {motive : List Î± â†’ Sort u_1} â†’\n    (t : List Î±) â†’ motive [] â†’ ((head : Î±) â†’ (tail : List Î±) â†’ motive (head :: tail)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "Set.ball_image_of_ball",
   "Set",
   "Monotone",
   "Set.image",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Monotone.mem_upperBounds_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Monotone f â†’ âˆ€ {a : Î±} {s : Set Î±}, a âˆˆ upperBounds s â†’ f a âˆˆ upperBounds (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "Preorder.le_refl",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a : TopologicalSpace Î±), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "cond",
   "False",
   "Eq.refl",
   "eq_true_of_decide",
   "eq_false_of_decide",
   "instDecidableTrue",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "instDecidableFalse",
   "Bool.casesOn",
   "Eq.ndrec",
   "of_eq_true",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "instDecidableEqBool"],
  "name": "Bool.cond_eq_ite",
  "constType":
  "âˆ€ {Î± : Type u_1} (b : Bool) (t e : Î±), (bif b then t else e) = if b = true then t else e",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set",
   "Singleton.singleton",
   "rfl",
   "Set.instMembershipSet"],
  "name": "Set.mem_singleton",
  "constType": "âˆ€ {Î± : Type u} (a : Î±), a âˆˆ {a}",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.hasDecEq.match_3",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ List Î± â†’ Sort u_2) â†’\n    (x x_1 : List Î±) â†’\n      (Unit â†’ motive [] []) â†’\n        ((head : Î±) â†’ (tail : List Î±) â†’ motive (head :: tail) []) â†’\n          ((head : Î±) â†’ (tail : List Î±) â†’ motive [] (head :: tail)) â†’\n            ((a : Î±) â†’ (as : List Î±) â†’ (b : Î±) â†’ (bs : List Î±) â†’ motive (a :: as) (b :: bs)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{Î± : Type u} â†’ [toPreorder : Preorder Î±] â†’ (âˆ€ (a b : Î±), a â‰¤ b â†’ b â‰¤ a â†’ a = b) â†’ PartialOrder Î±",
  "constCategory": "Other"},
 {"references":
  ["Char.val", "UInt32", "Char", "Char.val_eq_of_eq.match_1", "rfl", "Eq"],
  "name": "Char.val_eq_of_eq",
  "constType": "âˆ€ {c d : Char}, c = d â†’ c.val = d.val",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.termð“._closed_4",
   "Topology.termð“._closed_2"],
  "name": "Topology.termð“._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.gt_of_not_le.match_1",
  "constType":
  "âˆ€ {n m : â„•} (motive : m < n âˆ¨ m â‰¥ n â†’ Prop) (x : m < n âˆ¨ m â‰¥ n),\n  (âˆ€ (hâ‚ : m < n), motive (_ : m < n âˆ¨ m â‰¥ n)) â†’ (âˆ€ (hâ‚ : m â‰¥ n), motive (_ : m < n âˆ¨ m â‰¥ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Acc.intro", "Acc"],
  "name": "Acc.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : (a : Î±) â†’ Acc r a â†’ Sort u_1} â†’\n      ((x : Î±) â†’\n          (h : âˆ€ (y : Î±), r y x â†’ Acc r y) â†’\n            ((y : Î±) â†’ (a : r y x) â†’ motive y (_ : Acc r y)) â†’ motive x (_ : Acc r x)) â†’\n        {a : Î±} â†’ (t : Acc r a) â†’ motive a t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.sUnion",
   "Set.instMembershipSet"],
  "name": "Set.mem_sUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {S : Set (Set Î±)}, x âˆˆ â‹ƒâ‚€ S â†” âˆƒ t âˆˆ S, x âˆˆ t",
  "constCategory": "Theorem"},
 {"references": ["Nat.rec", "Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : â„• â†’ Sort u} â†’ (t : â„•) â†’ motive Nat.zero â†’ ((n : â„•) â†’ motive (Nat.succ n)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "List.Mem.tail",
   "List.casesOn",
   "List.Mem",
   "Eq.refl",
   "Eq",
   "HEq.refl",
   "List",
   "Bool.true",
   "List.Mem.head",
   "List.Mem.casesOn",
   "Bool",
   "List.nil",
   "List.noConfusion"],
  "name": "List.exists_of_eraseP.match_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} (motive : (x : List Î±) â†’ (x_1 : Î±) â†’ x_1 âˆˆ x â†’ p x_1 = true â†’ Prop) (x : List Î±)\n  (x_1 : Î±) (x_2 : x_1 âˆˆ x) (x_3 : p x_1 = true),\n  (âˆ€ (b : Î±) (l : List Î±) (a : Î±) (al : a âˆˆ b :: l) (pa : p a = true), motive (b :: l) a al pa) â†’ motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "False", "List", "Not", "List.noConfusion", "absurd", "Eq"],
  "name": "List.hasDecEq.proof_6",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (as : List Î±) (b : Î±) (bs : List Î±), Â¬a = b â†’ a :: as = b :: bs â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec", "List", "Eq.refl", "List.casesOn", "List.noConfusionType", "Eq"],
  "name": "List.noConfusion",
  "constType":
  "{Î± : Type u} â†’ {P : Sort u_1} â†’ {v1 v2 : List Î±} â†’ v1 = v2 â†’ List.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.mk",
  "constType":
  "{Î± : Type u} â†’ [inst : LE Î±] â†’ [toBot : Bot Î±] â†’ (âˆ€ (a : Î±), âŠ¥ â‰¤ a) â†’ OrderBot Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "lowerBounds",
   "Preorder",
   "Set.instMembershipSet"],
  "name": "IsLeast",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1"],
  "name": "List.map",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ List Î± â†’ List Î²",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "OrderDual.ofDual_toDual",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toAddCommMonoid : AddCommMonoid Î±] â†’\n    [toPartialOrder : PartialOrder Î±] â†’\n      (âˆ€ (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c + a â‰¤ c + b) â†’\n        (âˆ€ (a b c : Î±), a + b â‰¤ a + c â†’ b â‰¤ c) â†’ OrderedCancelAddCommMonoid Î±",
  "constCategory": "Other"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Std.Data.List.Count._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "Sup",
   "Continuous",
   "TopologicalSpace",
   "Sup.sup",
   "Prod",
   "Prod.fst",
   "ContinuousSup"],
  "name": "ContinuousSup.mk",
  "constType":
  "âˆ€ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L], (Continuous fun p â†¦ p.1 âŠ” p.2) â†’ ContinuousSup L",
  "constCategory": "Other"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "Nat.decLt",
   "Eq.refl",
   "Classical.em",
   "instLTNat",
   "True",
   "ite",
   "Eq",
   "Lean.Data.AC.Context.assoc",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.List.two_step_induction",
   "List.nil",
   "Nat",
   "Eq.trans",
   "if_neg",
   "id",
   "eq_self",
   "List.cons",
   "Or",
   "False",
   "Lean.Data.AC.insert",
   "Or.casesOn",
   "ite_congr",
   "instDecidableFalse",
   "Lean.Data.AC.Context.op",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "of_eq_true",
   "List",
   "LT.lt",
   "Lean.IsCommutative",
   "Eq.mp",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Not",
   "congrArg",
   "Lean.IsCommutative.comm",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_insert",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±),\n  Lean.IsCommutative ctx.op â†’\n    âˆ€ (x : â„•) (xs : List â„•),\n      Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.insert x xs) = Lean.Data.AC.evalList Î± ctx (x :: xs)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.zero_add",
  "constType": "âˆ€ (n : â„•), 0 + n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Variable",
   "Lean.Data.AC.Context",
   "List"],
  "name": "Lean.Data.AC.Context.vars",
  "constType":
  "{Î± : Sort u} â†’ (self : Lean.Data.AC.Context Î±) â†’ List (Lean.Data.AC.Variable self.op)",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_1",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_2",
   "GeneralizedBooleanAlgebra",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toBot",
   "GeneralizedBooleanAlgebra.mk",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra",
  "constType":
  "{Î± : Type u} â†’ [inst : BooleanAlgebra Î±] â†’ GeneralizedBooleanAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Topology.Basic._auxLemma.43",
   "funext",
   "nhds",
   "Set",
   "Set.Nonempty",
   "Eq.refl",
   "Inter.inter",
   "Mathlib.Topology.Basic._auxLemma.42",
   "implies_congr",
   "ClusterPt",
   "Filter.Frequently",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Topology.Basic._auxLemma.41",
   "Filter.principal",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "TopologicalSpace",
   "congr",
   "Filter",
   "congrArg",
   "Eq.trans",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "clusterPt_principal_iff_frequently",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {x : Î±} {s : Set Î±},\n  ClusterPt x (Filter.principal s) â†” âˆƒá¶  (y : Î±) in nhds x, y âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} â†’ [self : AddSemigroup G] â†’ Add G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Inf.inf",
   "SupSet.sSup",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet"],
  "name": "CompleteAtomicBooleanAlgebra.inf_sSup_le_iSup_inf",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpper", "Nonempty"],
  "name": "Topology.WithUpper.instNonemptyWithUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Nonempty Î±], Nonempty (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Applicative",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) {x : Î±} {a : Set Î±}, x âˆˆ a â†’ f x âˆˆ f '' a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "setOf",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "UpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Set.Finite",
   "SetLike.coe",
   "Eq"],
  "name": "Topology.IsLower.lowerBasis",
  "constType": "(Î± : Type u_1) â†’ [inst : Preorder Î±] â†’ Set (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : â„•) â†’ Decidable (n â‰¤ m)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "âˆ€ {Î± : Sort u} {a b : Î±}, a = b â†’ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["List",
   "Lean.SourceInfo",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax",
   "Substring"],
  "name": "Lean.Syntax.ident",
  "constType":
  "Lean.SourceInfo â†’ Substring â†’ Lean.Name â†’ List Lean.Syntax.Preresolved â†’ Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["BEq.beq",
   "List.Perm",
   "DecidableEq",
   "List",
   "instBEq",
   "List.Perm.countP_eq",
   "Nat",
   "List.count",
   "Eq"],
  "name": "List.Perm.count_eq",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ âˆ€ (a : Î±), List.count a lâ‚ = List.count a lâ‚‚",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "TopologicalSpace",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[<]_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add_assoc.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ â„• â†’ â„• â†’ Prop) (x x_1 x_2 : â„•),\n  (âˆ€ (x x_3 : â„•), motive x x_3 0) â†’ (âˆ€ (n m k : â„•), motive n m (Nat.succ k)) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Option.casesOn",
   "Option"],
  "name": "List.filterMap_cons.match_1",
  "constType":
  "{Î² : Type u_1} â†’\n  (motive : Option Î² â†’ Sort u_2) â†’ (x : Option Î²) â†’ (Unit â†’ motive none) â†’ ((b : Î²) â†’ motive (some b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedCoheytingAlgebra",
   "Sup.sup",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.sdiff_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : GeneralizedCoheytingAlgebra Î±] (a b c : Î±), a \\ b â‰¤ c â†” a â‰¤ b âŠ” c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.instPreorderProd",
   "inferInstanceAs",
   "Prod",
   "Preorder.le_trans",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Prod.instPartialOrder.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (a b c : Î± Ã— Î²), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "forall_eq_or_imp", "propext", "Eq"],
  "name": "Mathlib.Data.List.Chain._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' âˆ¨ q a â†’ p a) = (p a' âˆ§ âˆ€ (a : Î±), q a â†’ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "interior",
   "IsOpen",
   "Set.subset_sUnion_of_mem"],
  "name": "interior_maximal",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, t âŠ† s â†’ IsOpen t â†’ t âŠ† interior s",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "HPow.hPow",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Eq.refl",
   "HMul.hMul",
   "Nat.pow_succ",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "id",
   "Eq"],
  "name": "Nat.pow_succ'",
  "constType": "âˆ€ {m n : â„•}, m ^ Nat.succ n = m * m ^ n",
  "constCategory": "Theorem"},
 {"references": ["forall_true_iff", "propext", "True", "Eq"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.19",
  "constType": "âˆ€ {Î± : Sort u_2}, (Î± â†’ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Lattice._auxLemma.12",
   "and_true",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_of_le_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, b â‰¤ a â†’ a âŠ“ b = b",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "âˆ€ {a : Prop}, a â†” a",
  "constCategory": "Theorem"},
 {"references":
  ["MonadReaderOf", "Monad", "ReaderT", "ReaderT.read", "MonadReaderOf.mk"],
  "name": "instMonadReaderOfReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ MonadReaderOf Ï (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ DecidableRel fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_4",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.EvalInformation", "Nat"],
  "name": "Lean.Data.AC.EvalInformation.mk",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ (Î± â†’ Î²) â†’ (Î± â†’ Î² â†’ Î² â†’ Î²) â†’ (Î± â†’ â„• â†’ Î²) â†’ Lean.Data.AC.EvalInformation Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "List.instMembershipList",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "instLTNat",
   "Eq",
   "List.mem_range'_1",
   "And",
   "instLENat",
   "propext",
   "List",
   "LT.lt",
   "instOfNatNat",
   "Nat"],
  "name": "Std.Data.List.Lemmas._auxLemma.108",
  "constType": "âˆ€ {m s n : â„•}, (m âˆˆ List.range' s n) = (s â‰¤ m âˆ§ m < s + n)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteLattice Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termÎ©._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Array", "List"],
  "name": "Array.data",
  "constType": "{Î± : Type u} â†’ Array Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "LE.le",
   "Pi.semilatticeInf",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.lattice.proof_4",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î±' i)] (a b : (i : Î¹) â†’ Î±' i), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.liftâ‚‚.proof_1",
   "Quotient.lift",
   "Quotient",
   "HasEquiv.Equiv",
   "Quotient.liftâ‚‚.proof_2",
   "Eq"],
  "name": "Quotient.liftâ‚‚",
  "constType":
  "{Î± : Sort uA} â†’\n  {Î² : Sort uB} â†’\n    {Ï† : Sort uC} â†’\n      {sâ‚ : Setoid Î±} â†’\n        {sâ‚‚ : Setoid Î²} â†’\n          (f : Î± â†’ Î² â†’ Ï†) â†’\n            (âˆ€ (aâ‚ : Î±) (bâ‚ : Î²) (aâ‚‚ : Î±) (bâ‚‚ : Î²), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ f aâ‚ bâ‚ = f aâ‚‚ bâ‚‚) â†’\n              Quotient sâ‚ â†’ Quotient sâ‚‚ â†’ Ï†",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "sup_of_le_right",
   "Sup.sup",
   "OrderBot",
   "bot_le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "bot_sup_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : OrderBot Î±] {a : Î±}, âŠ¥ âŠ” a = a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.orderBot",
   "Topology.instIsLowerProd",
   "OrderDual.instPreorder",
   "Topology.IsLower.topology_eq_lowerTopology",
   "instTopologicalSpaceProd",
   "Prod.instPreorderProd",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "OrderTop",
   "TopologicalSpace",
   "Prod",
   "instTopologicalSpaceOrderDual",
   "Topology.IsUpper.mk",
   "Preorder",
   "Preorder.toLE"],
  "name": "Topology.instIsUpperProd.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±]\n  [inst_3 : OrderTop Î±] [inst_4 : Preorder Î²] [inst_5 : TopologicalSpace Î²] [inst_6 : Topology.IsUpper Î²]\n  [inst_7 : OrderTop Î²], Topology.IsUpper (Î± Ã— Î²)",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "flip"],
  "name": "imp.swap",
  "constType":
  "âˆ€ {a : Sort u_1} {b : Sort u_2} {c : Prop}, a â†’ b â†’ c â†” b â†’ a â†’ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.exists_subset_inter",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’ âˆ€ tâ‚ âˆˆ s, âˆ€ tâ‚‚ âˆˆ s, âˆ€ x âˆˆ tâ‚ âˆ© tâ‚‚, âˆƒ tâ‚ƒ âˆˆ s, x âˆˆ tâ‚ƒ âˆ§ tâ‚ƒ âŠ† tâ‚ âˆ© tâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.finRange.proof_1",
   "List.pmap",
   "List.mem_range",
   "List.instMembershipList",
   "Fin.val",
   "List.mem_pmap",
   "Eq.refl",
   "Exists.intro",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "List.finRange",
   "Nat",
   "Eq.symm",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "Fin.casesOn",
   "List.range"],
  "name": "List.mem_finRange",
  "constType": "âˆ€ {n : â„•} (a : Fin n), a âˆˆ List.finRange n",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "TopologicalSpace.isOpen_univ",
   "TopologicalSpace.coinduced.proof_2",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.coinduced.proof_1",
   "IsOpen"],
  "name": "TopologicalSpace.coinduced",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ TopologicalSpace Î± â†’ TopologicalSpace Î²",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_1",
  "constType": "âˆ€ (a : â„•), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.MacroScopesView", "Lean.Name"],
  "name": "Lean.MacroScopesView.mainModule",
  "constType": "Lean.MacroScopesView â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "HeytingAlgebra.bot_le",
  "constType": "âˆ€ {Î± : Type u_4} [self : HeytingAlgebra Î±] (a : Î±), âŠ¥ â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Set",
   "Set.univ",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Iff",
   "Set.iUnion",
   "of_eq_true",
   "forall_congr",
   "Mathlib.Data.Set.Lattice._auxLemma.28",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnionâ‚‚_eq_univ_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Îº : Î¹ â†’ Sort u_7} {s : (i : Î¹) â†’ Îº i â†’ Set Î±},\n  â‹ƒ i, â‹ƒ j, s i j = Set.univ â†” âˆ€ (a : Î±), âˆƒ i, âˆƒ j, a âˆˆ s i j",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Prod.snd",
   "Iff.rfl",
   "LT.lt",
   "Not",
   "Prod",
   "Prod.fst",
   "LT.mk",
   "Preorder"],
  "name": "Prod.instPreorderProd.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Preorder Î±] [inst_1 : Preorder Î²] (a b : Î± Ã— Î²), a < b â†” a < b",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpper.toUpper._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "Function.Injective"],
  "name": "FunLike.mk",
  "constType":
  "{F : Sort u_1} â†’\n  {Î± : outParam (Sort u_2)} â†’\n    {Î² : outParam (Î± â†’ Sort u_3)} â†’ (coe : F â†’ (a : Î±) â†’ Î² a) â†’ Function.Injective coe â†’ FunLike F Î± Î²",
  "constCategory": "Other"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded.intro",
   "OfNat.ofNat",
   "Or",
   "Nat.lt_wfRel.match_1",
   "Nat.lt",
   "Acc",
   "instLTNat",
   "Eq",
   "Nat.rec",
   "Eq.ndrec",
   "Nat.le_of_succ_le_succ",
   "Acc.inv",
   "LT.lt",
   "WellFounded",
   "instOfNatNat",
   "Nat",
   "Acc.intro",
   "absurd",
   "Nat.not_lt_zero",
   "Nat.succ",
   "Nat.eq_or_lt_of_le"],
  "name": "Nat.lt_wfRel.proof_1",
  "constType": "WellFounded Nat.lt",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context",
   "Lean.IsIdempotent",
   "Option"],
  "name": "Lean.Data.AC.Context.idem",
  "constType":
  "{Î± : Sort u} â†’ (self : Lean.Data.AC.Context Î±) â†’ Option (Lean.IsIdempotent self.op)",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "funext",
   "Iff.rfl",
   "TopologicalSpace.ext",
   "Set",
   "Topology.lowerSet",
   "Eq.refl",
   "Topology.upperSet",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq",
   "Topology.IsLowerSet.mk",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "TopologicalSpace",
   "OrderDual",
   "Topology.IsUpperSet.topology_eq",
   "IsOpen",
   "id"],
  "name": "OrderDual.instIsLowerSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±],\n  Topology.IsLowerSet Î±áµ’áµˆ",
  "constCategory": "Theorem"},
 {"references": ["False", "Not", "id"],
  "name": "not_false",
  "constType": "Â¬False",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Inf.inf",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "Eq"],
  "name": "GeneralizedBooleanAlgebra.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toDistribLattice : DistribLattice Î±] â†’\n    [toSDiff : SDiff Î±] â†’\n      [toBot : Bot Î±] â†’\n        (âˆ€ (a b : Î±), a âŠ“ b âŠ” a \\ b = a) â†’ (âˆ€ (a b : Î±), a âŠ“ b âŠ“ a \\ b = âŠ¥) â†’ GeneralizedBooleanAlgebra Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "HEq",
   "List.instMembershipList",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Sublist.slnil",
   "List.Pairwise.cons",
   "Eq",
   "List.Pairwise",
   "List.Pairwise.casesOn",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.below.consâ‚‚",
   "List.Sublist.consâ‚‚",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Pairwise.sublist.match_1._@.Std.Data.List.Lemmas._hyg.28830",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop}\n  (motive : (lâ‚‚ lâ‚ : List Î±) â†’ (x : List.Sublist lâ‚ lâ‚‚) â†’ List.Pairwise R lâ‚‚ â†’ List.Sublist.below x â†’ Prop)\n  (lâ‚‚ lâ‚ : List Î±) (x : List.Sublist lâ‚ lâ‚‚) (x_1 : List.Pairwise R lâ‚‚) (h_below : List.Sublist.below x),\n  (âˆ€ (h : List.Pairwise R []),\n      motive [] [] (_ : List.Sublist [] []) h (_ : List.Sublist.below (_ : List.Sublist [] []))) â†’\n    (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (s : List.Sublist lâ‚ lâ‚‚) (a_1 : âˆ€ a' âˆˆ lâ‚‚, R a a') (hâ‚‚ : List.Pairwise R lâ‚‚)\n        (h : List.Sublist.below s) (a_2 : âˆ€ {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R lâ‚‚ â†’ List.Pairwise R lâ‚),\n        motive (a :: lâ‚‚) lâ‚ (_ : List.Sublist lâ‚ (a :: lâ‚‚)) (_ : List.Pairwise R (a :: lâ‚‚))\n          (_ : List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚)))) â†’\n      (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (s : List.Sublist lâ‚ lâ‚‚) (hâ‚ : âˆ€ a' âˆˆ lâ‚‚, R a a') (hâ‚‚ : List.Pairwise R lâ‚‚)\n          (h : List.Sublist.below s) (a_1 : âˆ€ {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R lâ‚‚ â†’ List.Pairwise R lâ‚),\n          motive (a :: lâ‚‚) (a :: lâ‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)) (_ : List.Pairwise R (a :: lâ‚‚))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n        motive lâ‚‚ lâ‚ x x_1 h_below",
  "constCategory": "Definition"},
 {"references":
  ["Function.Surjective",
   "compl_involutive",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Function.Involutive.surjective",
   "BooleanAlgebra"],
  "name": "compl_surjective",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BooleanAlgebra Î±], Function.Surjective compl",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "False",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.ne_of_beq_eq_false.match_1",
   "Nat.zero",
   "Bool.false",
   "Nat.noConfusion",
   "PUnit",
   "Not",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.ne_of_beq_eq_false",
  "constType": "âˆ€ {n m : â„•}, Nat.beq n m = false â†’ Â¬n = m",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Nat.le.refl", "Nat", "LE.le"],
  "name": "Nat.le_refl",
  "constType": "âˆ€ (n : â„•), n â‰¤ n",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "compl_le_compl",
   "compl_compl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Iff.intro",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Iff",
   "Eq.mp",
   "congr",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "congrArg",
   "HeytingAlgebra.toHasCompl"],
  "name": "compl_le_compl_iff_le",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : BooleanAlgebra Î±], yá¶œ â‰¤ xá¶œ â†” x â‰¤ y",
  "constCategory": "Theorem"},
 {"references": ["Quot", "Quot.mk"],
  "name": "Quot.ind",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {Î² : Quot r â†’ Prop}, (âˆ€ (a : Î±), Î² (Quot.mk r a)) â†’ âˆ€ (q : Quot r), Î² q",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Data.AC.Variable",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["true_and",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_eq_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, a âŠ“ b = a â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "ContravariantClass",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "ContravariantClass.mk",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.to_contravariantClass_le_left.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±], ContravariantClass Î± Î± (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Nonempty.intro",
   "Exists",
   "Iff",
   "nonempty_subtype.match_1",
   "nonempty_subtype.match_2",
   "Exists.intro",
   "Subtype.mk",
   "Subtype",
   "Nonempty"],
  "name": "nonempty_subtype",
  "constType":
  "âˆ€ {Î± : Sort u_2} {p : Î± â†’ Prop}, Nonempty (Subtype p) â†” âˆƒ a, p a",
  "constCategory": "Theorem"},
 {"references":
  ["not_and_of_not_or_not",
   "Iff.intro",
   "And",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Decidable",
   "dite",
   "Not",
   "And.intro"],
  "name": "Decidable.not_and",
  "constType": "âˆ€ {a b : Prop} [inst : Decidable a], Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteSemilatticeInf",
  "constType": "Type u_9 â†’ Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Filter.GenerateSets.inter",
   "setOf",
   "Filter.GenerateSets",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ"],
  "name": "Filter.generate",
  "constType": "{Î± : Type u} â†’ Set (Set Î±) â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references": ["Set", "LE", "UpperSet"],
  "name": "UpperSet.carrier",
  "constType": "{Î± : Type u_6} â†’ [inst : LE Î±] â†’ UpperSet Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet", "Preorder"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Equiv.toHomeomorphOfInducing",
   "Topology.WithUpperSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Topology.IsUpperSet",
   "Equiv.refl",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsUpperSet Î±] â†’ Topology.WithUpperSet Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.map_le_iff_le_comap",
   "PartialOrder.toPreorder",
   "Filter.map_map",
   "Function.comp",
   "Eq.refl",
   "LE.le",
   "Filter.Tendsto.comp",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Filter.tendsto_comap",
   "Iff.mp",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter",
   "Filter.Tendsto",
   "id"],
  "name": "Filter.tendsto_comap_iff",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {f : Î± â†’ Î²} {g : Î² â†’ Î³} {a : Filter Î±} {c : Filter Î³},\n  Filter.Tendsto f a (Filter.comap g c) â†” Filter.Tendsto (g âˆ˜ f) a c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le.match_1",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "And.intro",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "lt_of_le_not_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "DistribLattice",
   "Prop.heytingAlgebra",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "DistribLattice.mk",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "Not",
   "And.intro",
   "And.casesOn",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice"],
  "name": "Prop.booleanAlgebra.match_1",
  "constType":
  "âˆ€ (p : Prop),\n  let src := Prop.heytingAlgebra;\n  let src_1 := GeneralizedHeytingAlgebra.toDistribLattice;\n  âˆ€ (motive : p âŠ“ pá¶œ â†’ Prop) (x : p âŠ“ pá¶œ), (âˆ€ (Hp : p) (Hpc : pá¶œ), motive (_ : p âˆ§ pá¶œ)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddLeftCancelMonoid.add_zero",
   "AddCommMonoid.mk",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddCancelCommMonoid.add_comm",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddMonoid.mk",
   "AddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCommMonoid",
  "constType":
  "{M : Type u} â†’ [self : AddCancelCommMonoid M] â†’ AddCommMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Nat.instModNat",
   "OfNat.ofNat",
   "instHMod",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMod.hMod",
   "instOfNatNat",
   "Fin.ofNat.proof_1",
   "Nat",
   "Nat.succ",
   "Fin",
   "Fin.mk"],
  "name": "Fin.ofNat",
  "constType": "{n : â„•} â†’ â„• â†’ Fin (Nat.succ n)",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.lt_or_ge.match_1",
  "constType":
  "âˆ€ (n m : â„•) (motive : m = n âˆ¨ m < n â†’ Prop) (x : m = n âˆ¨ m < n),\n  (âˆ€ (h1 : m = n), motive (_ : m = n âˆ¨ m < n)) â†’ (âˆ€ (h1 : m < n), motive (_ : m = n âˆ¨ m < n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["semiOutParam", "MonadExceptOf"],
  "name": "MonadExceptOf.throw",
  "constType":
  "{Îµ : semiOutParam (Type u)} â†’ {m : Type v â†’ Type w} â†’ [self : MonadExceptOf Îµ m] â†’ {Î± : Type v} â†’ Îµ â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set.insert_eq",
   "Set",
   "Union.union",
   "Eq.refl",
   "Insert.insert",
   "IsLUB",
   "Eq",
   "SemilatticeSup",
   "Eq.mpr",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "isLUB_singleton",
   "Sup.sup",
   "Singleton.singleton",
   "IsLUB.union",
   "SemilatticeSup.toPartialOrder",
   "Set.instUnionSet",
   "Set.instInsertSet",
   "id"],
  "name": "IsLUB.insert",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] (a : Î³) {b : Î³} {s : Set Î³}, IsLUB s b â†’ IsLUB (insert a s) (a âŠ” b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Finset.Basic._auxLemma.18",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Data.Finset.Basic._auxLemma.4",
   "Set.instMembershipSet",
   "Set.ext",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "Finset.toSet",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.coe_empty",
  "constType": "âˆ€ {Î± : Type u_1}, â†‘âˆ… = âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.instInfFilter.proof_3",
   "Membership.mem",
   "And",
   "Exists",
   "Inf.mk",
   "Filter.instInfFilter.proof_1",
   "setOf",
   "Inf",
   "Filter.mk",
   "Set",
   "Inter.inter",
   "Filter",
   "Filter.instInfFilter.proof_2",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instInfFilter",
  "constType": "{Î± : Type u} â†’ Inf (Filter Î±)",
  "constCategory": "Definition"},
 {"references":
  ["setOf",
   "Set.instBooleanAlgebraSet",
   "Set.preimage",
   "congr_fun",
   "Set.compl_image",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Eq"],
  "name": "Set.compl_image_set_of",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Set Î± â†’ Prop}, compl '' {s | p s} = {s | p sá¶œ}",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Iff.rfl",
   "Inf.inf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "inf_assoc",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "disjoint_iff_inf_le",
   "propext",
   "OrderBot.toBot",
   "SemilatticeInf",
   "id"],
  "name": "disjoint_assoc",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a b c : Î±}, Disjoint (a âŠ“ b) c â†” Disjoint a (b âŠ“ c)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "âˆ€ {a b : Prop}, a â†’ a âˆ¨ b",
  "constCategory": "Other"},
 {"references": ["Equiv"],
  "name": "Equiv.invFun",
  "constType": "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ Î± â‰ƒ Î² â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Prop.heytingAlgebra",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "HasCompl.compl",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "DistribLattice.toLattice",
   "imp_iff_or_not",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "propext",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Not",
   "Lattice.toSemilatticeSup"],
  "name": "Prop.booleanAlgebra.proof_4",
  "constType": "âˆ€ (p q : Prop), p â‡¨ q = q âŠ” pá¶œ",
  "constCategory": "Theorem"},
 {"references": ["Order.Frame", "CompleteDistribLattice"],
  "name": "CompleteDistribLattice.toFrame",
  "constType":
  "{Î± : Type u_1} â†’ [self : CompleteDistribLattice Î±] â†’ Order.Frame Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "List.Perm", "List", "List.Sublist"],
  "name": "List.Subperm",
  "constType": "{Î± : Type uu} â†’ List Î± â†’ List Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "setOf",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "nhds_basis_opens.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] (a : Î±) (t : Set Î±) (motive : t âˆˆ {s | a âˆˆ s âˆ§ IsOpen s} â†’ Prop)\n  (x : t âˆˆ {s | a âˆˆ s âˆ§ IsOpen s}), (âˆ€ (hat : a âˆˆ t) (ht : IsOpen t), motive (_ : a âˆˆ t âˆ§ IsOpen t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "Unit",
   "Eq.refl",
   "List.Mem",
   "instBEq",
   "beq_self_eq_true",
   "List.elem",
   "_private.Init.Data.List.Basic.0.List.erase.match_1.splitter",
   "List.Mem.rec",
   "True",
   "instLawfulBEqInstBEq",
   "Eq",
   "BEq.beq",
   "Eq.ndrec",
   "DecidableEq",
   "of_eq_true",
   "Bool.false",
   "List",
   "Bool.true",
   "Bool",
   "List.erase.match_1",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "id",
   "congrFun"],
  "name": "List.elem_eq_true_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {as : List Î±}, a âˆˆ as â†’ List.elem a as = true",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "Finset.toSet",
   "Set",
   "Set.Finite.exists_finset_coe",
   "Finset",
   "CanLift.mk",
   "Set.Finite"],
  "name": "Set.instCanLiftSetFinsetToSetFinite.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1}, CanLift (Set Î±) (Finset Î±) Finset.toSet Set.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.add_zero",
  "constType": "âˆ€ (n : â„•), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Prod.snd",
   "Prod",
   "And.intro",
   "Prod.fst",
   "Iff.mpr",
   "Prod.ext_iff",
   "Eq"],
  "name": "Prod.ext",
  "constType":
  "âˆ€ {Î± : Type u_5} {Î² : Type u_6} {p q : Î± Ã— Î²}, p.1 = q.1 â†’ p.2 = q.2 â†’ p = q",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero", "ZeroHom", "AddZeroClass", "AddMonoidHom"],
  "name": "AddMonoidHom.toZeroHom",
  "constType":
  "{M : Type u_9} â†’ {N : Type u_10} â†’ [inst : AddZeroClass M] â†’ [inst_1 : AddZeroClass N] â†’ (M â†’+ N) â†’ ZeroHom M N",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "False", "Or.inr", "Or.casesOn", "True", "Eq"],
  "name": "Classical.em.match_1",
  "constType":
  "âˆ€ (p u v : Prop),\n  let U := fun x â†¦ x = True âˆ¨ p;\n  let V := fun x â†¦ x = False âˆ¨ p;\n  âˆ€ (motive : U u â†’ V v â†’ Prop) (u_def : U u) (v_def : V v),\n    (âˆ€ (h : p) (x : V v), motive (_ : u = True âˆ¨ p) x) â†’\n      (âˆ€ (x : U u) (h : p), motive x (_ : v = False âˆ¨ p)) â†’\n        (âˆ€ (hut : u = True) (hvf : v = False), motive (_ : u = True âˆ¨ p) (_ : v = False âˆ¨ p)) â†’ motive u_def v_def",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.decLt",
   "Array.appendCore.loop.match_1",
   "Unit",
   "HAdd.hAdd",
   "Array.get",
   "Array.push",
   "dite",
   "Array.size",
   "instLTNat",
   "Array",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "LT.lt",
   "PUnit",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Fin.mk"],
  "name": "Array.extract.loop",
  "constType": "{Î± : Type u_1} â†’ Array Î± â†’ â„• â†’ â„• â†’ Array Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inf_sup_left",
   "Lattice.mk",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "le_of_eq",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "OrderDual",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Eq.symm"],
  "name": "OrderDual.distribLattice.proof_4",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : DistribLattice Î±] (x x_1 x_2 : Î±áµ’áµˆ), (x âŠ” x_1) âŠ“ (x âŠ” x_2) â‰¤ x âŠ” x_1 âŠ“ x_2",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "GaloisInsertion", "Preorder.toLE"],
  "name": "GaloisInsertion.le_l_u",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisInsertion l u â†’ âˆ€ (x : Î²), x â‰¤ l (u x)",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Union Î±",
  "constCategory": "Other"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "âˆ€ {Î± : Sort u} [h : Subsingleton Î±] (a b : Î±), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Setoid.refl",
   "Quotient.ind",
   "Quotient.lift",
   "Quotient",
   "HasEquiv.Equiv",
   "Eq"],
  "name": "Quotient.liftâ‚‚.proof_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_3} {Ï† : Sort u_2} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} (f : Î± â†’ Î² â†’ Ï†)\n  (c : âˆ€ (aâ‚ : Î±) (bâ‚ : Î²) (aâ‚‚ : Î±) (bâ‚‚ : Î²), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ f aâ‚ bâ‚ = f aâ‚‚ bâ‚‚) (qâ‚‚ : Quotient sâ‚‚) (a b : Î±),\n  a â‰ˆ b â†’\n    (fun aâ‚ â†¦ Quotient.lift (f aâ‚) (_ : âˆ€ (a b : Î²), a â‰ˆ b â†’ f aâ‚ a = f aâ‚ b) qâ‚‚) a =\n      (fun aâ‚ â†¦ Quotient.lift (f aâ‚) (_ : âˆ€ (a b : Î²), a â‰ˆ b â†’ f aâ‚ a = f aâ‚ b) qâ‚‚) b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "Std.Logic._auxLemma.64",
  "constType": "âˆ€ {a : Prop}, (Â¬Â¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq"],
  "name": "coinduced_le_iff_le_induced.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {tÎ² : TopologicalSpace Î²} (_s : Set Î±) (motive : IsOpen _s â†’ Prop)\n  (x : IsOpen _s),\n  (âˆ€ (_t : Set Î²) (ht : IsOpen _t) (hst : f â»Â¹' _t = _s), motive (_ : âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = _s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["GaloisConnection", "GaloisCoinsertion", "Preorder"],
  "name": "GaloisCoinsertion.gc",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisCoinsertion l u â†’ GaloisConnection l u",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "iSup_range",
   "Set",
   "OrderDual.completeLattice",
   "OrderDual",
   "Set.instMembershipSet",
   "Eq"],
  "name": "iInf_range",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {g : Î² â†’ Î±} {f : Î¹ â†’ Î²},\n  â¨… b âˆˆ Set.range f, g b = â¨… i, g (f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "funext",
   "setOf",
   "EmptyCollection.emptyCollection",
   "Set",
   "Mathlib.Order.Bounds.Basic._auxLemma.19",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "upperBounds",
   "Mathlib.Order.Bounds.Basic._auxLemma.18",
   "of_eq_true",
   "Mathlib.Order.Bounds.Basic._auxLemma.17",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "upperBounds_empty",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±], upperBounds âˆ… = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.instInhabitedMacroScopesView",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "List.cons",
   "Lean.MacroScopesView",
   "Lean.Name.num",
   "String",
   "_private.Init.Prelude.0.Lean.extractMainModule",
   "_private.Init.Prelude.0.Lean.extractMacroScopesAux.match_1",
   "Lean.MacroScope",
   "PProd",
   "PProd.fst",
   "Lean.Name.rec",
   "List",
   "PUnit",
   "panic",
   "List.nil",
   "Lean.Name",
   "Nat",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractMacroScopesAux",
  "constType": "Lean.Name â†’ List Lean.MacroScope â†’ Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Mul Î±",
  "constCategory": "Other"},
 {"references":
  ["Set.nonempty_iff_ne_empty",
   "Ne",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Not",
   "Set.instEmptyCollectionSet",
   "or_iff_not_imp_left",
   "Iff.mpr",
   "Eq"],
  "name": "Set.eq_empty_or_nonempty",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±), s = âˆ… âˆ¨ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.finite_coe_iff", "Set.Elem", "Set", "Finite", "Iff.mpr", "Set.Finite"],
  "name": "Set.Finite.to_subtype",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Finite s â†’ Finite â†‘s",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{Î± : Sort u_1} â†’ {Î³ : Sort u_2} â†’ (r : Î± â†’ Î³ â†’ Sort u) â†’ Trans Eq r r",
  "constCategory": "Definition"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.4",
  "constType": "âˆ€ {Î± : Sort u_1} {a b : Î±}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "And.right",
   "setOf",
   "Set",
   "LE.le.trans",
   "Exists.imp",
   "And.intro",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperClosure.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (s : Set Î±) (x x_1 : Î±), x â‰¤ x_1 â†’ x âˆˆ {x | âˆƒ a âˆˆ s, a â‰¤ x} â†’ âˆƒ a âˆˆ s, a â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["sInf_insert",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Insert.insert",
   "Set.sInter",
   "Set.instInterSet",
   "Set.instInsertSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_insert",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set Î±) (T : Set (Set Î±)), â‹‚â‚€ insert s T = s âˆ© â‹‚â‚€ T",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "âˆ€ {p : Prop}, p â†’ p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.GenerateSets", "Set", "Inter.inter", "Set.instInterSet"],
  "name": "Filter.GenerateSets.inter",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {s t : Set Î±},\n  Filter.GenerateSets g s â†’ Filter.GenerateSets g t â†’ Filter.GenerateSets g (s âˆ© t)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.eq_of_mem_singleton",
  "constType": "âˆ€ {Î± : Type u} {x y : Î±}, x âˆˆ {y} â†’ x = y",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toLE : LE Î±] â†’\n    [toLT : LT Î±] â†’\n      (âˆ€ (a : Î±), a â‰¤ a) â†’\n        (âˆ€ (a b c : Î±), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c) â†’ autoParam (âˆ€ (a b : Î±), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a) _autoâœ â†’ Preorder Î±",
  "constCategory": "Other"},
 {"references":
  ["AddCancelCommMonoid",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "AddCommSemigroup.toAddSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
  "constType":
  "âˆ€ (M : Type u_1) [inst : AddCancelCommMonoid M] (a b c : M), a + b = c + b â†’ a = c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "flip",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "ge_antisymm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ b â‰¤ a â†’ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteBooleanAlgebra",
   "BooleanAlgebra.le_top",
   "Order.Frame.mk",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "CompleteBooleanAlgebra.sInf_le",
   "CompleteBooleanAlgebra.toSupSet",
   "CompleteLattice.mk",
   "BooleanAlgebra.toBot",
   "CompleteBooleanAlgebra.toInfSet",
   "DistribLattice.toLattice",
   "CompleteDistribLattice.mk",
   "CompleteBooleanAlgebra.iInf_sup_le_sup_sInf",
   "CompleteDistribLattice",
   "CompleteBooleanAlgebra.sSup_le",
   "CompleteBooleanAlgebra.le_sInf",
   "CompleteBooleanAlgebra.le_sSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toTop",
   "CompleteBooleanAlgebra.inf_sSup_le_iSup_inf"],
  "name": "CompleteBooleanAlgebra.toCompleteDistribLattice",
  "constType":
  "{Î± : Type u_1} â†’ [self : CompleteBooleanAlgebra Î±] â†’ CompleteDistribLattice Î±",
  "constCategory": "Definition"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "â„• â†’ â„• â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Inter.inter",
   "IsUpperSet",
   "IsUpperSet.inter",
   "Preorder",
   "Preorder.toLE",
   "Set.instInterSet"],
  "name": "Topology.upperSet.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] (x x_1 : Set Î±), IsUpperSet x â†’ IsUpperSet x_1 â†’ IsUpperSet (x âˆ© x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["namedPattern",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.mod.match_1",
  "constType":
  "(motive : â„• â†’ â„• â†’ Sort u_1) â†’\n  (x x_1 : â„•) â†’\n    ((x : â„•) â†’ motive 0 x) â†’\n      ((x n : â„•) â†’ (h : x = n + 1) â†’ (y : â„•) â†’ motive (namedPattern x (Nat.succ n) h) y) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["add_left_inj",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Defs._auxLemma.4",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G) {b c : G}, (b + a = c + a) = (b = c)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Continuous_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Lattice.toInf",
   "Order.Frame.toCompleteLattice",
   "CompleteLattice.toLattice",
   "Order.Frame",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "iSup",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Order.Frame.inf_sSup_le_iSup_inf",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : Order.Frame Î±] (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Bool.decEq", "Bool"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "Eq.ndrec",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.add_sub_add_left",
   "Eq.refl",
   "Nat.zero_sub",
   "instOfNatNat",
   "Nat",
   "id",
   "Eq"],
  "name": "Nat.sub_self_add",
  "constType": "âˆ€ (n m : â„•), n - (n + m) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "âˆ€ {Î± : Type u_2} [self : LinearOrderedCommSemiring Î±] (a b : Î±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "CompleteBooleanAlgebra.toSupSet",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.sSup_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_8",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Î± â†’ Prop), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["le_of_not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "le_of_not_gt",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b : Î±}, Â¬a > b â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "One",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termð“[â‰¤]_Â»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Bool.of_not_eq_true",
   "List.eraseP",
   "List.cons",
   "cond",
   "of_eq_true",
   "Bool.false",
   "List",
   "Bool.true",
   "Not",
   "Bool",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.eraseP_cons_of_neg",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} (p : Î± â†’ Bool), Â¬p a = true â†’ List.eraseP p (a :: l) = a :: List.eraseP p l",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousMap.continuous_toFun",
   "ContinuousMap.toContinuousMapClass.proof_1",
   "ContinuousMapClass",
   "FunLike.mk",
   "TopologicalSpace",
   "ContinuousMap",
   "ContinuousMapClass.mk",
   "ContinuousMap.toFun"],
  "name": "ContinuousMap.toContinuousMapClass",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’ [inst : TopologicalSpace Î±] â†’ [inst_1 : TopologicalSpace Î²] â†’ ContinuousMapClass C(Î±, Î²) Î± Î²",
  "constCategory": "Definition"},
 {"references": ["Lean.IsNeutral", "Eq"],
  "name": "Lean.IsNeutral.right_neutral",
  "constType":
  "âˆ€ {Î± : Sort u} {op : Î± â†’ Î± â†’ Î±} {neutral : Î±} [self : Lean.IsNeutral op neutral] (a : Î±), op a neutral = a",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{Î± : Type u} â†’ [self : EmptyCollection Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Or",
   "List.mem_union_iff",
   "Multiset.ndunion",
   "Iff",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.induction_onâ‚‚",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.mem_ndunion",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {s t : Multiset Î±} {a : Î±}, a âˆˆ Multiset.ndunion s t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.hash.match_1",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "OfNat.ofNat",
   "UInt64.size",
   "Lean.Name.num",
   "Lean.Name.hash.proof_2",
   "Nat.decLt",
   "Unit",
   "String",
   "dite",
   "instLTNat",
   "PProd",
   "PProd.fst",
   "Lean.Name.rec",
   "LT.lt",
   "String.hash",
   "PUnit",
   "Not",
   "instOfNatNat",
   "UInt64",
   "Lean.Name.hash.proof_1",
   "Lean.Name",
   "Lean.Name.anonymous",
   "UInt64.ofNatCore",
   "Nat",
   "mixHash",
   "Lean.Name.str"],
  "name": "Lean.Name.hash",
  "constType": "Lean.Name â†’ UInt64",
  "constCategory": "Definition"},
 {"references":
  ["Set.ext",
   "Membership.mem",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.ext_iff",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, s = t â†” âˆ€ (x : Î±), x âˆˆ s â†” x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Topology.IsUpperSet.closure_eq_lowerClosure",
   "LowerSet.Iic",
   "Set",
   "Eq.refl",
   "Set.Iic",
   "Preorder",
   "lowerClosure_singleton",
   "Preorder.toLE",
   "Eq",
   "LowerSet",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "LowerSet.instSetLikeLowerSet",
   "TopologicalSpace",
   "Singleton.singleton",
   "lowerClosure",
   "SetLike.coe",
   "id"],
  "name": "Topology.IsUpperSet.closure_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±] {a : Î±},\n  closure {a} = Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "EStateM.tryCatch",
   "EStateM.Backtrackable",
   "MonadExceptOf",
   "EStateM.throw",
   "MonadExceptOf.mk"],
  "name": "EStateM.instMonadExceptOfEStateM",
  "constType":
  "{Îµ Ïƒ Î´ : Type u} â†’ [inst : EStateM.Backtrackable Î´ Ïƒ] â†’ MonadExceptOf Îµ (EStateM Îµ Ïƒ)",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "âˆ€ {G : Type u} [inst : Add G], (âˆ€ (a b c : G), a + b = c + b â†’ a = c) â†’ IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.preorder",
   "Preorder.le_refl",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ PartialOrder (Ï€ i)] (a : (i : Î¹) â†’ Ï€ i), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Set.image_univ",
   "Set.univ",
   "and_true",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "And",
   "Eq.mpr",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "Set.image",
   "Std.Logic._auxLemma.52",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "Subtype.coe_image",
   "Subtype.mk",
   "Subtype",
   "exists_prop_congr'",
   "congrFun",
   "id"],
  "name": "Subtype.range_coe",
  "constType": "âˆ€ {Î± : Type u_1} {s : Set Î±}, Set.range Subtype.val = s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "SupSet.sSup",
   "iSup",
   "iSup_subtype''",
   "Eq",
   "Set.instMembershipSet",
   "sSup_image'",
   "Eq.mpr",
   "CompleteLattice",
   "Eq.ndrec",
   "Set.Elem",
   "Set.image",
   "Eq.symm",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "sSup_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : CompleteLattice Î±] {s : Set Î²} {f : Î² â†’ Î±}, sSup (f '' s) = â¨† a âˆˆ s, f a",
  "constCategory": "Theorem"},
 {"references":
  ["instTopologicalSpaceProd",
   "Topology.IsLower",
   "Prod.instPreorderProd",
   "TopologicalSpace",
   "Prod",
   "OrderBot",
   "Preorder",
   "Topology.instIsLowerProd.proof_1",
   "Preorder.toLE"],
  "name": "Topology.instIsLowerProd",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±]\n  [inst_3 : OrderBot Î±] [inst_4 : Preorder Î²] [inst_5 : TopologicalSpace Î²] [inst_6 : Topology.IsLower Î²]\n  [inst_7 : OrderBot Î²], Topology.IsLower (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeSup.le_sSup",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteSemilatticeSup Î±] (s : Set Î±), âˆ€ a âˆˆ s, a â‰¤ sSup s",
  "constCategory": "Definition"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.compare",
  "constType": "{Î± : Type u} â†’ [self : Ord Î±] â†’ Î± â†’ Î± â†’ Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "isClosed_Ici",
   "Set.Finite.isClosed_biUnion",
   "funext",
   "UpperSet.coe_iInf",
   "UpperSet.Ici",
   "Topology.IsLower.instClosedIciTopology",
   "UpperSet.instInfSetUpperSet",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Preorder",
   "UpperSet",
   "Set.Finite",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "Eq.mpr",
   "Set.iUnion",
   "iInf",
   "Topology.IsLower",
   "upperClosure",
   "TopologicalSpace",
   "IsClosed",
   "congrArg",
   "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.1",
   "Eq.trans",
   "SetLike.coe",
   "id"],
  "name": "Topology.IsLower.isClosed_upperClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(upperClosure s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Order.Preimage",
  "constType":
  "{Î± : Sort u_3} â†’ {Î² : Sort u_4} â†’ (Î± â†’ Î²) â†’ (Î² â†’ Î² â†’ Prop) â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["lcProof", "PLift", "ULift", "Eq"],
  "name": "unsafeCast.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2}, ULift.{max u_1 u_2, u_1} (PLift Î±) = ULift.{max u_1 u_2, u_2} (PLift Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.em",
   "if_pos",
   "Eq.mpr",
   "Or",
   "Eq.ndrec",
   "Or.inl",
   "Or.inr",
   "Decidable",
   "Eq.refl",
   "Not",
   "Or.casesOn",
   "Eq.symm",
   "if_neg",
   "id",
   "ite",
   "Eq"],
  "name": "ite_congr",
  "constType":
  "âˆ€ {Î± : Sort u_1} {b c : Prop} {x y u v : Î±} {s : Decidable b} [inst : Decidable c],\n  b = c â†’ (c â†’ x = u) â†’ (Â¬c â†’ y = v) â†’ (if b then x else y) = if c then u else v",
  "constCategory": "Theorem"},
 {"references": ["MonadLiftT"],
  "name": "MonadLiftT.monadLift",
  "constType":
  "{m : Type u â†’ Type v} â†’ {n : Type u â†’ Type w} â†’ [self : MonadLiftT m n] â†’ {Î± : Type u} â†’ m Î± â†’ n Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "iSup_le.match_1",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "CompleteLattice",
   "Eq.rec",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sSup_le",
   "CompleteLattice.toSupSet"],
  "name": "iSup_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {a : Î±}, (âˆ€ (i : Î¹), f i â‰¤ a) â†’ iSup f â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Sup.sup",
   "sup_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.semilatticeSup.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ SemilatticeSup (Î±' i)] (x x_1 x_2 : (i : Î¹) â†’ Î±' i),\n  x â‰¤ x_2 â†’ x_1 â‰¤ x_2 â†’ âˆ€ (i : Î¹), x i âŠ” x_1 i â‰¤ x_2 i",
  "constCategory": "Theorem"},
 {"references":
  ["instIsCommutative.proof_1",
   "Lean.IsCommutative",
   "Lean.IsCommutative.mk",
   "IsCommutative"],
  "name": "instIsCommutative",
  "constType":
  "{Î± : Type u_1} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ [inst : IsCommutative Î± op] â†’ Lean.IsCommutative op",
  "constCategory": "Definition"},
 {"references":
  ["cond",
   "CompleteSemilatticeInf.toPartialOrder",
   "Order.Frame.mk",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "instInhabitedPUnit",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "dite",
   "iSup",
   "le_iSup",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Iff.of_eq",
   "Mathlib.Data.Subtype._auxLemma.1",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "iSup_congr_Prop",
   "SemilatticeSup.toSup",
   "Set.Elem",
   "Bool.true",
   "iSup_const",
   "PUnit",
   "iSup_subtype",
   "le_trans",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Subtype",
   "iInf_congr_Prop",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompletelyDistribLattice.toCompleteDistribLattice.match_1",
   "Mathlib.Order.Lattice._auxLemma.2",
   "Classical.propDecidable",
   "Set.instMembershipSet",
   "iSup_bool_eq",
   "Order.Frame.toCompleteLattice",
   "Mathlib.Order.Lattice._auxLemma.1",
   "iInf",
   "of_eq_true",
   "Eq.mp",
   "instTransEq",
   "Not",
   "iInf_iSup_eq",
   "congrArg",
   "exists_prop_congr'",
   "congrFun",
   "iInf_subtype",
   "Exists",
   "CompletelyDistribLattice.toCompleteDistribLattice.match_2",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "True",
   "Lattice.toInf",
   "Subtype.property",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.1",
   "Bool.not_eq_false",
   "Std.Logic._auxLemma.65",
   "Lattice.toSemilatticeSup",
   "iInf_le",
   "instNonempty",
   "id",
   "Membership.mem",
   "eq_self",
   "funext",
   "SupSet.sSup",
   "iSup_le",
   "LE.le",
   "iInf_bool_eq",
   "Bool.false",
   "CompleteLattice.toInfSet",
   "sSup_eq_iSup",
   "le_refl",
   "Sup.sup",
   "Bool",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Subtype.mk"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompletelyDistribLattice Î±] (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Unit.unit",
   "Bool",
   "optParam"],
  "name": "Lean.SourceInfo.fromRef.match_2",
  "constType":
  "(motive : optParam Bool false â†’ Sort u_1) â†’\n  (canonical : optParam Bool false) â†’ (Unit â†’ motive true) â†’ (Unit â†’ motive) â†’ motive canonical",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM.Result.rec",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.Result.casesOn",
  "constType":
  "{Îµ Ïƒ Î± : Type u} â†’\n  {motive : EStateM.Result Îµ Ïƒ Î± â†’ Sort u_1} â†’\n    (t : EStateM.Result Îµ Ïƒ Î±) â†’\n      ((a : Î±) â†’ (a_1 : Ïƒ) â†’ motive (EStateM.Result.ok a a_1)) â†’\n        ((a : Îµ) â†’ (a_1 : Ïƒ) â†’ motive (EStateM.Result.error a a_1)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["True.intro", "forall_true_left", "propext", "True", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.41",
  "constType": "âˆ€ (p : True â†’ Prop), (âˆ€ (x : True), p x) = p True.intro",
  "constCategory": "Theorem"},
 {"references": ["List.Subset", "List", "HasSubset", "HasSubset.mk"],
  "name": "List.instHasSubsetList",
  "constType": "{Î± : Type u_1} â†’ HasSubset (List Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "instDecidableNot",
   "Bool.false",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_true",
  "constType": "âˆ€ (b : Bool), (Â¬b = true) = (b = false)",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "âˆ€ {Î± : Sort u_1} (a : Î±), (a = a) = True",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Inf"],
  "name": "InfHomClass",
  "constType":
  "Type u_7 â†’\n  (Î± : outParam (Type u_8)) â†’ (Î² : outParam (Type u_9)) â†’ [inst : Inf Î±] â†’ [inst : Inf Î²] â†’ Type (max (max u_7 u_8) u_9)",
  "constCategory": "Other"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "GaloisInsertion.liftCompleteLattice.proof_1",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "GaloisInsertion.liftCompleteLattice.proof_2",
   "GaloisInsertion.liftBoundedOrder",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice.proof_4",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "GaloisInsertion.liftCompleteLattice.proof_6",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "GaloisInsertion.choice",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.liftCompleteLattice.proof_5",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "GaloisInsertion.liftCompleteLattice.proof_7",
   "OrderBot.toBot",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisInsertion.liftCompleteLattice",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’\n      {u : Î² â†’ Î±} â†’ [inst : PartialOrder Î²] â†’ [inst_1 : CompleteLattice Î±] â†’ GaloisInsertion l u â†’ CompleteLattice Î²",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Fintype.subtype",
   "Set.instMembershipSet"],
  "name": "Fintype.ofFinset",
  "constType":
  "{Î± : Type u_1} â†’ {p : Set Î±} â†’ (s : Finset Î±) â†’ (âˆ€ (x : Î±), x âˆˆ s â†” x âˆˆ p) â†’ Fintype â†‘p",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le",
   "instLENat",
   "Nat.lt_of_le_of_lt",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "instLTNat",
   "absurd",
   "Nat.succ",
   "rfl",
   "LE.le",
   "Eq",
   "Nat.le_antisymm.match_1"],
  "name": "Nat.le_antisymm",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ m â‰¤ n â†’ n = m",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "PartialOrder.toPreorder",
   "GaloisInsertion.liftBoundedOrder.proof_1",
   "GaloisInsertion.liftBoundedOrder.proof_2",
   "OrderBot",
   "Preorder",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder",
   "OrderTop.toTop",
   "GaloisInsertion.liftBoundedOrder.proof_3",
   "GaloisInsertion.liftOrderTop",
   "BoundedOrder.mk",
   "OrderBot.toBot",
   "GaloisConnection.liftOrderBot",
   "OrderTop",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "GaloisInsertion.liftBoundedOrder",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’\n      {u : Î² â†’ Î±} â†’\n        [inst : PartialOrder Î²] â†’\n          [inst_1 : Preorder Î±] â†’ [inst_2 : BoundedOrder Î±] â†’ GaloisInsertion l u â†’ BoundedOrder Î²",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.termð“._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.termð“._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "instDecidableOr.proof_1",
   "Or.inl",
   "Or.inr",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableOr",
  "constType":
  "{p q : Prop} â†’ [dp : Decidable p] â†’ [dq : Decidable q] â†’ Decidable (p âˆ¨ q)",
  "constCategory": "Definition"},
 {"references":
  ["Set.eq_of_mem_singleton",
   "Membership.mem",
   "upperBounds",
   "Set.instSingletonSet",
   "Set.mem_singleton",
   "Set",
   "IsGreatest",
   "Singleton.singleton",
   "And.intro",
   "Preorder",
   "le_of_eq",
   "Set.instMembershipSet"],
  "name": "isGreatest_singleton",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsGreatest {a} a",
  "constCategory": "Theorem"},
 {"references":
  ["Inducing.mk",
   "TopologicalSpace",
   "Inducing",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "Inducing.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [tÎ± : TopologicalSpace Î±] â†’\n      [tÎ² : TopologicalSpace Î²] â†’\n        {f : Î± â†’ Î²} â†’\n          {motive : Inducing f â†’ Sort u} â†’\n            ((induced : tÎ± = TopologicalSpace.induced f tÎ²) â†’ motive (_ : Inducing f)) â†’ (t : Inducing f) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "compl_compl",
   "Inf.inf",
   "Set",
   "CompleteLattice.toBoundedOrder",
   "Mathlib.Order.Filter.Basic._auxLemma.62",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "Filter.isCompl_principal",
   "Preorder.toLE",
   "True",
   "iff_self",
   "CompleteLattice.toLattice",
   "Set.compl_inter",
   "Filter.principal",
   "Iff",
   "Mathlib.Order.Filter.Basic._auxLemma.61",
   "Filter",
   "IsCompl.le_right_iff",
   "Filter.inf_principal",
   "Eq.symm",
   "Eq.trans",
   "BoundedOrder.toOrderBot",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Union.union",
   "Disjoint",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "DistribLattice.toLattice",
   "IsCompl.le_left_iff",
   "Filter.instDistribLatticeFilter",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "propext",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "congr",
   "congrArg",
   "Set.instUnionSet",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_principal'",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s t : Set Î±}, s âˆˆ f âŠ“ Filter.principal t â†” tá¶œ âˆª s âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLowerSet.ofLowerSet_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Topology.WithLowerSet Î±},\n  â†‘Topology.WithLowerSet.ofLowerSet a = â†‘Topology.WithLowerSet.ofLowerSet b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "And",
   "Top",
   "Prod.snd",
   "Top.top",
   "le_top",
   "inferInstanceAs",
   "OrderTop",
   "LE",
   "Prod",
   "Prod.fst",
   "And.intro",
   "Prod.top",
   "Top.mk",
   "LE.le"],
  "name": "Prod.orderTop.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LE Î±] [inst_1 : LE Î²] [inst_2 : OrderTop Î±] [inst_3 : OrderTop Î²] (x : Î± Ã— Î²),\n  x.1 â‰¤ âŠ¤.1 âˆ§ x.2 â‰¤ âŠ¤.2",
  "constCategory": "Theorem"},
 {"references": ["Multiset.Mem", "Multiset", "Membership.mk", "Membership"],
  "name": "Multiset.instMembershipMultiset",
  "constType": "{Î± : Type u_1} â†’ Membership Î± (Multiset Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.frequently_iff",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Filter",
   "Filter.Frequently",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.42",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {P : Î± â†’ Prop}, (âˆƒá¶  (x : Î±) in f, P x) = âˆ€ {U : Set Î±}, U âˆˆ f â†’ âˆƒ x âˆˆ U, P x",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "inferInstanceAs",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "PartialOrder"],
  "name": "OrderDual.semilatticeInf.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : SemilatticeSup Î±] (a b : Î±áµ’áµˆ), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOnâ‚‚",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.append_assoc",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "instHAppend",
   "Setoid.r",
   "le_of_add_le_add_left",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Zero.mk",
   "Quotient.inductionOnâ‚ƒ",
   "Quotient.inductionOn",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
  "constType":
  "âˆ€ {Î± : Type u_1} (sâ‚ sâ‚‚ sâ‚ƒ : Multiset Î±), sâ‚ + sâ‚‚ â‰¤ sâ‚ + sâ‚ƒ â†’ sâ‚‚ â‰¤ sâ‚ƒ",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Classical.arbitrary",
  "constType": "(Î± : Sort u_2) â†’ [h : Nonempty Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "Exists.intro",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Set.Subset.refl",
   "And",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "IsOpen.mem_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {a : Î±} {s : Set Î±}, IsOpen s â†’ a âˆˆ s â†’ s âˆˆ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "String",
   "instBEq",
   "Lean.Name.hasMacroScopes.match_1",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "Lean.Name.rec",
   "Bool.false",
   "PUnit",
   "Bool",
   "Lean.Name",
   "Nat",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "Lean.Name.hasMacroScopes",
  "constType": "Lean.Name â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.sets_of_superset",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_of_superset",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {x y : Set Î±}, x âˆˆ f â†’ x âŠ† y â†’ y âˆˆ f",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff"],
  "name": "Iff.refl",
  "constType": "âˆ€ (a : Prop), a â†” a",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "eq_true",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.11",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, (a âŠ“ b â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Std.Logic._auxLemma.34",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.3",
   "Eq.refl",
   "implies_congr",
   "True",
   "Eq",
   "iff_self",
   "Iff",
   "of_eq_true",
   "List",
   "forall_congr",
   "List.nil",
   "Eq.trans",
   "List.TFAE"],
  "name": "List.tfae_singleton",
  "constType": "âˆ€ (p : Prop), List.TFAE [p]",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Set.Finite",
   "Set.Finite.casesOn"],
  "name": "Set.finite_def.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Set Î±} (motive : Set.Finite s â†’ Prop) (x : Set.Finite s),\n  (âˆ€ (h : Fintype â†‘s), motive (_ : Set.Finite s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Or",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "GE.ge",
   "HSub.hSub",
   "Nat.mod_eq_sub_mod.match_1",
   "instDecidableAnd",
   "LE.le",
   "rfl",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "ite",
   "Eq",
   "GT.gt",
   "And",
   "Nat.instModNat",
   "if_pos",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "LT.lt",
   "Eq.rec",
   "HMod.hMod",
   "Nat.sub_zero",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Eq.symm",
   "Nat.decLe"],
  "name": "Nat.mod_eq_sub_mod",
  "constType": "âˆ€ {a b : â„•}, a â‰¥ b â†’ a % b = (a - b) % b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Iff", "RelIso", "FunLike.coe", "Equiv.instFunLikeEquiv"],
  "name": "RelIso.mk",
  "constType":
  "{Î± : Type u_5} â†’\n  {Î² : Type u_6} â†’\n    {r : Î± â†’ Î± â†’ Prop} â†’\n      {s : Î² â†’ Î² â†’ Prop} â†’ (toEquiv : Î± â‰ƒ Î²) â†’ (âˆ€ {a b : Î±}, s (â†‘toEquiv a) (â†‘toEquiv b) â†” r a b) â†’ r â‰ƒr s",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "Codisjoint",
   "SemilatticeSup",
   "OrderDual.semilatticeInf",
   "OrderDual.orderBot",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderDual",
   "OrderTop",
   "Sup.sup",
   "Disjoint.eq_bot",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Codisjoint.eq_top",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±] [inst_1 : OrderTop Î±] {a b : Î±}, Codisjoint a b â†’ a âŠ” b = âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{Î± : Type u} â†’ [inst : LE Î±] â†’ [self : OrderBot Î±] â†’ Bot Î±",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.eq_or_lt_of_le.match_1",
  "constType":
  "âˆ€ (n m : â„•) (motive : n = m âˆ¨ n < m â†’ Prop) (x : n = m âˆ¨ n < m),\n  (âˆ€ (h : n = m), motive (_ : n = m âˆ¨ n < m)) â†’ (âˆ€ (h : n < m), motive (_ : n = m âˆ¨ n < m)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "le_antisymm",
   "mt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "lt_of_le_of_ne",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ a â‰  b â†’ a < b",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "propext", "or_iff_left_iff_imp", "Eq"],
  "name": "Std.Logic._auxLemma.21",
  "constType": "âˆ€ {a b : Prop}, (a âˆ¨ b â†” a) = (b â†’ a)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.le_top",
   "CompleteBooleanAlgebra",
   "CompleteLattice.le_sSup",
   "CompleteAtomicBooleanAlgebra.le_sup_inf",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteAtomicBooleanAlgebra.inf_sSup_le_iSup_inf",
   "CompleteAtomicBooleanAlgebra.top_le_sup_compl",
   "CompleteLattice.bot_le",
   "DistribLattice.mk",
   "CompleteLattice.sInf_le",
   "CompleteLattice.toBot",
   "CompleteAtomicBooleanAlgebra.toHImp",
   "CompleteBooleanAlgebra.mk",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "BooleanAlgebra.mk",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "CompleteLattice.sSup_le",
   "CompleteAtomicBooleanAlgebra.sdiff_eq",
   "CompleteLattice.toInfSet",
   "CompleteAtomicBooleanAlgebra",
   "CompleteLattice.toTop",
   "CompleteAtomicBooleanAlgebra.iInf_sup_le_sup_sInf",
   "CompleteAtomicBooleanAlgebra.toSDiff",
   "CompleteAtomicBooleanAlgebra.inf_compl_le_bot",
   "CompleteLattice.toSupSet",
   "CompleteAtomicBooleanAlgebra.himp_eq"],
  "name": "CompleteAtomicBooleanAlgebra.toCompleteBooleanAlgebra",
  "constType":
  "{Î± : Type u} â†’ [self : CompleteAtomicBooleanAlgebra Î±] â†’ CompleteBooleanAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "List.cons",
   "Iff",
   "List",
   "List.cons_sublist_cons.match_1",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.sublist_of_cons_sublist"],
  "name": "List.cons_sublist_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {lâ‚ lâ‚‚ : List Î±}, List.Sublist (a :: lâ‚) (a :: lâ‚‚) â†” List.Sublist lâ‚ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.elim",
  "constType":
  "âˆ€ {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {r : N â†’ N â†’ Prop} [self : ContravariantClass M N Î¼ r],\n  Contravariant M N Î¼ r",
  "constCategory": "Definition"},
 {"references": ["IsTrans", "IsTrans.trans"],
  "name": "trans",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [inst : IsTrans Î± r] {a b c : Î±}, r a b â†’ r b c â†’ r a c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "nhds",
   "Eq.ge",
   "Eq.le",
   "Filter.instPartialOrderFilter",
   "le_of_nhds_le_nhds",
   "TopologicalSpace",
   "Filter",
   "le_antisymm",
   "Eq"],
  "name": "eq_of_nhds_eq_nhds",
  "constType":
  "âˆ€ {Î± : Type u_1} {tâ‚ tâ‚‚ : TopologicalSpace Î±}, (âˆ€ (x : Î±), nhds x = nhds x) â†’ tâ‚ = tâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.mk",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Singleton Î± Î²",
  "constCategory": "Other"},
 {"references": ["Or", "propext", "or_comm", "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.7",
  "constType": "âˆ€ {a b : Prop}, (a âˆ¨ b) = (b âˆ¨ a)",
  "constCategory": "Theorem"},
 {"references":
  ["beq_iff_eq",
   "BEq.beq",
   "BEq",
   "propext",
   "Bool.true",
   "LawfulBEq",
   "Bool",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.32",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] (a b : Î±), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["IsAssociative.mk",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsAssociative",
   "sup_assoc",
   "Sup.sup"],
  "name": "instIsAssociativeSupToSup.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±], IsAssociative Î± fun x x_1 â†¦ x âŠ” x_1",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "Prod.snd",
   "Prod.mk",
   "Set",
   "SupSet.mk",
   "Prod",
   "Prod.fst",
   "SupSet.sSup",
   "Set.image"],
  "name": "Prod.supSet",
  "constType":
  "(Î± : Type u_1) â†’ (Î² : Type u_2) â†’ [inst : SupSet Î±] â†’ [inst : SupSet Î²] â†’ SupSet (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax.Preresolved.namespace",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.finRange",
  "constType": "(n : â„•) â†’ List (Fin n)",
  "constCategory": "Definition"},
 {"references": ["PSigma", "PSigma.mk", "Quot", "Quot.mk"],
  "name": "Quot.indep",
  "constType":
  "{Î± : Sort u} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ {motive : Quot r â†’ Sort v} â†’ ((a : Î±) â†’ motive (Quot.mk r a)) â†’ Î± â†’ PSigma motive",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Lean.Data.AC.Context.unwrap_isNeutral.match_1",
   "Unit",
   "Lean.IsNeutral",
   "Lean.Data.AC.Context.var",
   "Eq",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Variable.neutral",
   "Lean.Data.AC.instEvalInformationContext",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.false",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Lean.Data.AC.Variable.value",
   "Option.some",
   "Bool",
   "Nat",
   "Option.toBool.match_1",
   "Lean.Data.AC.ContextInformation.isNeutral",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "Option"],
  "name": "Lean.Data.AC.Context.unwrap_isNeutral",
  "constType":
  "{Î± : Sort u_1} â†’\n  {ctx : Lean.Data.AC.Context Î±} â†’\n    {x : â„•} â†’\n      Lean.Data.AC.ContextInformation.isNeutral ctx x = true â†’\n        Lean.IsNeutral (Lean.Data.AC.EvalInformation.evalOp ctx) (Lean.Data.AC.EvalInformation.evalVar ctx x)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "âˆ€ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_17",
  "constType": "âˆ€ {Î± : Type u_1} (x y : Î± â†’ Prop), x â‡¨ y = y âŠ” xá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] (n : â„•) (x : Î±),\n  AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithUpper.instTopologicalSpaceWithUpper._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom", "Eq"],
  "name": "ZeroHom.mk",
  "constType":
  "{M : Type u_9} â†’ {N : Type u_10} â†’ [inst : Zero M] â†’ [inst_1 : Zero N] â†’ (toFun : M â†’ N) â†’ toFun 0 = 0 â†’ ZeroHom M N",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "List.cons",
   "PUnit.unit",
   "List.rec",
   "List.below",
   "List",
   "PUnit",
   "List.nil",
   "PProd.mk"],
  "name": "List.brecOn",
  "constType":
  "{Î± : Type u} â†’ {motive : List Î± â†’ Sort u_1} â†’ (t : List Î±) â†’ ((t : List Î±) â†’ List.below t â†’ motive t) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Array.empty",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "Lean.SourceInfo",
   "Lean.Syntax"],
  "name": "Lean.Syntax.getArgs",
  "constType": "Lean.Syntax â†’ Array Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "âˆ€ (p : Prop), (p âˆ§ p) = p",
  "constCategory": "Theorem"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) â†’ (N : Type u_10) â†’ [inst : AddZeroClass M] â†’ [inst : AddZeroClass N] â†’ Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.append",
   "Eq.refl",
   "True",
   "Eq",
   "instHAppend",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "List.append_nil",
  "constType": "âˆ€ {Î± : Type u} (as : List Î±), as ++ [] = as",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image_subset_preimage_of_inverse.match_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {f : Î± â†’ Î²} (s : Set Î±) (x : Î²) (motive : x âˆˆ f '' s â†’ Prop) (x_1 : x âˆˆ f '' s),\n  (âˆ€ (a : Î±) (h : a âˆˆ s) (e : f a = x), motive (_ : âˆƒ a âˆˆ s, f a = x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references": ["Lean.IsCommutative", "Eq"],
  "name": "Lean.IsCommutative.comm",
  "constType":
  "âˆ€ {Î± : Sort u} {op : Î± â†’ Î± â†’ Î±} [self : Lean.IsCommutative op] (a b : Î±), op a b = op b a",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Fintype", "Nonempty", "Nonempty.casesOn"],
  "name": "finite_iff_nonempty_fintype.match_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (motive : Nonempty (Fintype Î±) â†’ Prop) (x : Nonempty (Fintype Î±)),\n  (âˆ€ (val : Fintype Î±), motive (_ : Nonempty (Fintype Î±))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["instLENat", "LT.lt", "Nat", "LE.le", "Nat.le_of_succ_le", "instLTNat"],
  "name": "Nat.le_of_lt",
  "constType": "âˆ€ {n m : â„•}, n < m â†’ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero",
   "Bool.true",
   "Nat.beq",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.eq_of_beq_eq_true.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ Nat.beq x x_1 = true â†’ Prop) (x x_1 : â„•) (x_2 : Nat.beq x x_1 = true),\n  (âˆ€ (x : Nat.beq Nat.zero Nat.zero = true), motive Nat.zero Nat.zero x) â†’\n    (âˆ€ (n : â„•) (h : Nat.beq Nat.zero (Nat.succ n) = true), motive Nat.zero (Nat.succ n) h) â†’\n      (âˆ€ (n : â„•) (h : Nat.beq (Nat.succ n) Nat.zero = true), motive (Nat.succ n) Nat.zero h) â†’\n        (âˆ€ (n m : â„•) (h : Nat.beq (Nat.succ n) (Nat.succ m) = true), motive (Nat.succ n) (Nat.succ m) h) â†’\n          motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["PSigma",
   "instHSub",
   "PSigma.casesOn",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "dite",
   "instSizeOfNat",
   "instDecidableAnd",
   "WellFounded.fix",
   "instLTNat",
   "LE.le",
   "instWellFoundedRelation",
   "And",
   "instLENat",
   "invImage",
   "Nat.div_rec_lemma",
   "LT.lt",
   "SizeOf.sizeOf",
   "PSigma.mk",
   "instOfNatNat",
   "Not",
   "Nat",
   "Nat.decLe"],
  "name": "Nat.div.inductionOn._unary",
  "constType":
  "{motive : â„• â†’ â„• â†’ Sort u} â†’\n  (_x :\n      (_ : â„•) Ã—'\n        (_ : â„•) Ã—'\n          (_ : (x y : â„•) â†’ 0 < y âˆ§ y â‰¤ x â†’ motive (x - y) y â†’ motive x y) Ã—'\n            ((x y : â„•) â†’ Â¬(0 < y âˆ§ y â‰¤ x) â†’ motive x y)) â†’\n    motive _x.1 _x.2.1",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "Lattice.toSemilatticeInf",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "HeytingAlgebra.bot_le",
   "OrderBot.mk",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "HeytingAlgebra.toBoundedOrder",
  "constType": "{Î± : Type u_2} â†’ [inst : HeytingAlgebra Î±] â†’ BoundedOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq",
   "id"],
  "name": "induced_id.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±] (s : Set Î±) (motive : IsOpen s â†’ Prop) (x : IsOpen s),\n  (âˆ€ (w : Set Î±) (hs : IsOpen w) (h : id â»Â¹' w = s), motive (_ : âˆƒ s', IsOpen s' âˆ§ id â»Â¹' s' = s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Iff.intro",
   "Membership.mem",
   "Iff.mp",
   "Iff",
   "List.instMembershipList",
   "List",
   "List.Pairwise.imp_of_mem",
   "Iff.mpr"],
  "name": "List.Pairwise.iff_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {R S : Î± â†’ Î± â†’ Prop} {l : List Î±},\n  (âˆ€ {a b : Î±}, a âˆˆ l â†’ b âˆˆ l â†’ (R a b â†” S a b)) â†’ (List.Pairwise R l â†” List.Pairwise S l)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LE.le",
   "ge_antisymm",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.antisymm'",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ b â‰¤ a â†’ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.mem_iUnion.match_2",
   "Set.mem_iUnion.match_1",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq",
   "Iff.intro",
   "Set.range",
   "And",
   "Set.iUnion",
   "Iff",
   "Eq.rec",
   "And.intro",
   "Eq.symm"],
  "name": "Set.mem_iUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {x : Î±} {s : Î¹ â†’ Set Î±}, x âˆˆ â‹ƒ i, s i â†” âˆƒ i, x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["instDecidableAnd.proof_2",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "And.intro",
   "instDecidableAnd.proof_1"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} â†’ [dp : Decidable p] â†’ [dq : Decidable q] â†’ Decidable (p âˆ§ q)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List",
   "List.nil",
   "List.noConfusion",
   "List.noConfusionType",
   "Eq"],
  "name": "List.hasDecEq.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (head : Î±) (tail : List Î±), [] = head :: tail â†’ List.noConfusionType False [] (head :: tail)",
  "constCategory": "Theorem"},
 {"references": ["InfSet.mk", "SupSet", "InfSet", "OrderDual", "SupSet.sSup"],
  "name": "OrderDual.infSet",
  "constType": "(Î± : Type u_9) â†’ [inst : SupSet Î±] â†’ InfSet Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Topology.Constructions.0.instTopologicalSpaceProd._eq_1",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "Eq.refl",
   "Prod.fst",
   "Filter.instSProd",
   "Eq",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Eq.mpr",
   "Eq.ndrec",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Prod",
   "Filter.prod",
   "nhds_induced",
   "nhds_inf",
   "TopologicalSpace.induced",
   "_private.Mathlib.Topology.Constructions.0.Filter.prod._eq_1",
   "id"],
  "name": "nhds_prod_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {a : Î±} {b : Î²},\n  nhds (a, b) = nhds a Ã—Ë¢ nhds b",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.RightInverse",
   "EquivLike.coe_injective'",
   "Eq.rec",
   "Function.LeftInverse.eq_rightInverse",
   "EquivLike.right_inv",
   "Eq.symm",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Eq"],
  "name": "EquivLike.toEmbeddingLike.proof_1",
  "constType":
  "âˆ€ {E : Sort u_3} {Î± : Sort u_1} {Î² : Sort u_2} [iE : EquivLike E Î± Î²] (e g : E),\n  EquivLike.coe e = EquivLike.coe g â†’ e = g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "mem_interior",
   "Set.instMembershipSet",
   "Iff.symm",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "interior",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "mem_interior_iff_mem_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {a : Î±}, a âˆˆ interior s â†” s âˆˆ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat.add_lt_add_left",
   "Nat",
   "instLTNat"],
  "name": "Nat.lt_add_of_pos_right",
  "constType": "âˆ€ {n k : â„•}, 0 < k â†’ n < n + k",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Filter.instCompleteLatticeFilter.proof_10",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Filter.instCompleteLatticeFilter.proof_11",
   "Filter.instCompleteLatticeFilter.proof_2",
   "Inf.inf",
   "Set",
   "Filter.instCompleteLatticeFilter.proof_4",
   "CompleteLattice.mk",
   "SupSet.mk",
   "Filter.generate",
   "CompleteLattice.toBot",
   "Lattice.mk",
   "Filter.join",
   "Filter.instCompleteLatticeFilter.proof_7",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Preorder.toLT",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.mem_inf_of_right",
   "Filter.instCompleteLatticeFilter.proof_5",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.proof_12",
   "Membership.mem",
   "Filter.sets",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPartialOrder",
   "Filter.instCompleteLatticeFilter.proof_8",
   "Top.top",
   "Function.comp",
   "SemilatticeSup.mk",
   "Filter.instCompleteLatticeFilter.proof_3",
   "Set.Set.completeAtomicBooleanAlgebra",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter.instCompleteLatticeFilter.proof_9",
   "Filter.instCompleteLatticeFilter.proof_1",
   "Filter.instCompleteLatticeFilter.proof_6",
   "Top.mk",
   "Filter.mem_inf_of_left"],
  "name": "Filter.instCompleteLatticeFilter",
  "constType": "{Î± : Type u} â†’ CompleteLattice (Filter Î±)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} â†’ [toAddMonoidWithOne : AddMonoidWithOne R] â†’ (âˆ€ (a b : R), a + b = b + a) â†’ AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Disjoint.le_bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Function.comp",
   "OrderBot.toBot",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "bot_unique",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Disjoint.eq_bot",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a b : Î±}, Disjoint a b â†’ a âŠ“ b = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{Î± : Type u} â†’ Î± â†’ Option Î±",
  "constCategory": "Other"},
 {"references":
  ["Set.instSingletonSet",
   "Set",
   "IsGreatest.isLUB",
   "isGreatest_singleton",
   "Singleton.singleton",
   "Preorder",
   "IsLUB"],
  "name": "isLUB_singleton",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsLUB {a} a",
  "constCategory": "Theorem"},
 {"references": ["Top", "top_nonempty.proof_1", "Nonempty"],
  "name": "top_nonempty",
  "constType": "âˆ€ (Î± : Type u) [inst : Top Î±], Nonempty Î±",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadRef", "Lean.Syntax"],
  "name": "Lean.MonadRef.mk",
  "constType":
  "{m : Type â†’ Type} â†’ m Lean.Syntax â†’ ({Î± : Type} â†’ Lean.Syntax â†’ m Î± â†’ m Î±) â†’ Lean.MonadRef m",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Filter.HasBasis",
   "Equiv.surjective",
   "Function.comp",
   "Set",
   "Filter",
   "FunLike.coe",
   "Filter.HasBasis.comp_surjective",
   "Equiv.instFunLikeEquiv"],
  "name": "Filter.HasBasis.comp_equiv",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Î¹' : Sort u_5} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ âˆ€ (e : Î¹' â‰ƒ Î¹), Filter.HasBasis l (p âˆ˜ â†‘e) (s âˆ˜ â†‘e)",
  "constCategory": "Theorem"},
 {"references": ["BEq", "Bool"],
  "name": "BEq.beq",
  "constType": "{Î± : Type u} â†’ [self : BEq Î±] â†’ Î± â†’ Î± â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["isLowerSet_univ", "IsLowerSet", "Preorder", "Set.univ", "Preorder.toLE"],
  "name": "Topology.lowerSet.proof_1",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Preorder Î±], IsLowerSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Nat.sub_lt_left_of_lt_add",
   "instSubNat",
   "Nat.add_sub_cancel'",
   "List.instMembershipList",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat.add_lt_add_left",
   "instLTNat",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Iff",
   "List.mem_range'_1.match_2",
   "Eq.rec",
   "instOfNatNat",
   "Nat",
   "Std.Data.List.Lemmas._auxLemma.107",
   "List.mem_range'_1.match_1",
   "Eq.symm",
   "Eq.trans",
   "id",
   "instHSub",
   "Membership.mem",
   "funext",
   "instAddNat",
   "List.range'",
   "Nat.le_add_right",
   "instHAdd",
   "HSub.hSub",
   "LE.le",
   "Iff.intro",
   "And",
   "instHMul",
   "Nat.one_mul",
   "List",
   "LT.lt",
   "HMul.hMul",
   "And.intro",
   "instMulNat",
   "congrArg",
   "congrFun"],
  "name": "List.mem_range'_1",
  "constType": "âˆ€ {m s n : â„•}, m âˆˆ List.range' s n â†” s â‰¤ m âˆ§ m < s + n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "id"],
  "name": "Set.Subset.refl",
  "constType": "âˆ€ {Î± : Type u} (a : Set Î±), a âŠ† a",
  "constCategory": "Theorem"},
 {"references": ["IsRefl", "IsRefl.refl"],
  "name": "refl",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [inst : IsRefl Î± r] (a : Î±), r a a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Iff",
   "Iff.rfl",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSet_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Topology.WithUpperSet Î±},\n  â†‘Topology.WithUpperSet.ofUpperSet a â‰¤ â†‘Topology.WithUpperSet.ofUpperSet b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_7",
   "List.cons",
   "_obj",
   "_neutral",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_5"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "LE",
   "Inter.inter",
   "And.imp",
   "IsUpperSet",
   "LE.le",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "IsUpperSet.inter",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s t : Set Î±}, IsUpperSet s â†’ IsUpperSet t â†’ IsUpperSet (s âˆ© t)",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Eq"],
  "name": "Eq.ndrecOn",
  "constType":
  "{Î± : Sort u2} â†’ {a : Î±} â†’ {motive : Î± â†’ Sort u1} â†’ {b : Î±} â†’ a = b â†’ motive a â†’ motive b",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "Not", "not_and", "Eq"],
  "name": "Std.Logic._auxLemma.24",
  "constType": "âˆ€ {a b : Prop}, (Â¬(a âˆ§ b)) = (a â†’ Â¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "PartialOrder.le_antisymm",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_4",
  "constType": "âˆ€ {Î± : Type u_1} (a b : (Filter Î±)áµ’áµˆáµ’áµˆ), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : â„•) â†’ Decidable (n < m)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CoheytingAlgebra",
   "Mathlib.Order.Heyting.Basic._auxLemma.27",
   "Top.top",
   "Inf.inf",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "True",
   "sdiff_inf_distrib",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Lattice.toInf",
   "Eq.mpr",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "CoheytingAlgebra.toHNot",
   "congrFun",
   "id"],
  "name": "hnot_inf_distrib",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] (a b : Î±), ï¿¢(a âŠ“ b) = ï¿¢a âŠ” ï¿¢b",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "himp_eq",
   "HasCompl.compl",
   "BooleanAlgebra",
   "Pi.heytingAlgebra",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.distribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "DistribLattice.toLattice",
   "BooleanAlgebra.toBiheytingAlgebra",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "HeytingAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice"],
  "name": "Pi.booleanAlgebra.proof_7",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (x x_1 : (i : Î¹) â†’ Î± i), x â‡¨ x_1 = x_1 âŠ” xá¶œ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq",
  "constType": "{Î± : Sort u} â†’ Î± â†’ {Î² : Sort u} â†’ Î² â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["List.below",
   "List.brecOn",
   "List.instMembershipList",
   "Eq.refl",
   "List.elem",
   "_private.Init.Data.List.Basic.0.List.erase.match_1.splitter",
   "implies_congr",
   "True",
   "Eq",
   "false_implies",
   "Decidable.decide",
   "PProd",
   "BEq.beq",
   "List.rec",
   "Bool.true",
   "PUnit",
   "List.nil",
   "List.erase.match_1",
   "Eq.symm",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "Membership.mem",
   "List.cons",
   "False",
   "decide_eq_true_eq",
   "Unit",
   "List.Mem.tail",
   "instBEq",
   "eq_false_of_decide",
   "List.mem_of_elem_eq_true.match_1",
   "PProd.fst",
   "Eq.ndrec",
   "of_eq_true",
   "DecidableEq",
   "Bool.false",
   "List",
   "Eq.mp",
   "List.Mem.head",
   "Bool"],
  "name": "List.mem_of_elem_eq_true",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {as : List Î±}, List.elem a as = true â†’ a âˆˆ as",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.Homeomorph._hyg.17",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "Prod.instLEProd",
   "Prod",
   "Prod.boundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_8",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (a : Î± Ã— Î²), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false",
   "Unit",
   "Bool.true",
   "Bool",
   "Option.toBool.match_1",
   "Option"],
  "name": "Option.isSome",
  "constType": "{Î± : Type u_1} â†’ Option Î± â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.exists_mem_subset_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {f : Filter Î±} {s : Set Î±} (motive : (âˆƒ t âˆˆ f, t âŠ† s) â†’ Prop) (x : âˆƒ t âˆˆ f, t âŠ† s),\n  (âˆ€ (w : Set Î±) (ht : w âˆˆ f) (ts : w âŠ† s), motive (_ : âˆƒ t âˆˆ f, t âŠ† s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Nodup",
   "List.not_nodup_cons_of_mem",
   "Not",
   "List.nil",
   "List.mem_singleton_self"],
  "name": "List.not_nodup_pair",
  "constType": "âˆ€ {Î± : Type u} (a : Î±), Â¬List.Nodup [a, a]",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "funext",
   "Function.comp",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "Eq",
   "id",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.self_comp_symm",
  "constType": "âˆ€ {Î± : Sort u} {Î² : Sort v} (e : Î± â‰ƒ Î²), â†‘e âˆ˜ â†‘e.symm = id",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Set",
   "Set.univ",
   "Set.mem_univ",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.14",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), (x âˆˆ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ PProd Î± Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Iff.intro",
   "Filter.filter_eq",
   "Iff",
   "congr_arg",
   "Set",
   "Filter",
   "Eq"],
  "name": "Filter.filter_eq_iff",
  "constType": "âˆ€ {Î± : Type u} {f g : Filter Î±}, f = g â†” f.sets = g.sets",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "namedPattern",
  "constType": "{Î± : Sort u} â†’ (x a : Î±) â†’ x = a â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.forall_mem_ne",
   "Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.List.Dedup._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {l : List Î±}, (âˆ€ a' âˆˆ l, Â¬a = a') = Â¬a âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["Order.Frame", "CompleteLattice"],
  "name": "Order.Frame.toCompleteLattice",
  "constType": "{Î± : Type u_1} â†’ [self : Order.Frame Î±] â†’ CompleteLattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Fintype.ofBijective",
   "Fintype",
   "Equiv.bijective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Fintype.ofEquiv",
  "constType":
  "{Î² : Type u_2} â†’ (Î± : Type u_4) â†’ [inst : Fintype Î±] â†’ Î± â‰ƒ Î² â†’ Fintype Î²",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Set.instSingletonSet",
   "of_eq_true",
   "Set",
   "Singleton.singleton",
   "Set.image_insert_eq",
   "Set.image",
   "Set.image_singleton",
   "congrArg",
   "Insert.insert",
   "Eq.trans",
   "True",
   "congrFun",
   "Set.instInsertSet",
   "Eq"],
  "name": "Set.image_pair",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (a b : Î±), f '' {a, b} = {f a, f b}",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.Perm.subperm_left.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {l lâ‚ : List Î±} (motive : l <+~ lâ‚ â†’ Prop) (x : l <+~ lâ‚),\n  (âˆ€ (_u : List Î±) (pu : _u ~ l) (su : List.Sublist _u lâ‚), motive (_ : âˆƒ l_1, âˆƒ (_ : l_1 ~ l), List.Sublist l_1 lâ‚)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_9",
   "List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_11",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "String.Pos.mk",
   "String",
   "instOfNatNat",
   "Substring.mk",
   "Nat",
   "Substring",
   "String.endPos"],
  "name": "String.toSubstring",
  "constType": "String â†’ Substring",
  "constCategory": "Definition"},
 {"references": ["List", "List.Chain.imp'", "List.Chain"],
  "name": "List.Chain.imp",
  "constType":
  "âˆ€ {Î± : Type u_1} {R S : Î± â†’ Î± â†’ Prop},\n  (âˆ€ (a b : Î±), R a b â†’ S a b) â†’ âˆ€ {a : Î±} {l : List Î±}, List.Chain R a l â†’ List.Chain S a l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.idem",
   "Lean.Data.AC.Variable.neutral",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.Context.comm",
   "Lean.IsCommutative",
   "Lean.Data.AC.Variable.value",
   "Lean.Data.AC.ContextInformation",
   "Lean.Data.AC.ContextInformation.mk",
   "Lean.IsNeutral",
   "Nat",
   "Lean.IsIdempotent",
   "Lean.Data.AC.Context.var",
   "Option.isSome"],
  "name": "Lean.Data.AC.instContextInformationContext",
  "constType":
  "{Î± : Sort u_1} â†’ Lean.Data.AC.ContextInformation (Lean.Data.AC.Context Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Iff",
   "List.mem_of_elem_eq_true",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Bool.true",
   "instBEq",
   "Bool",
   "List.elem",
   "List.elem_eq_true_of_mem",
   "Eq"],
  "name": "List.instDecidableMemListInstMembershipList.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (as : List Î±), List.elem a as = true â†” a âˆˆ as",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Not", "mt", "Iff.mpr"],
  "name": "not_congr",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ (Â¬a â†” Â¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.ilast'.match_1",
   "List.nil"],
  "name": "List.ilast'",
  "constType": "{Î± : Type u_1} â†’ Î± â†’ List Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Top", "outParam", "Inf"],
  "name": "InfTopHomClass",
  "constType":
  "Type u_7 â†’\n  (Î± : outParam (Type u_8)) â†’\n    (Î² : outParam (Type u_9)) â†’\n      [inst : Inf Î±] â†’ [inst : Inf Î²] â†’ [inst : Top Î±] â†’ [inst : Top Î²] â†’ Type (max (max u_7 u_8) u_9)",
  "constCategory": "Other"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{Î± : Type u} â†’ [self : Semiring Î±] â†’ NatCast Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.IsUpper.mk",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsUpper Î± â†’ Sort u} â†’\n        ((topology_eq_upperTopology : t = Topology.upper Î±) â†’ motive (_ : Topology.IsUpper Î±)) â†’\n          (t : Topology.IsUpper Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.mk",
  "constType": "âˆ€ {Î± : Type u_3}, (âˆƒ x, âˆƒ y, x â‰  y) â†’ Nontrivial Î±",
  "constCategory": "Other"},
 {"references": ["List.Pairwise", "List"],
  "name": "List.Pairwise.below",
  "constType":
  "{Î± : Type u_1} â†’\n  {R : Î± â†’ Î± â†’ Prop} â†’ {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop} â†’ {a : List Î±} â†’ List.Pairwise R a â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Set",
   "Topology.IsUpper",
   "Eq.refl",
   "IsUpperSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "Topology.IsUpperSet.isOpen_iff_isUpperSet",
   "Topology.IsUpper.isUpperSet_of_isOpen",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpperSet.upperSet_le_upper",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {tâ‚ tâ‚‚ : TopologicalSpace Î±} [inst_1 : Topology.IsUpperSet Î±]\n  [inst : Topology.IsUpper Î±], tâ‚ â‰¤ tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "Nat.le_of_succ_le_succ",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.le_of_lt_succ",
  "constType": "âˆ€ {m n : â„•}, m < Nat.succ n â†’ m â‰¤ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "âˆ€ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c â†’ b = c",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Exists.intro",
   "Quot",
   "rfl",
   "Quot.inductionOn",
   "Quot.mk",
   "Eq"],
  "name": "Quot.exists_rep",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} (q : Quot r), âˆƒ a, Quot.mk r a = q",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpperSet.toDualHomeomorph._lambda_1",
   "_obj",
   "Function.comp._rarg",
   "_neutral",
   "Topology.WithLowerSet.map._elambda_1"],
  "name": "Topology.WithLowerSet.map._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termI^_Â»._closed_2",
   "Topology.Â«termI^_Â»._closed_1"],
  "name": "Topology.Â«termI^_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.attach.proof_1",
   "Multiset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Finset.mk",
   "Subtype"],
  "name": "Finset.attach",
  "constType": "{Î± : Type u_1} â†’ (s : Finset Î±) â†’ Finset { x // x âˆˆ s }",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) â†’ (N : Type u_2) â†’ (M â†’ N â†’ N) â†’ (N â†’ N â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ InfSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "Lattice",
   "LE.le",
   "Pi.semilatticeInf",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.lattice.proof_6",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î±' i)] (a b c : (i : Î¹) â†’ Î±' i),\n  a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "SupSet",
   "sInfHom.toFun",
   "Set",
   "sInfHom.map_sInf'",
   "InfSet.sInf",
   "OrderDual.infSet",
   "OrderDual",
   "Set.image",
   "Eq"],
  "name": "sSupHom.dual.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : SupSet Î±] [inst_1 : SupSet Î²] (f : sInfHom Î±áµ’áµˆ Î²áµ’áµˆ) (s : Set Î±áµ’áµˆ),\n  sInfHom.toFun f (sInf s) = sInf (f.toFun '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Continuous_of._closed_2",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Continuous_of._closed_10"],
  "name": "Topology.Continuous_of._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection", "Preorder", "LE.le", "Preorder.toLE", "Iff.mpr"],
  "name": "GaloisConnection.l_le",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ âˆ€ {a : Î±} {b : Î²}, a â‰¤ u b â†’ l a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["String.Pos.mk", "String", "String.utf8ByteSize", "String.Pos"],
  "name": "String.endPos",
  "constType": "String â†’ String.Pos",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "SemilatticeInf.toPartialOrder",
   "Pi.heytingAlgebra.proof_2",
   "OrderBot",
   "Pi.generalizedHeytingAlgebra",
   "Pi.heytingAlgebra.proof_4",
   "Pi.heytingAlgebra.proof_3",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Pi.hasCompl",
   "Pi.orderBot",
   "OrderBot.toBot",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.mk",
   "Pi.hasLe",
   "GeneralizedHeytingAlgebra",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot",
   "Pi.heytingAlgebra.proof_1",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Pi.heytingAlgebra",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î± : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ HeytingAlgebra (Î± i)] â†’ HeytingAlgebra ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.left_mem_Ici",
   "Set",
   "LE.le.trans",
   "HasSubset.Subset",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Ici_subset_Ici",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, Set.Ici a âŠ† Set.Ici b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Seq", "Applicative", "SeqRight", "Functor", "Pure", "SeqLeft"],
  "name": "Applicative.mk",
  "constType":
  "{f : Type u â†’ Type v} â†’\n  [toFunctor : Functor f] â†’\n    [toPure : Pure f] â†’ [toSeq : Seq f] â†’ [toSeqLeft : SeqLeft f] â†’ [toSeqRight : SeqRight f] â†’ Applicative f",
  "constCategory": "Other"},
 {"references":
  ["eq_true", "List.Perm", "List.Perm.refl", "List", "True", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.1",
  "constType": "âˆ€ {Î± : Type uu} (l : List Î±), (l ~ l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "nhdsAdjoint.proof_1",
   "Set",
   "TopologicalSpace",
   "Filter",
   "nhdsAdjoint.proof_2",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint",
  "constType": "{Î± : Type u} â†’ Î± â†’ Filter Î± â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["funext", "FunLike", "FunLike.coe", "FunLike.coe_injective'", "Eq"],
  "name": "FunLike.ext",
  "constType":
  "âˆ€ {F : Sort u_1} {Î± : Sort u_2} {Î² : Î± â†’ Sort u_3} [i : FunLike F Î± Î²] (f g : F), (âˆ€ (x : Î±), â†‘f x = â†‘g x) â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.generalizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.heytingAlgebra.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ HeytingAlgebra (Î± i)] (a b c : (i : Î¹) â†’ Î± i),\n  a â‰¤ b â‡¨ c â†” a âŠ“ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "OrderDual",
   "OrderBot.bot_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "OrderDual.boundedOrder"],
  "name": "OrderDual.completeLattice.proof_5",
  "constType": "âˆ€ (Î± : Type u_1) [inst : CompleteLattice Î±] (a : Î±áµ’áµˆ), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "Iff",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "LE.le",
   "sup_le_iff",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "le_inf_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b c : Î±}, a â‰¤ b âŠ“ c â†” a â‰¤ b âˆ§ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Std.Logic._auxLemma.34",
   "List.instMembershipList",
   "List.Sublist",
   "List.casesOn",
   "Std.Data.List.Lemmas._auxLemma.3",
   "Eq.refl",
   "List.map_get_sublist",
   "implies_congr",
   "instLTNat",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "false_implies",
   "Eq",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Eq.mpr",
   "Std.Data.List.Basic._auxLemma.3",
   "Iff",
   "and_false",
   "eq_false'",
   "forall_congr",
   "List.sublist_eq_map_get",
   "List.nil",
   "Nat",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "List.cons",
   "False",
   "Fin.val",
   "implies_true",
   "List.length",
   "and_true",
   "instLTFin",
   "List.Pairwise",
   "Iff.intro",
   "And",
   "eq_true",
   "False.elim",
   "Eq.ndrec",
   "of_eq_true",
   "Fin.lt_def",
   "propext",
   "List",
   "LT.lt",
   "Eq.mp",
   "List.pairwise_iff_get.match_1",
   "congr",
   "List.map",
   "List.noConfusion",
   "List.get",
   "congrArg",
   "List.cons.injEq",
   "and_self",
   "Fin",
   "List.pairwise_iff_forall_sublist"],
  "name": "List.pairwise_iff_get",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {l : List Î±},\n  List.Pairwise R l â†” âˆ€ (i j : Fin (List.length l)), i < j â†’ R (List.get l i) (List.get l j)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSet_toLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±), â†‘Topology.WithLowerSet.ofLowerSet (â†‘Topology.WithLowerSet.toLowerSet a) = a",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool", "Eq"],
  "name": "ne_false_of_eq_true.match_1",
  "constType":
  "âˆ€ (motive : (x : Bool) â†’ x = true â†’ Prop) (x : Bool) (x_1 : x = true),\n  (âˆ€ (x : true = true), motive true x) â†’ (âˆ€ (h : false = true), motive false h) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.join.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (f : Filter (Filter Î±)) {x y : Set Î±}, x âˆˆ {s | {t | s âˆˆ t} âˆˆ f} â†’ x âŠ† y â†’ {t | y âˆˆ t} âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["BEq.beq",
   "Lean.Syntax.isOfKind",
   "and",
   "Lean.Syntax.getNumArgs",
   "Lean.SyntaxNodeKind",
   "instBEqNat",
   "Bool",
   "Nat",
   "Lean.Syntax"],
  "name": "Lean.Syntax.isNodeOf",
  "constType": "Lean.Syntax â†’ Lean.SyntaxNodeKind â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.inf_le_left",
  "constType": "âˆ€ {Î± : Type u} [self : SemilatticeInf Î±] (a b : Î±), a âŠ“ b â‰¤ a",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "and_assoc.match_1",
  "constType":
  "âˆ€ {a b c : Prop} (motive : (a âˆ§ b) âˆ§ c â†’ Prop) (x : (a âˆ§ b) âˆ§ c),\n  (âˆ€ (ha : a) (hb : b) (hc : c), motive (_ : (a âˆ§ b) âˆ§ c)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "Equiv",
   "sSupHom.mk",
   "OrderDual.toDual",
   "sSupHom",
   "Function.comp",
   "OrderDual.infSet",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sSupHom.map_sSup'",
   "rfl",
   "Eq",
   "sSupHom.ext",
   "Equiv.instFunLikeEquiv",
   "SupSet",
   "sSupHom.instSSupHomClassSSupHom",
   "sSupHomClass.toFunLike",
   "OrderDual.ofDual",
   "sInfHom.map_sInf'",
   "OrderDual",
   "sInfHom.mk",
   "sInfHom.instSInfHomClassSInfHom"],
  "name": "sSupHom.dual.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : SupSet Î±] [inst_1 : SupSet Î²] (x : sSupHom Î± Î²),\n  (fun f â†¦\n        { toFun := â†‘OrderDual.ofDual âˆ˜ â†‘f âˆ˜ â†‘OrderDual.toDual,\n          map_sSup' := (_ : âˆ€ (s : Set Î±áµ’áµˆ), sInfHom.toFun f (sInf s) = sInf (f.toFun '' s)) })\n      ((fun f â†¦\n          { toFun := â†‘OrderDual.toDual âˆ˜ â†‘f âˆ˜ â†‘OrderDual.ofDual,\n            map_sInf' := (_ : âˆ€ (s : Set Î±), sSupHom.toFun f (sSup s) = sSup (f.toFun '' s)) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_16",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_17._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "IsLowerSet",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "lowerClosure_min.match_1",
   "HasSubset.Subset",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "lowerClosure_min",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s t : Set Î±}, s âŠ† t â†’ IsLowerSet t â†’ â†‘(lowerClosure s) âŠ† t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.mk",
   "Set",
   "Filter.rec",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  {motive : Filter Î± â†’ Sort u} â†’\n    (t : Filter Î±) â†’\n      ((sets : Set (Set Î±)) â†’\n          (univ_sets : Set.univ âˆˆ sets) â†’\n            (sets_of_superset : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets) â†’\n              (inter_sets : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets) â†’\n                motive\n                  { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset,\n                    inter_sets := inter_sets }) â†’\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "DistribLattice.mk",
   "SemilatticeInf.toPartialOrder",
   "Lattice.mk",
   "OrderDual.distribLattice",
   "Lattice.le_inf",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DistribLattice.le_sup_inf",
   "OrderDual",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "DistribLattice.ofInfSupLe.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Lattice Î±] (inf_sup_le : âˆ€ (a b c : Î±), a âŠ“ (b âŠ” c) â‰¤ a âŠ“ b âŠ” a âŠ“ c) (x y z : Î±áµ’áµˆáµ’áµˆ),\n  (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.casesOn",
   "Eq"],
  "name": "Topology.IsLowerSet.noConfusionType",
  "constType":
  "{Î± : Type u_4} â†’\n  {t : TopologicalSpace Î±} â†’ {inst : Preorder Î±} â†’ Sort u â†’ Topology.IsLowerSet Î± â†’ Topology.IsLowerSet Î± â†’ Sort u",
  "constCategory": "Definition"},
 {"references": ["OrderedCancelAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toAddCommMonoid",
  "constType":
  "{Î± : Type u} â†’ [self : OrderedCancelAddCommMonoid Î±] â†’ AddCommMonoid Î±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.rec", "le_refl", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_eq",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a = b â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Iff.rfl",
   "antitone_comp_ofDual_iff",
   "Function.comp",
   "Eq.refl",
   "FunLike.coe",
   "Preorder",
   "Iff.mpr",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "monotone_toDual_comp_iff",
   "Monotone",
   "OrderDual",
   "Antitone",
   "id"],
  "name": "Monotone.dual",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Monotone f â†’ Monotone (â†‘OrderDual.toDual âˆ˜ f âˆ˜ â†‘OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Syntax.Preresolved",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["HEq",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Iff.rfl",
   "Eq.refl",
   "True",
   "Eq",
   "Iff",
   "true_or",
   "List.Mem.casesOn",
   "Iff.trans",
   "And.casesOn",
   "Eq.symm",
   "Eq.trans",
   "List.TFAE",
   "Membership.mem",
   "eq_self",
   "Or",
   "List.cons",
   "eq_of_heq",
   "List.Mem.tail",
   "List.Mem",
   "Iff.symm",
   "Iff.intro",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "List",
   "List.Mem.head",
   "And.intro",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "List.tfae_cons_of_mem",
  "constType":
  "âˆ€ {a b : Prop} {l : List Prop}, b âˆˆ l â†’ (List.TFAE (a :: l) â†” (a â†” b) âˆ§ List.TFAE l)",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsAssociative", "Eq"],
  "name": "Lean.IsAssociative.mk",
  "constType":
  "{Î± : Sort u} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ (âˆ€ (a b c : Î±), op (op a b) c = op a (op b c)) â†’ Lean.IsAssociative op",
  "constCategory": "Other"},
 {"references":
  ["FinsetCoe.fintype",
   "Finset.cons_induction_on",
   "Membership.mem",
   "Exists",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Set",
   "CanLift.prf",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Insert.insert",
   "Exists.casesOn",
   "Set.toFinite",
   "Set.Finite",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.Elem",
   "Finset.toSet",
   "Finset",
   "Finset.cons",
   "Not",
   "Finset.coe_empty",
   "Finset.coe_cons",
   "Finite.of_fintype",
   "id",
   "Set.instInsertSet"],
  "name": "Set.Finite.induction_on",
  "constType":
  "âˆ€ {Î± : Type u} {C : Set Î± â†’ Prop} {s : Set Î±},\n  Set.Finite s â†’ C âˆ… â†’ (âˆ€ {a : Î±} {s : Set Î±}, Â¬a âˆˆ s â†’ Set.Finite s â†’ C s â†’ C (insert a s)) â†’ C s",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "LE.le",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : PartialOrder Î²] (f : Î± â†’ Î²),\n  Function.Injective f â†’ âˆ€ (x x_1 : Î±), x â‰¤ x_1 â†’ x_1 â‰¤ x â†’ x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHAppend",
   "Or",
   "List.instAppendList",
   "HAppend.hAppend",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_append",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.6",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {s t : List Î±}, (a âˆˆ s ++ t) = (a âˆˆ s âˆ¨ a âˆˆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "IsLowerSet",
   "Topology.WithLowerSet",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.isLowerSet_toLowerSet_preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set (Topology.WithLowerSet Î±)},\n  IsLowerSet (â†‘Topology.WithLowerSet.toLowerSet â»Â¹' s) â†” IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Subtype.rec", "Subtype.mk", "Subtype"],
  "name": "Subtype.casesOn",
  "constType":
  "{Î± : Sort u} â†’\n  {p : Î± â†’ Prop} â†’\n    {motive : Subtype p â†’ Sort u_1} â†’\n      (t : Subtype p) â†’ ((val : Î±) â†’ (property : p val) â†’ motive { val := val, property := property }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_3",
   "_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Membership.mem",
   "isClosed_Ici",
   "Topology.IsLower.instClosedIciTopology",
   "Set",
   "Eq.ge",
   "Preorder",
   "Set.Ici",
   "subset_closure",
   "rfl",
   "Eq",
   "Set.instMembershipSet",
   "isClosed_closure",
   "Set.instSingletonSet",
   "Topology.IsLower",
   "TopologicalSpace",
   "Singleton.singleton",
   "closure_minimal",
   "IsUpperSet.Ici_subset",
   "Set.Subset.antisymm",
   "Topology.IsLower.isUpperSet_of_isClosed"],
  "name": "Topology.IsLower.closure_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±] (a : Î±),\n  closure {a} = Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.rec",
   "Nat.zero",
   "Nat.pred",
   "instSubNat",
   "HSub.hSub",
   "Nat",
   "congrArg",
   "rfl",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_sub_succ_eq_sub",
  "constType": "âˆ€ (n m : â„•), Nat.succ n - Nat.succ m = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.ble_succ_eq_true.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ Nat.ble x x_1 = true â†’ Prop) (x x_1 : â„•) (x_2 : Nat.ble x x_1 = true),\n  (âˆ€ (x : â„•) (x_3 : Nat.ble 0 x = true), motive 0 x x_3) â†’\n    (âˆ€ (n n_1 : â„•) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) â†’\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.29",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Char.mk", "UInt32", "Char", "UInt32.isValidChar", "Char.rec"],
  "name": "Char.casesOn",
  "constType":
  "{motive : Char â†’ Sort u} â†’\n  (t : Char) â†’ ((val : UInt32) â†’ (valid : UInt32.isValidChar val) â†’ motive { val := val, valid := valid }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Bool",
   "absurd",
   "rfl",
   "decide_eq_true.match_1",
   "Eq"],
  "name": "decide_eq_true",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], p â†’ decide p = true",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Fin.val",
   "Iff.rfl",
   "LT.lt",
   "Nat",
   "instLTNat",
   "instLTFin",
   "Fin"],
  "name": "Fin.lt_def",
  "constType": "âˆ€ {n : â„•} {a b : Fin n}, a < b â†” â†‘a < â†‘b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "False",
   "List.brecOn",
   "List.below",
   "Lean.Data.AC.EvalInformation",
   "Unit",
   "Eq.refl",
   "Eq",
   "PProd",
   "PUnit.unit",
   "Eq.mpr",
   "PProd.fst",
   "Lean.Data.AC.evalList",
   "List.rec",
   "List",
   "PUnit",
   "Lean.Data.AC.EvalInformation.evalVar",
   "_private.Init.Data.AC.0.Lean.Data.AC.evalList.match_1.eq_3",
   "List.nil",
   "Nat",
   "Lean.Data.AC.EvalInformation.arbitrary",
   "congrArg",
   "Lean.Data.AC.evalList.match_1",
   "PProd.mk",
   "Lean.Data.AC.EvalInformation.evalOp",
   "congrFun",
   "id"],
  "name": "_private.Init.Data.AC.0.Lean.Data.AC.evalList._eq_3",
  "constType":
  "âˆ€ {Î± : Sort u_1} (Î² : Sort u) [inst : Lean.Data.AC.EvalInformation Î± Î²] (ctx : Î±) (x_1 : â„•) (xs : List â„•),\n  (xs = [] â†’ False) â†’\n    Lean.Data.AC.evalList Î² ctx (x_1 :: xs) =\n      Lean.Data.AC.EvalInformation.evalOp ctx (Lean.Data.AC.EvalInformation.evalVar ctx x_1)\n        (Lean.Data.AC.evalList Î² ctx xs)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.cat", "_obj", "Topology.Â«termI^_Â»._closed_9"],
  "name": "Topology.Â«termI^_Â»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.length_le",
   "List.filter",
   "instLENat",
   "List",
   "List.filter_sublist",
   "Bool",
   "List.length",
   "Nat",
   "LE.le"],
  "name": "List.length_filter_le",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (l : List Î±), List.length (List.filter p l) â‰¤ List.length l",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "himp_eq",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : BooleanAlgebra Î±], x â‡¨ y = y âŠ” xá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.filterMap",
   "List.Perm",
   "List.filterMap_eq_map",
   "List.filterMap",
   "List",
   "Function.comp",
   "Eq.rec",
   "Option.some",
   "List.map",
   "Eq",
   "Option"],
  "name": "List.Perm.map",
  "constType":
  "âˆ€ {Î± : Type uu} {Î² : Type vv} (f : Î± â†’ Î²) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.map f lâ‚ ~ List.map f lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "sInf_le",
   "IsGLB",
   "upperBounds",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "le_sInf",
   "And.intro",
   "CompleteSemilatticeInf",
   "Set.instMembershipSet"],
  "name": "isGLB_sInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] (s : Set Î±), IsGLB s (sInf s)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "EmptyCollection.emptyCollection",
   "and_iff_left",
   "Set.Subset.antisymm_iff",
   "Set",
   "Set.empty_subset",
   "HasSubset.Subset",
   "Iff.trans",
   "Set.instEmptyCollectionSet",
   "Eq"],
  "name": "Set.subset_empty_iff",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s âŠ† âˆ… â†” s = âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt.match_1",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "le_refl",
   "LinearOrder.toPartialOrder",
   "Not",
   "le_of_lt",
   "absurd",
   "LE.le",
   "Preorder.toLE",
   "lt_trichotomy",
   "Eq"],
  "name": "le_of_not_lt",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b : Î±}, Â¬b < a â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "Or", "Not", "And.left", "mt", "Or.elim"],
  "name": "not_and_of_not_or_not",
  "constType": "âˆ€ {a b : Prop}, Â¬a âˆ¨ Â¬b â†’ Â¬(a âˆ§ b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddMonoidHom.rec",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.casesOn",
  "constType":
  "{M : Type u_9} â†’\n  {N : Type u_10} â†’\n    [inst : AddZeroClass M] â†’\n      [inst_1 : AddZeroClass N] â†’\n        {motive : (M â†’+ N) â†’ Sort u} â†’\n          (t : M â†’+ N) â†’\n            ((toZeroHom : ZeroHom M N) â†’\n                (map_add' :\n                    âˆ€ (x y : M),\n                      ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) â†’\n                  motive { toZeroHom := toZeroHom, map_add' := map_add' }) â†’\n              motive t",
  "constCategory": "Definition"},
 {"references": ["Function.comp", "rfl", "Eq", "id"],
  "name": "Function.comp.left_id",
  "constType": "âˆ€ {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²), id âˆ˜ f = f",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_5"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.gc_map_comap",
   "GaloisConnection.l_u_le",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.map_comap_le",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {g : Filter Î²} {m : Î± â†’ Î²}, Filter.map m (Filter.comap m g) â‰¤ g",
  "constCategory": "Theorem"},
 {"references": ["String", "UInt64"],
  "name": "String.hash",
  "constType": "String â†’ UInt64",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "Set.instBooleanAlgebraSet",
   "BooleanAlgebra.toHImp",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_10",
  "constType": "âˆ€ {Î± : Type u_1} (x y : Set Î±), x â‡¨ y = y âŠ” xá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "eq_true", "List.Perm", "List", "List.Perm.swap", "True", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.14",
  "constType":
  "âˆ€ {Î± : Type uu} (x y : Î±) (l : List Î±), (y :: x :: l ~ x :: y :: l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.completeLattice.proof_8",
   "CompleteSemilatticeInf.toPartialOrder",
   "Prod.completeLattice.proof_4",
   "PartialOrder.toPreorder",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "Prod.instLEProd",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "Prod.completeLattice.proof_3",
   "Preorder.toLE",
   "OrderTop.toTop",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Prod.infSet",
   "Prod.supSet",
   "Prod.completeLattice.proof_5",
   "Prod.boundedOrder",
   "Lattice.toSemilatticeSup",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "Prod.completeLattice.proof_2",
   "Prod.lattice",
   "Prod.completeLattice.proof_7",
   "InfSet",
   "SupSet.sSup",
   "SupSet",
   "InfSet.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderBot.toBot",
   "Prod.completeLattice.proof_6",
   "Prod",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Prod.completeLattice.proof_9",
   "Prod.completeLattice.proof_1"],
  "name": "Prod.completeLattice",
  "constType":
  "(Î± : Type u_1) â†’ (Î² : Type u_2) â†’ [inst : CompleteLattice Î±] â†’ [inst : CompleteLattice Î²] â†’ CompleteLattice (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "Eq.rec",
   "exists_eq_left.match_1",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Eq"],
  "name": "exists_eq_left",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, a = a' âˆ§ p a) â†” p a'",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "OfNat",
   "instOfNatNat",
   "OfNat.mk",
   "Nat",
   "Fin",
   "Fin.ofNat"],
  "name": "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
  "constType": "{n i : â„•} â†’ OfNat (Fin (n + 1)) i",
  "constCategory": "Definition"},
 {"references":
  ["Option.some.injEq",
   "Exists",
   "False",
   "HEq",
   "List.get?_len_le",
   "Eq.refl",
   "Option.noConfusion",
   "Exists.intro",
   "List.length",
   "List.get?_eq_get",
   "List.get?_eq_some.match_1",
   "LE.le",
   "instLTNat",
   "Eq",
   "Iff.intro",
   "Iff",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Option.none",
   "List",
   "Eq.rec",
   "LT.lt",
   "Eq.mp",
   "Option.some",
   "Eq.casesOn",
   "Nat.lt_of_not_le",
   "Nat",
   "List.get?",
   "List.get",
   "Fin.mk",
   "Option"],
  "name": "List.get?_eq_some",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} {n : â„•},\n  List.get? l n = some a â†” âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "List.instMembershipList",
   "List",
   "List.attach",
   "True",
   "Subtype",
   "Eq",
   "List.mem_attach"],
  "name": "Mathlib.Data.List.Basic._auxLemma.62",
  "constType":
  "âˆ€ {Î± : Type u} (l : List Î±) (x : { x // x âˆˆ l }), (x âˆˆ List.attach l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "funext",
   "List.cons",
   "List.filterMap",
   "Unit",
   "Eq.refl",
   "List.Perm.rec",
   "Option.casesOn",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "True",
   "Eq",
   "Mathlib.Data.List.Perm._auxLemma.13",
   "eq_true",
   "List.Perm",
   "Eq.ndrec",
   "of_eq_true",
   "Mathlib.Data.List.Perm._auxLemma.14",
   "List.filterMap_cons.match_1",
   "List.filterMap_cons_none",
   "List",
   "Option.none",
   "congr",
   "List.Perm.trans",
   "Option.some",
   "List.nil",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option"],
  "name": "List.Perm.filterMap",
  "constType":
  "âˆ€ {Î± : Type uu} {Î² : Type vv} (f : Î± â†’ Option Î²) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.filterMap f lâ‚ ~ List.filterMap f lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "Preorder",
   "LE.le",
   "bot_le",
   "Preorder.toLE",
   "GaloisConnection.l_le",
   "PartialOrder"],
  "name": "GaloisConnection.liftOrderBot.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : OrderBot Î±] [inst_2 : PartialOrder Î²] {l : Î± â†’ Î²}\n  {u : Î² â†’ Î±}, GaloisConnection l u â†’ âˆ€ (x : Î²), l âŠ¥ â‰¤ x",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLower.toDualHomeomorph._lambda_1", "_obj"],
  "name": "Topology.WithLower.toDualHomeomorph._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Sup",
   "Prod.instSupProd",
   "Prod.fst",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "le_sup_left",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "inferInstanceAs",
   "Prod",
   "Sup.sup",
   "And.intro",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeSup Î±] [inst_1 : SemilatticeSup Î²] (x x_1 : Î± Ã— Î²),\n  x.1 â‰¤ (x âŠ” x_1).1 âˆ§ x.2 â‰¤ (x âŠ” x_1).2",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM.Result.casesOn",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.bind.match_1",
  "constType":
  "{Îµ Ïƒ Î± : Type u_1} â†’\n  (motive : EStateM.Result Îµ Ïƒ Î± â†’ Sort u_2) â†’\n    (x : EStateM.Result Îµ Ïƒ Î±) â†’\n      ((a : Î±) â†’ (s : Ïƒ) â†’ motive (EStateM.Result.ok a s)) â†’\n        ((e : Îµ) â†’ (s : Ïƒ) â†’ motive (EStateM.Result.error e s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.Equiv",
  "constType": "{Î± : Sort u} â†’ [self : HasEquiv Î±] â†’ Î± â†’ Î± â†’ Sort v",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.IsCommutative",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Type",
  "constCategory": "Other"},
 {"references":
  ["Not.elim",
   "List.pwFilter_subset",
   "List.find?_some",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "Or.resolve_right",
   "dite",
   "Std.Logic._auxLemma.64",
   "Std.Logic._auxLemma.45",
   "implies_congr",
   "Eq",
   "Decidable.decide",
   "Std.Data.List.Pairwise._auxLemma.14",
   "Eq.mpr",
   "List.pairwise_filterMap.match_1",
   "Iff",
   "Iff.mp",
   "List.rec",
   "List.decidableBAll",
   "List.pwFilter_cons_of_pos",
   "Option.none",
   "instDecidableNot",
   "forall_congr",
   "Bool.true",
   "Eq.rec",
   "Option.some",
   "Bool.not_eq_true'",
   "List.pwFilter",
   "List.nil",
   "Eq.symm",
   "Eq.trans",
   "id",
   "Option",
   "Membership.mem",
   "List.cons",
   "Or",
   "not",
   "List.not_mem_nil",
   "Std.Logic._auxLemma.23",
   "List.pwFilter_cons_of_neg",
   "decide_not",
   "Iff.intro",
   "List.find?",
   "And",
   "Eq.ndrec",
   "False.elim",
   "List.find?_eq_none",
   "propext",
   "Bool.false",
   "List",
   "Eq.mp",
   "Std.Logic._auxLemma.58",
   "Not",
   "Bool",
   "And.intro",
   "congrArg",
   "decide_eq_true_iff",
   "List.mem_of_find?_eq_some",
   "congrFun",
   "DecidableRel"],
  "name": "List.forall_mem_pwFilter",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [inst : DecidableRel R],\n  (âˆ€ {x y z : Î±}, R x z â†’ R x y âˆ¨ R y z) â†’ âˆ€ (a : Î±) (l : List Î±), (âˆ€ b âˆˆ List.pwFilter R l, R a b) â†” âˆ€ b âˆˆ l, R a b",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.length_le",
   "List.filter",
   "List.Sublist",
   "List.Sublist.filter",
   "List.length",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "List",
   "congr",
   "Bool",
   "Nat",
   "List.countP",
   "congrArg",
   "id",
   "List.countP_eq_length_filter"],
  "name": "List.Sublist.countP_le",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.countP p lâ‚ â‰¤ List.countP p lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.IsUpperSet.WithUpperSetHomeomorph._rarg", "_neutral"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.succ_mul",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "Nat.zero_mul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.mul_comm",
  "constType": "âˆ€ (n m : â„•), n * m = m * n",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "BEq",
   "List.brecOn",
   "List.below",
   "Unit",
   "List.beq.match_1",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "List.rec",
   "List",
   "and",
   "Bool.false",
   "Bool.true",
   "PUnit",
   "Bool",
   "List.nil"],
  "name": "List.beq",
  "constType": "{Î± : Type u} â†’ [inst : BEq Î±] â†’ List Î± â†’ List Î± â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Set.instHasSubsetSet",
   "Eq.rec",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter.generate",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)), (Filter.generate s).sets = s â†’ âˆ€ {x y : Set Î±}, x âˆˆ s â†’ x âŠ† y â†’ y âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.Sublist.rec"],
  "name": "List.Sublist.casesOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop} {a a_1 : List Î±} (t : List.Sublist a a_1),\n  motive [] [] (_ : List.Sublist [] []) â†’\n    (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) (a_2 : List.Sublist lâ‚ lâ‚‚), motive lâ‚ (a :: lâ‚‚) (_ : List.Sublist lâ‚ (a :: lâ‚‚))) â†’\n      (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) (a_2 : List.Sublist lâ‚ lâ‚‚),\n          motive (a :: lâ‚) (a :: lâ‚‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))) â†’\n        motive a a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "SDiff.sdiff",
   "Lattice.toSemilatticeSup",
   "BiheytingAlgebra.toSDiff",
   "LE.le",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "BiheytingAlgebra.sdiff_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : BiheytingAlgebra Î±] (a b c : Î±), a \\ b â‰¤ c â†” a â‰¤ b âŠ” c",
  "constCategory": "Definition"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{Î± : Type u_1} â†’ (x y : Î±) â†’ [inst : LT Î±] â†’ [inst : Decidable (x < y)] â†’ [inst : DecidableEq Î±] â†’ Ordering",
  "constCategory": "Definition"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "Lattice.mk",
   "And.left",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "And.right",
   "upperBounds",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.isGLB_of_u_image",
   "id",
   "Membership.mem",
   "isGLB_sInf",
   "Monotone.mem_lowerBounds_image",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "GaloisInsertion.choice",
   "Set.instMembershipSet",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.choice_eq",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±]\n  (gi : GaloisInsertion l u) (s : Set Î²), âˆ€ a âˆˆ s, sInf s â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "OfNat.ofNat",
   "not_lt",
   "List.Sublist",
   "instBEq",
   "List.nodup_iff_sublist",
   "instLTNat",
   "LE.le",
   "Iff.symm",
   "Nat.linearOrder",
   "Iff",
   "List.Nodup",
   "instLENat",
   "DecidableEq",
   "not_congr",
   "List",
   "LT.lt",
   "List.replicate",
   "List.le_count_iff_replicate_sublist",
   "Iff.trans",
   "Not",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.count",
   "forall_congr'"],
  "name": "List.nodup_iff_count_le_one",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {l : List Î±}, List.Nodup l â†” âˆ€ (a : Î±), List.count a l â‰¤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["add_left_cancel",
   "add_comm",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "IsRightCancelAdd.mk",
   "Eq.trans",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd",
  "constType":
  "âˆ€ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsLeftCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "OrderTop.mk",
   "PartialOrder.toPreorder",
   "Top.top",
   "GaloisInsertion.liftOrderTop.proof_1",
   "GaloisInsertion.liftOrderTop.proof_2",
   "OrderTop",
   "Preorder",
   "GaloisInsertion.choice",
   "Top.mk",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftOrderTop",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’\n      {u : Î² â†’ Î±} â†’\n        [inst : PartialOrder Î²] â†’ [inst_1 : Preorder Î±] â†’ [inst_2 : OrderTop Î±] â†’ GaloisInsertion l u â†’ OrderTop Î²",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_add'",
  "constType":
  "âˆ€ {M : Type u_9} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M â†’+ N) (x y : M),\n  ZeroHom.toFun (â†‘self) (x + y) = ZeroHom.toFun (â†‘self) x + ZeroHom.toFun (â†‘self) y",
  "constCategory": "Definition"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ SProd Î± Î² Î³",
  "constCategory": "Other"},
 {"references": ["OrderHom", "Monotone", "Preorder"],
  "name": "OrderHom.mk",
  "constType":
  "{Î± : Type u_6} â†’\n  {Î² : Type u_7} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (toFun : Î± â†’ Î²) â†’ Monotone toFun â†’ Î± â†’o Î²",
  "constCategory": "Other"},
 {"references": ["Bool.casesOn", "Bool"],
  "name": "Bool.noConfusionType",
  "constType": "Sort u â†’ Bool â†’ Bool â†’ Sort u",
  "constCategory": "Definition"},
 {"references": ["BiheytingAlgebra", "SDiff"],
  "name": "BiheytingAlgebra.toSDiff",
  "constType": "{Î± : Type u_4} â†’ [self : BiheytingAlgebra Î±] â†’ SDiff Î±",
  "constCategory": "Definition"},
 {"references":
  ["IsAntisymm", "HasSubset.Subset", "HasSubset", "antisymm", "Eq"],
  "name": "subset_antisymm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsAntisymm Î± fun x x_1 â†¦ x âŠ† x_1], a âŠ† b â†’ b âŠ† a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "Set",
   "Inter.inter",
   "and_self_iff",
   "Eq",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "Set.inter_self",
  "constType": "âˆ€ {Î± : Type u} (a : Set Î±), a âˆ© a = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "HAppend.hAppend",
   "List.Sublist.trans",
   "List",
   "List.append_sublist_append_left",
   "List.Sublist",
   "List.Sublist.append_right",
   "Iff.mpr"],
  "name": "List.Sublist.append",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist râ‚ râ‚‚ â†’ List.Sublist (lâ‚ ++ râ‚) (lâ‚‚ ++ râ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["List.instHasSubsetList",
   "List.cons",
   "List",
   "List.casesOn",
   "HasSubset.Subset",
   "List.nil"],
  "name": "List.subset_nil.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (l : List Î±) â†’ l âŠ† [] â†’ Prop) (l : List Î±) (h : l âŠ† []),\n  (âˆ€ (h : [] âŠ† []), motive [] h) â†’\n    (âˆ€ (head : Î±) (tail : List Î±) (h : head :: tail âŠ† []), motive (head :: tail) h) â†’ motive l h",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.antisymm",
   "Iff.intro",
   "Iff",
   "PartialOrder.toPreorder",
   "Eq.le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.le_iff_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ (b â‰¤ a â†” b = a)",
  "constCategory": "Theorem"},
 {"references": ["PSigma", "PSigma.fst"],
  "name": "PSigma.snd",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Î± â†’ Sort v} â†’ (self : PSigma Î²) â†’ Î² self.fst",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.Ici",
   "Mathlib.Order.UpperLower.Basic._auxLemma.94",
   "UpperSet",
   "Preorder.toLE",
   "True",
   "SetLike.instMembership",
   "Iff.of_eq",
   "iff_self",
   "Eq",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "upperClosure",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "SetLike.coe",
   "exists_prop_congr'"],
  "name": "coe_upperClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (s : Set Î±), â†‘(upperClosure s) = â‹ƒ a âˆˆ s, Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis.to_hasBasis'.match_1",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "Filter.HasBasis.mem_of_mem",
   "HasSubset.Subset",
   "Filter.HasBasis.mem_iff",
   "LE.le",
   "Preorder.toLE",
   "Iff.intro",
   "Filter.HasBasis",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "Iff.mp",
   "Filter.instPartialOrderFilter",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.ge_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹' : Sort u_5} {l l' : Filter Î±} {p' : Î¹' â†’ Prop} {s' : Î¹' â†’ Set Î±},\n  Filter.HasBasis l' p' s' â†’ (l â‰¤ l' â†” âˆ€ (i' : Î¹'), p' i' â†’ s' i' âˆˆ l)",
  "constCategory": "Theorem"},
 {"references": ["Acc.rec", "Acc"],
  "name": "WellFounded.fixF",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’ {C : Î± â†’ Sort v} â†’ ((x : Î±) â†’ ((y : Î±) â†’ r y x â†’ C y) â†’ C x) â†’ (x : Î±) â†’ Acc r x â†’ C x",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Or",
   "Iff",
   "Decidable.not_or_of_imp",
   "Decidable",
   "Not",
   "Or.neg_resolve_left"],
  "name": "Decidable.imp_iff_not_or",
  "constType": "âˆ€ {a b : Prop} [inst : Decidable a], a â†’ b â†” Â¬a âˆ¨ b",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.17",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) = (a âˆ§ b)",
  "constCategory": "Theorem"},
 {"references": ["Seq", "Applicative"],
  "name": "Applicative.toSeq",
  "constType": "{f : Type u â†’ Type v} â†’ [self : Applicative f] â†’ Seq f",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inf.inf",
   "isGLB_pair",
   "InfSet.sInf",
   "Insert.insert",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Set.instSingletonSet",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Singleton.singleton",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instInsertSet"],
  "name": "sInf_pair",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {a b : Î±}, sInf {a, b} = a âŠ“ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Top", "Top.top", "Top.mk"],
  "name": "Pi.instTopForAll",
  "constType":
  "{Î¹ : Type u_3} â†’ {Î±' : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ Top (Î±' i)] â†’ Top ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(Î± : Type u) â†’ [inst : LE Î±] â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["List.mem_map.match_1",
   "List.filter",
   "List.cons",
   "Std.Data.List.Lemmas._auxLemma.39",
   "List.brecOn",
   "List.below",
   "_private.Std.Data.List.Lemmas.0.List.erase.match_1.splitter",
   "Unit",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.slnil",
   "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
   "Std.Data.List.Lemmas._auxLemma.57",
   "Eq",
   "PProd",
   "PProd.fst",
   "eq_true",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "of_eq_true",
   "Bool.false",
   "List",
   "Bool.true",
   "PUnit",
   "Bool",
   "List.nil",
   "List.erase.match_1",
   "Eq.symm",
   "id"],
  "name": "List.filter_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} (l : List Î±), List.Sublist (List.filter p l) l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.IsOpen",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.isOpen_sUnion",
  "constType":
  "âˆ€ {Î± : Type u} [self : TopologicalSpace Î±] (s : Set (Set Î±)),\n  (âˆ€ t âˆˆ s, TopologicalSpace.IsOpen t) â†’ TopologicalSpace.IsOpen (â‹ƒâ‚€ s)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.inter_sets",
  "constType":
  "âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ y âˆˆ self.sets â†’ x âˆ© y âˆˆ self.sets",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Iff.mp", "Iff", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.subtype.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (s : Finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†” p x) â†’ âˆ€ x âˆˆ s, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLowerSet.mk",
  "constType":
  "âˆ€ {Î± : Type u_4} [t : TopologicalSpace Î±] [inst : Preorder Î±], t = Topology.lowerSet Î± â†’ Topology.IsLowerSet Î±",
  "constCategory": "Other"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
  "constType":
  "{Î± : Type u} â†’ [self : CompleteAtomicBooleanAlgebra Î±] â†’ CompletelyDistribLattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.6",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Trans", "Iff", "Iff.trans", "Trans.mk"],
  "name": "instTransPropIff_1",
  "constType": "Trans Iff Iff Iff",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "and_assoc",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "Set.inter_assoc",
  "constType": "âˆ€ {Î± : Type u} (a b c : Set Î±), a âˆ© b âˆ© c = a âˆ© (b âˆ© c)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "propext",
   "Set",
   "Topology.IsUpperSet.isOpen_iff_isUpperSet",
   "TopologicalSpace",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±] {s : Set Î±},\n  IsOpen s = IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰ ]_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "le_inf",
   "SemilatticeInf.toPartialOrder",
   "sup_le_sup_left",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "sup_inf_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Lattice Î±] {a b c : Î±}, a âŠ” b âŠ“ c â‰¤ (a âŠ” b) âŠ“ (a âŠ” c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "True",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.19",
  "constType": "âˆ€ (n : â„•), (0 < Nat.succ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "cond",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.countP.go",
   "True",
   "Eq",
   "Nat.zero_add",
   "Bool.of_not_eq_true",
   "of_eq_true",
   "List",
   "Bool.false",
   "Bool.true",
   "congr",
   "Not",
   "instOfNatNat",
   "Bool",
   "List.countP",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.countP_cons_of_neg",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {a : Î±} (l : List Î±), Â¬p a = true â†’ List.countP p (a :: l) = List.countP p l",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "dite",
   "Not",
   "absurd",
   "rfl",
   "Eq"],
  "name": "dif_pos",
  "constType":
  "âˆ€ {c : Prop} {h : Decidable c} (hc : c) {Î± : Sort u} {t : c â†’ Î±} {e : Â¬c â†’ Î±}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references":
  ["UInt32", "UInt32.mk", "LT.lt", "UInt32.size", "Nat", "instLTNat", "Fin.mk"],
  "name": "UInt32.ofNatCore",
  "constType": "(n : â„•) â†’ n < UInt32.size â†’ UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Subtype.val",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Subtype.coe_image.match_2",
   "Subtype.coe_image.match_1",
   "Eq.rec",
   "And.intro",
   "Set.image",
   "Subtype",
   "Subtype.mk"],
  "name": "Subtype.coe_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {s : Set (Subtype p)},\n  Subtype.val '' s = {x | âˆƒ (h : p x), { val := x, property := h } âˆˆ s}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "And.right",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_right",
  "constType": "âˆ€ {Î± : Type u} (s t : Set Î±), s âˆ© t âŠ† t",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "False", "List", "Not", "List.noConfusion", "absurd", "Eq"],
  "name": "List.hasDecEq.proof_5",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (as : List Î±) (b : Î±) (bs : List Î±), Â¬as = bs â†’ a :: as = b :: bs â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "Set.mem_preimage",
   "Eq.refl",
   "HasSubset.Subset",
   "Exists.intro",
   "rfl",
   "Iff.mpr",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Filter.mem_comap'.match_1",
   "Filter.comap",
   "Filter",
   "And.intro",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.mem_comap'",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {l : Filter Î²} {s : Set Î±},\n  s âˆˆ Filter.comap f l â†” {y | âˆ€ â¦ƒx : Î±â¦„, f x = y â†’ x âˆˆ s} âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["WellFoundedRelation", "WellFounded"],
  "name": "WellFoundedRelation.mk",
  "constType":
  "{Î± : Sort u} â†’ (rel : Î± â†’ Î± â†’ Prop) â†’ WellFounded rel â†’ WellFoundedRelation Î±",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} â†’ [self : AddRightCancelMonoid M] â†’ AddMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inf",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.add",
   "List.cons",
   "OfNat.ofNat",
   "HEq",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "Eq.refl",
   "List.casesOn",
   "instOfNatNat",
   "Eq.casesOn",
   "List.nil",
   "List.length",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "List.eq_nil_of_length_eq_zero.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (l : List Î±) â†’ List.length l = 0 â†’ Prop) (l : List Î±) (x : List.length l = 0),\n  (âˆ€ (x : List.length [] = 0), motive [] x) â†’ motive l x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper",
   "Equiv.toHomeomorphOfInducing",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.IsUpper.WithUpperHomeomorph.proof_1",
   "Homeomorph",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Topology.WithUpper.ofUpper"],
  "name": "Topology.IsUpper.WithUpperHomeomorph",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsUpper Î±] â†’ Topology.WithUpper Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.mk",
  "constType":
  "âˆ€ {Î± : Type u_4} [t : TopologicalSpace Î±] [inst : Preorder Î±], t = Topology.upperSet Î± â†’ Topology.IsUpperSet Î±",
  "constCategory": "Other"},
 {"references": ["IsAntisymm", "Eq"],
  "name": "IsAntisymm.mk",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop}, (âˆ€ (a b : Î±), r a b â†’ r b a â†’ a = b) â†’ IsAntisymm Î± r",
  "constCategory": "Other"},
 {"references": ["Lean.MonadRef", "Lean.Syntax"],
  "name": "Lean.MonadRef.getRef",
  "constType": "{m : Type â†’ Type} â†’ [self : Lean.MonadRef m] â†’ m Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List.Perm", "List"],
  "name": "List.Perm.cons",
  "constType":
  "âˆ€ {Î± : Type uu} (x : Î±) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ x :: lâ‚ ~ x :: lâ‚‚",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "EStateM.get",
   "EStateM.set",
   "EStateM.modifyGet",
   "MonadStateOf",
   "MonadStateOf.mk"],
  "name": "EStateM.instMonadStateOfEStateM",
  "constType": "{Îµ Ïƒ : Type u} â†’ MonadStateOf Ïƒ (EStateM Îµ Ïƒ)",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.lt_wfRel.match_1",
  "constType":
  "âˆ€ (n m : â„•) (motive : m = n âˆ¨ m < n â†’ Prop) (this : m = n âˆ¨ m < n),\n  (âˆ€ (e : m = n), motive (_ : m = n âˆ¨ m < n)) â†’ (âˆ€ (e : m < n), motive (_ : m = n âˆ¨ m < n)) â†’ motive this",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "OrderDual.instIsLower.proof_1",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "OrderDual.instIsLower",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±], Topology.IsLower Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "TopologicalSpace.isOpen_inter",
   "TopologicalSpace",
   "Inter.inter",
   "IsOpen",
   "Set.instInterSet"],
  "name": "IsOpen.inter",
  "constType":
  "âˆ€ {Î± : Type u} {sâ‚ sâ‚‚ : Set Î±} [inst : TopologicalSpace Î±], IsOpen sâ‚ â†’ IsOpen sâ‚‚ â†’ IsOpen (sâ‚ âˆ© sâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "Set",
   "LE",
   "Set.sUnion",
   "Exists.imp",
   "And.intro",
   "IsUpperSet",
   "And.left",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "isUpperSet_sUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {S : Set (Set Î±)}, (âˆ€ s âˆˆ S, IsUpperSet s) â†’ IsUpperSet (â‹ƒâ‚€ S)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "HEq",
   "instLENat",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Nat.le.refl",
   "instOfNatNat",
   "Nat.le.casesOn",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.not_succ_le_zero.match_1",
  "constType":
  "âˆ€ (motive : Nat.succ 0 â‰¤ 0 â†’ Prop) (h : Nat.succ 0 â‰¤ 0), motive h",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelCommMonoid.add_comm",
  "constType":
  "âˆ€ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["List.Perm", "List.nil"],
  "name": "List.Perm.nil",
  "constType": "âˆ€ {Î± : Type uu}, [] ~ []",
  "constCategory": "Other"},
 {"references": ["Inhabited", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_4",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_comap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {g : Filter Î²} {m : Î± â†’ Î²} {s : Set Î±}, s âˆˆ Filter.comap m g â†” âˆƒ t âˆˆ g, m â»Â¹' t âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List.Chain.casesOn",
   "List",
   "eq_of_heq",
   "List.Chain.nil",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Chain",
   "Eq",
   "List.Chain.cons"],
  "name": "List.Chain.pairwise.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} (motive : (x : Î±) â†’ (x_1 : List Î±) â†’ List.Chain R x x_1 â†’ Prop) (x : Î±)\n  (x_1 : List Î±) (x_2 : List.Chain R x x_1),\n  (âˆ€ (a : Î±), motive a [] (_ : List.Chain R a [])) â†’\n    (âˆ€ (a b : Î±) (l : List Î±) (h : R a b) (hb : List.Chain R b l), motive a (b :: l) (_ : List.Chain R a (b :: l))) â†’\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["Acc.recOn", "Acc"],
  "name": "Acc.inv.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {r : Î± â†’ Î± â†’ Prop} {x y : Î±}, Acc r x â†’ r y x â†’ Acc r y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "WellFoundedRelation",
  "constType": "Sort u â†’ Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": [],
  "name": "SeqRight",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "GaloisConnection",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Function.comp",
   "OrderDual",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisConnection.dual",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’\n    GaloisConnection (â†‘OrderDual.toDual âˆ˜ u âˆ˜ â†‘OrderDual.ofDual) (â†‘OrderDual.toDual âˆ˜ l âˆ˜ â†‘OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Disjoint",
   "IsCompl",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.disjoint",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, IsCompl x y â†’ Disjoint x y",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.forall_image2_iff",
   "Set.image2",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.image2_subset_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} {u : Set Î³},\n  Set.image2 f s t âŠ† u â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, f x y âˆˆ u",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Eq",
   "Filter.mem_principal",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.11",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, (s âˆˆ Filter.principal t) = (t âŠ† s)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Sup",
   "Prod.instSupProd",
   "Prod.fst",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "inferInstanceAs",
   "Prod",
   "Sup.sup",
   "le_sup_right",
   "And.intro",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeSup Î±] [inst_1 : SemilatticeSup Î²] (x x_1 : Î± Ã— Î²),\n  x_1.1 â‰¤ (x âŠ” x_1).1 âˆ§ x_1.2 â‰¤ (x âŠ” x_1).2",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.comm.match_2",
  "constType":
  "âˆ€ {a b : Prop} (motive : b âˆ§ a â†’ Prop) (h : b âˆ§ a), (âˆ€ (hâ‚ : b) (hâ‚‚ : a), motive (_ : b âˆ§ a)) â†’ motive h",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Subsingleton.intro",
   "Decidable.isFalse",
   "Subsingleton",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "Eq"],
  "name": "instSubsingletonDecidable.proof_1",
  "constType": "âˆ€ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Lean.MacroScope",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.Homotopy.Â«termÎ©^Â»._closed_2",
   "Topology.Homotopy.Â«termÎ©^Â»._closed_4"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "EStateM.Backtrackable",
  "constType": "outParam (Type u) â†’ Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{Î± : Type u} â†’ [self : NonUnitalNonAssocSemiring Î±] â†’ Mul Î±",
  "constCategory": "Definition"},
 {"references": ["Inter"],
  "name": "Inter.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Inter Î±",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} â†’ [self : AddMonoidWithOne R] â†’ AddMonoid R",
  "constCategory": "Definition"},
 {"references": ["Lean.Name._impl"],
  "name": "Lean.Name.anonymous._impl",
  "constType": "Lean.Name._impl",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "HEq",
   "instLENat",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Nat.le.refl",
   "instOfNatNat",
   "Nat.le.casesOn",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.not_succ_le_zero.match_2",
  "constType":
  "âˆ€ (n : â„•) (motive : Nat.succ (Nat.succ n) â‰¤ 0 â†’ Prop) (h : Nat.succ (Nat.succ n) â‰¤ 0), motive h",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toZero",
  "constType": "{M : Type u} â†’ [self : AddLeftCancelMonoid M] â†’ Zero M",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Iff",
   "le_compl_iff_disjoint_right",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "disjoint_comm",
   "Iff.trans",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "le_compl_iff_disjoint_left",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, a â‰¤ bá¶œ â†” Disjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.rec",
  "constType":
  "{Î± : Type u} â†’\n  {motive : TopologicalSpace Î± â†’ Sort u_1} â†’\n    ((IsOpen : Set Î± â†’ Prop) â†’\n        (isOpen_univ : IsOpen Set.univ) â†’\n          (isOpen_inter : âˆ€ (s t : Set Î±), IsOpen s â†’ IsOpen t â†’ IsOpen (s âˆ© t)) â†’\n            (isOpen_sUnion : âˆ€ (s : Set (Set Î±)), (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹ƒâ‚€ s)) â†’\n              motive\n                { IsOpen := IsOpen, isOpen_univ := isOpen_univ, isOpen_inter := isOpen_inter,\n                  isOpen_sUnion := isOpen_sUnion }) â†’\n      (t : TopologicalSpace Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["False", "False.rec"],
  "name": "False.casesOn",
  "constType": "(motive : False â†’ Sort u) â†’ (t : False) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Eq.refl",
   "Std.Logic._auxLemma.23",
   "implies_congr",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.57",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.ball_image_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s : Set Î±} {p : Î² â†’ Prop}, (âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ x âˆˆ s, p (f x)",
  "constCategory": "Theorem"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{Î± : Type u_1} â†’ Singleton Î± (Set Î±)",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.ofUpperSet._cstage1",
  "constType": "{Î± : Type u_1} â†’ Topology.WithUpperSet Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "SemilatticeSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toSup",
   "Mathlib.Order.Basic._auxLemma.1",
   "of_eq_true",
   "sup_of_le_left",
   "Sup.sup",
   "congrArg",
   "LE.le",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "True",
   "congrFun",
   "Eq"],
  "name": "sup_idem",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a : Î±}, a âŠ” a = a",
  "constCategory": "Theorem"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Min Î±",
  "constCategory": "Other"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Char.utf8Size.proof_2",
   "Char.val",
   "UInt32",
   "OfNat.ofNat",
   "Char.utf8Size.proof_4",
   "UInt32.ofNatCore",
   "Char.utf8Size.proof_7",
   "Char.utf8Size.proof_3",
   "LE.le",
   "ite",
   "Char",
   "Char.utf8Size.proof_6",
   "Char.utf8Size.proof_5",
   "instLEUInt32",
   "instOfNatNat",
   "Nat",
   "Char.utf8Size.proof_1",
   "instDecidableLeUInt32InstLEUInt32"],
  "name": "Char.utf8Size",
  "constType": "Char â†’ UInt32",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "BEq",
   "List.brecOn",
   "List.below",
   "Unit",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "List.rec",
   "List",
   "Bool.false",
   "Bool.true",
   "PUnit",
   "Bool",
   "List.nil",
   "List.erase.match_1",
   "List.isEmpty.match_1"],
  "name": "List.elem",
  "constType": "{Î± : Type u} â†’ [inst : BEq Î±] â†’ Î± â†’ List Î± â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toSemilatticeSup : SemilatticeSup Î±] â†’\n    [toInf : Inf Î±] â†’\n      (âˆ€ (a b : Î±), a âŠ“ b â‰¤ a) â†’ (âˆ€ (a b : Î±), a âŠ“ b â‰¤ b) â†’ (âˆ€ (a b c : Î±), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c) â†’ Lattice Î±",
  "constCategory": "Other"},
 {"references": [],
  "name": "PLift",
  "constType": "Sort u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "HasSubset.Subset",
   "Filter.mkOfClosure",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "Filter.le_generate_iff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "Filter.instPartialOrderFilter",
   "Filter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "Filter.mkOfClosure_sets"],
  "name": "Filter.giGenerate.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (x : Set (Set Î±)) (x_1 : (Filter.generate x).sets â‰¤ x),\n  Filter.mkOfClosure x (_ : (Filter.generate x).sets = x) = Filter.generate x",
  "constCategory": "Theorem"},
 {"references":
  ["compl_compl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Function.Involutive",
   "BooleanAlgebra"],
  "name": "compl_involutive",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BooleanAlgebra Î±], Function.Involutive compl",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{Î± : Sort u} â†’ {p : Î± â†’ Prop} â†’ (âˆƒ x, p x) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_4",
  "constType": "2 < UInt32.size",
  "constCategory": "Theorem"},
 {"references": ["Applicative", "SeqRight"],
  "name": "Applicative.toSeqRight",
  "constType": "{f : Type u â†’ Type v} â†’ [self : Applicative f] â†’ SeqRight f",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable", "Subsingleton", "instSubsingletonDecidable.proof_1"],
  "name": "instSubsingletonDecidable",
  "constType": "âˆ€ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike",
   "Function.LeftInverse",
   "outParam",
   "Function.RightInverse",
   "Eq"],
  "name": "EquivLike.mk",
  "constType":
  "{E : Sort u_1} â†’\n  {Î± : outParam (Sort u_2)} â†’\n    {Î² : outParam (Sort u_3)} â†’\n      (coe : E â†’ Î± â†’ Î²) â†’\n        (inv : E â†’ Î² â†’ Î±) â†’\n          (âˆ€ (e : E), Function.LeftInverse (inv e) (coe e)) â†’\n            (âˆ€ (e : E), Function.RightInverse (inv e) (coe e)) â†’\n              (âˆ€ (e g : E), coe e = coe g â†’ inv e = inv g â†’ e = g) â†’ EquivLike E Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Ne",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "instBEq",
   "List.erase",
   "Eq",
   "ite",
   "Eq.mpr",
   "List.count_erase",
   "Eq.ndrec",
   "DecidableEq",
   "List",
   "Nat.sub_zero",
   "instOfNatNat",
   "Nat",
   "List.count",
   "if_neg",
   "id"],
  "name": "List.count_erase_of_ne",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a b : Î±},\n  a â‰  b â†’ âˆ€ (l : List Î±), List.count a (List.erase l b) = List.count a l",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.Sublist.below.consâ‚‚",
   "List.Sublist.below.cons",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.Sublist.below.slnil",
   "List.Sublist.below"],
  "name": "List.Sublist.below.rec",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop}\n  {motive_1 : {a a_1 : List Î±} â†’ (x : List.Sublist a a_1) â†’ List.Sublist.below x â†’ Prop},\n  motive_1 (_ : List.Sublist [] []) (_ : List.Sublist.below (_ : List.Sublist [] [])) â†’\n    (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) {a_1 : List.Sublist lâ‚ lâ‚‚} (a_2 : List.Sublist.below a_1) (a_3 : motive lâ‚ lâ‚‚ a_1),\n        motive_1 a_1 a_2 â†’\n          motive_1 (_ : List.Sublist lâ‚ (a :: lâ‚‚)) (_ : List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚)))) â†’\n      (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) {a_1 : List.Sublist lâ‚ lâ‚‚} (a_2 : List.Sublist.below a_1) (a_3 : motive lâ‚ lâ‚‚ a_1),\n          motive_1 a_1 a_2 â†’\n            motive_1 (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))\n              (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n        âˆ€ {a a_1 : List Î±} {x : List.Sublist a a_1} (t : List.Sublist.below x), motive_1 x t",
  "constCategory": "Other"},
 {"references": ["Nonempty.intro", "Classical.arbitrary", "Nonempty"],
  "name": "Pi.Nonempty.proof_1",
  "constType":
  "âˆ€ {Î¹ : Sort u_1} {Î± : Î¹ â†’ Sort u_2} [inst : âˆ€ (i : Î¹), Nonempty (Î± i)], Nonempty ((i : Î¹) â†’ Î± i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "UpperSet.instSetLikeUpperSet",
   "SetLike.ext'",
   "LE",
   "UpperSet",
   "SetLike.coe",
   "Eq"],
  "name": "UpperSet.ext",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s t : UpperSet Î±}, â†‘s = â†‘t â†’ s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.isFalse",
   "instDecidableForAll.proof_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "absurd"],
  "name": "instDecidableForAll",
  "constType":
  "{p q : Prop} â†’ [inst : Decidable p] â†’ [inst : Decidable q] â†’ Decidable (p â†’ q)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "Iff",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_himp_iff",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedHeytingAlgebra Î±] {a b c : Î±}, a â‰¤ b â‡¨ c â†” a âŠ“ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpper.rec._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet", "Nonempty"],
  "name": "Topology.WithLowerSet.instNonemptyWithLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Nonempty Î±], Nonempty (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "IsClosed",
   "And.left",
   "isClosed_sInter"],
  "name": "isClosed_closure",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsClosed (closure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "And",
   "Exists.intro",
   "And.intro",
   "Exists.casesOn",
   "And.casesOn"],
  "name": "exists_and_left.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop} (motive : (b âˆ§ âˆƒ x, p x) â†’ Prop) (x : b âˆ§ âˆƒ x, p x),\n  (âˆ€ (h : b) (x : Î±) (hp : p x), motive (_ : b âˆ§ âˆƒ x, p x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "eq_false",
   "False",
   "Finset.not_mem_empty",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.18",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), (a âˆˆ âˆ…) = False",
  "constCategory": "Theorem"},
 {"references":
  ["List.decidableBAll.match_2",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "Unit",
   "List.Mem"],
  "name": "List.decidableBAll.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Prop) (x : Î±) (xs : List Î±), p x â†’ (âˆ€ x âˆˆ xs, p x) â†’ âˆ€ x_1 âˆˆ x :: xs, p x_1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "eq_false", "False", "exists_false", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "âˆ€ {Î± : Sort u_1}, (âˆƒ _a, False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "eq_true_of_decide",
   "instDecidableEqNat",
   "True",
   "Eq",
   "Nat.rec",
   "Nat.zero",
   "of_eq_true",
   "Nat.pred",
   "Bool.true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.zero_sub",
  "constType": "âˆ€ (n : â„•), 0 - n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Bot.bot",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.NeBot.mk",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±}, f â‰  âŠ¥ â†’ Filter.NeBot f",
  "constCategory": "Other"},
 {"references": ["Equiv"],
  "name": "Equiv.toFun",
  "constType": "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ Î± â‰ƒ Î² â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.mem_map.match_1",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Sublist",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil"],
  "name": "List.nil_sublist",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), List.Sublist [] l",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.subperm_left.match_1",
   "List.Perm.symm",
   "Iff.intro",
   "List.exists_perm_sublist",
   "Exists",
   "Iff",
   "List.Perm",
   "List",
   "List.exists_perm_sublist.match_1",
   "List.Subperm",
   "List.Sublist",
   "List.Perm.trans",
   "Exists.intro"],
  "name": "List.Perm.subperm_left",
  "constType":
  "âˆ€ {Î± : Type uu} {l lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (l <+~ lâ‚ â†” l <+~ lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["Decidable.isFalse", "Decidable", "Decidable.isTrue", "Not"],
  "name": "Decidable.rec",
  "constType":
  "{p : Prop} â†’\n  {motive : Decidable p â†’ Sort u} â†’\n    ((h : Â¬p) â†’ motive (isFalse h)) â†’ ((h : p) â†’ motive (isTrue h)) â†’ (t : Decidable p) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Set.image_comp",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.image_id",
   "Function.comp",
   "Set",
   "compl_comp_compl",
   "Eq.refl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Eq.symm",
   "BooleanAlgebra",
   "id",
   "Eq"],
  "name": "Set.compl_compl_image",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BooleanAlgebra Î±] (S : Set Î±), compl '' (compl '' S) = S",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Eq.refl", "Nat", "Nat.instMaxNat", "Eq"],
  "name": "Nat.linearOrder.proof_2",
  "constType": "âˆ€ (a b : â„•), max a b = max a b",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{Î± : Type u} â†’ Option Î±",
  "constCategory": "Other"},
 {"references":
  ["isClosed_compl_iff",
   "Membership.mem",
   "closure",
   "False",
   "setOf",
   "Set",
   "Set.Nonempty",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "by_contradiction",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "mem_closure_iff.match_2",
   "IsClosed.isOpen_compl",
   "TopologicalSpace",
   "Not",
   "And.intro",
   "IsClosed",
   "closure_minimal",
   "mem_closure_iff.match_1",
   "IsOpen",
   "Set.instInterSet"],
  "name": "mem_closure_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {a : Î±},\n  a âˆˆ closure s â†” âˆ€ (o : Set Î±), IsOpen o â†’ a âˆˆ o â†’ Set.Nonempty (o âˆ© s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Set.mem_preimage",
   "Mathlib.Order.Filter.Bases._auxLemma.59",
   "Eq.refl",
   "HasSubset.Subset",
   "exists_congr",
   "Filter.HasBasis.mem_iff",
   "rfl",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "Filter.HasBasis",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Iff",
   "propext",
   "Filter.comap",
   "Filter",
   "congrArg",
   "Iff.and",
   "Eq.trans",
   "Filter.HasBasis.mk",
   "congrFun",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.comap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (f : Î² â†’ Î±),\n  Filter.HasBasis l p s â†’ Filter.HasBasis (Filter.comap f l) p fun i â†¦ f â»Â¹' s i",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Codisjoint",
   "SemilatticeSup",
   "OrderDual.semilatticeInf",
   "OrderDual.orderBot",
   "SemilatticeSup.toSup",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "disjoint_iff",
   "OrderDual",
   "OrderTop",
   "Sup.sup",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "codisjoint_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±] [inst_1 : OrderTop Î±] {a b : Î±}, Codisjoint a b â†” a âŠ” b = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "sInf_le",
   "Set.instHasSubsetSet",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.sInter",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.sInter_subset_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {S : Set (Set Î±)} {t : Set Î±}, t âˆˆ S â†’ â‹‚â‚€ S âŠ† t",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "âˆ€ {Î± : Type u} [self : NonAssocSemiring Î±], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "flip",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {Ï† : Sort w} â†’ (Î± â†’ Î² â†’ Ï†) â†’ Î² â†’ Î± â†’ Ï†",
  "constCategory": "Definition"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{Î± : Type u_9} â†’ [self : CompleteSemilatticeInf Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String.mk", "String", "String.casesOn"],
  "name": "String.utf8ByteSize.match_1",
  "constType":
  "(motive : String â†’ Sort u_1) â†’ (x : String) â†’ ((s : List Char) â†’ motive { data := s }) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.MacroScopesView", "List", "Lean.MacroScope"],
  "name": "Lean.MacroScopesView.scopes",
  "constType": "Lean.MacroScopesView â†’ List Lean.MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsCommutative.mk",
   "Sup.sup",
   "sup_comm",
   "IsCommutative"],
  "name": "instIsCommutativeSupToSup.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±], IsCommutative Î± fun x x_1 â†¦ x âŠ” x_1",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{Î± : Type u} â†’ [self : Mul Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.Mem.head"],
  "name": "List.mem_cons_self",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±) (l : List Î±), a âˆˆ a :: l",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ HSub Î± Î² Î³",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "List.ilast'_mem",
   "Function.comp",
   "Eq.refl",
   "Mathlib.Data.List.TFAE._auxLemma.2",
   "implies_congr",
   "True",
   "Eq",
   "Iff.intro",
   "Mathlib.Data.List.TFAE._auxLemma.6",
   "And",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "List.rec",
   "List.ilast'",
   "forall_congr",
   "List",
   "Eq.mp",
   "List.Mem.head",
   "Mathlib.Data.List.TFAE._auxLemma.1",
   "Mathlib.Data.List.TFAE._auxLemma.4",
   "And.intro",
   "List.nil",
   "And.casesOn",
   "List.Chain",
   "congrArg",
   "Eq.trans",
   "List.TFAE",
   "id",
   "Mathlib.Data.List.TFAE._auxLemma.5"],
  "name": "List.tfae_of_cycle",
  "constType":
  "âˆ€ {a b : Prop} {l : List Prop},\n  List.Chain (fun x x_1 â†¦ x â†’ x_1) a (b :: l) â†’ (List.ilast' b l â†’ a) â†’ List.TFAE (a :: b :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.instMembershipList",
   "List",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.length_pos_iff_exists_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} (motive : (âˆƒ a, a âˆˆ l) â†’ Prop) (x : âˆƒ a, a âˆˆ l),\n  (âˆ€ (w : Î±) (h : w âˆˆ l), motive (_ : âˆƒ a, a âˆˆ l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Bot.bot",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot",
   "Eq"],
  "name": "GeneralizedBooleanAlgebra.inf_inf_sdiff",
  "constType":
  "âˆ€ {Î± : Type u} [self : GeneralizedBooleanAlgebra Î±] (a b : Î±), a âŠ“ b âŠ“ a \\ b = âŠ¥",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Preorder",
   "AlexandrovDiscrete",
   "Topology.IsUpperSet.toAlexandrovDiscrete.proof_1"],
  "name": "Topology.IsUpperSet.toAlexandrovDiscrete",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsUpperSet Î±], AlexandrovDiscrete Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "congr_arg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "List.isSetoid",
   "rfl",
   "Quot.inductionOn",
   "Multiset.instAddMultiset",
   "Eq",
   "Zero.toOfNat0",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Multiset",
   "Zero.mk",
   "List.append_assoc",
   "Quotient.inductionOnâ‚ƒ",
   "Quot.mk",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
  "constType": "âˆ€ {Î± : Type u_1} (s : Multiset Î±), 0 + s = s",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.atom",
  "constType": "Lean.SourceInfo â†’ String â†’ Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Bool.false",
   "decide_eq_true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "Not",
   "Bool",
   "absurd",
   "ne_false_of_eq_true",
   "Eq"],
  "name": "of_decide_eq_false",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], decide p = false â†’ Â¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add",
   "Function.Injective.eq_iff",
   "Eq",
   "add_left_injective"],
  "name": "add_left_inj",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G) {b c : G}, b + a = c + a â†” b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace.GenerateOpen",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.basic",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)}, âˆ€ s âˆˆ g, TopologicalSpace.GenerateOpen g s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "funext",
   "Set",
   "Eq.refl",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "implies_congr",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.Finite",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "forall_congr",
   "Set.Finite.isOpen_biInter",
   "Eq.mp",
   "TopologicalSpace",
   "Set.iInter",
   "IsClosed",
   "Mathlib.Topology.Basic._auxLemma.8",
   "congrArg",
   "IsOpen",
   "Eq.trans",
   "Set.compl_iUnion",
   "id"],
  "name": "Set.Finite.isClosed_biUnion",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] {s : Set Î²} {f : Î² â†’ Set Î±},\n  Set.Finite s â†’ (âˆ€ i âˆˆ s, IsClosed (f i)) â†’ IsClosed (â‹ƒ i âˆˆ s, f i)",
  "constCategory": "Theorem"},
 {"references": ["sInfHom", "InfSet"],
  "name": "sInfHom.toFun",
  "constType":
  "{Î± : Type u_8} â†’ {Î² : Type u_9} â†’ [inst : InfSet Î±] â†’ [inst_1 : InfSet Î²] â†’ sInfHom Î± Î² â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.semilatticeSup",
   "SemilatticeSup.sup_le",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.lattice.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î±' i)] (a b c : (i : Î¹) â†’ Î±' i),\n  a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Iff.mp", "Finite", "finite_iff_nonempty_fintype", "Nonempty"],
  "name": "nonempty_fintype",
  "constType": "âˆ€ (Î± : Type u_4) [inst : Finite Î±], Nonempty (Fintype Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Name.mkStr2",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_HomotopyGroup_Pi_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "âˆ€ {a b c : Prop}, a âˆ¨ b â†’ (a â†’ c) â†’ (b â†’ c) â†’ c",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Set.range_const.match_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î¹ : Sort u_1} (motive : Nonempty Î¹ â†’ Î± â†’ Prop) (x : Nonempty Î¹) (x_1 : Î±),\n  (âˆ€ (x : Î¹) (x_2 : Î±), motive (_ : Nonempty Î¹) x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["False.elim", "False", "Decidable", "Not", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "âˆ€ {p : Prop} [dec : Decidable p], (Â¬p â†’ False) â†’ p",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Iff.rfl",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpperSet.ofUpperSet_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Topology.WithUpperSet Î±},\n  â†‘Topology.WithUpperSet.ofUpperSet a = â†‘Topology.WithUpperSet.ofUpperSet b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Or.inr",
   "Set",
   "Union.union",
   "Or.casesOn",
   "And.left",
   "LE.le",
   "IsLUB",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SemilatticeSup",
   "And.right",
   "upperBounds",
   "Or.inl",
   "SemilatticeSup.toSup",
   "le_sup_of_le_right",
   "lowerBounds",
   "sup_le",
   "Sup.sup",
   "And.intro",
   "le_sup_of_le_left",
   "SemilatticeSup.toPartialOrder",
   "Set.instUnionSet"],
  "name": "IsLUB.union",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {a b : Î³} {s t : Set Î³}, IsLUB s a â†’ IsLUB t b â†’ IsLUB (s âˆª t) (a âŠ” b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.cons",
   "List.get._sunfold.proof_1",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "List.instMembershipList",
   "HAdd.hAdd",
   "List.Mem.tail",
   "List.length",
   "instLTNat",
   "List.get?_eq_get.match_1",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "List.Mem.head",
   "instOfNatNat",
   "Nat",
   "List.get",
   "Fin.mk"],
  "name": "List.get_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} (l : List Î±) (n : â„•) (h : n < List.length l), List.get l { val := n, isLt := h } âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.rec._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Topology.WithLowerSet Î± â†’ Sort u_4} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithLowerSet.toLowerSet a)) â†’ (a : Topology.WithLowerSet Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "âˆ€ {n m : â„•} (k : â„•), n â‰¤ m â†’ k * n â‰¤ k * m",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "nhds",
   "Set",
   "Eq.refl",
   "nhdsAdjoint",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "le_nhds_iff",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "instMembershipSetFilter",
   "id"],
  "name": "gc_nhds",
  "constType":
  "âˆ€ {Î± : Type u} (a : Î±), GaloisConnection (nhdsAdjoint a) fun t â†¦ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "Setoid.r",
   "Iff",
   "Function.Injective",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.mem_map_of_injective",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.mem_map_of_injective",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type v} {f : Î± â†’ Î²},\n  Function.Injective f â†’ âˆ€ {a : Î±} {s : Multiset Î±}, f a âˆˆ Multiset.map f s â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Inter",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower.topology_eq_lowerTopology",
   "Topology.IsLower",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLower.topology_eq",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±],\n  inst_1 = Topology.lower Î±",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl.mk", "IsRefl", "le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "instIsReflLeToLE.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], IsRefl Î± fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Iff", "forall_exists_index"],
  "name": "exists_imp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, p x) â†’ b â†” âˆ€ (x : Î±), p x â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set.preimage",
   "Set",
   "implies_true",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "Eq",
   "iff_self",
   "Set.instMembershipSet",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Set.preimage_iUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {f : Î± â†’ Î²} {s : Î¹ â†’ Set Î²}, f â»Â¹' â‹ƒ i, s i = â‹ƒ i, f â»Â¹' s i",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "List.foldl.match_1"],
  "name": "List.foldl",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î² â†’ Î±) â†’ Î± â†’ List Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "sSupHom.mk",
   "Eq.ndrec",
   "sSupHom",
   "Eq.rec",
   "Set",
   "Eq.refl",
   "sSupHom.casesOn",
   "sSupHom.toFun",
   "SupSet.sSup",
   "Set.image",
   "Eq.symm",
   "Eq"],
  "name": "sSupHom.instSSupHomClassSSupHom.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : SupSet Î±] [inst_1 : SupSet Î²] (f g : sSupHom Î± Î²), f.toFun = g.toFun â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.generateFrom",
   "Set",
   "TopologicalSpace",
   "Eq",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis s â†’ t = TopologicalSpace.generateFrom s",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Pi.preorder.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î± : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ Preorder (Î± i)] (a : (i : Î¹) â†’ Î± i) (i : Î¹), a i â‰¤ a i",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "GE.ge", "LE", "LE.le"],
  "name": "ge_iff_le",
  "constType": "âˆ€ {Î± : Type u} [inst : LE Î±] {a b : Î±}, a â‰¥ b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Prod.semilatticeSup",
   "inferInstanceAs",
   "Sup.sup",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.lattice.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Lattice Î±] [inst_1 : Lattice Î²] (a b : Î± Ã— Î²), a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Option.some.injEq",
   "List.cons",
   "List.brecOn",
   "List.below",
   "Unit",
   "dite",
   "Eq",
   "PProd",
   "List.find?",
   "Bool.of_not_eq_true",
   "PProd.fst",
   "List.rec",
   "Bool.false",
   "List",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "List.find?_some.match_1",
   "Eq.mp",
   "Not",
   "Option.some",
   "Bool",
   "List.erase.match_1",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option",
   "instDecidableEqBool"],
  "name": "List.find?_some",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {a : Î±} {l : List Î±}, List.find? p l = some a â†’ p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "disjoint_iff",
   "Disjoint",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "IsCompl.inf_left_eq_bot_iff",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "Eq.ndrec",
   "DistribLattice",
   "Iff",
   "propext",
   "OrderBot.toBot",
   "BoundedOrder.toOrderBot",
   "id",
   "BoundedOrder"],
  "name": "IsCompl.disjoint_left_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y z : Î±}, IsCompl y z â†’ (Disjoint x y â†” x â‰¤ z)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "GetElem"],
  "name": "GetElem.mk",
  "constType":
  "{cont : Type u} â†’\n  {idx : Type v} â†’\n    {elem : outParam (Type w)} â†’\n      {dom : outParam (cont â†’ idx â†’ Prop)} â†’ ((xs : cont) â†’ (i : idx) â†’ dom xs i â†’ elem) â†’ GetElem cont idx elem dom",
  "constCategory": "Other"},
 {"references":
  ["Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.IsUpper.mk",
   "Preorder",
   "Topology.IsUpper.rec",
   "Eq"],
  "name": "Topology.IsUpper.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsUpper Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsUpper Î±) â†’\n          ((topology_eq_upperTopology : t = Topology.upper Î±) â†’ motive (_ : Topology.IsUpper Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpper.ofUpper._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "OfNat.ofNat",
   "List.instMembershipList",
   "Std.Data.List.Count._auxLemma.7",
   "instBEq",
   "instLTNat",
   "True",
   "iff_self",
   "instLawfulBEqInstBEq",
   "Std.Data.List.Count._auxLemma.6",
   "Eq",
   "And",
   "BEq.beq",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Bool.true",
   "LT.lt",
   "Std.Data.List.Count._auxLemma.8",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "List.count",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.count_pos_iff_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, 0 < List.count a l â†” a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Std.Data.List.Lemmas._auxLemma.39",
   "List.filterMap",
   "Unit",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.rec",
   "Std.Data.List.Lemmas._auxLemma.57",
   "Eq",
   "Std.Data.List.Lemmas._auxLemma.30",
   "eq_true",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "_private.Std.Data.List.Lemmas.0.List.filterMap_cons.match_1.splitter",
   "List.filterMap_cons.match_1",
   "Option.none",
   "Option.some",
   "List.nil",
   "Eq.symm",
   "Option",
   "id"],
  "name": "List.Sublist.filterMap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {lâ‚ lâ‚‚ : List Î±} (f : Î± â†’ Option Î²),\n  List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist (List.filterMap f lâ‚) (List.filterMap f lâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "propext",
   "Sup.sup",
   "sup_le_iff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, (a âŠ” b â‰¤ c) = (a â‰¤ c âˆ§ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod", "Eq"],
  "name": "Prod.noConfusionType",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ Sort u_1 â†’ Î± Ã— Î² â†’ Î± Ã— Î² â†’ Sort u_1",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {fâ‚ fâ‚‚ : Î± â†’ Î²} {aâ‚ aâ‚‚ : Î±}, fâ‚ = fâ‚‚ â†’ aâ‚ = aâ‚‚ â†’ fâ‚ aâ‚ = fâ‚‚ aâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_2",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_3",
   "_obj",
   "Lean.Name.mkStr4",
   "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_1",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_3"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "inferInstanceAs",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.distribLattice.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : DistribLattice Î±] (a b : Î±áµ’áµˆ), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "instDiscreteTopologyProdInstTopologicalSpaceProd.match_1",
   "Set",
   "Filter.NeBot",
   "True",
   "iff_self",
   "Eq",
   "Set.ext",
   "Mathlib.Topology.Constructions._auxLemma.27",
   "Eq.mpr",
   "Iff",
   "SProd.sprod",
   "TopologicalSpace",
   "Filter",
   "nhdsWithin",
   "Eq.trans",
   "id",
   "Membership.mem",
   "Set.instSProd",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Mathlib.Topology.Constructions._auxLemma.28",
   "Prod.fst",
   "Filter.instSProd",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "Prod.mk",
   "congr",
   "nhdsWithin_prod_eq",
   "Prod",
   "congrArg",
   "Mathlib.Topology.Constructions._auxLemma.26",
   "congrFun"],
  "name": "closure_prod_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²},\n  closure (s Ã—Ë¢ t) = closure s Ã—Ë¢ closure t",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.toLower",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithLower Î±",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} â†’ False â†’ C",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Lean.identKind",
   "Lean.Name.mkSimple",
   "List",
   "String",
   "Unit",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax.getKind.match_1",
   "Substring",
   "Lean.Syntax"],
  "name": "Lean.Syntax.getKind",
  "constType": "Lean.Syntax â†’ Lean.SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "âˆ€ {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {r : N â†’ N â†’ Prop} [self : CovariantClass M N Î¼ r], Covariant M N Î¼ r",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "OrderDual", "LE", "LE.le"],
  "name": "OrderDual.instLEOrderDual",
  "constType": "(Î± : Type u_3) â†’ [inst : LE Î±] â†’ LE Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inr", "True", "Eq"],
  "name": "or_true",
  "constType": "âˆ€ (p : Prop), (p âˆ¨ True) = True",
  "constCategory": "Theorem"},
 {"references": ["Applicative", "Unit", "Alternative"],
  "name": "Alternative.mk",
  "constType":
  "{f : Type u â†’ Type v} â†’\n  [toApplicative : Applicative f] â†’ ({Î± : Type u} â†’ f Î±) â†’ ({Î± : Type u} â†’ f Î± â†’ (Unit â†’ f Î±) â†’ f Î±) â†’ Alternative f",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.mk",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "SemilatticeSup.mk",
   "GaloisInsertion.liftSemilatticeSup.proof_1",
   "Sup.sup",
   "GaloisInsertion.liftSemilatticeSup.proof_3",
   "Sup.mk",
   "GaloisInsertion",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftSemilatticeSup.proof_2",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’\n      {u : Î² â†’ Î±} â†’ [inst : PartialOrder Î²] â†’ [inst_1 : SemilatticeSup Î±] â†’ GaloisInsertion l u â†’ SemilatticeSup Î²",
  "constCategory": "Definition"},
 {"references": ["Inf.mk", "Inf", "Inf.inf"],
  "name": "Pi.instInfForAll",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î±' : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ Inf (Î±' i)] â†’ Inf ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Disjoint",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "le_compl_iff_disjoint_right",
   "propext",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "le_compl_iff_disjoint_left",
   "BoundedOrder.toOrderBot",
   "id"],
  "name": "le_compl_comm",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, a â‰¤ bá¶œ â†” b â‰¤ aá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.instMembershipList",
   "Eq.refl",
   "Exists.intro",
   "List.exists_erase_eq.match_1",
   "beq_self_eq_true",
   "List.erase",
   "Eq",
   "instLawfulBEqInstBEq",
   "Decidable.decide",
   "BEq.beq",
   "List.eraseP",
   "Eq.mpr",
   "Bool.true",
   "Eq.rec",
   "Eq.symm",
   "id",
   "Membership.mem",
   "List.cons",
   "List.exists_of_eraseP",
   "List.erase_eq_eraseP",
   "instBEq",
   "instHAppend",
   "And",
   "List.instAppendList",
   "Eq.ndrec",
   "DecidableEq",
   "HAppend.hAppend",
   "List",
   "LawfulBEq.eq_of_beq",
   "Not",
   "Bool",
   "And.intro"],
  "name": "List.exists_erase_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±},\n  a âˆˆ l â†’ âˆƒ lâ‚, âˆƒ lâ‚‚, Â¬a âˆˆ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.erase l a = lâ‚ ++ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "Equiv.mk"],
  "name": "Equiv.symm",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ Î± â‰ƒ Î² â†’ Î² â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Option.none", "Option.some", "Option.casesOn", "String.Pos", "Option"],
  "name": "Lean.replaceRef.match_1",
  "constType":
  "(motive : Option String.Pos â†’ Sort u_1) â†’\n  (x : Option String.Pos) â†’ ((val : String.Pos) â†’ motive (some val)) â†’ ((x : Option String.Pos) â†’ motive x) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Prelude.0.Lean.extractMacroScopesAux",
   "cond.match_1",
   "Lean.MacroScopesView",
   "Unit",
   "Lean.MacroScopesView.mk",
   "Lean.Name.hasMacroScopes",
   "List.nil",
   "Bool",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.MacroScope"],
  "name": "Lean.extractMacroScopes",
  "constType": "Lean.Name â†’ Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.IsUpper.mk",
   "Preorder",
   "Topology.IsUpper.rec",
   "Eq"],
  "name": "Topology.IsUpper.recOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsUpper Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsUpper Î±) â†’\n          ((topology_eq_upperTopology : t = Topology.upper Î±) â†’ motive (_ : Topology.IsUpper Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.false",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "decide_eq_false.match_1",
   "Eq"],
  "name": "decide_eq_false",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], Â¬p â†’ decide p = false",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Prod.snd",
   "Prod.mk",
   "Prod.instLEProd",
   "inferInstanceAs",
   "LE",
   "Prod",
   "And.intro",
   "Prod.fst",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "Prod.instPreorderProd.match_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Preorder Î±] [inst_1 : Preorder Î²] (c : Î±) (d : Î²) (e : Î±) (f : Î²),\n  let src := inferInstanceAs (LE (Î± Ã— Î²));\n  âˆ€ (motive : (c, d) â‰¤ (e, f) â†’ Prop) (x : (c, d) â‰¤ (e, f)),\n    (âˆ€ (hce : (c, d).1 â‰¤ (e, f).1) (hdf : (c, d).2 â‰¤ (e, f).2),\n        motive (_ : (c, d).1 â‰¤ (e, f).1 âˆ§ (c, d).2 â‰¤ (e, f).2)) â†’\n      motive x",
  "constCategory": "Definition"},
 {"references":
  ["instMonadExcept",
   "tryCatchThe",
   "ReaderT",
   "liftM",
   "instMonadLiftT",
   "MonadExcept.throw",
   "ReaderT.instMonadLiftReaderT",
   "MonadExceptOf.mk",
   "MonadExceptOf",
   "instMonadLiftT_1"],
  "name": "ReaderT.instMonadExceptOfReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ (Îµ : Type u_1) â†’ [inst : MonadExceptOf Îµ m] â†’ MonadExceptOf Îµ (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references": ["PUnit", "semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.set",
  "constType":
  "{Ïƒ : semiOutParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadStateOf Ïƒ m] â†’ Ïƒ â†’ m PUnit.{u + 1}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "sSup_image",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Set",
   "InfSet.sInf",
   "OrderDual",
   "Set.image",
   "Set.instMembershipSet",
   "Eq"],
  "name": "sInf_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : CompleteLattice Î±] {s : Set Î²} {f : Î² â†’ Î±}, sInf (f '' s) = â¨… a âˆˆ s, f a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_principal",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, s âˆˆ Filter.principal t â†” t âŠ† s",
  "constCategory": "Theorem"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.inductionOn",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {motive : Quot r â†’ Prop} (q : Quot r), (âˆ€ (a : Î±), motive (Quot.mk r a)) â†’ motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective", "Function.Embedding.mk", "Function.Embedding"],
  "name": "Function.Embedding.rec",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {motive : (Î± â†ª Î²) â†’ Sort u} â†’\n      ((toFun : Î± â†’ Î²) â†’ (inj' : Function.Injective toFun) â†’ motive { toFun := toFun, inj' := inj' }) â†’\n        (t : Î± â†ª Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.not_and", "And", "Or", "Iff", "Classical.propDecidable", "Not"],
  "name": "not_and_or",
  "constType": "âˆ€ {a b : Prop}, Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "List.filter_cons_of_pos",
   "eq_true_of_decide",
   "Std.Logic._auxLemma.45",
   "iff_false",
   "implies_congr",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Eq.mpr",
   "instLENat",
   "Iff",
   "List.rec",
   "forall_congr",
   "Eq.rec",
   "Bool.true",
   "List.nil",
   "Nat",
   "Eq.symm",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "eq_self",
   "Membership.mem",
   "List.filter",
   "List.cons",
   "Or",
   "False",
   "List.filter_cons_of_neg",
   "implies_true",
   "List.length",
   "eq_false_of_decide",
   "List.length_filter_le",
   "LE.le",
   "And",
   "Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "propext",
   "List",
   "Bool.false",
   "Nat.lt_irrefl",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "List.cons.injEq",
   "congrFun"],
  "name": "List.filter_eq_self",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {l : List Î±}, List.filter p l = l â†” âˆ€ a âˆˆ l, p a = true",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_exists_eq_and", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.32",
  "constType":
  "âˆ€ {Î± : Sort u_3} {Î² : Sort u_2} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b) = âˆƒ a, p (f a)",
  "constCategory": "Theorem"},
 {"references": ["Set.insert", "Set", "Insert", "Insert.mk"],
  "name": "Set.instInsertSet",
  "constType": "{Î± : Type u_1} â†’ Insert Î± (Set Î±)",
  "constCategory": "Definition"},
 {"references": ["Quot"],
  "name": "Quot.mk",
  "constType": "{Î± : Sort u} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ Î± â†’ Quot r",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Or", "Iff", "False", "or_false", "iff_of_eq"],
  "name": "or_false_iff",
  "constType": "âˆ€ (p : Prop), p âˆ¨ False â†” p",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} â†’ {N : Type u_4} â†’ [inst : AddZeroClass M] â†’ [inst_1 : AddZeroClass N] â†’ AddMonoidHomClass (M â†’+ N) M N",
  "constCategory": "Definition"},
 {"references": ["List.append", "List", "Append.mk", "Append"],
  "name": "List.instAppendList",
  "constType": "{Î± : Type u} â†’ Append (List Î±)",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "EquivLike.toEmbeddingLike",
   "EquivLike.surjective",
   "FunLike.coe",
   "And.intro",
   "EquivLike.injective"],
  "name": "EquivLike.bijective",
  "constType":
  "âˆ€ {E : Sort u_1} {Î± : Sort u_3} {Î² : Sort u_4} [iE : EquivLike E Î± Î²] (e : E), Function.Bijective â†‘e",
  "constCategory": "Theorem"},
 {"references": ["Setoid"],
  "name": "Setoid.r",
  "constType": "{Î± : Sort u} â†’ [self : Setoid Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ.injEq",
   "implies_congr",
   "Eq",
   "Nat.zero_add",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "id"],
  "name": "Nat.add_left_cancel",
  "constType": "âˆ€ {n m k : â„•}, n + m = n + k â†’ m = k",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.not_mem_zero",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.7",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), (a âˆˆ 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Or.inl",
   "Or.inr",
   "List.instMembershipList",
   "List",
   "Or.casesOn",
   "Eq"],
  "name": "List.mem_insert_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {l : List Î±} (motive : a = b âˆ¨ a âˆˆ l â†’ Prop) (x : a = b âˆ¨ a âˆˆ l),\n  (âˆ€ (h' : a = b), motive (_ : a = b âˆ¨ a âˆˆ l)) â†’ (âˆ€ (h' : a âˆˆ l), motive (_ : a = b âˆ¨ a âˆˆ l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "propext",
   "And.intro",
   "And.left",
   "True",
   "Eq"],
  "name": "and_true",
  "constType": "âˆ€ (p : Prop), (p âˆ§ True) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EmptyCollection",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["Lean.MacroScopesView", "Lean.Name"],
  "name": "Lean.MacroScopesView.name",
  "constType": "Lean.MacroScopesView â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} â†’ [self : AddCancelMonoid M] â†’ AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Applicative", "SeqLeft"],
  "name": "Applicative.toSeqLeft",
  "constType": "{f : Type u â†’ Type v} â†’ [self : Applicative f] â†’ SeqLeft f",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "instOfNatNat",
   "Lean.SourceInfo",
   "Nat",
   "Array.size",
   "Lean.Syntax"],
  "name": "Lean.Syntax.getNumArgs",
  "constType": "Lean.Syntax â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "âˆ€ {Î± : Type u} [self : LinearOrder Î±] (a b : Î±), a â‰¤ b âˆ¨ b â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "Iff",
   "List.Perm",
   "List.Perm.pairwise_iff",
   "List",
   "Ne.symm"],
  "name": "List.Perm.nodup_iff",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (List.Nodup lâ‚ â†” List.Nodup lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "And.intro", "And.casesOn"],
  "name": "and_or_left.match_1",
  "constType":
  "âˆ€ {a b c : Prop} (motive : a âˆ§ (b âˆ¨ c) â†’ Prop) (x : a âˆ§ (b âˆ¨ c)),\n  (âˆ€ (ha : a) (hbc : b âˆ¨ c), motive (_ : a âˆ§ (b âˆ¨ c))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_true",
   "List.insert",
   "List.Perm",
   "DecidableEq",
   "List.Perm.insert",
   "List",
   "True",
   "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.31",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] (a : Î±) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (List.insert a lâ‚ ~ List.insert a lâ‚‚) = True",
  "constCategory": "Theorem"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{Î± : Type u_1} â†’ [inst : Add Î±] â†’ HAdd Î± Î± Î±",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.toUpperSet._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.closure_of._closed_5",
   "Topology.IsOpen_of._closed_13"],
  "name": "Topology.closure_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "List.cons",
   "List.instMembershipList",
   "Mathlib.Data.List.Nodup._auxLemma.1",
   "True",
   "iff_self",
   "Eq",
   "List.Pairwise",
   "And",
   "List.Nodup",
   "Iff",
   "of_eq_true",
   "List",
   "Mathlib.Data.List.Nodup._auxLemma.3",
   "Not",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.nodup_cons",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {l : List Î±}, List.Nodup (a :: l) â†” Â¬a âˆˆ l âˆ§ List.Nodup l",
  "constCategory": "Theorem"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray2",
  "constType": "{Î± : Type u} â†’ Î± â†’ Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.succ_pos",
  "constType": "âˆ€ (n : â„•), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ HMul Î± Î² Î³",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.not_nonempty_iff_eq_empty",
   "Set.instEmptyCollectionSet",
   "True",
   "iff_self",
   "Eq",
   "Iff.symm",
   "And",
   "Iff",
   "of_eq_true",
   "propext",
   "Mathlib.Data.Set.Prod._auxLemma.27",
   "SProd.sprod",
   "congr",
   "Prod",
   "Not",
   "Mathlib.Data.Set.Prod._auxLemma.18",
   "congrArg",
   "Eq.trans"],
  "name": "Set.prod_eq_empty_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, s Ã—Ë¢ t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_1"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "Set.Nonempty", "Preorder"],
  "name": "BddBelow",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "âˆ€ {Î± : Sort u} {p q : Î± â†’ Prop}, (âˆ€ (a : Î±), p a = q a) â†’ (âˆ€ (a : Î±), p a) = âˆ€ (a : Î±), q a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "SemilatticeSup.toSup",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Sup.sup",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_12",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Set Î±) (s : Set (Set Î±)), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "propext",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Topology.WithUpperSet.toUpperSet_le_iff",
   "Equiv.instFunLikeEquiv"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.5",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±},\n  (â†‘Topology.WithUpperSet.toUpperSet a â‰¤ â†‘Topology.WithUpperSet.toUpperSet b) = (a â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists"],
  "name": "Directed",
  "constType": "{Î± : Type u} â†’ {Î¹ : Sort w} â†’ (Î± â†’ Î± â†’ Prop) â†’ (Î¹ â†’ Î±) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "sup_compl_eq_top",
   "IsCompl.of_eq",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toBoundedOrder",
   "IsCompl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "inf_compl_eq_bot'",
   "BooleanAlgebra"],
  "name": "isCompl_compl",
  "constType": "âˆ€ {Î± : Type u} {x : Î±} [inst : BooleanAlgebra Î±], IsCompl x xá¶œ",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name": "_private.Init.Data.List.Basic.0.List.erase.match_1.splitter",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ motive true â†’ motive false â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "isClosed_closure",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Set.Subset.trans",
   "closure_minimal",
   "subset_closure"],
  "name": "closure_mono",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âŠ† t â†’ closure s âŠ† closure t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.12",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {b : Î²} {f : Î± â†’ Î²} {l : List Î±}, (b âˆˆ List.map f l) = âˆƒ a âˆˆ l, f a = b",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} â†’ [self : AddCommMonoid M] â†’ AddMonoid M",
  "constCategory": "Definition"},
 {"references": ["Subtype.mk", "Subtype", "Subtype.casesOn"],
  "name": "iSup_subtype.match_1",
  "constType":
  "âˆ€ {Î¹ : Sort u_1} {p : Î¹ â†’ Prop} (motive : Subtype p â†’ Prop) (x : Subtype p),\n  (âˆ€ (i : Î¹) (h : p i), motive { val := i, property := h }) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Iff",
   "nhds",
   "Filter.inf_principal_neBot_iff",
   "Set",
   "Set.Nonempty",
   "TopologicalSpace",
   "Inter.inter",
   "Filter",
   "ClusterPt",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "clusterPt_principal_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {x : Î±} {s : Set Î±},\n  ClusterPt x (Filter.principal s) â†” âˆ€ U âˆˆ nhds x, Set.Nonempty (U âˆ© s)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "propext", "bex_imp", "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {P : (x : Î±) â†’ p x â†’ Prop} {b : Prop},\n  ((âˆƒ x, âˆƒ (h : p x), P x h) â†’ b) = âˆ€ (x : Î±) (h : p x), P x h â†’ b",
  "constCategory": "Theorem"},
 {"references": ["Or", "Not", "Classical.em"],
  "name": "em",
  "constType": "âˆ€ (p : Prop), p âˆ¨ Â¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_iInter.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} {s : Î¹ â†’ Set Î±} (x : Set Î±) (motive : (x âˆˆ Set.range fun i â†¦ s i) â†’ Prop)\n  (x_1 : x âˆˆ Set.range fun i â†¦ s i), (âˆ€ (a : Î¹) (eq : s a = x), motive (_ : âˆƒ y, (fun i â†¦ s i) y = x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Prop) â†’ LE Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.mk",
  "constType":
  "{Î± : Type u} â†’\n  (IsOpen : Set Î± â†’ Prop) â†’\n    IsOpen Set.univ â†’\n      (âˆ€ (s t : Set Î±), IsOpen s â†’ IsOpen t â†’ IsOpen (s âˆ© t)) â†’\n        (âˆ€ (s : Set (Set Î±)), (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹ƒâ‚€ s)) â†’ TopologicalSpace Î±",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Antitone",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "List", "Multiset", "List.isSetoid", "Quot.mk"],
  "name": "Multiset.ofList",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.SourceInfo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Fin.val", "Eq.rec", "Nat", "rfl", "Fin", "Eq"],
  "name": "Fin.val_eq_of_eq",
  "constType": "âˆ€ {n : â„•} {i j : Fin n}, i = j â†’ â†‘i = â†‘j",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "isLUB_pair",
   "Set.image_pair",
   "PartialOrder.toPreorder",
   "Set",
   "GaloisConnection.isLUB_l_image",
   "Insert.insert",
   "True",
   "IsLUB",
   "Eq",
   "SemilatticeSup",
   "IsLUB.unique",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "Mathlib.Order.GaloisConnection._auxLemma.1",
   "Singleton.singleton",
   "Sup.sup",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congrFun",
   "Set.instInsertSet"],
  "name": "GaloisConnection.l_sup",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {aâ‚ aâ‚‚ : Î±} [inst : SemilatticeSup Î±] [inst_1 : SemilatticeSup Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ l (aâ‚ âŠ” aâ‚‚) = l aâ‚ âŠ” l aâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Bool.true", "Unit", "Bool"],
  "name": "or",
  "constType": "Bool â†’ Bool â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["upperBounds", "Set", "Set.Nonempty", "Preorder"],
  "name": "BddAbove",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.23",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "List", "List.nil", "Inhabited.mk"],
  "name": "instInhabitedList",
  "constType": "{Î± : Type u_1} â†’ Inhabited (List Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "mem_of_mem_nhds.match_1",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "mem_of_mem_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {a : Î±} {s : Set Î±}, s âˆˆ nhds a â†’ a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_4",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
  "constType": "{Î± : Type u_3} â†’ [self : HasCompl Î±] â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "funext",
   "List.pmap",
   "List.Perm.pmap",
   "List.instMembershipList",
   "List.isSetoid",
   "Eq.refl",
   "Multiset.instMembershipMultiset",
   "Eq",
   "List.Perm.subset",
   "Setoid.r",
   "List.Perm",
   "Eq.ndrec",
   "List",
   "Eq.rec",
   "Multiset",
   "Quot",
   "Multiset.ofList",
   "Eq.trans",
   "Quot.mk",
   "Quot.sound"],
  "name": "Multiset.pmap.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} (f : (a : Î±) â†’ p a â†’ Î²) (lâ‚ lâ‚‚ : List Î±) (pp : lâ‚ ~ lâ‚‚),\n  Eq.ndrec (motive := fun x â†¦ (âˆ€ a âˆˆ x, p a) â†’ Multiset Î²) (fun H â†¦ â†‘(List.pmap f lâ‚ H))\n      (_ : Quot.mk Setoid.r lâ‚ = Quot.mk Setoid.r lâ‚‚) =\n    fun H â†¦ â†‘(List.pmap f lâ‚‚ H)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_inf_iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Topology.Order._auxLemma.31",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b c : Î±}, (a â‰¤ b âŠ“ c) = (a â‰¤ b âˆ§ a â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Iff",
   "Iff.rfl",
   "Function.comp",
   "OrderDual",
   "Monotone",
   "FunLike.coe",
   "Preorder",
   "Antitone",
   "Equiv.instFunLikeEquiv"],
  "name": "monotone_toDual_comp_iff",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Monotone (â†‘OrderDual.toDual âˆ˜ f) â†” Antitone f",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.le_sup_inf",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : DistribLattice Î±] (x y z : Î±), (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "and_true",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "SemilatticeSup",
   "And",
   "Mathlib.Order.Lattice._auxLemma.1",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Iff.trans",
   "Mathlib.Order.Lattice._auxLemma.3",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "le_antisymm_iff",
   "congrFun"],
  "name": "sup_of_le_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, b â‰¤ a â†’ a âŠ” b = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.find?",
   "List.cons",
   "HEq",
   "HEq.refl",
   "Option.none",
   "List",
   "Eq.refl",
   "List.casesOn",
   "Option.noConfusion",
   "Option.some",
   "Eq.casesOn",
   "List.nil",
   "Bool",
   "Option",
   "Eq"],
  "name": "List.find?_some.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {a : Î±} (motive : (x : List Î±) â†’ List.find? p x = some a â†’ Prop) (x : List Î±)\n  (x_1 : List.find? p x = some a),\n  (âˆ€ (b : Î±) (l : List Î±) (H : List.find? p (b :: l) = some a), motive (b :: l) H) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["WellFoundedRelation.wf",
   "WellFoundedRelation.rel",
   "InvImage.wf",
   "WellFoundedRelation",
   "WellFounded",
   "InvImage"],
  "name": "invImage.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (h : WellFoundedRelation Î²),\n  WellFounded (InvImage WellFoundedRelation.rel f)",
  "constCategory": "Theorem"},
 {"references":
  ["outParam", "FunLike", "Function.Injective", "EmbeddingLike", "FunLike.coe"],
  "name": "EmbeddingLike.mk",
  "constType":
  "{F : Sort u_1} â†’\n  {Î± : outParam (Sort u_2)} â†’\n    {Î² : outParam (Sort u_3)} â†’\n      [toFunLike : FunLike F Î± fun x â†¦ Î²] â†’ (âˆ€ (f : F), Function.Injective â†‘f) â†’ EmbeddingLike F Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "OfNat.ofNat",
   "List.get._sunfold.proof_1",
   "List.brecOn",
   "instAddNat",
   "List.below",
   "instHAdd",
   "Fin.val",
   "HAdd.hAdd",
   "List.get_cons_drop.match_1",
   "List.drop",
   "List.length",
   "rfl",
   "instLTNat",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "List.get",
   "Nat",
   "Fin.mk",
   "Fin"],
  "name": "List.get_cons_drop",
  "constType":
  "âˆ€ {Î± : Type u_1} (l : List Î±) (i : Fin (List.length l)), List.get l i :: List.drop (â†‘i + 1) l = List.drop (â†‘i) l",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Surjective", "Exists.intro", "Function.Involutive", "Eq"],
  "name": "Function.Involutive.surjective",
  "constType":
  "âˆ€ {Î± : Sort u} {f : Î± â†’ Î±}, Function.Involutive f â†’ Function.Surjective f",
  "constCategory": "Theorem"},
 {"references": ["Subtype.val", "NonemptyType", "Nonempty"],
  "name": "NonemptyType.type",
  "constType": "NonemptyType â†’ Type u",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Topology.WithLower.toDualHomeomorph.proof_2",
   "Topology.WithLower.toDualHomeomorph.proof_1",
   "Homeomorph",
   "Topology.WithLower.toDualHomeomorph.proof_3",
   "OrderDual",
   "Equiv.mk",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithLower.toDualHomeomorph",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithLower Î± â‰ƒâ‚œ Topology.WithUpper Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "forall_eq_or_imp", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.45",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' âˆ¨ q a â†’ p a) = (p a' âˆ§ âˆ€ (a : Î±), q a â†’ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Iff",
   "Classical.propDecidable",
   "Not",
   "Decidable.or_iff_not_imp_left"],
  "name": "or_iff_not_imp_left",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†” Â¬a â†’ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Data.AC.ContextInformation",
  "constType": "Sort u â†’ Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termð“[â‰¥]_Â»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u â†’ â„• â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.Finite.induction_on",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.sInter_empty",
   "IsOpen.inter",
   "Eq.refl",
   "Inter.inter",
   "Set.instEmptyCollectionSet",
   "And.left",
   "Insert.insert",
   "Set.univ",
   "isOpen_univ",
   "Set.Finite",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "And.right",
   "Eq.mpr",
   "Set.sInter_insert",
   "Eq.ndrec",
   "Eq.mp",
   "TopologicalSpace",
   "Not",
   "congrArg",
   "Set.sInter",
   "Mathlib.Topology.Basic._auxLemma.3",
   "IsOpen",
   "Set.instInterSet",
   "Set.instInsertSet",
   "id"],
  "name": "Set.Finite.isOpen_sInter",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set (Set Î±)}, Set.Finite s â†’ (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹‚â‚€ s)",
  "constCategory": "Theorem"},
 {"references": ["AddLeftCancelSemigroup", "AddSemigroup"],
  "name": "AddLeftCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} â†’ [self : AddLeftCancelSemigroup G] â†’ AddSemigroup G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MacroScopesView",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "Finset.mem_map'",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe",
   "Iff.mpr"],
  "name": "Finset.mem_map_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†ª Î²) {a : Î±} {s : Finset Î±}, a âˆˆ s â†’ â†‘f a âˆˆ Finset.map f s",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) â†’ Type v â†’ Type (max u v)",
  "constCategory": "Other"},
 {"references": ["outParam", "FunLike", "RelHomClass", "FunLike.coe"],
  "name": "RelHomClass.mk",
  "constType":
  "{F : Type u_5} â†’\n  {Î± : outParam (Type u_6)} â†’\n    {Î² : outParam (Type u_7)} â†’\n      {r : outParam (Î± â†’ Î± â†’ Prop)} â†’\n        {s : outParam (Î² â†’ Î² â†’ Prop)} â†’\n          [toFunLike : FunLike F Î± fun x â†¦ Î²] â†’ (âˆ€ (f : F) {a b : Î±}, r a b â†’ s (â†‘f a) (â†‘f b)) â†’ RelHomClass F r s",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.instPreorder",
   "Set",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "IsUpperSet",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLower.isLowerSet_of_isOpen",
   "Preorder",
   "IsOpen",
   "Preorder.toLE"],
  "name": "Topology.IsUpper.isUpperSet_of_isOpen",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±] {s : Set Î±},\n  IsOpen s â†’ IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "Iff",
   "forall_swap",
   "PartialOrder.toPreorder",
   "Disjoint",
   "OrderBot.toBot",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "forall_congr'",
   "PartialOrder"],
  "name": "disjoint_comm",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : OrderBot Î±] {a b : Î±}, Disjoint a b â†” Disjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "continuous_coinduced_rng",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.WithLower",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.coinduced",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Equiv.invFun",
   "Continuous",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithLower.toDualHomeomorph.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±],\n  Continuous\n    { toFun := â†‘OrderDual.toDual, invFun := â†‘OrderDual.ofDual,\n        left_inv := (_ : âˆ€ (a : Î±áµ’áµˆ), â†‘OrderDual.toDual (â†‘OrderDual.ofDual a) = a),\n        right_inv := (_ : âˆ€ (a : Topology.WithUpper Î±áµ’áµˆ), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a) }.invFun",
  "constCategory": "Theorem"},
 {"references":
  ["Std.Logic._auxLemma.40",
   "And",
   "Exists",
   "funext",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.7",
   "congr",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self"],
  "name": "exists_and_right",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "HEq",
   "compl_compl",
   "Set",
   "eq_of_heq",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "HEq.refl",
   "LE",
   "Eq.casesOn",
   "IsLowerSet.compl",
   "Eq.symm",
   "IsUpperSet.compl",
   "id"],
  "name": "isLowerSet_compl",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s : Set Î±}, IsLowerSet sá¶œ â†” IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.singleton_subset_iff",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.132",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {s : Set Î±}, ({a} âŠ† s) = (a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "âˆ€ {Î± : Sort u}, Î± â†’ Nonempty Î±",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.lt_or_ge.match_2",
  "constType":
  "âˆ€ (n m : â„•) (motive : n < m âˆ¨ n â‰¥ m â†’ Prop) (x : n < m âˆ¨ n â‰¥ m),\n  (âˆ€ (h : n < m), motive (_ : n < m âˆ¨ n â‰¥ m)) â†’ (âˆ€ (h : n â‰¥ m), motive (_ : n < m âˆ¨ n â‰¥ m)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "Iff.mp",
   "List.Perm",
   "List.instMembershipList",
   "List",
   "List.Perm.mem_iff",
   "HasSubset.Subset"],
  "name": "List.Perm.subset",
  "constType": "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ lâ‚ âŠ† lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["List.forall_mem_ne",
   "Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.List.Nodup._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {l : List Î±}, (âˆ€ a' âˆˆ l, Â¬a = a') = Â¬a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd.proof_1",
  "constType": "âˆ€ (M : Type u_1) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Theorem"},
 {"references": ["outParam", "InfSet"],
  "name": "sInfHomClass",
  "constType":
  "Type u_8 â†’\n  (Î± : outParam (Type u_9)) â†’\n    (Î² : outParam (Type u_10)) â†’ [inst : InfSet Î±] â†’ [inst : InfSet Î²] â†’ Type (max (max u_10 u_8) u_9)",
  "constCategory": "Other"},
 {"references": ["PLift", "Finite", "instFinitePLift.proof_1"],
  "name": "instFinitePLift",
  "constType": "âˆ€ {Î± : Sort u_1} [inst : Finite Î±], Finite (PLift Î±)",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse", "funext", "Function.comp", "Eq", "id"],
  "name": "Function.LeftInverse.comp_eq_id",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.LeftInverse f g â†’ f âˆ˜ g = id",
  "constCategory": "Theorem"},
 {"references": ["Set.iUnion", "Set", "LE", "isUpperSet_iUnion", "IsUpperSet"],
  "name": "isUpperSet_iUnionâ‚‚",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Îº : Î¹ â†’ Sort u_5} [inst : LE Î±] {f : (i : Î¹) â†’ Îº i â†’ Set Î±},\n  (âˆ€ (i : Î¹) (j : Îº i), IsUpperSet (f i j)) â†’ IsUpperSet (â‹ƒ i, â‹ƒ j, f i j)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Iff.symm",
   "Exists",
   "Iff",
   "Subtype.exists",
   "Subtype.val",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.exists'",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (x : Î±) â†’ p x â†’ Prop}, (âˆƒ x, âˆƒ (h : p x), q x h) â†” âˆƒ x, q â†‘x (_ : p â†‘x)",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "ReaderT",
   "ReaderT.bind",
   "ReaderT.instApplicativeReaderT",
   "Monad.mk",
   "Bind.mk"],
  "name": "ReaderT.instMonadReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ Monad (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Set.inter_isComm.proof_1",
   "Inter.inter",
   "Set.instInterSet",
   "IsCommutative"],
  "name": "Set.inter_isComm",
  "constType": "âˆ€ {Î± : Type u}, IsCommutative (Set Î±) fun x x_1 â†¦ x âˆ© x_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Decidable.isFalse",
   "propext",
   "instDecidableEqProp.match_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqProp.proof_1",
   "Eq"],
  "name": "instDecidableEqProp",
  "constType": "{p q : Prop} â†’ [d : Decidable (p â†” q)] â†’ Decidable (p = q)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Set.univ_inter",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_right",
  "constType": "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, s âˆˆ g â†’ s âˆˆ f âŠ“ g",
  "constCategory": "Theorem"},
 {"references": ["nhds", "TopologicalSpace", "Filter", "Eq"],
  "name": "Inseparable",
  "constType": "{X : Type u_1} â†’ [inst : TopologicalSpace X] â†’ X â†’ X â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.mem_inf_iff",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, s âˆˆ f âŠ“ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, s = tâ‚ âˆ© tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "PLift.up", "propext", "PLift.exists", "PLift", "Eq"],
  "name": "Mathlib.Data.ULift._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Sort u} {p : PLift Î± â†’ Prop}, (âˆƒ x, p x) = âˆƒ x, p { down := x }",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Bot.bot",
   "Pi.orderBot.proof_1",
   "OrderBot.toBot",
   "Bot.mk",
   "inferInstanceAs",
   "LE",
   "OrderBot.mk",
   "OrderBot",
   "Pi.hasLe",
   "Pi.instBotForAll"],
  "name": "Pi.orderBot",
  "constType":
  "{Î¹ : Type u_3} â†’\n  {Î±' : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ LE (Î±' i)] â†’ [inst_1 : (i : Î¹) â†’ OrderBot (Î±' i)] â†’ OrderBot ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{Î± : Sort u_1} â†’\n  {a : Î±} â†’ {motive : (a_1 : Î±) â†’ a = a_1 â†’ Sort u} â†’ motive a (_ : a = a) â†’ {a_1 : Î±} â†’ (t : a = a_1) â†’ motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Top",
   "setOf",
   "Filter.mk",
   "Filter.instTopFilter.proof_2",
   "Set",
   "Filter.instTopFilter.proof_1",
   "Filter",
   "Set.mem_univ",
   "Top.mk",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter",
  "constType": "{Î± : Type u} â†’ Top (Filter Î±)",
  "constCategory": "Definition"},
 {"references": ["OrderTop", "LE", "OrderBot", "BoundedOrder"],
  "name": "BoundedOrder.mk",
  "constType":
  "{Î± : Type u} â†’ [inst : LE Î±] â†’ [toOrderTop : OrderTop Î±] â†’ [toOrderBot : OrderBot Î±] â†’ BoundedOrder Î±",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "Nat.sub_lt.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ 0 < x â†’ 0 < x_1 â†’ Prop) (x x_1 : â„•) (x_2 : 0 < x) (x_3 : 0 < x_1),\n  (âˆ€ (x : â„•) (h1 : 0 < 0) (x_4 : 0 < x), motive 0 x h1 x_4) â†’\n    (âˆ€ (n : â„•) (x : 0 < n + 1) (h2 : 0 < 0), motive (Nat.succ n) 0 x h2) â†’\n      (âˆ€ (n m : â„•) (x : 0 < n + 1) (x_4 : 0 < m + 1), motive (Nat.succ n) (Nat.succ m) x x_4) â†’ motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["EStateM.Result"],
  "name": "EStateM.Result.error",
  "constType": "{Îµ Ïƒ Î± : Type u} â†’ Îµ â†’ Ïƒ â†’ EStateM.Result Îµ Ïƒ Î±",
  "constCategory": "Other"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.toLowerSet",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithLowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "instTopologicalSpaceProd",
   "CompleteLattice.toBoundedOrder",
   "ConditionallyCompleteLattice.toLattice",
   "Prod.completeLattice",
   "ContinuousInf",
   "Preorder.toLE",
   "Lattice.toInf",
   "Topology.instIsLowerProd",
   "CompleteLattice",
   "Topology.IsLower",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "ContinuousInf.mk",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sInfHom.continuous",
   "BoundedOrder.toOrderBot",
   "infsInfHom"],
  "name": "Topology.IsLower.toContinuousInf.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±], ContinuousInf Î±",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Prod.semilatticeSup",
   "SemilatticeSup.sup_le",
   "inferInstanceAs",
   "Sup.sup",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.lattice.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Lattice Î±] [inst_1 : Lattice Î²] (a b c : Î± Ã— Î²), a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["PSigma", "PSigma.mk"],
  "name": "PSigma.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {Î² : Î± â†’ Sort v} â†’\n    {motive : PSigma Î² â†’ Sort u_1} â†’\n      ((fst : Î±) â†’ (snd : Î² fst) â†’ motive { fst := fst, snd := snd }) â†’ (t : PSigma Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["PProd", "List.rec", "List", "PUnit"],
  "name": "List.below",
  "constType":
  "{Î± : Type u} â†’ {motive : List Î± â†’ Sort u_1} â†’ List Î± â†’ Sort (max 1 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "dite",
   "List.pwFilter_cons_of_neg",
   "Iff.mpr",
   "Eq",
   "List.Pairwise",
   "PProd",
   "And",
   "PProd.fst",
   "List.pwFilter_cons_of_pos",
   "List.rec",
   "List.decidableBAll",
   "List.pairwise_cons",
   "List",
   "List.pwFilter_map.match_1",
   "Eq.rec",
   "PUnit",
   "Not",
   "List.pwFilter",
   "And.intro",
   "List.nil",
   "Eq.symm",
   "DecidableRel"],
  "name": "List.pairwise_pwFilter",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [inst : DecidableRel R] (l : List Î±), List.Pairwise R (List.pwFilter R l)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toStrictOrderedSemiring : StrictOrderedSemiring Î±] â†’ (âˆ€ (a b : Î±), a * b = b * a) â†’ StrictOrderedCommSemiring Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Set.inter_univ",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_left",
  "constType": "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, s âˆˆ f â†’ s âˆˆ f âŠ“ g",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Expr", "Nat"],
  "name": "Lean.Data.AC.Expr.var",
  "constType": "â„• â†’ Lean.Data.AC.Expr",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Classical.choose_spec",
   "Exists",
   "Classical.choose",
   "Set.preimage",
   "isOpen_biUnion",
   "Function.sometimes",
   "Set",
   "Eq.refl",
   "Set.iUnionâ‚‚_congr",
   "Exists.intro",
   "And.left",
   "Function.sometimes_spec",
   "Set.instMembershipSet",
   "Eq",
   "Set.sUnion_eq_biUnion",
   "Set.preimage_iUnionâ‚‚",
   "And",
   "And.right",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.iUnion",
   "Set.instInhabitedSet",
   "TopologicalSpace",
   "Set.sUnion",
   "And.intro",
   "IsOpen",
   "instNonempty",
   "id"],
  "name": "TopologicalSpace.induced.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (t : TopologicalSpace Î²) (S : Set (Set Î±)),\n  (âˆ€ t_1 âˆˆ S, (fun s â†¦ âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = s) t_1) â†’ âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = â‹ƒâ‚€ S",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.length_eq",
   "List.Perm",
   "List",
   "List.nil",
   "List.eq_nil_of_length_eq_zero",
   "Eq"],
  "name": "List.Perm.eq_nil",
  "constType": "âˆ€ {Î± : Type uu} {l : List Î±}, l ~ [] â†’ l = []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "UInt64",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["List.cons", "List", "List.Sublist", "List.Sublist.consâ‚‚"],
  "name": "List.Sublist.cons_cons",
  "constType":
  "âˆ€ {Î± : Type u} {lâ‚ lâ‚‚ : List Î±} (a : Î±), List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist (a :: lâ‚) (a :: lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.20",
  "constType": "âˆ€ {Î± : Sort u_1} {a b : Î±}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "â„•",
  "constCategory": "Other"},
 {"references": ["HAppend.mk", "HAppend", "Append", "Append.append"],
  "name": "instHAppend",
  "constType": "{Î± : Type u_1} â†’ [inst : Append Î±] â†’ HAppend Î± Î± Î±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_iInf",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_iInfâ‚‚",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {Îº : Î¹ â†’ Sort u_7} [inst : CompleteLattice Î±] {a : Î±} {f : (i : Î¹) â†’ Îº i â†’ Î±},\n  (âˆ€ (i : Î¹) (j : Îº i), a â‰¤ f i j) â†’ a â‰¤ â¨… i, â¨… j, f i j",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_1",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Lean.Data.AC.Expr",
   "Nat",
   "Lean.Data.AC.Expr.casesOn",
   "Lean.Data.AC.Expr.var"],
  "name":
  "_private.Init.Data.AC.0.Lean.Data.AC.reprExpr.match_1._@.Init.Data.AC._hyg.40",
  "constType":
  "(motive : Lean.Data.AC.Expr â†’ Sort u_1) â†’\n  (x : Lean.Data.AC.Expr) â†’\n    ((a : â„•) â†’ motive (Lean.Data.AC.Expr.var a)) â†’\n      ((a a_1 : Lean.Data.AC.Expr) â†’ motive (Lean.Data.AC.Expr.op a a_1)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["implies_dep_congr_ctx", "Eq"],
  "name": "implies_congr_ctx",
  "constType":
  "âˆ€ {pâ‚ pâ‚‚ qâ‚ qâ‚‚ : Prop}, pâ‚ = pâ‚‚ â†’ (pâ‚‚ â†’ qâ‚ = qâ‚‚) â†’ (pâ‚ â†’ qâ‚) = (pâ‚‚ â†’ qâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Set.Subset", "Set", "LE"],
  "name": "Set.instLESet",
  "constType": "{Î± : Type u_1} â†’ LE (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Lattice._auxLemma.2",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Eq",
   "SemilatticeSup",
   "And",
   "Mathlib.Order.Lattice._auxLemma.1",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Mathlib.Order.Lattice._auxLemma.3",
   "le_antisymm",
   "congrArg",
   "Eq.trans",
   "and_self",
   "SemilatticeSup.toPartialOrder"],
  "name": "sup_comm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a âŠ” b = b âŠ” a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.filter",
   "Eq.mpr",
   "Eq.ndrec",
   "Bool.false",
   "List",
   "Unit",
   "Bool.true",
   "Eq.refl",
   "Not",
   "List.erase.match_1",
   "Bool",
   "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
   "eq_false_of_ne_true",
   "id",
   "Eq"],
  "name": "List.filter_cons_of_neg",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {a : Î±} (l : List Î±), Â¬p a = true â†’ List.filter p (a :: l) = List.filter p l",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Nat.rec",
   "instLENat",
   "Nat.pred_le",
   "Nat.pred",
   "instSubNat",
   "Nat.le_refl",
   "HSub.hSub",
   "Nat.le_trans",
   "instOfNatNat",
   "Nat",
   "LE.le"],
  "name": "Nat.sub_le",
  "constType": "âˆ€ (n m : â„•), n - m â‰¤ n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "of_eq_true",
   "List.rec",
   "List",
   "Function.comp",
   "List.nil",
   "List.map",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.map_map",
  "constType":
  "âˆ€ {Î² : Type u_1} {Î³ : Type u_2} {Î± : Type u_3} (g : Î² â†’ Î³) (f : Î± â†’ Î²) (l : List Î±),\n  List.map g (List.map f l) = List.map (g âˆ˜ f) l",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "CanLift",
  "constType":
  "(Î± : Sort u_1) â†’ (Î² : Sort u_2) â†’ outParam (Î² â†’ Î±) â†’ outParam (Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termð“[>]_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["cond",
   "Nat.add_comm",
   "List.cons",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.countP.go",
   "Eq",
   "List.countP_go_eq_add",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "Bool.true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "id"],
  "name": "List.countP_cons_of_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {a : Î±} (l : List Î±), p a = true â†’ List.countP p (a :: l) = List.countP p l + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.inf_compl_le_bot",
  "constType": "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x : Î±), x âŠ“ xá¶œ â‰¤ âŠ¥",
  "constCategory": "Definition"},
 {"references": ["Exists", "False", "not_forall_of_exists_not.match_1", "Not"],
  "name": "not_forall_of_exists_not",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (âˆƒ x, Â¬p x) â†’ Â¬âˆ€ (x : Î±), p x",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "Directed.mono.match_1",
   "Directed"],
  "name": "Directed.mono",
  "constType":
  "âˆ€ {Î± : Type u} {r s : Î± â†’ Î± â†’ Prop} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±},\n  (âˆ€ (a b : Î±), r a b â†’ s a b) â†’ Directed r f â†’ Directed s f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Topology.Bases._auxLemma.1",
   "funext",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff",
   "congrArg",
   "Eq.trans",
   "Filter.HasBasis.mk",
   "TopologicalSpace.IsTopologicalBasis",
   "instMembershipSetFilter"],
  "name": "TopologicalSpace.IsTopologicalBasis.nhds_hasBasis",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {b : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis b â†’ âˆ€ {a : Î±}, Filter.HasBasis (nhds a) (fun t â†¦ t âˆˆ b âˆ§ a âˆˆ t) fun t â†¦ t",
  "constCategory": "Theorem"},
 {"references":
  ["List.nodup_dedup",
   "eq_true",
   "List.Nodup",
   "DecidableEq",
   "List.dedup",
   "List",
   "True",
   "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.30",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] (l : List Î±), List.Nodup (List.dedup l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termI^_Â»._closed_1",
   "Topology.termÏ€_._closed_1"],
  "name": "Topology.termÏ€_._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Multiset", "Finset", "Multiset.Nodup", "Finset.mk", "Finset.rec"],
  "name": "Finset.casesOn",
  "constType":
  "{Î± : Type u_4} â†’\n  {motive : Finset Î± â†’ Sort u} â†’\n    (t : Finset Î±) â†’\n      ((val : Multiset Î±) â†’ (nodup : Multiset.Nodup val) â†’ motive { val := val, nodup := nodup }) â†’ motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "Nat.rec",
   "OfNat.ofNat",
   "Nat.zero",
   "Nat.pred",
   "Eq.refl",
   "instOfNatNat",
   "Nat",
   "absurd",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_pred",
  "constType": "âˆ€ {a : â„•}, a â‰  0 â†’ Nat.succ (Nat.pred a) = a",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ b â†’ a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "IsOpen.interior_eq",
   "Eq.rec",
   "Set",
   "TopologicalSpace",
   "isOpen_interior",
   "IsOpen",
   "interior",
   "Eq"],
  "name": "interior_eq_iff_isOpen",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, interior s = s â†” IsOpen s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Prod.lattice",
   "Prod",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (a b c : Î± Ã— Î²),\n  a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLowerSet",
   "Equiv.toHomeomorphOfInducing",
   "Homeomorph",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.WithLowerSetHomeomorph.proof_1"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsLowerSet Î±] â†’ Topology.WithLowerSet Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references": ["Exists", "Or", "propext", "exists_or", "Eq"],
  "name": "Std.Logic._auxLemma.47",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆƒ x, p x âˆ¨ q x) = ((âˆƒ x, p x) âˆ¨ âˆƒ x, q x)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "âˆ€ {Î± : Type u_2} [self : LinearOrderedCommSemiring Î±] (a b : Î±), max a b = if a â‰¤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.MacroM",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["SupSet", "funext", "congr_arg", "iSup", "Eq"],
  "name": "iSup_congr",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : SupSet Î±] {f g : Î¹ â†’ Î±}, (âˆ€ (i : Î¹), f i = g i) â†’ â¨† i, f i = â¨† i, g i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Order.Frame.toCompleteLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteDistribLattice.iInf_sup_le_sup_sInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteDistribLattice Î±] (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Continuous_of._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.Continuous_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1",
   "Topology.IsOpen_of._closed_2"],
  "name": "Topology.IsOpen_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{Î± : Sort u_1} â†’\n  {a : Î±} â†’ {motive : (a_1 : Î±) â†’ a = a_1 â†’ Sort u} â†’ {a_1 : Î±} â†’ (t : a = a_1) â†’ motive a (_ : a = a) â†’ motive a_1 t",
  "constCategory": "Definition"},
 {"references": ["Pi.le_def", "propext", "LE", "Pi.hasLe", "LE.le", "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.10",
  "constType":
  "âˆ€ {Î¹ : Type u} {Î± : Î¹ â†’ Type v} [inst : (i : Î¹) â†’ LE (Î± i)] {x y : (i : Î¹) â†’ Î± i}, (x â‰¤ y) = âˆ€ (i : Î¹), x i â‰¤ y i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "setOf",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "HasSubset.Subset",
   "Filter.comap.proof_1",
   "Filter",
   "Filter.comap.proof_3",
   "Filter.comap.proof_2",
   "instMembershipSetFilter"],
  "name": "Filter.comap",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Filter Î² â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerBounds",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_succ",
  "constType":
  "âˆ€ {M : Type u} [self : AddMonoid M] (n : â„•) (x : M), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["List.below",
   "List.brecOn",
   "List.instMembershipList",
   "Eq.refl",
   "List.Pairwise.cons",
   "Mathlib.Data.List.Chain._auxLemma.8",
   "implies_congr",
   "True",
   "Eq",
   "Mathlib.Data.List.Chain._auxLemma.9",
   "PProd",
   "Eq.mpr",
   "List.rec",
   "forall_congr",
   "PUnit",
   "List.nil",
   "List.Chain",
   "Mathlib.Data.List.Chain._auxLemma.7",
   "Eq.trans",
   "id",
   "Membership.mem",
   "trans",
   "List.cons",
   "Or",
   "List.pairwise_singleton",
   "List.Pairwise",
   "And",
   "eq_true",
   "PProd.fst",
   "List",
   "IsTrans",
   "congrArg",
   "List.Chain.pairwise.match_1",
   "List.rel_of_pairwise_cons",
   "congrFun"],
  "name": "List.Chain.pairwise",
  "constType":
  "âˆ€ {Î± : Type u} {R : Î± â†’ Î± â†’ Prop} [inst : IsTrans Î± R] {a : Î±} {l : List Î±}, List.Chain R a l â†’ List.Pairwise R (a :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Pi.booleanAlgebra",
   "Not",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_3",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Î± â†’ Prop), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.val",
   "LT.lt",
   "Fin.eq_of_val_eq.match_1",
   "Nat",
   "rfl",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Eq"],
  "name": "Fin.eq_of_val_eq",
  "constType": "âˆ€ {n : â„•} {i j : Fin n}, â†‘i = â†‘j â†’ i = j",
  "constCategory": "Theorem"},
 {"references": ["List.Pairwise", "Ne", "List"],
  "name": "List.Nodup",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Order.Filter.Prod._auxLemma.20",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Subtype.val",
   "Set",
   "Mathlib.Order.Filter.Prod._auxLemma.28",
   "Eq.refl",
   "CompleteLattice.toBot",
   "Mathlib.Order.Filter.Prod._auxLemma.21",
   "True",
   "Mathlib.Order.Filter.Prod._auxLemma.23",
   "iff_self",
   "Iff.of_eq",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Mathlib.Order.Filter.Prod._auxLemma.24",
   "SProd.sprod",
   "Filter",
   "Mathlib.Order.Filter.Prod._auxLemma.27",
   "Eq.trans",
   "instNonempty",
   "Subtype",
   "id",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Set.instSProd",
   "Or",
   "Bot.bot",
   "funext",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Filter.instSProd",
   "Mathlib.Order.Filter.Prod._auxLemma.26",
   "Filter.inhabitedMem",
   "And",
   "Set.instHasSubsetSet",
   "Mathlib.Order.Filter.Prod._auxLemma.6",
   "of_eq_true",
   "Mathlib.Order.Filter.Prod._auxLemma.22",
   "congr",
   "Prod",
   "Mathlib.Order.Filter.Prod._auxLemma.29",
   "congrArg",
   "Subtype.mk",
   "Mathlib.Order.Filter.Prod._auxLemma.25",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Filter.prod_eq_bot",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Filter Î±} {g : Filter Î²}, f Ã—Ë¢ g = âŠ¥ â†” f = âŠ¥ âˆ¨ g = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[_]_Â»._closed_9",
   "Topology.Â«termð“[â‰ ]_Â»._closed_4"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "closure",
   "Set.instSProd",
   "instTopologicalSpaceProd",
   "Set",
   "True",
   "Eq",
   "Iff.mp",
   "of_eq_true",
   "closure_prod_eq",
   "closure_eq_iff_isClosed",
   "SProd.sprod",
   "IsClosed.closure_eq",
   "congr",
   "TopologicalSpace",
   "Prod",
   "IsClosed",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "IsClosed.prod",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {sâ‚ : Set Î±} {sâ‚‚ : Set Î²},\n  IsClosed sâ‚ â†’ IsClosed sâ‚‚ â†’ IsClosed (sâ‚ Ã—Ë¢ sâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "IsClosed.isOpen_compl",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed.mk",
   "IsClosed",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen"],
  "name": "isOpen_compl_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen sá¶œ â†” IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_5",
   "List.cons",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "HasSubset.Subset",
   "le_rfl",
   "And.intro",
   "Exists.intro",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "subset_lowerClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, s âŠ† â†‘(lowerClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.gt_of_not_le",
   "instSubNat",
   "Nat.decLt",
   "Eq.refl",
   "instLTNat",
   "Nat.mod_eq_of_lt",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Iff.mp",
   "instOfNatNat",
   "Nat",
   "Decidable.not_and_iff_or_not",
   "Eq.symm",
   "absurd",
   "Nat.decLe",
   "id",
   "instHSub",
   "Or",
   "HSub.hSub",
   "LE.le",
   "Nat.mod.inductionOn",
   "GT.gt",
   "And",
   "Nat.instModNat",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Eq.ndrec",
   "LT.lt",
   "Eq.mp",
   "HMod.hMod",
   "Not",
   "Nat.mod_lt.match_1",
   "Nat.mod_eq_sub_mod"],
  "name": "Nat.mod_lt",
  "constType": "âˆ€ (x : â„•) {y : â„•}, y > 0 â†’ x % y < y",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "List.cons",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String â†’ String â†’ String â†’ String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["funext", "Function.RightInverse", "Function.comp", "Eq", "id"],
  "name": "Function.RightInverse.comp_eq_id",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.RightInverse f g â†’ g âˆ˜ f = id",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Topology.WithUpper",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.rfl",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "isOpen_compl_iff",
   "Eq",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen",
   "id"],
  "name": "isClosed_compl_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsClosed sá¶œ â†” IsOpen s",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "Mathlib.Topology.Basic._auxLemma.15",
   "Set",
   "HasSubset.Subset",
   "interior_eq_iff_isOpen",
   "True",
   "iff_self",
   "Eq",
   "Iff.symm",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "propext",
   "TopologicalSpace",
   "congrArg",
   "Mathlib.Topology.Basic._auxLemma.16",
   "interior",
   "IsOpen",
   "Eq.trans",
   "congrFun"],
  "name": "subset_interior_iff_isOpen",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, s âŠ† interior s â†” IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.toUpper",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithUpper Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.eq_of_length",
   "List.Sublist.length_le",
   "instLENat",
   "List",
   "List.Sublist",
   "List.length",
   "Nat",
   "Nat.le_antisymm",
   "LE.le",
   "Eq"],
  "name": "List.Sublist.eq_of_length_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.length lâ‚‚ â‰¤ List.length lâ‚ â†’ lâ‚ = lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "Equiv.toFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "sSupHom",
   "OrderDual.infSet",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "FunLike.coe",
   "sSupHom.dual",
   "instTopologicalSpaceOrderDual",
   "sSupHom.instSSupHomClassSSupHom",
   "sSupHomClass.toFunLike",
   "CompleteLattice",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Continuous",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderDual.completeLattice",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sInfHom.continuous",
   "CompleteLattice.toSupSet"],
  "name": "sSupHom.continuous",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : Topology.IsUpper Î±] [inst_4 : TopologicalSpace Î²] [inst_5 : Topology.IsUpper Î²] (f : sSupHom Î± Î²),\n  Continuous â†‘f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.mem_range'",
   "List.range'",
   "instAddNat",
   "List.instMembershipList",
   "instHAdd",
   "HAdd.hAdd",
   "instLTNat",
   "Eq",
   "And",
   "instHMul",
   "propext",
   "List",
   "LT.lt",
   "HMul.hMul",
   "Nat",
   "instMulNat"],
  "name": "Std.Data.List.Lemmas._auxLemma.107",
  "constType":
  "âˆ€ {m s step n : â„•}, (m âˆˆ List.range' s n step) = âˆƒ i < n, m = s + step * i",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsAssociative",
  "constType": "(Î± : Type u) â†’ (Î± â†’ Î± â†’ Î±) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["UpperSet.casesOn",
   "Eq.ndrec",
   "Eq.rec",
   "Set",
   "UpperSet.carrier",
   "Eq.refl",
   "LE",
   "UpperSet.mk",
   "IsUpperSet",
   "Eq.symm",
   "UpperSet",
   "Eq"],
  "name": "UpperSet.instSetLikeUpperSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] (s t : UpperSet Î±), s.carrier = t.carrier â†’ s = t",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "GaloisConnection.l_u_le",
   "LE.le.trans",
   "Monotone",
   "GaloisConnection.le_u",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "GaloisConnection.monotone_u",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ Monotone u",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.union_eq_self_of_subset_left",
   "Union.union",
   "Set",
   "Filter.mem_of_superset",
   "Eq.refl",
   "HasSubset.Subset",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Set.subset_union_left",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.inter_union_distrib_right",
   "Filter",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Set.instUnionSet",
   "id",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (f g : Filter Î±) {x y : Set Î±},\n  x âˆˆ {s | âˆƒ a âˆˆ f, âˆƒ b âˆˆ g, s = a âˆ© b} â†’ x âŠ† y â†’ y âˆˆ {s | âˆƒ a âˆˆ f, âˆƒ b âˆˆ g, s = a âˆ© b}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.closure_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "Prod.snd",
   "Prod.mk",
   "Prod",
   "Prod.fst",
   "PProd.snd",
   "PProd.mk",
   "rfl",
   "Eq"],
  "name": "Equiv.pprodEquivProd.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (x : PProd Î± Î²),\n  (fun x â†¦ { fst := x.1, snd := x.2 }) ((fun x â†¦ (x.fst, x.snd)) x) =\n    (fun x â†¦ { fst := x.1, snd := x.2 }) ((fun x â†¦ (x.fst, x.snd)) x)",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "List.append",
   "List.instAppendList",
   "List.Perm",
   "List.Perm.refl",
   "HAppend.hAppend",
   "List",
   "List.Perm.trans",
   "List.nil",
   "List.Perm.rec",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.append_right",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±} (tâ‚ : List Î±), lâ‚ ~ lâ‚‚ â†’ lâ‚ ++ tâ‚ ~ lâ‚‚ ++ tâ‚",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Unit",
   "Unit.unit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.hash.match_1",
  "constType":
  "(motive : Lean.Name â†’ Sort u_1) â†’\n  (x : Lean.Name) â†’\n    (Unit â†’ motive Lean.Name.anonymous) â†’\n      ((p : Lean.Name) â†’ (s : String) â†’ motive (Lean.Name.str p s)) â†’\n        ((p : Lean.Name) â†’ (v : â„•) â†’ motive (Lean.Name.num p v)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["DistribLattice", "GeneralizedBooleanAlgebra"],
  "name": "GeneralizedBooleanAlgebra.toDistribLattice",
  "constType":
  "{Î± : Type u} â†’ [self : GeneralizedBooleanAlgebra Î±] â†’ DistribLattice Î±",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î² : Type v} â†’ [self : Singleton Î± Î²] â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual.instIsUpper.proof_1",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "OrderDual.instIsUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±], Topology.IsUpper Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Set.range", "InfSet.sInf", "InfSet"],
  "name": "iInf",
  "constType":
  "{Î± : Type u_1} â†’ [inst : InfSet Î±] â†’ {Î¹ : Sort u_9} â†’ (Î¹ â†’ Î±) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_of_forall",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (âˆ€ (x : Î±), x âˆˆ s) â†’ s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "propext",
   "Sup.sup",
   "Eq.symm",
   "sup_le_iff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.9",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, (a â‰¤ c âˆ§ b â‰¤ c) = (a âŠ” b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Perm",
   "List.instMembershipList",
   "propext",
   "List",
   "List.Perm.mem_iff",
   "Eq"],
  "name": "Multiset.Mem.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (lâ‚ lâ‚‚ : List Î±), lâ‚ ~ lâ‚‚ â†’ (fun l â†¦ a âˆˆ l) lâ‚ = (fun l â†¦ a âˆˆ l) lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "IsGLB",
   "Set.preimage",
   "Set",
   "OrderDual",
   "FunLike.coe",
   "Preorder",
   "IsLUB",
   "Equiv.instFunLikeEquiv"],
  "name": "IsGLB.dual",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±},\n  IsGLB s a â†’ IsLUB (â†‘OrderDual.ofDual â»Â¹' s) (â†‘OrderDual.toDual a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.iUnion",
   "isUpperSet_iUnionâ‚‚",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "LE",
   "UpperSet.upper",
   "IsUpperSet",
   "UpperSet",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "UpperSet.instInfSetUpperSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] (S : Set (UpperSet Î±)), IsUpperSet (â‹ƒ i âˆˆ S, â†‘i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List.Nodup.pmap",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.pmap",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset",
   "Quot.mk",
   "Eq"],
  "name": "Multiset.Nodup.pmap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {s : Multiset Î±} {H : âˆ€ a âˆˆ s, p a},\n  (âˆ€ (a : Î±) (ha : p a) (b : Î±) (hb : p b), f a ha = f b hb â†’ a = b) â†’\n    Multiset.Nodup s â†’ Multiset.Nodup (Multiset.pmap f s H)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "IsLowerSet",
   "Set",
   "LE",
   "Set.sUnion",
   "Exists.imp",
   "And.intro",
   "And.left",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "isLowerSet_sUnion",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {S : Set (Set Î±)}, (âˆ€ s âˆˆ S, IsLowerSet s) â†’ IsLowerSet (â‹ƒâ‚€ S)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Filter.HasBasis.comap",
   "And",
   "Filter.HasBasis",
   "Filter.HasBasis.inf",
   "Prod.snd",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "Filter.comap",
   "Prod",
   "Filter",
   "Prod.fst",
   "Filter.instSProd"],
  "name": "Filter.HasBasis.prod",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {la : Filter Î±} {lb : Filter Î²} {Î¹ : Type u_6} {Î¹' : Type u_7} {pa : Î¹ â†’ Prop}\n  {sa : Î¹ â†’ Set Î±} {pb : Î¹' â†’ Prop} {sb : Î¹' â†’ Set Î²},\n  Filter.HasBasis la pa sa â†’\n    Filter.HasBasis lb pb sb â†’ Filter.HasBasis (la Ã—Ë¢ lb) (fun i â†¦ pa i.1 âˆ§ pb i.2) fun i â†¦ sa i.1 Ã—Ë¢ sb i.2",
  "constCategory": "Theorem"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.lift.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î²] (f : Î± â†’ Î²) (x x_1 x_2 : Î±),\n  f x â‰¤ f x_1 â†’ f x_1 â‰¤ f x_2 â†’ f x â‰¤ f x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.plift", "PLift", "Finite", "Finite.of_equiv", "Equiv.symm"],
  "name": "instFinitePLift.proof_1",
  "constType": "âˆ€ {Î± : Sort u_1} [inst : Finite Î±], Finite (PLift Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.top_le_sup_compl",
  "constType": "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x : Î±), âŠ¤ â‰¤ x âŠ” xá¶œ",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.Chain",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Î± â†’ Prop) â†’ Î± â†’ List Î± â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Function.Surjective.exists",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Function.Surjective",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "Filter",
   "Filter.HasBasis.mem_iff",
   "Filter.HasBasis.mk",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.comp_surjective",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Î¹' : Sort u_5} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ âˆ€ {g : Î¹' â†’ Î¹}, Function.Surjective g â†’ Filter.HasBasis l (p âˆ˜ g) (s âˆ˜ g)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.termÎ©._closed_3",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Homotopy.termÎ©._closed_5"],
  "name": "Topology.Homotopy.termÎ©._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.rec._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Topology.WithUpperSet Î± â†’ Sort u_4} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithUpperSet.toUpperSet a)) â†’ (a : Topology.WithUpperSet Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references": ["Lattice", "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toLattice",
  "constType":
  "{Î± : Type u_4} â†’ [self : GeneralizedHeytingAlgebra Î±] â†’ Lattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Eq.refl",
   "Insert.insert",
   "True",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "Set.instSingletonSet",
   "InfHomClass.mk",
   "InfHomClass.toFunLike",
   "Set.image",
   "Eq.symm",
   "Eq.trans",
   "id",
   "eq_self",
   "sInfHomClass.map_sInf",
   "Set.image_pair",
   "Top.top",
   "sInfHomClass.toFunLike",
   "Set.instEmptyCollectionSet",
   "FunLike.coe",
   "sInf_empty",
   "sInfHomClass",
   "sInf_singleton",
   "sInf_insert",
   "CompleteLattice",
   "Eq.ndrec",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "CompleteLattice.toTop",
   "Singleton.singleton",
   "sInf_pair",
   "Set.image_empty",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Set.instInsertSet",
   "congrFun"],
  "name": "sInfHomClass.toInfTopHomClass.proof_2",
  "constType":
  "âˆ€ {F : Type u_3} {Î± : Type u_2} {Î² : Type u_1} [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²]\n  [inst_2 : sInfHomClass F Î± Î²] (f : F), â†‘f âŠ¤ = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Iff.intro",
   "isClosed_closure",
   "Iff",
   "Eq.rec",
   "Set",
   "IsClosed.closure_eq",
   "TopologicalSpace",
   "IsClosed",
   "Eq"],
  "name": "closure_eq_iff_isClosed",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, closure s = s â†” IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.Sublist.below"],
  "name": "List.Sublist.below.consâ‚‚",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop} {lâ‚ lâ‚‚ : List Î±} (a : Î±)\n  {a_1 : List.Sublist lâ‚ lâ‚‚},\n  List.Sublist.below a_1 â†’ motive lâ‚ lâ‚‚ a_1 â†’ List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))",
  "constCategory": "Other"},
 {"references": [],
  "name": "Union",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.comap_principal.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {m : Î± â†’ Î²} {t : Set Î²} (x : Set Î±)\n  (motive : x âˆˆ Filter.comap m (Filter.principal t) â†’ Prop) (x_1 : x âˆˆ Filter.comap m (Filter.principal t)),\n  (âˆ€ (_u : Set Î²) (hu : _u âˆˆ Filter.principal t) (b : m â»Â¹' _u âŠ† x),\n      motive (_ : âˆƒ t_1 âˆˆ Filter.principal t, m â»Â¹' t_1 âŠ† x)) â†’\n    motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf.inf",
   "Eq.refl",
   "sup_le_iff",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "Lattice.toInf",
   "Eq.mpr",
   "Iff",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeSup",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "id",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "le_inf_iff",
   "Mathlib.Order.Heyting.Basic._auxLemma.14",
   "LE.le",
   "sdiff_le_comm",
   "And",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "congr",
   "Sup.sup",
   "GeneralizedCoheytingAlgebra.toLattice",
   "eq_of_forall_ge_iff",
   "congrArg",
   "congrFun"],
  "name": "sdiff_inf_distrib",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] (a b c : Î±), a \\ (b âŠ“ c) = a \\ b âŠ” a \\ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "PLift.up",
   "PLift.down",
   "PLift.down_up",
   "PLift",
   "Equiv.mk",
   "PLift.up_down"],
  "name": "Equiv.plift",
  "constType": "{Î± : Sort u} â†’ PLift Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "Nat.ne_of_lt",
   "instBEq",
   "List.indexOf",
   "List.length",
   "instLTNat",
   "Iff.mpr",
   "Decidable.by_contradiction",
   "Eq",
   "Iff.intro",
   "lt_of_le_of_ne",
   "Iff",
   "Iff.mp",
   "List.indexOf_le_length",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "List",
   "LT.lt",
   "List.instDecidableMemListInstMembershipList",
   "List.indexOf_eq_length",
   "Not",
   "Nat",
   "Nat.strictOrderedSemiring"],
  "name": "List.indexOf_lt_length",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, List.indexOf a l < List.length l â†” a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Std.Logic._auxLemma.34",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "eq_comm",
   "Eq.refl",
   "congrArg",
   "implies_congr",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "forall_eq'",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a' = a â†’ p a) â†” p a'",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.eq_of_length",
   "Iff.intro",
   "Membership.mem",
   "List.filter",
   "Iff",
   "List.filter_eq_self",
   "List.instMembershipList",
   "List",
   "List.filter_sublist",
   "Bool.true",
   "Iff.trans",
   "Bool",
   "List.length",
   "Nat",
   "congrArg",
   "Eq"],
  "name": "List.filter_length_eq_length",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {l : List Î±}, List.length (List.filter p l) = List.length l â†” âˆ€ a âˆˆ l, p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.MonadRef.withRef",
   "Monad",
   "Lean.replaceRef",
   "Lean.MonadRef",
   "Bind.bind",
   "Lean.MonadRef.getRef",
   "Monad.toBind",
   "Lean.Syntax"],
  "name": "Lean.withRef",
  "constType":
  "{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadRef m] â†’ {Î± : Type} â†’ Lean.Syntax â†’ m Î± â†’ m Î±",
  "constCategory": "Definition"},
 {"references": ["Array", "List"],
  "name": "Array.mk",
  "constType": "{Î± : Type u} â†’ List Î± â†’ Array Î±",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Prod.semilatticeInf.proof_2",
   "SemilatticeInf.toInf",
   "Prod.semilatticeInf.proof_1",
   "Inf.inf",
   "Prod.semilatticeInf.proof_3",
   "SemilatticeInf.toPartialOrder",
   "Prod.instInfProd",
   "PartialOrder",
   "Prod.semilatticeInf.proof_4",
   "Inf.mk",
   "Inf",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "Prod",
   "SemilatticeInf",
   "SemilatticeInf.mk"],
  "name": "Prod.semilatticeInf",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : SemilatticeInf Î±] â†’ [inst : SemilatticeInf Î²] â†’ SemilatticeInf (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references": ["instLENat", "Min", "minOfLe", "Nat", "Nat.decLe"],
  "name": "instMinNat",
  "constType": "Min â„•",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.add_sub_add_right",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "id",
   "Eq"],
  "name": "Nat.add_sub_add_left",
  "constType": "âˆ€ (k n m : â„•), k + n - (k + m) = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_6",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String"],
  "name": "String.mk",
  "constType": "List Char â†’ String",
  "constCategory": "Other"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Lean.Data.AC.Expr",
   "Lean.Data.AC.eval",
   "Lean.Data.AC.Context.evalList_append",
   "Eq.refl",
   "Eq",
   "instHAppend",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.instEvalInformationContext",
   "List.instAppendList",
   "Lean.Data.AC.Context",
   "HAppend.hAppend",
   "List",
   "congr",
   "Lean.Data.AC.Expr.rec",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Lean.Data.AC.Expr.toList",
   "Lean.Data.AC.Expr.var",
   "Lean.Data.AC.EvalInformation.evalOp",
   "Lean.Data.AC.Context.toList_nonEmpty",
   "id"],
  "name": "Lean.Data.AC.Context.eval_toList",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±) (e : Lean.Data.AC.Expr),\n  Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.Expr.toList e) = Lean.Data.AC.eval Î± ctx e",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.toUpperSetOrderIso._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.rec",
   "List.instMembershipList",
   "List",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.casesOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop} {a : List Î±}\n  (t : List.Pairwise R a),\n  motive [] (_ : List.Pairwise R []) â†’\n    (âˆ€ {a : Î±} {l : List Î±} (a_1 : âˆ€ a' âˆˆ l, R a a') (a_2 : List.Pairwise R l),\n        motive (a :: l) (_ : List.Pairwise R (a :: l))) â†’\n      motive a t",
  "constCategory": "Definition"},
 {"references": ["_obj", "Lean.ParserDescr.symbol", "Topology.termð“._closed_3"],
  "name": "Topology.termð“._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "List",
   "LT.lt",
   "List.length",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "List.get.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (head : Î±) (as : List Î±) (i : â„•), Nat.succ i < List.length (head :: as) â†’ Nat.succ i â‰¤ List.length as",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "iSup_le.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} {f : Î¹ â†’ Î±} (x : Î±) (motive : x âˆˆ Set.range f â†’ Prop) (x_1 : x âˆˆ Set.range f),\n  (âˆ€ (i : Î¹) (Eq : f i = x), motive (_ : âˆƒ y, f y = x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "List.pairwise_map",
   "List.Pairwise.imp",
   "List",
   "List.map",
   "Iff.mpr"],
  "name": "List.Pairwise.map",
  "constType":
  "âˆ€ {Î² : Type u_1} {Î± : Type u_2} {R : Î± â†’ Î± â†’ Prop} {l : List Î±} {S : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²),\n  (âˆ€ (a b : Î±), R a b â†’ S (f a) (f b)) â†’ List.Pairwise R l â†’ List.Pairwise S (List.map f l)",
  "constCategory": "Theorem"},
 {"references": ["List", "Lean.SyntaxNodeKind"],
  "name": "Lean.SyntaxNodeKinds",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List",
   "List.Perm.trans",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.swap'",
  "constType":
  "âˆ€ {Î± : Type uu} (x y : Î±) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ y :: x :: lâ‚ ~ x :: y :: lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["RelIso", "LE", "LE.le"],
  "name": "OrderIso",
  "constType":
  "(Î± : Type u_6) â†’ (Î² : Type u_7) â†’ [inst : LE Î±] â†’ [inst : LE Î²] â†’ Type (max u_6 u_7)",
  "constCategory": "Definition"},
 {"references": ["IsAntisymm", "IsAntisymm.antisymm", "Eq"],
  "name": "antisymm",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [inst : IsAntisymm Î± r] {a b : Î±}, r a b â†’ r b a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ SemilatticeInf (Î±' i)] (x x_1 : (i : Î¹) â†’ Î±' i) (x_2 : Î¹),\n  x x_2 âŠ“ x_1 x_2 â‰¤ x_1 x_2",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.mk",
   "OrderHom",
   "OrderHomClass.monotone",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "OrderHomClass",
   "RelHomClass.toFunLike"],
  "name": "OrderHomClass.toOrderHom",
  "constType":
  "{F : Type u_1} â†’\n  {Î± : Type u_2} â†’\n    {Î² : Type u_3} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ [inst_2 : OrderHomClass F Î± Î²] â†’ F â†’ Î± â†’o Î²",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Function.Surjective.exists.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} {p : Î² â†’ Prop} (motive : (âˆƒ x, p (f x)) â†’ Prop) (x : âˆƒ x, p (f x)),\n  (âˆ€ (x : Î±) (hx : p (f x)), motive (_ : âˆƒ x, p (f x))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "Exists",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun"],
  "name": "bex_imp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {P : (x : Î±) â†’ p x â†’ Prop} {b : Prop},\n  (âˆƒ x, âˆƒ (h : p x), P x h) â†’ b â†” âˆ€ (x : Î±) (h : p x), P x h â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "IsGLB",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Set.preimage",
   "Inf.inf",
   "Set",
   "Union.union",
   "SemilatticeInf.toPartialOrder",
   "IsGLB.dual",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "IsLUB.union",
   "SemilatticeInf",
   "Set.instUnionSet"],
  "name": "IsGLB.union",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] {aâ‚ aâ‚‚ : Î³} {s t : Set Î³}, IsGLB s aâ‚ â†’ IsGLB t aâ‚‚ â†’ IsGLB (s âˆª t) (aâ‚ âŠ“ aâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["List.Perm.subperm", "List.Perm.refl", "List", "List.Subperm"],
  "name": "List.Subperm.refl",
  "constType": "âˆ€ {Î± : Type uu} (l : List Î±), l <+~ l",
  "constCategory": "Theorem"},
 {"references":
  ["List.Subperm.trans",
   "Multiset.Le",
   "LE.mk",
   "Setoid.r",
   "List",
   "Quot.ind",
   "List.isSetoid",
   "Multiset",
   "LE.le",
   "Quot.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_2",
  "constType": "âˆ€ {Î± : Type u_1} (a b c : Multiset Î±), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.ofLowerSet._cstage1",
  "constType": "{Î± : Type u_1} â†’ Topology.WithLowerSet Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Fintype", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.mk",
  "constType":
  "{Î± : Type u_4} â†’ (elems : Finset Î±) â†’ (âˆ€ (x : Î±), x âˆˆ elems) â†’ Fintype Î±",
  "constCategory": "Other"},
 {"references": [],
  "name": "Order.Coframe",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "disjoint_iff_inf_le",
   "Inf.inf",
   "OrderBot.toBot",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Disjoint.le_bot",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a b : Î±}, Disjoint a b â†’ a âŠ“ b â‰¤ âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["String", "Substring", "String.Pos"],
  "name": "Substring.mk",
  "constType": "String â†’ String.Pos â†’ String.Pos â†’ Substring",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_trans",
  "constType":
  "âˆ€ {Î± : Type u} [self : Preorder Î±] (a b c : Î±), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "congr_arg",
   "List",
   "List.map",
   "mt",
   "List.Pairwise.of_map",
   "Eq"],
  "name": "List.Nodup.of_map",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) {l : List Î±}, List.Nodup (List.map f l) â†’ List.Nodup l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Filter.iInf_sets_eq.match_1",
  "constType":
  "âˆ€ {Î¹ : Sort u_1} (motive : Nonempty Î¹ â†’ Prop) (ne : Nonempty Î¹), (âˆ€ (i : Î¹), motive (_ : Nonempty Î¹)) â†’ motive ne",
  "constCategory": "Definition"},
 {"references": ["GaloisConnection", "Preorder", "GaloisInsertion"],
  "name": "GaloisInsertion.gc",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisInsertion l u â†’ GaloisConnection l u",
  "constCategory": "Definition"},
 {"references":
  ["Filter.Frequently.and_eventually",
   "Exists",
   "funext",
   "Filter.Frequently.exists",
   "False",
   "Filter.Eventually",
   "Mathlib.Order.Filter.Basic._auxLemma.85",
   "Mathlib.Order.Filter.Basic._auxLemma.86",
   "Filter.Frequently",
   "Iff.intro",
   "And",
   "Iff",
   "False.elim",
   "Eq.mp",
   "Filter",
   "Not",
   "congrArg",
   "Eq.trans"],
  "name": "Filter.frequently_iff_forall_eventually_exists_and",
  "constType":
  "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {f : Filter Î±},\n  (âˆƒá¶  (x : Î±) in f, p x) â†” âˆ€ {q : Î± â†’ Prop}, (âˆ€á¶  (x : Î±) in f, q x) â†’ âˆƒ x, p x âˆ§ q x",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.le_of_ble_eq_true.match_1",
  "constType":
  "âˆ€ (motive : (n m : â„•) â†’ Nat.ble n m = true â†’ Prop) (n m : â„•) (h : Nat.ble n m = true),\n  (âˆ€ (x : â„•) (h : Nat.ble 0 x = true), motive 0 x h) â†’\n    (âˆ€ (n n_1 : â„•) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) â†’\n      motive n m h",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["iInf", "Set", "Set.instInfSetSet"],
  "name": "Set.iInter",
  "constType": "{Î² : Type u_2} â†’ {Î¹ : Sort u_4} â†’ (Î¹ â†’ Set Î²) â†’ Set Î²",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Bool.true",
   "Decidable",
   "List.instDecidableMemListInstMembershipList.proof_1",
   "instBEq",
   "Bool",
   "List.elem",
   "instDecidableEqBool",
   "Eq",
   "decidable_of_decidable_of_iff"],
  "name": "List.instDecidableMemListInstMembershipList",
  "constType":
  "{Î± : Type u} â†’ [inst : DecidableEq Î±] â†’ (a : Î±) â†’ (as : List Î±) â†’ Decidable (a âˆˆ as)",
  "constCategory": "Definition"},
 {"references": ["EStateM.Result.ok", "EStateM"],
  "name": "EStateM.pure",
  "constType": "{Îµ Ïƒ Î± : Type u} â†’ Î± â†’ EStateM Îµ Ïƒ Î±",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "HasCompl.compl", "HasCompl.mk"],
  "name": "Pi.hasCompl",
  "constType":
  "{Î¹ : Type u} â†’ {Î± : Î¹ â†’ Type v} â†’ [inst : (i : Î¹) â†’ HasCompl (Î± i)] â†’ HasCompl ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Exists", "propext", "exists_imp", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.48",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, ((âˆƒ x, p x) â†’ b) = âˆ€ (x : Î±), p x â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Nonempty.elim",
   "Iff",
   "exists_const.match_1",
   "Exists.intro",
   "Nonempty"],
  "name": "exists_const",
  "constType": "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆƒ x, b) â†” b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set",
   "Eq.refl",
   "BooleanAlgebra.toHasCompl",
   "True",
   "Eq",
   "_private.Mathlib.Topology.Basic.0.closure._eq_1",
   "Eq.mpr",
   "_private.Mathlib.Topology.Basic.0.interior._eq_1",
   "TopologicalSpace",
   "Set.image",
   "IsOpen",
   "interior",
   "Eq.trans",
   "id",
   "eq_self",
   "funext",
   "setOf",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "And",
   "Mathlib.Topology.Basic._auxLemma.5",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.compl_sUnion",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "Set.compl_image_set_of",
   "Mathlib.Topology.Basic._auxLemma.23",
   "congr",
   "Set.sUnion",
   "IsClosed",
   "Set.sInter",
   "congrArg"],
  "name": "closure_eq_compl_interior_compl",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, closure s = (interior sá¶œ)á¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Lean.ParserDescr.symbol", "Topology.Â«termð“[â‰¤]_Â»._closed_3"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Iff.symm",
   "Iff",
   "Subtype.val",
   "Subtype.forall",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.forall'",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (x : Î±) â†’ p x â†’ Prop},\n  (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : { a // p a }), q â†‘x (_ : p â†‘x)",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.liftâ‚‚",
   "HasEquiv.Equiv",
   "Quotient",
   "Eq"],
  "name": "Quotient.liftOnâ‚‚",
  "constType":
  "{Î± : Sort uA} â†’\n  {Î² : Sort uB} â†’\n    {Ï† : Sort uC} â†’\n      {sâ‚ : Setoid Î±} â†’\n        {sâ‚‚ : Setoid Î²} â†’\n          Quotient sâ‚ â†’\n            Quotient sâ‚‚ â†’\n              (f : Î± â†’ Î² â†’ Ï†) â†’ (âˆ€ (aâ‚ : Î±) (bâ‚ : Î²) (aâ‚‚ : Î±) (bâ‚‚ : Î²), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ f aâ‚ bâ‚ = f aâ‚‚ bâ‚‚) â†’ Ï†",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Subtype.val",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "Subtype.ext.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (motive : (x x_1 : { x // p x }) â†’ â†‘x = â†‘x_1 â†’ Prop) (x x_1 : { x // p x })\n  (x_2 : â†‘x = â†‘x_1),\n  (âˆ€ (val : Î±) (property property_1 : p val),\n      motive { val := val, property := property } { val := val, property := property_1 }\n        (_ : â†‘{ val := val, property := (_ : p val) } = â†‘{ val := val, property := (_ : p val) })) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "HEq",
   "Or.inr",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Or.casesOn",
   "Eq",
   "Or.inl",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "Eq.casesOn",
   "Eq.symm"],
  "name": "List.mem_cons.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} (motive : (b : Î±) â†’ a = b âˆ¨ a âˆˆ l â†’ Prop) (b : Î±) (x : a = b âˆ¨ a âˆˆ l),\n  (Unit â†’ motive a (_ : a = a âˆ¨ a âˆˆ l)) â†’ (âˆ€ (b : Î±) (h : a âˆˆ l), motive b (_ : a = b âˆ¨ a âˆˆ l)) â†’ motive b x",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "Membership.mem",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "List.Sublist",
   "List.Sublist.cons",
   "dite",
   "List.pwFilter_cons_of_neg",
   "Eq",
   "PProd",
   "PProd.fst",
   "List.pwFilter_cons_of_pos",
   "List.rec",
   "List.decidableBAll",
   "List",
   "List.pwFilter_map.match_1",
   "Eq.rec",
   "PUnit",
   "List.Sublist.consâ‚‚",
   "Not",
   "List.pwFilter",
   "List.nil",
   "Eq.symm",
   "DecidableRel"],
  "name": "List.pwFilter_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [inst : DecidableRel R] (l : List Î±), List.Sublist (List.pwFilter R l) l",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.mem_map.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : List Î± â†’ Prop) (x : List Î±),\n  (Unit â†’ motive []) â†’ (âˆ€ (head : Î±) (l : List Î±), motive (head :: l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "Iff",
   "Iff.rfl",
   "Set",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_insert_iff",
  "constType":
  "âˆ€ {Î± : Type u} {x a : Î±} {s : Set Î±}, x âˆˆ insert a s â†” x = a âˆ¨ x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.Perm",
   "List.Perm.refl",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro"],
  "name": "List.Sublist.subperm",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ lâ‚ <+~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["BiheytingAlgebra", "HNot"],
  "name": "BiheytingAlgebra.toHNot",
  "constType": "{Î± : Type u_4} â†’ [self : BiheytingAlgebra Î±] â†’ HNot Î±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : â„•} â†’ (val : â„•) â†’ val < n â†’ Fin n",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (Î± â†’ Î²) â†’ Set Î± â†’ Set Î²",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "And",
   "PartialOrder.toPreorder",
   "And.intro",
   "And.casesOn",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeSup Î±] {a b c : Î±} (motive : a â‰¤ c âˆ§ b â‰¤ c â†’ Prop) (x : a â‰¤ c âˆ§ b â‰¤ c),\n  (âˆ€ (hâ‚ : a â‰¤ c) (hâ‚‚ : b â‰¤ c), motive (_ : a â‰¤ c âˆ§ b â‰¤ c)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Bot", "Top", "Bot.bot", "OrderDual", "Top.mk"],
  "name": "OrderDual.top",
  "constType": "(Î± : Type u) â†’ [inst : Bot Î±] â†’ Top Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "sSup_image",
   "Set",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.image",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sUnion_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Set Î²) (s : Set Î±), â‹ƒâ‚€ (f '' s) = â‹ƒ x âˆˆ s, f x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.toSet",
  "constType": "{Î± : Type u_1} â†’ Finset Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["MonadLift", "semiOutParam"],
  "name": "MonadLift.mk",
  "constType":
  "{m : semiOutParam (Type u â†’ Type v)} â†’ {n : Type u â†’ Type w} â†’ ({Î± : Type u} â†’ m Î± â†’ n Î±) â†’ MonadLift m n",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Â«termI^_Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.cons",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "List",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.rec",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop},\n  motive [] (_ : List.Pairwise R []) â†’\n    (âˆ€ {a : Î±} {l : List Î±} (a_1 : âˆ€ a' âˆˆ l, R a a') (a_2 : List.Pairwise R l),\n        motive l a_2 â†’ motive (a :: l) (_ : List.Pairwise R (a :: l))) â†’\n      âˆ€ {a : List Î±} (t : List.Pairwise R a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "FunLike.coe",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "inf_eq_left",
   "Eq.mpr",
   "InfHomClass.map_inf",
   "Eq.ndrec",
   "propext",
   "InfHomClass.toFunLike",
   "Eq.symm",
   "SemilatticeInf",
   "InfHomClass",
   "id"],
  "name": "InfHomClass.toOrderHomClass.proof_1",
  "constType":
  "âˆ€ {F : Type u_3} {Î± : Type u_1} {Î² : Type u_2} [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²]\n  [inst_2 : InfHomClass F Î± Î²] (f : F) (a b : Î±), a â‰¤ b â†’ â†‘f a â‰¤ â†‘f b",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{Î± : Type u} â†’ [self : SemilatticeSup Î±] â†’ Sup Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Subtype.mk",
   "Subtype",
   "Set.instMembershipSet"],
  "name": "Subtype.coe_image.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {s : Set (Subtype p)} (a : Î±)\n  (motive : a âˆˆ {x | âˆƒ (h : p x), { val := x, property := h } âˆˆ s} â†’ Prop)\n  (x : a âˆˆ {x | âˆƒ (h : p x), { val := x, property := h } âˆˆ s}),\n  (âˆ€ (ha : p a) (in_s : { val := a, property := ha } âˆˆ s), motive (_ : âˆƒ (h : p a), { val := a, property := h } âˆˆ s)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.toLattice",
   "Order.Coframe",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Order.Coframe.mk",
  "constType":
  "{Î± : Type u_1} â†’\n  [toCompleteLattice : CompleteLattice Î±] â†’ (âˆ€ (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s) â†’ Order.Coframe Î±",
  "constCategory": "Other"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray3",
  "constType": "{Î± : Type u} â†’ Î± â†’ Î± â†’ Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.preimage",
   "Function.comp",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq"],
  "name": "induced_compose.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_2} [tÎ³ : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} (x : Set Î±)\n  (motive : IsOpen x â†’ Prop) (x_1 : IsOpen x),\n  (âˆ€ (s : Set Î³) (hs : IsOpen s) (h : g âˆ˜ f â»Â¹' s = x), motive (_ : âˆƒ s', IsOpen s' âˆ§ g âˆ˜ f â»Â¹' s' = x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray6",
  "constType": "{Î± : Type u} â†’ Î± â†’ Î± â†’ Î± â†’ Î± â†’ Î± â†’ Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "true_and",
   "And",
   "eq_true",
   "Iff",
   "and_congr_right",
   "Eq.mp",
   "congr",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun"],
  "name": "and_congr_right_iff",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†” a âˆ§ c) â†” a â†’ (b â†” c)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Macro.State.macroScope",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Macro.State.traceMsgs",
   "Lean.Macro.Context.mk",
   "Lean.MacroM",
   "HAdd.hAdd",
   "EStateM.instMonadStateOfEStateM",
   "Monad.toBind",
   "instMonadWithReaderOfReaderT",
   "Lean.Macro.State",
   "MonadState.modifyGet",
   "Lean.Macro.Exception",
   "ReaderT.instMonadLiftReaderT",
   "instOfNatNat",
   "Bind.bind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "instAddNat",
   "instHAdd",
   "Lean.Macro.Context.ref",
   "instMonadStateOf",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.Macro.Context.methods",
   "instMonadState",
   "instMonadWithReader",
   "Prod.mk",
   "Lean.Macro.Context.mainModule",
   "Lean.Macro.Context.maxRecDepth",
   "Lean.Macro.Context.currRecDepth",
   "Lean.Macro.State.mk",
   "MonadWithReader.withReader"],
  "name": "Lean.Macro.withFreshMacroScope",
  "constType": "{Î± : Type} â†’ Lean.MacroM Î± â†’ Lean.MacroM Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.subset_empty_iff",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.21",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (s âŠ† âˆ…) = (s = âˆ…)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î± : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (x : (i : Î¹) â†’ Î± i) (x_1 : Î¹),\n  x x_1 âŠ“ (x x_1)á¶œ â‰¤ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["List.mem_map.match_1",
   "List.cons",
   "List.append",
   "List.brecOn",
   "List.below",
   "List.cons_sublist_cons",
   "Iff.rfl",
   "Unit",
   "List.Sublist",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "Iff",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "Iff.trans",
   "List.nil"],
  "name": "List.append_sublist_append_left",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (l : List Î±), List.Sublist (l ++ lâ‚) (l ++ lâ‚‚) â†” List.Sublist lâ‚ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "dite",
   "List.Perm.swap",
   "True",
   "Eq",
   "ite",
   "Eq.mpr",
   "true_or",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "or_self",
   "Membership.mem",
   "eq_self",
   "Mathlib.Data.List.Perm._auxLemma.2",
   "List.cons",
   "Or",
   "List.insert",
   "False",
   "Ne.symm",
   "or_true",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "ite_congr",
   "instDecidableFalse",
   "eq_true",
   "eq_false",
   "List.Perm",
   "of_eq_true",
   "DecidableEq",
   "List.insert_of_not_mem",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "congr",
   "Not",
   "List.insert_of_mem",
   "congrArg",
   "congrFun"],
  "name": "List.perm_insert_swap",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] (x y : Î±) (l : List Î±),\n  List.insert x (List.insert y l) ~ List.insert y (List.insert x l)",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Max Î±",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkSimple",
  "constType": "String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Prop.heytingAlgebra",
   "Top.top",
   "GeneralizedHeytingAlgebra.toHImp",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "DistribLattice.mk",
   "HeytingAlgebra.bot_le",
   "Classical.em",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "BooleanAlgebra.mk",
   "Prop.booleanAlgebra.proof_4",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "DistribLattice",
   "SDiff.mk",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Prop.booleanAlgebra.proof_3",
   "Not",
   "Prop.booleanAlgebra.proof_1",
   "Prop.booleanAlgebra.proof_2"],
  "name": "Prop.booleanAlgebra",
  "constType": "BooleanAlgebra Prop",
  "constCategory": "Definition"},
 {"references":
  ["RelHomClass.map_rel",
   "Monotone",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "OrderHomClass",
   "RelHomClass.toFunLike"],
  "name": "OrderHomClass.mono",
  "constType":
  "âˆ€ {F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : OrderHomClass F Î± Î²]\n  (f : F), Monotone â†‘f",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false", "Lean.SourceInfo", "Bool", "optParam", "String.Pos"],
  "name": "Lean.SourceInfo.synthetic",
  "constType":
  "String.Pos â†’ String.Pos â†’ optParam Bool false â†’ Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ CompleteSemilatticeInf Î±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.sub_zero",
  "constType": "âˆ€ (n : â„•), n - 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "ite",
   "Eq"],
  "name": "if_pos",
  "constType":
  "âˆ€ {c : Prop} {h : Decidable c}, c â†’ âˆ€ {Î± : Sort u} {t e : Î±}, (if c then t else e) = t",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "LowerSet",
  "constType": "(Î± : Type u_6) â†’ [inst : LE Î±] â†’ Type u_6",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop", "Top.top", "le_top", "OrderTop", "LE", "LE.le"],
  "name": "Pi.orderTop.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ LE (Î±' i)] [inst_1 : (i : Î¹) â†’ OrderTop (Î±' i)]\n  (x : (i : Î¹) â†’ Î±' i) (x_1 : Î¹), x x_1 â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Finset.map.proof_1",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.val",
   "Function.Embedding",
   "FunLike.coe",
   "Finset.mk"],
  "name": "Finset.map",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (Î± â†ª Î²) â†’ Finset Î± â†’ Finset Î²",
  "constCategory": "Definition"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "EmbeddingLike.toFunLike",
   "And",
   "Exists",
   "Function.instEmbeddingLikeEmbedding",
   "propext",
   "Finset",
   "Finset.mem_map",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†ª Î²} {s : Finset Î±} {b : Î²}, (b âˆˆ Finset.map f s) = âˆƒ a âˆˆ s, â†‘f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "OrderDual",
   "Sup.sup",
   "OrderDual.semilatticeSup",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_1",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Lattice Î±] (a b : Î±áµ’áµˆ), a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "TopologicalSpace.GenerateOpen.rec",
   "setOf",
   "IsLowerSet",
   "isLowerSet_sUnion",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Exists.casesOn",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsLowerSet.inter",
   "Preorder.toLE",
   "Topology.IsLower.isOpen_iff_generate_Ici_compl",
   "Set.instMembershipSet",
   "Eq",
   "isLowerSet_univ",
   "Iff.mp",
   "Eq.ndrec",
   "isUpperSet_Ici",
   "Topology.IsLower",
   "TopologicalSpace",
   "IsOpen",
   "IsUpperSet.compl"],
  "name": "Topology.IsLower.isLowerSet_of_isOpen",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±] {s : Set Î±},\n  IsOpen s â†’ IsLowerSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.SourceInfo.original",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "Substring",
   "String.Pos"],
  "name": "Lean.SourceInfo.rec",
  "constType":
  "{motive : Lean.SourceInfo â†’ Sort u} â†’\n  ((leading : Substring) â†’\n      (pos : String.Pos) â†’\n        (trailing : Substring) â†’\n          (endPos : String.Pos) â†’ motive (Lean.SourceInfo.original leading pos trailing endPos)) â†’\n    ((pos endPos : String.Pos) â†’ (canonical : Bool) â†’ motive (Lean.SourceInfo.synthetic pos endPos canonical)) â†’\n      motive Lean.SourceInfo.none â†’ (t : Lean.SourceInfo) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "propext",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "Eq.symm",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.6",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : GeneralizedHeytingAlgebra Î±] (a b c : Î±), (a âŠ“ b â‰¤ c) = (a â‰¤ b â‡¨ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Char.val",
   "Char.mk",
   "UInt32",
   "Char",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Char.casesOn",
   "Eq.symm",
   "UInt32.isValidChar",
   "Eq"],
  "name": "Char.eq_of_val_eq.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : Char) â†’ x.val = x_1.val â†’ Prop) (x x_1 : Char) (x_2 : x.val = x_1.val),\n  (âˆ€ (val : UInt32) (valid valid_1 : UInt32.isValidChar val),\n      motive { val := val, valid := valid } { val := val, valid := valid_1 }\n        (_ :\n          { val := val, valid := (_ : UInt32.isValidChar val) }.val =\n            { val := val, valid := (_ : UInt32.isValidChar val) }.val)) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Eq",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.toUpper_ofUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Topology.WithUpper Î±), â†‘Topology.WithUpper.toUpper (â†‘Topology.WithUpper.ofUpper a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Continuous.tendsto.match_1",
   "Exists",
   "Filter.HasBasis.tendsto_iff",
   "Set.preimage",
   "nhds",
   "Set",
   "Exists.intro",
   "Set.Subset.rfl",
   "Iff.mpr",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "And",
   "Continuous",
   "TopologicalSpace",
   "Filter.Tendsto",
   "And.intro",
   "IsOpen.preimage",
   "IsOpen"],
  "name": "Continuous.tendsto",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ âˆ€ (x : Î±), Filter.Tendsto f (nhds x) (nhds (f x))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Filter.HasBasis.mem_iff",
   "Iff.mpr",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_of_superset",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {t : Set Î±} {i : Î¹},\n  Filter.HasBasis l p s â†’ p i â†’ s i âŠ† t â†’ t âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubsetSet",
   "propext",
   "Set",
   "Set.Iic_subset_Iic",
   "HasSubset.Subset",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.4",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, (Set.Iic a âŠ† Set.Iic b) = (a â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteDistribLattice",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references": ["List.cons", "List.Perm", "List", "List.casesOn", "List.nil"],
  "name": "List.Perm.append_left.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {tâ‚ tâ‚‚ : List Î±} (motive : List Î± â†’ tâ‚ ~ tâ‚‚ â†’ Prop) (x : List Î±) (x_1 : tâ‚ ~ tâ‚‚),\n  (âˆ€ (p : tâ‚ ~ tâ‚‚), motive [] p) â†’ (âˆ€ (x : Î±) (xs : List Î±) (p : tâ‚ ~ tâ‚‚), motive (x :: xs) p) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm",
   "List",
   "List.Subperm",
   "List.Subperm.length_le",
   "List.Subperm.perm_of_length_le"],
  "name": "List.Subperm.antisymm",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <+~ lâ‚‚ â†’ lâ‚‚ <+~ lâ‚ â†’ lâ‚ ~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.rec._cstage1",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Topology.WithUpper Î± â†’ Sort u_1} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithUpper.toUpper a)) â†’ (a : Topology.WithUpper Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "Nat.pow.match_1", "Unit", "instOfNatNat", "Nat"],
  "name": "Nat.pred",
  "constType": "â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE â„•",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "eq_false",
   "False",
   "List.instMembershipList",
   "List",
   "List.not_mem_nil",
   "List.nil",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.1",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), (a âˆˆ []) = False",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "instSubsingletonForAll.proof_1"],
  "name": "instSubsingletonForAll",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} [inst : âˆ€ (a : Î±), Subsingleton (Î² a)], Subsingleton ((a : Î±) â†’ Î² a)",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} â†’ (â„• â†’ R) â†’ NatCast R",
  "constCategory": "Other"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List"],
  "name": "List.Pairwise.cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±},\n  (âˆ€ a' âˆˆ l, R a a') â†’ List.Pairwise R l â†’ List.Pairwise R (a :: l)",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "of_decide_eq_self_eq_true.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (a : Î±) (motive : Decidable (a = a) â†’ Prop) (x : Decidable (a = a)),\n  (âˆ€ (h : a = a), motive (isTrue h)) â†’ (âˆ€ (hâ‚ : Â¬a = a), motive (isFalse hâ‚)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], decide p = true â†’ p",
  "constCategory": "Theorem"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.prf",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {coe : outParam (Î² â†’ Î±)} {cond : outParam (Î± â†’ Prop)} [self : CanLift Î± Î² coe cond]\n  (x : Î±), cond x â†’ âˆƒ y, coe y = x",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "Prod.orderBot.proof_1",
   "Bot.bot",
   "OrderBot.toBot",
   "Bot.mk",
   "Prod.instLEProd",
   "inferInstanceAs",
   "LE",
   "Prod",
   "OrderBot.mk",
   "OrderBot",
   "Prod.bot"],
  "name": "Prod.orderBot",
  "constType":
  "(Î± : Type u) â†’\n  (Î² : Type v) â†’ [inst : LE Î±] â†’ [inst_1 : LE Î²] â†’ [inst_2 : OrderBot Î±] â†’ [inst_3 : OrderBot Î²] â†’ OrderBot (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a = b â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsLowerSet.rec",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.mk",
   "Eq"],
  "name": "Topology.IsLowerSet.recOn",
  "constType":
  "{Î± : Type u_4} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsLowerSet Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsLowerSet Î±) â†’\n          ((topology_eq_lowerSetTopology : t = Topology.lowerSet Î±) â†’ motive (_ : Topology.IsLowerSet Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references": ["List.Pairwise", "List.nil"],
  "name": "List.Pairwise.nil",
  "constType": "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R []",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Setoid.r",
   "OfNat.ofNat",
   "List.rec",
   "List",
   "Quot.ind",
   "Multiset.instZeroMultiset",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons",
   "Quot.mk"],
  "name": "Multiset.induction",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Multiset Î± â†’ Prop},\n  p 0 â†’ (âˆ€ â¦ƒa : Î±â¦„ {s : Multiset Î±}, p s â†’ p (a ::â‚˜ s)) â†’ âˆ€ (s : Multiset Î±), p s",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.foldl_eq_foldr.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : Î± â†’ List Î± â†’ Prop) (x : Î±) (x_1 : List Î±),\n  (âˆ€ (a : Î±), motive a []) â†’ (âˆ€ (a b : Î±) (l : List Î±), motive a (b :: l)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "Not", "HasCompl.mk"],
  "name": "Prop.hasCompl",
  "constType": "HasCompl Prop",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "And",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Multiset.nodup_cons",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Not",
   "And.intro",
   "Multiset.instMembershipMultiset",
   "Iff.mpr"],
  "name": "Finset.cons.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (s : Finset Î±), Â¬a âˆˆ s â†’ Multiset.Nodup (a ::â‚˜ s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["BiheytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HNot",
   "HNot.hnot",
   "SDiff.sdiff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Iff",
   "SemilatticeSup.toSup",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "SemilatticeSup.toPartialOrder"],
  "name": "BiheytingAlgebra.mk",
  "constType":
  "{Î± : Type u_4} â†’\n  [toHeytingAlgebra : HeytingAlgebra Î±] â†’\n    [toSDiff : SDiff Î±] â†’\n      [toHNot : HNot Î±] â†’ (âˆ€ (a b c : Î±), a \\ b â‰¤ c â†” a â‰¤ b âŠ” c) â†’ (âˆ€ (a : Î±), âŠ¤ \\ a = ï¿¢a) â†’ BiheytingAlgebra Î±",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Iff"],
  "name": "forall_comm",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {p : Î± â†’ Î² â†’ Prop}, (âˆ€ (a : Î±) (b : Î²), p a b) â†” âˆ€ (b : Î²) (a : Î±), p a b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Std.Logic._auxLemma.54",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "Std.Logic._auxLemma.35",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "forall_apply_eq_imp_iff",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆ€ (b : Î²) (a : Î±), f a = b â†’ p b) â†” âˆ€ (a : Î±), p (f a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Equivalence",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (_a : Î±) (motive : _a â‰¤ _a âˆ§ Â¬_a â‰¤ _a â†’ Prop) (x : _a â‰¤ _a âˆ§ Â¬_a â‰¤ _a),\n  (âˆ€ (h1 : _a â‰¤ _a) (h2 : Â¬_a â‰¤ _a), motive (_ : _a â‰¤ _a âˆ§ Â¬_a â‰¤ _a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["propext", "forall_apply_eq_imp_iffâ‚‚", "Eq"],
  "name": "Std.Logic._auxLemma.57",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  (âˆ€ (b : Î²) (a : Î±), p a â†’ f a = b â†’ q b) = âˆ€ (a : Î±), p a â†’ q (f a)",
  "constCategory": "Theorem"},
 {"references": ["OrderedCancelAddCommMonoid", "PartialOrder"],
  "name": "OrderedCancelAddCommMonoid.toPartialOrder",
  "constType":
  "{Î± : Type u} â†’ [self : OrderedCancelAddCommMonoid Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Set.forall_range_iff",
   "Set.instMembershipSet"],
  "name": "Set.range_subset_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {s : Set Î±}, Set.range f âŠ† s â†” âˆ€ (y : Î¹), f y âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsLowerSet",
  "constType":
  "(Î± : Type u_4) â†’ [t : TopologicalSpace Î±] â†’ [inst : Preorder Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.indexOf_get",
   "List.nodup_iff_injective_get",
   "List.indexOf_lt_length",
   "Fin.val",
   "List.instMembershipList",
   "instBEq",
   "List.indexOf",
   "List.length",
   "instLTNat",
   "True",
   "Iff.mpr",
   "Eq",
   "Fin.veq_of_eq",
   "Iff.mp",
   "List.Nodup",
   "of_eq_true",
   "Function.Injective",
   "DecidableEq",
   "List",
   "LT.lt",
   "List.get_mem",
   "List.get",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "congrFun"],
  "name": "List.get_indexOf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {l : List Î±},\n  List.Nodup l â†’ âˆ€ (i : Fin (List.length l)), List.indexOf (List.get l i) l = â†‘i",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.topology_eq_upperTopology",
   "OrderDual.instPreorder",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "Topology.IsLower.mk"],
  "name": "OrderDual.instIsLower.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±], Topology.IsLower Î±áµ’áµˆ",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.symm", "Eq"],
  "name": "eq_comm",
  "constType": "âˆ€ {Î± : Sort u_1} {a b : Î±}, a = b â†” b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) â†’ Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.27",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (s = Set.univ) = âˆ€ (x : Î±), x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.iInf_iSup_eq",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompletelyDistribLattice Î±] {Î¹ : Type u} {Îº : Î¹ â†’ Type u} (f : (a : Î¹) â†’ Îº a â†’ Î±),\n  â¨… a, â¨† b, f a b = â¨† g, â¨… a, f a (g a)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.not_mem_zero",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.16",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), (a âˆˆ 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.instClosedIicTopology.proof_1",
   "ClosedIicTopology",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder"],
  "name": "Topology.IsUpper.instClosedIicTopology",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±], ClosedIicTopology Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise", "List.pairwise_map", "propext", "List", "List.map", "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.18",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î±_1 : Type u_2} {f : Î± â†’ Î±_1} {R : Î±_1 â†’ Î±_1 â†’ Prop} {l : List Î±},\n  List.Pairwise R (List.map f l) = List.Pairwise (fun a b â†¦ R (f a) (f b)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Lean.SourceInfo.fromRef.match_2",
   "Lean.Syntax.getTailPos?",
   "Lean.SourceInfo.fromRef.match_1",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "optParam",
   "Lean.Syntax",
   "Lean.Syntax.getPos?",
   "String.Pos",
   "Option"],
  "name": "Lean.SourceInfo.fromRef",
  "constType": "Lean.Syntax â†’ optParam Bool false â†’ Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.cons",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.range.loop.match_1",
   "Nat",
   "Nat.succ"],
  "name": "List.range.loop",
  "constType": "â„• â†’ List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Mathlib.Topology.Order._auxLemma.26",
   "Function.comp",
   "induced_compose",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Iff",
   "of_eq_true",
   "Continuous",
   "TopologicalSpace",
   "congr",
   "TopologicalSpace.induced",
   "congrArg",
   "Eq.trans"],
  "name": "continuous_induced_rng",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} {f : Î± â†’ Î²} {g : Î³ â†’ Î±} {tâ‚‚ : TopologicalSpace Î²} {tâ‚ : TopologicalSpace Î³},\n  Continuous g â†” Continuous (f âˆ˜ g)",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "funext",
   "Eq.ndrec",
   "Iff",
   "propext",
   "Eq.rec",
   "Eq.refl",
   "iSup",
   "Iff.mpr",
   "Eq"],
  "name": "iSup_congr_Prop",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SupSet Î±] {p q : Prop} {fâ‚ : p â†’ Î±} {fâ‚‚ : q â†’ Î±} (pq : p â†” q),\n  (âˆ€ (x : q), fâ‚ (_ : p) = fâ‚‚ x) â†’ iSup fâ‚ = iSup fâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“Ë¢Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.exists_erase_eq",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "instBEq",
   "List.erase",
   "Eq",
   "And",
   "instHAppend",
   "List.instAppendList",
   "List.Perm",
   "DecidableEq",
   "List",
   "HAppend.hAppend",
   "Eq.rec",
   "List.perm_middle",
   "Not",
   "List.perm_cons_erase.match_1",
   "Eq.symm"],
  "name": "List.perm_cons_erase",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, a âˆˆ l â†’ l ~ a :: List.erase l a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "setOf",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Topology.IsLower.topology_eq",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Topology.IsLower",
   "Topology.lower",
   "TopologicalSpace",
   "IsOpen",
   "id"],
  "name": "Topology.IsLower.isOpen_iff_generate_Ici_compl",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±] {s : Set Î±},\n  IsOpen s â†” TopologicalSpace.GenerateOpen {t | âˆƒ a, (Set.Ici a)á¶œ = t} s",
  "constCategory": "Theorem"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{Î± : Type u} â†’ [self : Preorder Î±] â†’ LE Î±",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "AlexandrovDiscrete",
  "constType": "(Î± : Type u_1) â†’ [inst : TopologicalSpace Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.symm",
   "Equivalence.mk",
   "List.Perm",
   "List.Perm.refl",
   "Equivalence",
   "List",
   "List.Perm.trans"],
  "name": "List.Perm.eqv",
  "constType": "âˆ€ (Î± : Type u_1), Equivalence List.Perm",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Topology.WithLowerSet.toLowerSet_le_iff",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Topology.WithLowerSet.toLowerSetOrderIso",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â‰ƒo Topology.WithLowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Or",
   "Iff",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "forall_and",
   "Set.instUnionSet",
   "or_imp",
   "forall_congr'",
   "Set.instMembershipSet"],
  "name": "Set.union_subset_iff",
  "constType": "âˆ€ {Î± : Type u} {s t u : Set Î±}, s âˆª t âŠ† u â†” s âŠ† u âˆ§ t âŠ† u",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "compl_anti",
   "HeytingAlgebra.toHasCompl",
   "LE.le",
   "Preorder.toLE"],
  "name": "compl_le_compl",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, a â‰¤ b â†’ bá¶œ â‰¤ aá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "And.right",
   "PartialOrder.toPreorder",
   "Set",
   "IsGreatest",
   "And.left",
   "le_antisymm",
   "Eq",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "IsGreatest.unique",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {s : Set Î±} {a b : Î±}, IsGreatest s a â†’ IsGreatest s b â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl.compl",
   "himp_eq",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "bot_sup_eq",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder.toOrderBot"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_2",
  "constType": "âˆ€ {Î± : Type u_1} [inst : BooleanAlgebra Î±] (x : Î±), x â‡¨ âŠ¥ = xá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Filter.inter_mem",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.map.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (m : Î± â†’ Î²) (f : Filter Î±) {x y : Set Î²},\n  x âˆˆ Set.preimage m â»Â¹' f.sets â†’ y âˆˆ Set.preimage m â»Â¹' f.sets â†’ ((fun x_1 â†¦ x (m x_1)) âˆ© fun x â†¦ y (m x)) âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred", "Option.none", "Option.some", "Option", "ite"],
  "name": "Option.guard",
  "constType":
  "{Î± : Type u_1} â†’ (p : Î± â†’ Prop) â†’ [inst : DecidablePred p] â†’ Î± â†’ Option Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Fin.val",
   "HAdd.hAdd",
   "Std.Data.Fin.Lemmas._auxLemma.14",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "Fin.val_succ",
   "instLTFin",
   "instLTNat",
   "True",
   "Std.Data.Fin.Lemmas._auxLemma.13",
   "of_eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Fin.succ",
   "Nat.succ",
   "Eq.trans",
   "Fin"],
  "name": "Fin.succ_pos",
  "constType": "âˆ€ {n : â„•} (a : Fin n), 0 < Fin.succ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set",
   "Filter",
   "Iff.mpr",
   "Filter.ext_iff",
   "instMembershipSetFilter",
   "Eq"],
  "name": "Filter.ext",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±}, (âˆ€ (s : Set Î±), s âˆˆ f â†” s âˆˆ g) â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ DecidableRel fun x x_1 â†¦ x < x_1",
  "constCategory": "Definition"},
 {"references": ["panicCore", "Inhabited", "String"],
  "name": "panic",
  "constType": "{Î± : Type u} â†’ [inst : Inhabited Î±] â†’ String â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.upperSet",
   "Topology.instIsUpperSetUpperSet.proof_1",
   "Preorder"],
  "name": "Topology.instIsUpperSetUpperSet",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsUpperSet Î±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.not_succ_le_self", "Not", "Nat", "instLTNat"],
  "name": "Nat.lt_irrefl",
  "constType": "âˆ€ (n : â„•), Â¬n < n",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Elem",
   "Union.union",
   "Set",
   "Finite",
   "Finite.Set.finite_union.proof_1",
   "Set.instUnionSet"],
  "name": "Finite.Set.finite_union",
  "constType":
  "âˆ€ {Î± : Type u} (s t : Set Î±) [inst : Finite â†‘s] [inst : Finite â†‘t], Finite â†‘(s âˆª t)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "BEq.beq",
   "Iff",
   "Eq.ndrec",
   "BEq",
   "LawfulBEq.rfl",
   "Bool.true",
   "LawfulBEq",
   "LawfulBEq.eq_of_beq",
   "Bool",
   "Eq"],
  "name": "beq_iff_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] (a b : Î±), (a == b) = true â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "TopologicalSpace",
   "ContinuousMap",
   "id",
   "ContinuousMap.mk"],
  "name": "ContinuousMap.id",
  "constType": "(Î± : Type u_1) â†’ [inst : TopologicalSpace Î±] â†’ C(Î±, Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Iff.intro",
   "And",
   "And.right",
   "Iff",
   "SProd.sprod",
   "Set",
   "Set.Nonempty.prod",
   "Set.Nonempty",
   "Prod",
   "And.intro",
   "And.left",
   "Set.Nonempty.fst",
   "Set.Nonempty.snd"],
  "name": "Set.prod_nonempty_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, Set.Nonempty (s Ã—Ë¢ t) â†” Set.Nonempty s âˆ§ Set.Nonempty t",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "And",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "Nat.div.inductionOn",
   "LT.lt",
   "HSub.hSub",
   "Not",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod.inductionOn",
  "constType":
  "{motive : â„• â†’ â„• â†’ Sort u} â†’\n  (x y : â„•) â†’\n    ((x y : â„•) â†’ 0 < y âˆ§ y â‰¤ x â†’ motive (x - y) y â†’ motive x y) â†’\n      ((x y : â„•) â†’ Â¬(0 < y âˆ§ y â‰¤ x) â†’ motive x y) â†’ motive x y",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.Nodup",
   "Multiset.Nodup.proof_1",
   "List",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Nodup",
  "constType": "{Î± : Type u_1} â†’ Multiset Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "Mathlib.Order.Lattice._auxLemma.2",
   "and_true",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Iff.trans",
   "Mathlib.Order.Lattice._auxLemma.3",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "le_antisymm_iff",
   "congrFun"],
  "name": "sup_of_le_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ b â†’ a âŠ” b = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Seq",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references": ["PProd", "PProd.mk"],
  "name": "PProd.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {Î² : Sort v} â†’\n    {motive : PProd Î± Î² â†’ Sort u_1} â†’\n      ((fst : Î±) â†’ (snd : Î²) â†’ motive { fst := fst, snd := snd }) â†’ (t : PProd Î± Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Finset.cons.proof_1",
   "Finset.instMembershipFinset",
   "Not",
   "Finset.mk"],
  "name": "Finset.cons",
  "constType": "{Î± : Type u_1} â†’ (a : Î±) â†’ (s : Finset Î±) â†’ Â¬a âˆˆ s â†’ Finset Î±",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.decEq.match_1",
   "Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Decidable",
   "Decidable.isTrue",
   "Bool",
   "rfl",
   "Eq"],
  "name": "Bool.decEq",
  "constType": "(a b : Bool) â†’ Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "Eq.refl",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "isOpen_iff_mem_nhds",
   "instMembershipSetFilter",
   "id"],
  "name": "le_of_nhds_le_nhds",
  "constType":
  "âˆ€ {Î± : Type u_1} {tâ‚ tâ‚‚ : TopologicalSpace Î±}, (âˆ€ (x : Î±), nhds x â‰¤ nhds x) â†’ tâ‚ â‰¤ tâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsRightCancelAdd",
  "constType": "(G : Type u) â†’ [inst : Add G] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["CoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Top.top",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "CoheytingAlgebra.toHNot",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq"],
  "name": "CoheytingAlgebra.top_sdiff",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : CoheytingAlgebra Î±] (a : Î±), âŠ¤ \\ a = ï¿¢a",
  "constCategory": "Definition"},
 {"references":
  ["Char",
   "Decidable.isFalse",
   "List",
   "instDecidableEqList",
   "String.mk",
   "String",
   "Decidable",
   "String.decEq.match_1",
   "Not",
   "Decidable.isTrue",
   "dite",
   "String.decEq.proof_2",
   "String.decEq.proof_1",
   "instDecidableEqChar",
   "Eq"],
  "name": "String.decEq",
  "constType": "(sâ‚ sâ‚‚ : String) â†’ Decidable (sâ‚ = sâ‚‚)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Trunc.out",
   "Classical.decEq",
   "Fintype",
   "Fintype.truncEquivFin",
   "Fintype.card",
   "Fin"],
  "name": "Fintype.equivFin",
  "constType": "(Î± : Type u_4) â†’ [inst : Fintype Î±] â†’ Î± â‰ƒ Fin (Fintype.card Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Function.comp",
   "TopologicalSpace",
   "FunLike.coe",
   "ContinuousMap",
   "ContinuousMap.toContinuousMapClass",
   "ContinuousMap.comp.proof_1",
   "ContinuousMapClass.toFunLike",
   "ContinuousMap.mk"],
  "name": "ContinuousMap.comp",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {Î³ : Type u_3} â†’\n      [inst : TopologicalSpace Î±] â†’\n        [inst_1 : TopologicalSpace Î²] â†’ [inst_2 : TopologicalSpace Î³] â†’ C(Î², Î³) â†’ C(Î±, Î²) â†’ C(Î±, Î³)",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Prelude.0.Lean.Macro.MethodsRefPointed", "NonemptyType.type"],
  "name": "_private.Init.Prelude.0.Lean.Macro.MethodsRef",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["cond.match_1",
   "Lean.Name.mkStr",
   "List.cons",
   "Lean.Name.instBEqName",
   "Lean.MacroScopesView",
   "Unit",
   "Lean.MacroScopesView.review",
   "Lean.Name.hasMacroScopes",
   "Lean.MacroScopesView.mainModule",
   "Lean.MacroScopesView.name",
   "List.foldl",
   "Lean.MacroScope",
   "BEq.beq",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.mk",
   "List.nil",
   "Bool",
   "Lean.MacroScopesView.imported",
   "Lean.Name.appendCore",
   "Lean.Name",
   "Lean.extractMacroScopes",
   "Nat",
   "Lean.MacroScopesView.scopes"],
  "name": "Lean.addMacroScope",
  "constType": "Lean.Name â†’ Lean.Name â†’ Lean.MacroScope â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.subperm_left.match_1",
   "List.Subperm.trans",
   "Exists",
   "List.cons",
   "List.Sublist.casesOn",
   "HEq",
   "eq_of_heq",
   "List.Subperm",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "Exists.intro",
   "List.Sublist.slnil",
   "List.Perm.cons",
   "Iff.mpr",
   "List.sublist_cons",
   "Eq",
   "Iff.intro",
   "List.Perm.cons_inv",
   "Iff",
   "List.Perm",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.consâ‚‚",
   "List.subperm_cons.match_1",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Sublist.subperm",
   "List.Perm.subperm_left"],
  "name": "List.subperm_cons",
  "constType":
  "âˆ€ {Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : List Î±}, a :: lâ‚ <+~ a :: lâ‚‚ â†” lâ‚ <+~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Subtype.mk",
   "Subtype",
   "Nonempty",
   "Subtype.casesOn",
   "Nonempty.casesOn"],
  "name": "nonempty_subtype.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (motive : Nonempty (Subtype p) â†’ Prop) (x : Nonempty (Subtype p)),\n  (âˆ€ (a : Î±) (h : p a), motive (_ : Nonempty (Subtype p))) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral", "Topology.WithLowerSet.map._rarg"],
  "name": "Topology.WithLowerSet.map._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadExcept"],
  "name": "MonadExcept.mk",
  "constType":
  "{Îµ : outParam (Type u)} â†’\n  {m : Type v â†’ Type w} â†’ ({Î± : Type v} â†’ Îµ â†’ m Î±) â†’ ({Î± : Type v} â†’ m Î± â†’ (Îµ â†’ m Î±) â†’ m Î±) â†’ MonadExcept Îµ m",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.str"],
  "name": "Lean.Name.mkStr",
  "constType": "Lean.Name â†’ String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_left",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Not", "absurd"],
  "name": "Not.elim",
  "constType": "{a : Prop} â†’ {Î± : Sort u_1} â†’ Â¬a â†’ a â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Fintype.finite", "Fintype", "Finite"],
  "name": "Finite.of_fintype",
  "constType": "âˆ€ (Î± : Type u_4) [inst : Fintype Î±], Finite Î±",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} â†’ [toAddSemigroup : AddSemigroup G] â†’ (âˆ€ (a b : G), a + b = b + a) â†’ AddCommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "EmptyCollection.emptyCollection",
   "False",
   "false_and",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Std.Logic._auxLemma.32",
   "Set.instEmptyCollectionSet",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_empty",
  "constType": "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²), f '' âˆ… = âˆ…",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "forall_and.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} (motive : ((âˆ€ (x : Î±), p x) âˆ§ âˆ€ (x : Î±), q x) â†’ Prop)\n  (x : (âˆ€ (x : Î±), p x) âˆ§ âˆ€ (x : Î±), q x),\n  (âˆ€ (hâ‚ : âˆ€ (x : Î±), p x) (hâ‚‚ : âˆ€ (x : Î±), q x), motive (_ : (âˆ€ (x : Î±), p x) âˆ§ âˆ€ (x : Î±), q x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["List.Perm", "List"],
  "name": "List.Perm.trans",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ lâ‚ƒ : List Î±}, lâ‚ ~ lâ‚‚ â†’ lâ‚‚ ~ lâ‚ƒ â†’ lâ‚ ~ lâ‚ƒ",
  "constCategory": "Other"},
 {"references":
  ["Equiv", "Equiv.refl.proof_1", "Equiv.refl.proof_2", "Equiv.mk", "id"],
  "name": "Equiv.refl",
  "constType": "(Î± : Sort u_1) â†’ Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "propext",
   "inseparable_iff_closure_eq",
   "Set",
   "TopologicalSpace",
   "Singleton.singleton",
   "Inseparable",
   "Eq"],
  "name": "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.2",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y = (closure {x} = closure {y})",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "eq_comm",
   "LE.le.le_iff_eq",
   "le_top",
   "OrderTop",
   "Iff.trans",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "top_le_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] {a : Î±}, âŠ¤ â‰¤ a â†” a = âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ StrictOrderedCommSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Set",
   "Set.instSupSetSet",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)) (t : Set Î±), (âˆ€ b âˆˆ s, b â‰¤ t) â†’ âˆ€ a âˆˆ sSup s, a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["isGLB_sInf",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Set",
   "Union.union",
   "Inf.inf",
   "InfSet.sInf",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "IsGLB.union",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instUnionSet"],
  "name": "sInf_union",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {s t : Set Î±}, sInf (s âˆª t) = sInf s âŠ“ sInf t",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.mul_succ",
  "constType": "âˆ€ (n m : â„•), n * Nat.succ m = n * m + n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.succ_mul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.add_left_comm",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.zero_mul",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "congrFun",
   "id"],
  "name": "Nat.left_distrib",
  "constType": "âˆ€ (n m k : â„•), n * (m + k) = n * m + n * k",
  "constCategory": "Theorem"},
 {"references": ["And", "List", "And.intro", "And.casesOn", "List.Chain"],
  "name": "List.chain_cons.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a b : Î±} {l : List Î±} (motive : R a b âˆ§ List.Chain R b l â†’ Prop)\n  (x : R a b âˆ§ List.Chain R b l),\n  (âˆ€ (n : R a b) (p : List.Chain R b l), motive (_ : R a b âˆ§ List.Chain R b l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["instHasEquiv", "Setoid", "Setoid.refl", "HasEquiv.Equiv", "Eq"],
  "name": "Quotient.liftâ‚‚.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_3} {Î² : Sort u_1} {Ï† : Sort u_2} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} (f : Î± â†’ Î² â†’ Ï†),\n  (âˆ€ (aâ‚ : Î±) (bâ‚ : Î²) (aâ‚‚ : Î±) (bâ‚‚ : Î²), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ f aâ‚ bâ‚ = f aâ‚‚ bâ‚‚) â†’\n    âˆ€ (aâ‚ : Î±) (a b : Î²), a â‰ˆ b â†’ f aâ‚ a = f aâ‚ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Topology.IsLower.t0Space",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "T0Space",
   "instTopologicalSpaceOrderDual",
   "PartialOrder"],
  "name": "Topology.IsUpper.t0Space.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsUpper Î±], T0Space Î±áµ’áµˆ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Inter.inter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mk",
  "constType":
  "{Î± : Type u_1} â†’\n  (sets : Set (Set Î±)) â†’\n    Set.univ âˆˆ sets â†’\n      (âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets) â†’ (âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets) â†’ Filter Î±",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "List.cons",
   "Nat.le",
   "False",
   "HEq",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "False.elim",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Fin",
   "Fin.mk",
   "Fin.casesOn"],
  "name": "List.get.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : (x : List Î±) â†’ Fin (List.length x) â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : Fin (List.length x)) â†’\n        ((a : Î±) â†’\n            (tail : List Î±) â†’ (isLt : 0 < List.length (a :: tail)) â†’ motive (a :: tail) { val := 0, isLt := isLt }) â†’\n          ((head : Î±) â†’\n              (as : List Î±) â†’\n                (i : â„•) â†’\n                  (h : Nat.succ i < List.length (head :: as)) â†’ motive (head :: as) { val := Nat.succ i, isLt := h }) â†’\n            motive x x_1",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "MonadReaderOf.read"],
  "name": "readThe",
  "constType":
  "(Ï : Type u) â†’ {m : Type u â†’ Type v} â†’ [inst : MonadReaderOf Ï m] â†’ m Ï",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet", "Inhabited"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "and.match_1",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ (Unit â†’ motive false) â†’ (Unit â†’ motive true) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "List.cons",
   "Lean.Syntax.missing",
   "List",
   "String",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Array.mk",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.rec",
  "constType":
  "{motive_1 : Lean.Syntax â†’ Sort u} â†’\n  {motive_2 : Array Lean.Syntax â†’ Sort u} â†’\n    {motive_3 : List Lean.Syntax â†’ Sort u} â†’\n      motive_1 Lean.Syntax.missing â†’\n        ((info : Lean.SourceInfo) â†’\n            (kind : Lean.SyntaxNodeKind) â†’\n              (args : Array Lean.Syntax) â†’ motive_2 args â†’ motive_1 (Lean.Syntax.node info kind args)) â†’\n          ((info : Lean.SourceInfo) â†’ (val : String) â†’ motive_1 (Lean.Syntax.atom info val)) â†’\n            ((info : Lean.SourceInfo) â†’\n                (rawVal : Substring) â†’\n                  (val : Lean.Name) â†’\n                    (preresolved : List Lean.Syntax.Preresolved) â†’\n                      motive_1 (Lean.Syntax.ident info rawVal val preresolved)) â†’\n              ((data : List Lean.Syntax) â†’ motive_3 data â†’ motive_2 { data := data }) â†’\n                motive_3 [] â†’\n                  ((head : Lean.Syntax) â†’\n                      (tail : List Lean.Syntax) â†’ motive_1 head â†’ motive_3 tail â†’ motive_3 (head :: tail)) â†’\n                    (t : Lean.Syntax) â†’ motive_1 t",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Nat.le_of_ble_eq_true.match_1",
   "Nat.succ_le_succ",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.zero_le",
   "Nat.succ"],
  "name": "Nat.le_of_ble_eq_true",
  "constType": "âˆ€ {n m : â„•}, Nat.ble n m = true â†’ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references": ["LowerSet", "IsLowerSet", "Set", "LE"],
  "name": "LowerSet.mk",
  "constType":
  "{Î± : Type u_6} â†’ [inst : LE Î±] â†’ (carrier : Set Î±) â†’ IsLowerSet carrier â†’ LowerSet Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "and_comm",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "Set.inter_comm",
  "constType": "âˆ€ {Î± : Type u} (a b : Set Î±), a âˆ© b = b âˆ© a",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Membership.mem",
   "Set.preimage",
   "Set",
   "Eq.refl",
   "Monotone.mem_upperBounds_image",
   "Preorder",
   "And.left",
   "IsLUB",
   "Eq",
   "Set.instMembershipSet",
   "GaloisConnection.l_le",
   "upperBounds",
   "And.right",
   "Eq.ndrec",
   "GaloisConnection.monotone_l",
   "lowerBounds",
   "Eq.mp",
   "And.intro",
   "GaloisConnection.upperBounds_l_image",
   "Set.image"],
  "name": "GaloisConnection.isLUB_l_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ âˆ€ {s : Set Î±} {a : Î±}, IsLUB s a â†’ IsLUB (l '' s) (l a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.instPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "Prod",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq",
   "PartialOrder"],
  "name": "Prod.semilatticeInf.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²] (a b : Î± Ã— Î²),\n  a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "propext",
   "Set",
   "Set.ext_iff",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.4",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, (s = t) = âˆ€ (x : Î±), x âˆˆ s â†” x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "Iff.mp",
   "List.pairwise_cons",
   "List.instMembershipList",
   "List",
   "And.left"],
  "name": "List.rel_of_pairwise_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R (a :: l) â†’ âˆ€ {a' : Î±}, a' âˆˆ l â†’ R a a'",
  "constCategory": "Theorem"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.induction_onâ‚‚",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} {Î´ : Quot r â†’ Quot s â†’ Prop} (qâ‚ : Quot r)\n  (qâ‚‚ : Quot s), (âˆ€ (a : Î±) (b : Î²), Î´ (Quot.mk r a) (Quot.mk s b)) â†’ Î´ qâ‚ qâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_add_of_pos_right",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "List.chain_succ_range'",
   "Eq.rec",
   "HAdd.hAdd",
   "LT.lt",
   "List.Chain.imp",
   "instOfNatNat",
   "Nat",
   "List.Chain",
   "Eq.symm",
   "instLTNat",
   "Eq"],
  "name": "List.chain_lt_range'",
  "constType":
  "âˆ€ (s n : â„•) {step : â„•}, 0 < step â†’ List.Chain (fun x x_1 â†¦ x < x_1) s (List.range' (s + step) n step)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_lt_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Nat.succ",
   "Fin.mk",
   "Fin",
   "Fin.succ.match_1"],
  "name": "Fin.succ",
  "constType": "{n : â„•} â†’ Fin n â†’ Fin (Nat.succ n)",
  "constCategory": "Definition"},
 {"references": ["Continuous", "TopologicalSpace", "Continuous.comp"],
  "name": "Continuous.comp'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²}, Continuous g â†’ Continuous f â†’ Continuous fun x â†¦ g (f x)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.monotone'",
   "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
   "FunLike.mk",
   "OrderHom",
   "OrderHom.toFun",
   "RelHomClass.mk",
   "Preorder",
   "LE.le",
   "OrderHomClass",
   "Preorder.toLE"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE",
  "constType":
  "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ OrderHomClass (Î± â†’o Î²) Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Iff",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset",
   "List.subperm_append_left",
   "Quotient.inductionOnâ‚ƒ",
   "Multiset.instAddMultiset",
   "LE.le",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
  "constType": "âˆ€ {Î± : Type u_1} {s t u : Multiset Î±}, s + t â‰¤ s + u â†” t â‰¤ u",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Topology.WithUpperSet.isUpperSet_toUpperSet_preimage",
   "Set.preimage",
   "Topology.WithUpperSet",
   "Set",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Topology.WithUpperSet.toUpperSet",
   "Preorder.toLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.isOpen_ofUpperSet_preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, IsOpen (â†‘Topology.WithUpperSet.ofUpperSet â»Â¹' s) â†” IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“Ë¢Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["IsUpperSet", "isUpperSet_univ", "Preorder", "Set.univ", "Preorder.toLE"],
  "name": "Topology.upperSet.proof_1",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Preorder Î±], IsUpperSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["isLeast_singleton",
   "IsGLB",
   "Set.instSingletonSet",
   "Set",
   "IsLeast.isGLB",
   "Singleton.singleton",
   "Preorder"],
  "name": "isGLB_singleton",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsGLB {a} a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray4",
  "constType": "{Î± : Type u} â†’ Î± â†’ Î± â†’ Î± â†’ Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "_neutral", "Topology.WithLowerSet.map._elambda_1._rarg"],
  "name": "Topology.WithLowerSet.map._elambda_1._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Bot", "HeytingAlgebra"],
  "name": "HeytingAlgebra.toBot",
  "constType": "{Î± : Type u_4} â†’ [self : HeytingAlgebra Î±] â†’ Bot Î±",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_sup_distrib_left",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_inf_distrib_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] (a b c : Î±), a âŠ“ (b âŠ“ c) = a âŠ“ b âŠ“ (a âŠ“ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Function.Surjective.forall.match_1",
   "Function.Surjective",
   "Eq.rec",
   "Function.Surjective.exists.match_1",
   "Function.Surjective.exists.match_2",
   "Exists.intro",
   "Eq.symm",
   "Eq"],
  "name": "Function.Surjective.exists",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²}, Function.Surjective f â†’ âˆ€ {p : Î² â†’ Prop}, (âˆƒ y, p y) â†” âˆƒ x, p (f x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{Î± : Sort u} â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "HasCompl"],
  "name": "HeytingAlgebra.toHasCompl",
  "constType": "{Î± : Type u_4} â†’ [self : HeytingAlgebra Î±] â†’ HasCompl Î±",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "isOpen_sUnion",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.left",
   "interior",
   "IsOpen"],
  "name": "isOpen_interior",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen (interior s)",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "sSupHom.mk",
   "sSupHom.rec",
   "sSupHom",
   "Set",
   "SupSet.sSup",
   "Set.image",
   "Eq"],
  "name": "sSupHom.casesOn",
  "constType":
  "{Î± : Type u_8} â†’\n  {Î² : Type u_9} â†’\n    [inst : SupSet Î±] â†’\n      [inst_1 : SupSet Î²] â†’\n        {motive : sSupHom Î± Î² â†’ Sort u} â†’\n          (t : sSupHom Î± Î²) â†’\n            ((toFun : Î± â†’ Î²) â†’\n                (map_sSup' : âˆ€ (s : Set Î±), toFun (sSup s) = sSup (toFun '' s)) â†’\n                  motive { toFun := toFun, map_sSup' := map_sSup' }) â†’\n              motive t",
  "constCategory": "Definition"},
 {"references": ["True.intro", "Iff", "iff_of_true", "True"],
  "name": "iff_true_intro",
  "constType": "âˆ€ {a : Prop}, a â†’ (a â†” True)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "âˆ€ {Î± : Type u} [self : LinearOrder Î±] (a b : Î±), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«termð“[<]_Â»._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[<]_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Fin.lt_def",
   "Fin.val",
   "propext",
   "LT.lt",
   "Nat",
   "instLTNat",
   "instLTFin",
   "Fin",
   "Eq"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.13",
  "constType": "âˆ€ {n : â„•} {a b : Fin n}, (a < b) = (â†‘a < â†‘b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.map",
   "Eq"],
  "name": "List.exists_of_mem_map",
  "constType":
  "âˆ€ {Î± : Type u_1} {b : Î±} {Î±_1 : Type u_2} {f : Î±_1 â†’ Î±} {l : List Î±_1}, b âˆˆ List.map f l â†’ âˆƒ a âˆˆ l, f a = b",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Or", "Iff", "Or.inl", "id", "Or.rec"],
  "name": "or_iff_left_of_imp",
  "constType": "âˆ€ {b a : Prop}, (b â†’ a) â†’ (a âˆ¨ b â†” a)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike",
   "UpperSet.instSetLikeUpperSet.proof_1",
   "SetLike.mk",
   "UpperSet.carrier",
   "LE",
   "UpperSet"],
  "name": "UpperSet.instSetLikeUpperSet",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ SetLike (UpperSet Î±) Î±",
  "constCategory": "Definition"},
 {"references": ["SizeOf", "measure", "WellFoundedRelation", "SizeOf.sizeOf"],
  "name": "sizeOfWFRel",
  "constType": "{Î± : Sort u} â†’ [inst : SizeOf Î±] â†’ WellFoundedRelation Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.preorder",
   "Preorder.le_trans",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ PartialOrder (Ï€ i)] (a b c : (i : Î¹) â†’ Ï€ i), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Topology.WithLower"],
  "name": "Topology.WithLower.instInhabitedWithLower._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "And",
   "setOf",
   "Set",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.nhds_generateFrom.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {g : Set (Set Î±)} {a : Î±} (s : Set Î±) (motive : s âˆˆ {s | a âˆˆ s âˆ§ IsOpen s} â†’ Prop)\n  (x : s âˆˆ {s | a âˆˆ s âˆ§ IsOpen s}), (âˆ€ (ha : a âˆˆ s) (hs : IsOpen s), motive (_ : a âˆˆ s âˆ§ IsOpen s)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Prod.lattice",
   "Prod",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (a b : Î± Ã— Î²), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.length_take.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : â„• â†’ List Î± â†’ Prop) (x : â„•) (x_1 : List Î±),\n  (âˆ€ (l : List Î±), motive 0 l) â†’\n    (âˆ€ (n : â„•), motive (Nat.succ n) []) â†’\n      (âˆ€ (n : â„•) (head : Î±) (l : List Î±), motive (Nat.succ n) (head :: l)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Continuous_of._closed_9",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_13"],
  "name": "Topology.Continuous_of._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "Iff.mp", "Iff", "And.imp", "Iff.mpr"],
  "name": "and_congr",
  "constType": "âˆ€ {a c b d : Prop}, (a â†” c) â†’ (b â†” d) â†’ (a âˆ§ b â†” c âˆ§ d)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8611",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Nat.linearOrderedCommSemiring.proof_4",
  "constType": "âˆ€ (a b : â„•), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["List", "List.nil", "rfl", "Eq"],
  "name": "List.hasDecEq.proof_1",
  "constType": "âˆ€ {Î± : Type u_1}, [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
   "autoParam",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} â†’\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] â†’\n    [toZero : Zero M] â†’\n      (âˆ€ (a : M), 0 + a = a) â†’\n        (âˆ€ (a : M), a + 0 = a) â†’\n          (nsmul : â„• â†’ M â†’ M) â†’\n            autoParam (âˆ€ (x : M), nsmul 0 x = 0) _autoâœ â†’\n              autoParam (âˆ€ (n : â„•) (x : M), nsmul (n + 1) x = x + nsmul n x) _autoâœÂ¹ â†’ AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["and_comm", "And", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.7",
  "constType": "âˆ€ {a b : Prop}, (a âˆ§ b) = (b âˆ§ a)",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "Eq.symm", "rfl", "Eq"],
  "name": "forall_eq",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) â†” p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Set.preimage",
   "Topology.WithUpperSet",
   "OrderHom.monotone",
   "Function.comp",
   "Set",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Continuous",
   "IsUpperSet.preimage",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "IsOpen",
   "continuous_def",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : Preorder Î²] (f : Î± â†’o Î²),\n  Continuous (â†‘Topology.WithUpperSet.toUpperSet âˆ˜ â†‘f âˆ˜ â†‘Topology.WithUpperSet.ofUpperSet)",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Multiset",
   "Multiset.mem_map",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {s : Multiset Î±}, (b âˆˆ Multiset.map f s) = âˆƒ a âˆˆ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“Ë¢Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.instUnionList",
   "of_eq_true",
   "DecidableEq",
   "List",
   "Union.union",
   "List.nil",
   "Eq"],
  "name": "List.nil_union",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±), [] âˆª l = l",
  "constCategory": "Theorem"},
 {"references": ["HeytingAlgebra", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toHeytingAlgebra",
  "constType":
  "{Î± : Type u_4} â†’ [self : BiheytingAlgebra Î±] â†’ HeytingAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.indexOf_lt_length",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "instBEq",
   "List.indexOf",
   "List.length",
   "Nat",
   "instLTNat",
   "Iff.mpr"],
  "name": "List.Nodup.getEquivOfForallMemList.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±), (âˆ€ (x : Î±), x âˆˆ l) â†’ âˆ€ (a : Î±), List.indexOf a l < List.length l",
  "constCategory": "Theorem"},
 {"references": ["HasCompl", "CompleteAtomicBooleanAlgebra"],
  "name": "CompleteAtomicBooleanAlgebra.toHasCompl",
  "constType":
  "{Î± : Type u} â†’ [self : CompleteAtomicBooleanAlgebra Î±] â†’ HasCompl Î±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.get",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "instLTNat",
   "Fin.mk",
   "Eq"],
  "name": "List.get?_eq_some.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} {n : â„•}\n  (motive : (âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a) â†’ Prop)\n  (x : âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a),\n  (âˆ€ (h : n < List.length l) (e : List.get l { val := n, isLt := h } = a),\n      motive (_ : âˆƒ (h : n < List.length l), List.get l { val := n, isLt := h } = a)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "IsGLB",
   "Set.preimage",
   "Set",
   "lowerBounds",
   "OrderDual",
   "IsGLB.dual",
   "Set.Iic",
   "FunLike.coe",
   "Preorder",
   "IsLUB.upperBounds_eq",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "IsGLB.lowerBounds_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsGLB s a â†’ lowerBounds s = Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get!.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ â„• â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : â„•) â†’\n        ((a : Î±) â†’ (tail : List Î±) â†’ motive (a :: tail) 0) â†’\n          ((head : Î±) â†’ (as : List Î±) â†’ (n : â„•) â†’ motive (head :: as) (Nat.succ n)) â†’\n            ((x : List Î±) â†’ (x_2 : â„•) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "TopologicalSpace.GenerateOpen.inter",
   "Eq.rec",
   "Set",
   "Inter.inter",
   "TopologicalSpace.GenerateOpen",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)),\n  {u | TopologicalSpace.GenerateOpen s u} = s â†’\n    âˆ€ (s_1 t : Set Î±), (fun u â†¦ u âˆˆ s) s_1 â†’ (fun u â†¦ u âˆˆ s) t â†’ (fun u â†¦ u âˆˆ s) (s_1 âˆ© t)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpper", "Preorder"],
  "name": "Topology.WithUpper.instPreorderWithUpper",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : â„•) â†’ Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.mem_Ici",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a x : Î±}, (x âˆˆ Set.Ici a) = (a â‰¤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.lattice.proof_4",
   "Prod.semilatticeSup",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Prod.lattice.proof_3",
   "Prod.lattice.proof_1",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Prod.lattice.proof_6",
   "SemilatticeSup",
   "Prod.lattice.proof_2",
   "SemilatticeSup.toSup",
   "inferInstanceAs",
   "Prod.lattice.proof_5",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "Prod.semilatticeInf",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.lattice",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : Lattice Î±] â†’ [inst : Lattice Î²] â†’ Lattice (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "eq_comm",
   "Eq.refl",
   "instBEq",
   "List.countP_cons",
   "ite_congr",
   "True",
   "instLawfulBEqInstBEq",
   "Eq",
   "ite",
   "BEq.beq",
   "DecidableEq",
   "of_eq_true",
   "propext",
   "List",
   "Bool.true",
   "Init.Core._auxLemma.1",
   "congr",
   "Not",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "List.count",
   "congrArg",
   "Eq.trans",
   "instDecidableEqBool"],
  "name": "List.count_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a b : Î±) (l : List Î±),\n  List.count a (b :: l) = List.count a l + if a = b then 1 else 0",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set",
   "Finset",
   "Singleton.singleton",
   "Fintype.ofFinset",
   "Set.fintypeSingleton.proof_1",
   "Finset.instSingletonFinset"],
  "name": "Set.fintypeSingleton",
  "constType": "{Î± : Type u} â†’ (a : Î±) â†’ Fintype â†‘{a}",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "UInt64.size",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "Nat",
   "instLTNat"],
  "name": "Lean.Name.hash.proof_2",
  "constType": "17 < UInt64.size",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.bot_le",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : BiheytingAlgebra Î±] (a : Î±), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.succ_le_succ", "Nat", "instLTNat", "Nat.succ"],
  "name": "Nat.succ_lt_succ",
  "constType": "âˆ€ {n m : â„•}, n < m â†’ Nat.succ n < Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_trans",
   "LE.le",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_of_le_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, c â‰¤ a â†’ c â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Set",
   "compl_le_compl_iff_le",
   "HasCompl.compl",
   "HasSubset.Subset",
   "BooleanAlgebra.toHasCompl"],
  "name": "Set.compl_subset_compl",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, sá¶œ âŠ† tá¶œ â†” t âŠ† s",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpperSet.toDualHomeomorph._lambda_1", "_obj"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.mk",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {coe : outParam (Î² â†’ Î±)} {cond : outParam (Î± â†’ Prop)},\n  (âˆ€ (x : Î±), cond x â†’ âˆƒ y, coe y = x) â†’ CanLift Î± Î² coe cond",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Data.AC.Expr",
   "List.instLawfulBEqListInstBEqList",
   "Lean.Data.AC.eval",
   "Eq.refl",
   "instBEqNat",
   "Eq",
   "BEq.beq",
   "List.instBEqList",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Lean.Data.AC.Context",
   "Nat.instLawfulBEqNatInstBEqNat",
   "List",
   "Bool.true",
   "LawfulBEq.eq_of_beq",
   "Lean.Data.AC.instContextInformationContext",
   "Eq.mp",
   "Lean.Data.AC.Context.eval_norm",
   "Bool",
   "Lean.Data.AC.norm",
   "Nat",
   "congrArg"],
  "name": "Lean.Data.AC.Context.eq_of_norm",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±) (a b : Lean.Data.AC.Expr),\n  (Lean.Data.AC.norm ctx a == Lean.Data.AC.norm ctx b) = true â†’ Lean.Data.AC.eval Î± ctx a = Lean.Data.AC.eval Î± ctx b",
  "constCategory": "Theorem"},
 {"references": ["imp_intro", "Iff.intro", "Iff"],
  "name": "imp_iff_right",
  "constType": "âˆ€ {b a : Prop}, a â†’ (a â†’ b â†” b)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax"],
  "name": "Lean.Syntax.missing",
  "constType": "Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLower.ofLower._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Iff",
   "Iff.rfl",
   "Set",
   "Filter",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.mem_sets",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±} {s : Set Î±}, s âˆˆ f.sets â†” s âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.indexOf_lt_length",
   "Fin.val",
   "List.instMembershipList",
   "Eq.refl",
   "instBEq",
   "List.indexOf",
   "List.get_indexOf",
   "List.length",
   "instLTNat",
   "True",
   "Iff.mpr",
   "Eq",
   "eq_true",
   "Eq.ndrec",
   "List.Nodup",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Eq.rec",
   "LT.lt",
   "List.get",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin",
   "Fin.mk",
   "congrFun"],
  "name": "List.Nodup.getEquivOfForallMemList.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±),\n  List.Nodup l â†’\n    âˆ€ (h : âˆ€ (x : Î±), x âˆˆ l) (i : Fin (List.length l)),\n      { val := List.indexOf ((fun i â†¦ List.get l i) i) l,\n          isLt := (_ : List.indexOf ((fun i â†¦ List.get l i) i) l < List.length l) } =\n        i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.eq",
   "List.Nodup.map",
   "List.instMembershipList",
   "Subtype.val",
   "List.Nodup.of_map",
   "List.attach",
   "Eq",
   "Iff.intro",
   "List.Nodup",
   "Iff",
   "List",
   "Eq.rec",
   "List.attach_map_val",
   "List.map",
   "Eq.symm",
   "Subtype"],
  "name": "List.nodup_attach",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±}, List.Nodup (List.attach l) â†” List.Nodup l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "HasSubset.Subset",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_sSup",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.subset_sUnion_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {S : Set (Set Î±)} {t : Set Î±}, t âˆˆ S â†’ t âŠ† â‹ƒâ‚€ S",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.fst.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²} (motive : Set.Nonempty (s Ã—Ë¢ t) â†’ Prop)\n  (x : Set.Nonempty (s Ã—Ë¢ t)), (âˆ€ (x : Î± Ã— Î²) (hx : x âˆˆ s Ã—Ë¢ t), motive (_ : âˆƒ x, x âˆˆ s Ã—Ë¢ t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.not_succ_le_zero.match_3",
   "Nat.not_succ_le_zero.match_2",
   "OfNat.ofNat",
   "False",
   "instLENat",
   "Nat.not_succ_le_zero.match_1",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.not_succ_le_zero",
  "constType": "âˆ€ (n : â„•), Nat.succ n â‰¤ 0 â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Pi.instHImpForAll",
   "LE.le",
   "True",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop",
   "iff_self",
   "Lattice.toInf",
   "Std.Logic._auxLemma.33",
   "HImp.himp",
   "Iff",
   "of_eq_true",
   "Pi.Nonempty",
   "Mathlib.Order.Heyting.Basic._auxLemma.1",
   "forall_congr",
   "Pi.lattice",
   "top_nonempty",
   "congr",
   "GeneralizedHeytingAlgebra.toLattice",
   "Mathlib.Order.Heyting.Basic._auxLemma.10",
   "GeneralizedHeytingAlgebra",
   "Pi.hasLe",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder"],
  "name": "Pi.generalizedHeytingAlgebra.proof_5",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ GeneralizedHeytingAlgebra (Î± i)] (i a a_1 : (i : Î¹) â†’ Î± i),\n  i â‰¤ a â‡¨ a_1 â†” i âŠ“ a â‰¤ a_1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "TopologicalSpace.GenerateOpen.univ",
   "Eq.rec",
   "Set",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)), {u | TopologicalSpace.GenerateOpen s u} = s â†’ Set.univ âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "not_not_intro",
  "constType": "âˆ€ {p : Prop}, p â†’ Â¬Â¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[>]_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "outParam",
   "FunLike",
   "Set",
   "sSupHomClass",
   "FunLike.coe",
   "SupSet.sSup",
   "Set.image",
   "Eq"],
  "name": "sSupHomClass.mk",
  "constType":
  "{F : Type u_8} â†’\n  {Î± : outParam (Type u_9)} â†’\n    {Î² : outParam (Type u_10)} â†’\n      [inst : SupSet Î±] â†’\n        [inst_1 : SupSet Î²] â†’\n          [toFunLike : FunLike F Î± fun x â†¦ Î²] â†’\n            (âˆ€ (f : F) (s : Set Î±), â†‘f (sSup s) = sSup (â†‘f '' s)) â†’ sSupHomClass F Î± Î²",
  "constCategory": "Other"},
 {"references": ["_obj", "_neutral", "Topology.WithUpperSet.rec._rarg"],
  "name": "Topology.WithUpperSet.rec._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.filterMap.match_1",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1",
   "Option"],
  "name": "List.filterMap",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Option Î²) â†’ List Î± â†’ List Î²",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM.Result.casesOn",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.tryCatch.match_1",
  "constType":
  "{Îµ Ïƒ Î± : Type u_1} â†’\n  (motive : EStateM.Result Îµ Ïƒ Î± â†’ Sort u_2) â†’\n    (x : EStateM.Result Îµ Ïƒ Î±) â†’\n      ((e : Îµ) â†’ (s : Ïƒ) â†’ motive (EStateM.Result.error e s)) â†’ ((ok : EStateM.Result Îµ Ïƒ Î±) â†’ motive ok) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "Iff",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "LE.le.le_iff_eq",
   "OrderBot",
   "LE.le",
   "bot_le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_bot_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderBot Î±] {a : Î±}, a â‰¤ âŠ¥ â†” a = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{Î± : Type u_1} â†’ Inter (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "propext",
   "Set",
   "Set.ball_insert_iff",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u} {P : Î± â†’ Prop} {a : Î±} {s : Set Î±}, (âˆ€ x âˆˆ insert a s, P x) = (P a âˆ§ âˆ€ x âˆˆ s, P x)",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Prop.booleanAlgebra.match_1",
   "Bot.bot",
   "Prop.heytingAlgebra",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "DistribLattice.mk",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "Not",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice"],
  "name": "Prop.booleanAlgebra.proof_1",
  "constType": "âˆ€ (p : Prop), p âŠ“ pá¶œ â†’ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Lean.Name.num",
   "List",
   "String",
   "List.casesOn",
   "List.nil",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.assembleParts.match_1",
  "constType":
  "(motive : List Lean.Name â†’ Lean.Name â†’ Sort u_1) â†’\n  (x : List Lean.Name) â†’\n    (x_1 : Lean.Name) â†’\n      ((acc : Lean.Name) â†’ motive [] acc) â†’\n        ((pre : Lean.Name) â†’\n            (s : String) â†’ (ps : List Lean.Name) â†’ (acc : Lean.Name) â†’ motive (Lean.Name.str pre s :: ps) acc) â†’\n          ((pre : Lean.Name) â†’\n              (n : â„•) â†’ (ps : List Lean.Name) â†’ (acc : Lean.Name) â†’ motive (Lean.Name.num pre n :: ps) acc) â†’\n            ((x : List Lean.Name) â†’ (x_2 : Lean.Name) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Inter.inter",
   "And.intro",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_inter",
  "constType":
  "âˆ€ {Î± : Type u} {x : Î±} {a b : Set Î±}, x âˆˆ a â†’ x âˆˆ b â†’ x âˆˆ a âˆ© b",
  "constCategory": "Theorem"},
 {"references":
  ["iInf_subtype",
   "Subtype.property",
   "CompleteLattice",
   "iInf",
   "Subtype.val",
   "CompleteLattice.toInfSet",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "iInf_subtype'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {p : Î¹ â†’ Prop} {f : (i : Î¹) â†’ p i â†’ Î±},\n  â¨… i, â¨… (h : p i), f i h = â¨… x, f â†‘x (_ : p â†‘x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "List.cons",
   "List.insert",
   "List.instMembershipList",
   "True",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Decidable",
   "Not",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "congrFun"],
  "name": "List.insert_of_not_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, Â¬a âˆˆ l â†’ List.insert a l = a :: l",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "MonadWithReader",
  "constType": "outParam (Type u) â†’ (Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "âˆ€ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{Î± : Type u} â†’ [self : LE Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "funext",
   "Or",
   "setOf",
   "Iff.rfl",
   "Set",
   "Inf.inf",
   "Union.union",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Mathlib.Order.Filter.Basic._auxLemma.63",
   "Eq",
   "Set.instMembershipSet",
   "Filter.principal",
   "Eq.mpr",
   "Iff",
   "Mathlib.Order.Filter.Basic._auxLemma.64",
   "Filter.instInfFilter",
   "congr",
   "Not",
   "Filter",
   "congrArg",
   "Set.instUnionSet",
   "congrFun",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.mem_inf_principal",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s t : Set Î±}, s âˆˆ f âŠ“ Filter.principal t â†” {x | x âˆˆ t â†’ x âˆˆ s} âˆˆ f",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.le_refl", "Nat", "instLTNat", "Nat.succ"],
  "name": "Nat.lt.base",
  "constType": "âˆ€ (n : â„•), n < Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB",
   "EmptyCollection.emptyCollection",
   "lowerBounds_empty",
   "Set",
   "IsGreatest",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Mathlib.Order.Bounds.Basic._auxLemma.13",
   "Set.univ",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Iff",
   "of_eq_true",
   "lowerBounds",
   "IsTop",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "isGLB_empty_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsGLB âˆ… a â†” IsTop a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Eq.refl",
   "List.forall_mem_cons",
   "And.left",
   "Eq"],
  "name": "_private.Mathlib.Data.List.Basic.0.List.pmap._eq_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} (f : (a : Î±) â†’ p a â†’ Î²) (a : Î±) (l : List Î±) (H : âˆ€ a_1 âˆˆ a :: l, p a_1),\n  List.pmap f (a :: l) H = f a (_ : p a) :: List.pmap f l (_ : âˆ€ x âˆˆ l, p x)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "False", "iff_of_eq", "false_or"],
  "name": "false_or_iff",
  "constType": "âˆ€ (p : Prop), False âˆ¨ p â†” p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "And.casesOn"],
  "name": "Set.Subset.antisymm_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Set Î±} (motive : a âŠ† b âˆ§ b âŠ† a â†’ Prop) (x : a âŠ† b âˆ§ b âŠ† a),\n  (âˆ€ (hâ‚ : a âŠ† b) (hâ‚‚ : b âŠ† a), motive (_ : a âŠ† b âˆ§ b âŠ† a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.17",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (s = Set.univ) = âˆ€ (x : Î±), x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "_private.Std.Data.List.Lemmas.0.List.findIdx.go.match_1.splitter",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ â„• â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : â„•) â†’ ((n : â„•) â†’ motive [] n) â†’ ((a : Î±) â†’ (l : List Î±) â†’ (n : â„•) â†’ motive (a :: l) n) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "âˆ€ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "le_compl_iff_disjoint_right",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "disjoint_comm",
   "Iff.trans",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "Disjoint.le_compl_left",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, Disjoint b a â†’ a â‰¤ bá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.mem_of_mem_of_subset",
  "constType": "âˆ€ {Î± : Type u} {x : Î±} {s t : Set Î±}, x âˆˆ s â†’ s âŠ† t â†’ x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Monad",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "dite",
   "Array.foldlM.proof_1",
   "optParam",
   "Array.size",
   "LE.le",
   "Array.foldlM.loop",
   "Array",
   "instLENat",
   "instOfNatNat",
   "Not",
   "Nat",
   "Nat.decLe"],
  "name": "Array.foldlM",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {m : Type v â†’ Type w} â†’\n      [inst : Monad m] â†’ (Î² â†’ Î± â†’ m Î²) â†’ Î² â†’ (as : Array Î±) â†’ optParam â„• 0 â†’ optParam â„• (Array.size as) â†’ m Î²",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Array",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "False.elim", "False", "True", "Eq"],
  "name": "false_implies",
  "constType": "âˆ€ (p : Prop), (False â†’ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.length_eq",
   "List.Perm.symm",
   "List.Subperm.perm_of_length_le.match_1",
   "List.Perm",
   "instLENat",
   "List",
   "Eq.rec",
   "List.Subperm",
   "List.Sublist",
   "List.length",
   "Nat",
   "List.Sublist.eq_of_length_le",
   "LE.le",
   "Eq"],
  "name": "List.Subperm.perm_of_length_le",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <+~ lâ‚‚ â†’ List.length lâ‚‚ â‰¤ List.length lâ‚ â†’ lâ‚ ~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_prop.match_1",
  "constType":
  "âˆ€ {b a : Prop} (motive : (âˆƒ (_ : a), b) â†’ Prop) (x : âˆƒ (_ : a), b),\n  (âˆ€ (hp : a) (hq : b), motive (_ : âˆƒ (_ : a), b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Or.inl",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.instUnionSet",
   "Set.instMembershipSet"],
  "name": "Set.subset_union_left",
  "constType": "âˆ€ {Î± : Type u} (s t : Set Î±), s âŠ† s âˆª t",
  "constCategory": "Theorem"},
 {"references": ["IsRefl"],
  "name": "IsRefl.refl",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [self : IsRefl Î± r] (a : Î±), r a a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MonadRef", "Lean.Name", "Lean.MonadQuotation", "Lean.MacroScope"],
  "name": "Lean.MonadQuotation.mk",
  "constType":
  "{m : Type â†’ Type} â†’\n  [toMonadRef : Lean.MonadRef m] â†’ m Lean.MacroScope â†’ m Lean.Name â†’ ({Î± : Type} â†’ m Î± â†’ m Î±) â†’ Lean.MonadQuotation m",
  "constCategory": "Other"},
 {"references":
  ["WellFounded.apply",
   "WellFounded",
   "WellFounded.fixFEq",
   "WellFounded.fix",
   "Eq"],
  "name": "WellFounded.fix_eq",
  "constType":
  "âˆ€ {Î± : Sort u} {C : Î± â†’ Sort v} {r : Î± â†’ Î± â†’ Prop} (hwf : WellFounded r) (F : (x : Î±) â†’ ((y : Î±) â†’ r y x â†’ C y) â†’ C x)\n  (x : Î±), WellFounded.fix hwf F x = F x fun y x â†¦ WellFounded.fix hwf F y",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.Perm.map",
   "List",
   "List.isSetoid",
   "List.map",
   "Quot",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.map.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (_lâ‚ _lâ‚‚ : List Î±),\n  Setoid.r _lâ‚ _lâ‚‚ â†’ Quot.mk Setoid.r (List.map f _lâ‚) = Quot.mk Setoid.r (List.map f _lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} â†’ [self : AddMonoid M] â†’ â„• â†’ M â†’ M",
  "constCategory": "Definition"},
 {"references": ["InfSet"],
  "name": "sInfHom",
  "constType":
  "(Î± : Type u_8) â†’ (Î² : Type u_9) â†’ [inst : InfSet Î±] â†’ [inst : InfSet Î²] â†’ Type (max u_8 u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn"],
  "name": "List.mem_attach.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (l : List Î±) (motive : { x // x âˆˆ l } â†’ Prop) (x : { x // x âˆˆ l }),\n  (âˆ€ (a : Î±) (h : a âˆˆ l), motive { val := a, property := h }) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "propext",
   "LT.lt",
   "Nat.lt_succ",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.105",
  "constType": "âˆ€ {m n : â„•}, (m < Nat.succ n) = (m â‰¤ n)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x}, f = g â†’ âˆ€ (a : Î±), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.univ",
   "Set.instMembershipSet"],
  "name": "Set.subset_univ",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±), s âŠ† Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "Iff",
   "le_rfl",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "eq_of_forall_ge_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, (âˆ€ (c : Î±), a â‰¤ c â†” b â‰¤ c) â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "âˆ€ {a b : Prop}, a â†’ b â†’ a âˆ§ b",
  "constCategory": "Other"},
 {"references": ["Array.mkEmpty", "_obj", "_neutral"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.toUpperSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.casesOn",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.noConfusion",
   "Eq.symm",
   "Eq"],
  "name": "List.cons_sublist_cons.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {lâ‚ lâ‚‚ : List Î±} (motive : List.Sublist (a :: lâ‚) (a :: lâ‚‚) â†’ Prop)\n  (x : List.Sublist (a :: lâ‚) (a :: lâ‚‚)),\n  (âˆ€ (s : List.Sublist (a :: lâ‚) lâ‚‚), motive (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))) â†’\n    (âˆ€ (s : List.Sublist lâ‚ lâ‚‚), motive (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "SemilatticeSup.le_sup_right",
  "constType": "âˆ€ {Î± : Type u} [self : SemilatticeSup Î±] (a b : Î±), b â‰¤ a âŠ” b",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff"],
  "name": "instDecidableIff.proof_1",
  "constType": "âˆ€ {p q : Prop}, p â†’ q â†’ (p â†” q)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "inf_of_le_left",
   "GE.ge",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Basic._auxLemma.4",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "Mathlib.Order.Lattice._auxLemma.1",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "inf_sup_self",
  "constType": "âˆ€ {Î± : Type u} [inst : Lattice Î±] {a b : Î±}, a âŠ“ (a âŠ” b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.countP_map.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : List Î± â†’ Prop) (x : List Î±),\n  (Unit â†’ motive []) â†’ (âˆ€ (a : Î±) (l : List Î±), motive (a :: l)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["False", "Decidable", "Not", "Decidable.byContradiction", "absurd"],
  "name": "Decidable.of_not_not",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], Â¬Â¬p â†’ p",
  "constCategory": "Theorem"},
 {"references": ["MonadWithReaderOf", "MonadWithReaderOf.withReader"],
  "name": "withTheReader",
  "constType":
  "(Ï : Type u) â†’ {m : Type u â†’ Type v} â†’ [inst : MonadWithReaderOf Ï m] â†’ {Î± : Type u} â†’ (Ï â†’ Ï) â†’ m Î± â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_6",
  "constType":
  "âˆ€ {Î± : Type u_1} (x y z : Set Î±), (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "Multiset.ndunion",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "List.Nodup.union",
   "Quot.induction_onâ‚‚"],
  "name": "Multiset.Nodup.ndunion",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (s : Multiset Î±) {t : Multiset Î±},\n  Multiset.Nodup t â†’ Multiset.Nodup (Multiset.ndunion s t)",
  "constCategory": "Theorem"},
 {"references":
  ["Char",
   "False",
   "List",
   "String.mk",
   "String",
   "Not",
   "String.noConfusion",
   "absurd",
   "Eq"],
  "name": "String.decEq.proof_2",
  "constType":
  "âˆ€ (sâ‚ sâ‚‚ : List Char), Â¬sâ‚ = sâ‚‚ â†’ { data := sâ‚ } = { data := sâ‚‚ } â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "Continuous",
   "ContinuousMapClass",
   "TopologicalSpace",
   "FunLike.coe"],
  "name": "ContinuousMapClass.mk",
  "constType":
  "{F : Type u_1} â†’\n  {Î± : outParam (Type u_2)} â†’\n    {Î² : outParam (Type u_3)} â†’\n      [inst : TopologicalSpace Î±] â†’\n        [inst_1 : TopologicalSpace Î²] â†’\n          [toFunLike : FunLike F Î± fun x â†¦ Î²] â†’ (âˆ€ (f : F), Continuous â†‘f) â†’ ContinuousMapClass F Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.pmap",
   "propext",
   "List.instMembershipList",
   "List",
   "List.mem_pmap",
   "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.10",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {l : List Î±} {H : âˆ€ a âˆˆ l, p a} {b : Î²},\n  (b âˆˆ List.pmap f l H) = âˆƒ a, âˆƒ (h : a âˆˆ l), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references": ["nhds", "TopologicalSpace", "Filter.Tendsto"],
  "name": "ContinuousAt",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.pmap",
   "List.instMembershipList",
   "List.Perm.rec",
   "List.pmap._sunfold.proof_1",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "List.pmap._sunfold.proof_2",
   "List.Perm.subset",
   "Mathlib.Data.List.Perm._auxLemma.13",
   "eq_true",
   "List.Perm",
   "of_eq_true",
   "List",
   "Mathlib.Data.List.Perm._auxLemma.14",
   "List.Perm.trans",
   "List.nil"],
  "name": "List.Perm.pmap",
  "constType":
  "âˆ€ {Î± : Type uu} {Î² : Type vv} {p : Î± â†’ Prop} (f : (a : Î±) â†’ p a â†’ Î²) {lâ‚ lâ‚‚ : List Î±},\n  lâ‚ ~ lâ‚‚ â†’ âˆ€ {Hâ‚ : âˆ€ a âˆˆ lâ‚, p a} {Hâ‚‚ : âˆ€ a âˆˆ lâ‚‚, p a}, List.pmap f lâ‚ Hâ‚ ~ List.pmap f lâ‚‚ Hâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Inf.inf",
   "Set",
   "Filter.generate",
   "Inter.inter",
   "Preorder.le_trans",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.inter_mem",
   "Preorder.toLT",
   "Eq.rec",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.match_1",
   "Filter.sets",
   "Membership.mem",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "Preorder.le_refl",
   "SemilatticeSup.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "OrderDual.completeLattice",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup.sup_le",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "Filter.giGenerate",
   "Preorder.lt_iff_le_not_le",
   "Set.instInterSet"],
  "name": "Filter.instCompleteLatticeFilter.proof_8",
  "constType":
  "âˆ€ {Î± : Type u_1} (x x_1 x_2 : Filter Î±), x â‰¤ x_1 â†’ x â‰¤ x_2 â†’ âˆ€ _s âˆˆ x_1 âŠ“ x_2, _s âˆˆ x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.union",
  "constType": "{Î± : Type u_1} â†’ Set Î± â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["GaloisCoinsertion", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisCoinsertion.choice",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’ {l : Î± â†’ Î²} â†’ {u : Î² â†’ Î±} â†’ GaloisCoinsertion l u â†’ (x : Î²) â†’ x â‰¤ l (u x) â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["SProd", "Set.prod", "SProd.mk", "Set", "Prod"],
  "name": "Set.instSProd",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ SProd (Set Î±) (Set Î²) (Set (Î± Ã— Î²))",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "Prod.mk", "Bot.mk", "Prod"],
  "name": "Prod.bot",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : Bot Î±] â†’ [inst : Bot Î²] â†’ Bot (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["List.length_pos_of_mem.match_1",
   "Membership.mem",
   "List.cons",
   "OfNat.ofNat",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "List.length",
   "Nat",
   "instLTNat"],
  "name": "List.length_pos_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±}, a âˆˆ l â†’ 0 < List.length l",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteAtomicBooleanAlgebra",
   "Inf.inf",
   "HasCompl.compl",
   "CompleteLattice.toBot",
   "Lattice.toSemilatticeSup",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.inf_compl_le_bot",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (x : Î±), x âŠ“ xá¶œ â‰¤ âŠ¥",
  "constCategory": "Definition"},
 {"references":
  ["IsLowerSet",
   "Set",
   "Inter.inter",
   "Preorder",
   "Preorder.toLE",
   "IsLowerSet.inter",
   "Set.instInterSet"],
  "name": "Topology.lowerSet.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] (x x_1 : Set Î±), IsLowerSet x â†’ IsLowerSet x_1 â†’ IsLowerSet (x âˆ© x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHAppend",
   "List.cons",
   "List.instAppendList",
   "of_eq_true",
   "List.rec",
   "HAppend.hAppend",
   "List",
   "Eq.refl",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.append_assoc",
  "constType":
  "âˆ€ {Î± : Type u} (as bs cs : List Î±), as ++ bs ++ cs = as ++ (bs ++ cs)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpperSet", "Preorder"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a < b â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.succ_sub.match_1",
  "constType":
  "âˆ€ {m n : â„•} (motive : (âˆƒ k, n + k = m) â†’ Prop) (x : âˆƒ k, n + k = m),\n  (âˆ€ (k : â„•) (hk : n + k = m), motive (_ : âˆƒ k, n + k = m)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["setOf", "Filter", "Filter.Eventually", "Filter.mp_mem"],
  "name": "Filter.Eventually.mp",
  "constType":
  "âˆ€ {Î± : Type u} {p q : Î± â†’ Prop} {f : Filter Î±},\n  (âˆ€á¶  (x : Î±) in f, p x) â†’ (âˆ€á¶  (x : Î±) in f, p x â†’ q x) â†’ âˆ€á¶  (x : Î±) in f, q x",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Eq.ndrec",
   "List.rec",
   "List",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Lean.Data.AC.List.two_step_induction",
  "constType":
  "{motive : List â„• â†’ Sort u} â†’\n  (l : List â„•) â†’\n    motive [] â†’ ((a : â„•) â†’ motive [a]) â†’ ((a b : â„•) â†’ (l : List â„•) â†’ motive (b :: l) â†’ motive (a :: b :: l)) â†’ motive l",
  "constCategory": "Theorem"},
 {"references":
  ["Order.Coframe.toCompleteLattice",
   "CompleteBooleanAlgebra",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "CompleteBooleanAlgebra.toSupSet",
   "le_iInf",
   "compl_le_compl",
   "Function.comp",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "iSup",
   "le_iSup",
   "iSup_le",
   "CompleteBooleanAlgebra.toCompleteDistribLattice",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Eq",
   "CompleteBooleanAlgebra.toInfSet",
   "BooleanAlgebra.toBiheytingAlgebra",
   "iInf",
   "compl_le_of_compl_le",
   "CompleteDistribLattice.toCoframe",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le",
   "le_antisymm"],
  "name": "compl_iInf",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} [inst : CompleteBooleanAlgebra Î±] {f : Î¹ â†’ Î±}, (iInf f)á¶œ = â¨† i, (f i)á¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid"],
  "name": "Nat.addMonoid",
  "constType": "AddMonoid â„•",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.instSupSetSet", "iSup"],
  "name": "Set.iUnion",
  "constType": "{Î² : Type u_2} â†’ {Î¹ : Sort u_4} â†’ (Î¹ â†’ Set Î²) â†’ Set Î²",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Pure.mk",
   "Set",
   "HasSubset.Subset",
   "Pure",
   "Filter",
   "Filter.instPureFilter.proof_1",
   "Set.instMembershipSet"],
  "name": "Filter.instPureFilter",
  "constType": "Pure Filter",
  "constCategory": "Definition"},
 {"references":
  ["Option.none", "Eq.refl", "Option.some", "Option.casesOn", "Eq", "Option"],
  "name": "List.pairwise_filterMap.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : Option Î± â†’ Prop) (x : Option Î±),\n  (x = none â†’ motive none) â†’ (âˆ€ (b : Î±), x = some b â†’ motive (some b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u â†’ Sort v â†’ Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Set.preimage",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Iff.rfl",
   "Set",
   "Topology.upper",
   "FunLike.coe",
   "Preorder",
   "IsOpen",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.isOpen_preimage_ofUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, IsOpen (â†‘Topology.WithUpper.ofUpper â»Â¹' s) â†” TopologicalSpace.IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool", "Eq"],
  "name": "ne_true_of_eq_false.match_1",
  "constType":
  "âˆ€ (motive : (x : Bool) â†’ x = false â†’ Prop) (x : Bool) (x_1 : x = false),\n  (âˆ€ (h : true = false), motive true h) â†’ (âˆ€ (x : false = false), motive false x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "congr_arg",
   "Iff.mp",
   "Iff",
   "Subtype.val",
   "Multiset.Nodup.pmap",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Subtype.mk",
   "Subtype"],
  "name": "Fintype.subtype.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (s : Finset Î±) (H : âˆ€ (x : Î±), x âˆˆ s â†” p x),\n  Multiset.Nodup (Multiset.pmap Subtype.mk s.val (_ : âˆ€ x âˆˆ s, p x))",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.principal_eq_iff_eq",
   "Filter.principal",
   "propext",
   "Set",
   "Filter",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.19",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, (Filter.principal s = Filter.principal t) = (s = t)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.right_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Equiv.apply_symm_apply",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} (e : Î± â‰ƒ Î²) (x : Î²), â†‘e (â†‘e.symm x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "Filter.mem_of_superset",
   "Filter.generate",
   "HasSubset.Subset",
   "LE.le",
   "Filter.GenerateSets.recOn",
   "Preorder.toLE",
   "Filter.univ_mem",
   "Set.instMembershipSet",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "Filter.inter_mem",
   "Filter.instPartialOrderFilter",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.le_generate_iff",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set (Set Î±)} {f : Filter Î±}, f â‰¤ Filter.generate s â†” s âŠ† f.sets",
  "constCategory": "Theorem"},
 {"references": ["Set.range", "SupSet", "SupSet.sSup"],
  "name": "iSup",
  "constType":
  "{Î± : Type u_1} â†’ [inst : SupSet Î±] â†’ {Î¹ : Sort u_9} â†’ (Î¹ â†’ Î±) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Trunc.instSubsingletonTrunc.proof_1", "Subsingleton", "Trunc"],
  "name": "Trunc.instSubsingletonTrunc",
  "constType": "âˆ€ {Î± : Sort u_1}, Subsingleton (Trunc Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "Eq.rec",
   "exists_exists_eq_and.match_1",
   "And.intro",
   "Exists.intro",
   "Eq.symm",
   "rfl",
   "exists_exists_eq_and.match_2",
   "Eq"],
  "name": "exists_exists_eq_and",
  "constType":
  "âˆ€ {Î± : Sort u_3} {Î² : Sort u_2} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b) â†” âˆƒ a, p (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.toHomeomorphOfInducing.proof_1",
   "Equiv.right_inv",
   "Homeomorph",
   "Equiv.toHomeomorphOfInducing.proof_2",
   "Equiv.left_inv",
   "Equiv.mk",
   "TopologicalSpace",
   "Inducing",
   "FunLike.coe",
   "Homeomorph.mk",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.toHomeomorphOfInducing",
  "constType":
  "{X : Type u_1} â†’\n  {Y : Type u_2} â†’ [inst : TopologicalSpace X] â†’ [inst_1 : TopologicalSpace Y] â†’ (f : X â‰ƒ Y) â†’ Inducing â†‘f â†’ X â‰ƒâ‚œ Y",
  "constCategory": "Definition"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.Perm",
   "of_eq_true",
   "List",
   "List.nil",
   "List.Perm.rec",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "rfl",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.Perm.length_eq",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.length lâ‚ = List.length lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "CompleteBooleanAlgebra.toSupSet",
   "Set",
   "Inf.inf",
   "SupSet.sSup",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteBooleanAlgebra.inf_sSup_le_iSup_inf",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.nodup_cons",
   "Iff.mp",
   "List.Nodup",
   "List.instMembershipList",
   "List",
   "Not",
   "And.left"],
  "name": "List.Nodup.not_mem",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±} {a : Î±}, List.Nodup (a :: l) â†’ Â¬a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.cons",
   "List",
   "List.isSetoid",
   "Quot",
   "List.Perm.cons",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.cons.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (x x_1 : List Î±), Setoid.r x x_1 â†’ Quot.mk Setoid.r (a :: x) = Quot.mk Setoid.r (a :: x_1)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.num", "Nat", "Lean.Name"],
  "name": "Lean.Name.mkNum",
  "constType": "Lean.Name â†’ â„• â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["T0Space.casesOn",
   "TopologicalSpace",
   "T0Space.mk",
   "T0Space",
   "Inseparable",
   "Eq"],
  "name": "t0Space_iff_inseparable.match_1",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : TopologicalSpace Î±] (motive : T0Space Î± â†’ Prop) (x : T0Space Î±),\n  (âˆ€ (h : âˆ€ â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y), motive (_ : T0Space Î±)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter.mem_inf_iff",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.20",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, (s âˆˆ f âŠ“ g) = âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, s = tâ‚ âˆ© tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.inj'",
   "Function.Embedding.toFun",
   "EmbeddingLike.mk",
   "Function.instEmbeddingLikeEmbedding.proof_1",
   "FunLike.mk",
   "EmbeddingLike",
   "Function.Embedding"],
  "name": "Function.instEmbeddingLikeEmbedding",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ EmbeddingLike (Î± â†ª Î²) Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["EStateM", "EStateM.bind.match_1", "EStateM.Result", "EStateM.Result.error"],
  "name": "EStateM.bind",
  "constType":
  "{Îµ Ïƒ Î± Î² : Type u} â†’ EStateM Îµ Ïƒ Î± â†’ (Î± â†’ EStateM Îµ Ïƒ Î²) â†’ EStateM Îµ Ïƒ Î²",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.64",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.mem_Iic",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {b x : Î±}, x âˆˆ Set.Iic b â†” x â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["GeneralizedHeytingAlgebra.toDistribLattice.proof_1",
   "DistribLattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "DistribLattice.ofInfSupLe",
   "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toDistribLattice",
  "constType":
  "{Î± : Type u_2} â†’ [inst : GeneralizedHeytingAlgebra Î±] â†’ DistribLattice Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ConditionallyCompleteLattice",
  "constType": "Type u_5 â†’ Type u_5",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.length_eq",
   "List.filter",
   "Eq.mpr",
   "Eq.ndrec",
   "List.Perm",
   "List",
   "Eq.refl",
   "Bool",
   "List.length",
   "List.countP",
   "Nat",
   "List.Perm.filter",
   "List.countP_eq_length_filter",
   "id",
   "Eq"],
  "name": "List.Perm.countP_eq",
  "constType":
  "âˆ€ {Î± : Type uu} (p : Î± â†’ Bool) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.countP p lâ‚ = List.countP p lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Lean.TSyntax", "Array", "Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntaxArray",
  "constType": "Lean.SyntaxNodeKinds â†’ Type",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpper.topology_eq_upperTopology",
   "Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.topology_eq",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±],\n  inst_1 = Topology.upper Î±",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SDiff",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Macro.Exception",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.33",
  "constType": "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (Î± â†’ b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "sSupHom",
   "sSupHomClass.mk",
   "FunLike.mk",
   "sSupHom.toFun",
   "sSupHomClass",
   "sSupHom.map_sSup'",
   "sSupHom.instSSupHomClassSSupHom.proof_1"],
  "name": "sSupHom.instSSupHomClassSSupHom",
  "constType":
  "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : SupSet Î±] â†’ [inst_1 : SupSet Î²] â†’ sSupHomClass (sSupHom Î± Î²) Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["Quot.rec",
   "Subsingleton",
   "Quot.recOnSubsingleton'.proof_1",
   "Quot",
   "Quot.mk"],
  "name": "Quot.recOnSubsingleton'",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : Quot r â†’ Sort v} â†’\n      [h : âˆ€ (a : Î±), Subsingleton (motive (Quot.mk r a))] â†’ (q : Quot r) â†’ ((a : Î±) â†’ motive (Quot.mk r a)) â†’ motive q",
  "constCategory": "Definition"},
 {"references": ["LE", "LE.le"],
  "name": "IsBot",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Bool", "Lean.Data.AC.ContextInformation"],
  "name": "Lean.Data.AC.ContextInformation.isIdem",
  "constType":
  "{Î± : Sort u} â†’ [self : Lean.Data.AC.ContextInformation Î±] â†’ Î± â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Filter.GenerateSets.inter",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.GenerateSets.rec",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.GenerateSets.recOn",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {motive : (a : Set Î±) â†’ Filter.GenerateSets g a â†’ Prop} {a : Set Î±}\n  (t : Filter.GenerateSets g a),\n  (âˆ€ {s : Set Î±} (a : s âˆˆ g), motive s (_ : Filter.GenerateSets g s)) â†’\n    motive Set.univ (_ : Filter.GenerateSets g Set.univ) â†’\n      (âˆ€ {s t : Set Î±} (a : Filter.GenerateSets g s) (a_1 : s âŠ† t),\n          motive s a â†’ motive t (_ : Filter.GenerateSets g t)) â†’\n        (âˆ€ {s t : Set Î±} (a : Filter.GenerateSets g s) (a_1 : Filter.GenerateSets g t),\n            motive s a â†’ motive t a_1 â†’ motive (s âˆ© t) (_ : Filter.GenerateSets g (s âˆ© t))) â†’\n          motive a t",
  "constCategory": "Definition"},
 {"references": ["Array", "List.get", "Array.size", "Fin", "Array.data"],
  "name": "Array.get",
  "constType": "{Î± : Type u} â†’ (a : Array Î±) â†’ Fin (Array.size a) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "And.intro",
   "Exists.intro",
   "Preorder",
   "And.casesOn",
   "Exists.casesOn",
   "lowerClosure",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "lowerClosure_min.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} (_a : Î±) (motive : _a âˆˆ â†‘(lowerClosure s) â†’ Prop)\n  (x : _a âˆˆ â†‘(lowerClosure s)), (âˆ€ (_b : Î±) (hb : _b âˆˆ s) (hab : _a â‰¤ _b), motive (_ : âˆƒ a âˆˆ s, _a â‰¤ a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSet_toUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±), â†‘Topology.WithUpperSet.ofUpperSet (â†‘Topology.WithUpperSet.toUpperSet a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Or",
   "Or.inl",
   "Or.inr",
   "Exists.intro",
   "Or.casesOn",
   "Exists.casesOn"],
  "name": "exists_or.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} (motive : ((âˆƒ x, p x) âˆ¨ âˆƒ x, q x) â†’ Prop) (x : (âˆƒ x, p x) âˆ¨ âˆƒ x, q x),\n  (âˆ€ (x : Î±) (h : p x), motive (_ : (âˆƒ x, p x) âˆ¨ âˆƒ x, q x)) â†’\n    (âˆ€ (x : Î±) (h : q x), motive (_ : (âˆƒ x, p x) âˆ¨ âˆƒ x, q x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["forall_eq", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.34",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.add_succ",
   "Nat.sub_ne_zero_of_lt",
   "instSubNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.sub_succ",
   "True",
   "Eq",
   "Nat.succ_pred",
   "Eq.mpr",
   "instLENat",
   "Nat.pred",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "id",
   "instHSub",
   "eq_self",
   "Nat.succ_add",
   "Ne",
   "instAddNat",
   "instHAdd",
   "HSub.hSub",
   "Nat.le_of_succ_le",
   "LE.le",
   "Nat.zero_add",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "of_eq_true",
   "congrArg",
   "congrFun"],
  "name": "Nat.add_sub_of_le",
  "constType": "âˆ€ {a b : â„•}, a â‰¤ b â†’ a + (b - a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "Nat.add_assoc.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.add_assoc",
  "constType": "âˆ€ (n m k : â„•), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "instTransLeToLE",
   "sup_comm",
   "LE.le",
   "Preorder.toLE",
   "inf_le_inf_left",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "sup_inf_right",
   "instTransEq_1",
   "Eq.mpr",
   "Eq.ndrec",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "le_refl",
   "sup_le_sup_left",
   "sup_le",
   "Sup.sup",
   "le_sup_right",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "sup_inf_left",
   "id"],
  "name": "le_of_inf_le_sup_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DistribLattice Î±] {x y z : Î±}, x âŠ“ z â‰¤ y âŠ“ z â†’ x âŠ” z â‰¤ y âŠ” z â†’ x â‰¤ y",
  "constCategory": "Theorem"},
 {"references": ["Mod"],
  "name": "Mod.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Mod Î±",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Set.instSProd",
   "Mathlib.Topology.Constructions._auxLemma.11",
   "nhds_prod_eq",
   "instTopologicalSpaceProd",
   "nhds",
   "Set",
   "Inf.inf",
   "Filter.instSProd",
   "True",
   "Eq",
   "Filter.principal",
   "of_eq_true",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "congr",
   "TopologicalSpace",
   "Filter",
   "Prod",
   "nhdsWithin",
   "congrArg",
   "Filter.prod_principal_principal",
   "Eq.trans",
   "congrFun"],
  "name": "nhdsWithin_prod_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (a : Î±) (b : Î²) (s : Set Î±)\n  (t : Set Î²), nhdsWithin (a, b) (s Ã—Ë¢ t) = nhdsWithin a s Ã—Ë¢ nhdsWithin b t",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap._sunfold.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (a : Î±) (l : List Î±), (âˆ€ a_1 âˆˆ a :: l, p a_1) â†’ âˆ€ x âˆˆ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Std.Data.List.Pairwise._auxLemma.6",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "Eq.refl",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "List.Pairwise",
   "instHAppend",
   "And",
   "Eq.mpr",
   "Iff",
   "List.instAppendList",
   "Eq.ndrec",
   "of_eq_true",
   "forall_congr",
   "propext",
   "List",
   "HAppend.hAppend",
   "congr",
   "List.pairwise_append",
   "List.nil",
   "List.append_assoc",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "List.pairwise_append_comm",
   "Std.Data.List.Pairwise._auxLemma.7",
   "id"],
  "name": "List.pairwise_middle",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop},\n  (âˆ€ {x y : Î±}, R x y â†’ R y x) â†’\n    âˆ€ {a : Î±} {lâ‚ lâ‚‚ : List Î±}, List.Pairwise R (lâ‚ ++ a :: lâ‚‚) â†” List.Pairwise R (a :: (lâ‚ ++ lâ‚‚))",
  "constCategory": "Theorem"},
 {"references": ["Subtype.mk", "Subtype", "Subtype.casesOn"],
  "name": "Fintype.subtype.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (motive : { x // p x } â†’ Prop) (x : { x // p x }),\n  (âˆ€ (x : Î±) (px : p x), motive { val := x, property := px }) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "False",
   "List.instMembershipList",
   "List",
   "Not",
   "List.not_mem_nil.match_1",
   "List.nil"],
  "name": "List.not_mem_nil",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), Â¬a âˆˆ []",
  "constCategory": "Theorem"},
 {"references": ["Lean.MacroM", "Lean.Syntax"],
  "name": "Lean.Macro",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.range",
   "Set.Elem",
   "of_eq_true",
   "Subtype.val",
   "Subtype.range_coe",
   "Set",
   "Set.iInter",
   "congrArg",
   "Set.sInter",
   "Eq.trans",
   "True",
   "Subtype",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.sInter_eq_iInter",
  "constType": "âˆ€ {Î± : Type u_1} {s : Set (Set Î±)}, â‹‚â‚€ s = â‹‚ i, â†‘i",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.length.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ Sort u_2) â†’\n    (x : List Î±) â†’ (Unit â†’ motive []) â†’ ((head : Î±) â†’ (as : List Î±) â†’ motive (head :: as)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_4",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["semiOutParam", "MonadExceptOf"],
  "name": "MonadExceptOf.tryCatch",
  "constType":
  "{Îµ : semiOutParam (Type u)} â†’ {m : Type v â†’ Type w} â†’ [self : MonadExceptOf Îµ m] â†’ {Î± : Type v} â†’ m Î± â†’ (Îµ â†’ m Î±) â†’ m Î±",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Prop) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "MonadReaderOf",
  "constType": "semiOutParam (Type u) â†’ (Type u â†’ Type v) â†’ Type v",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpper",
   "Topology.IsUpper.upperBasis",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "TopologicalSpace.IsTopologicalBasis",
   "Topology.IsLower.isTopologicalBasis"],
  "name": "Topology.IsUpper.isTopologicalBasis",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±],\n  TopologicalSpace.IsTopologicalBasis (Topology.IsUpper.upperBasis Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "Id",
   "Pure.mk",
   "Unit",
   "Function.comp",
   "Unit.unit",
   "Function.const",
   "Seq.mk",
   "Functor.mk",
   "SeqRight.mk",
   "Applicative.mk",
   "Monad.mk",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "Id.instMonadId",
  "constType": "Monad Id",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Exists",
   "Finite",
   "Fin.fintype",
   "Fintype.ofEquiv",
   "Nonempty",
   "Iff.intro",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Iff",
   "finite_iff_nonempty_fintype.match_1",
   "Finite.exists_equiv_fin",
   "Nat",
   "finite_iff_nonempty_fintype.match_2",
   "Finite.of_fintype",
   "Fin",
   "Equiv.symm"],
  "name": "finite_iff_nonempty_fintype",
  "constType": "âˆ€ (Î± : Type u_4), Finite Î± â†” Nonempty (Fintype Î±)",
  "constCategory": "Theorem"},
 {"references": ["SizeOf", "Nat"],
  "name": "SizeOf.sizeOf",
  "constType": "{Î± : Sort u} â†’ [self : SizeOf Î±] â†’ Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{Î± Î² : Sort u} â†’ Î± = Î² â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Seq", "Unit"],
  "name": "Seq.seq",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : Seq f] â†’ {Î± Î² : Type u} â†’ f (Î± â†’ Î²) â†’ (Unit â†’ f Î±) â†’ f Î²",
  "constCategory": "Definition"},
 {"references":
  ["eq_of_nhds_eq_nhds",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "nhds",
   "Eq.rec",
   "Eq.refl",
   "Filter.comap",
   "TopologicalSpace",
   "Filter",
   "nhds_induced",
   "TopologicalSpace.induced",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "induced_iff_nhds_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] (f : Î² â†’ Î±),\n  tÎ² = TopologicalSpace.induced f tÎ± â†” âˆ€ (b : Î²), nhds b = Filter.comap f (nhds (f b))",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "OrderTop.toTop",
   "Top",
   "Prod.orderTop.proof_1",
   "Top.top",
   "Prod.instLEProd",
   "inferInstanceAs",
   "OrderTop",
   "LE",
   "Prod",
   "Top.mk",
   "Prod.top"],
  "name": "Prod.orderTop",
  "constType":
  "(Î± : Type u) â†’\n  (Î² : Type v) â†’ [inst : LE Î±] â†’ [inst_1 : LE Î²] â†’ [inst_2 : OrderTop Î±] â†’ [inst_3 : OrderTop Î²] â†’ OrderTop (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List.singleton_sublist",
   "List.Sublist",
   "List.Nodup.cons",
   "List.Nodup.sublist",
   "Iff.mpr",
   "Iff.intro",
   "List.nodup_nil",
   "Iff",
   "List.Nodup",
   "List.rec",
   "List",
   "List.sublist_cons_of_sublist",
   "List.not_nodup_pair",
   "Not",
   "List.nil",
   "List.Sublist.cons_cons"],
  "name": "List.nodup_iff_sublist",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±}, List.Nodup l â†” âˆ€ (a : Î±), Â¬List.Sublist [a, a] l",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.succ_le_succ",
   "Nat.zero_le",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.zero_lt_succ",
  "constType": "âˆ€ (n : â„•), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection", "Iff.mp", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisConnection.le_u",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ âˆ€ {a : Î±} {b : Î²}, l a â‰¤ b â†’ a â‰¤ u b",
  "constCategory": "Theorem"},
 {"references":
  ["and_assoc.match_2",
   "Iff.intro",
   "And",
   "Iff",
   "and_assoc.match_1",
   "And.intro"],
  "name": "and_assoc",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b) âˆ§ c â†” a âˆ§ b âˆ§ c",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "FunLike.coe",
   "Set.image",
   "sInfHomClass",
   "Eq"],
  "name": "sInfHomClass.mk",
  "constType":
  "{F : Type u_8} â†’\n  {Î± : outParam (Type u_9)} â†’\n    {Î² : outParam (Type u_10)} â†’\n      [inst : InfSet Î±] â†’\n        [inst_1 : InfSet Î²] â†’\n          [toFunLike : FunLike F Î± fun x â†¦ Î²] â†’\n            (âˆ€ (f : F) (s : Set Î±), â†‘f (sInf s) = sInf (â†‘f '' s)) â†’ sInfHomClass F Î± Î²",
  "constCategory": "Other"},
 {"references": ["Setoid", "Quotient.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.inductionOnâ‚‚",
  "constType":
  "âˆ€ {Î± : Sort uA} {Î² : Sort uB} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} {motive : Quotient sâ‚ â†’ Quotient sâ‚‚ â†’ Prop}\n  (qâ‚ : Quotient sâ‚) (qâ‚‚ : Quotient sâ‚‚),\n  (âˆ€ (a : Î±) (b : Î²), motive (Quotient.mk sâ‚ a) (Quotient.mk sâ‚‚ b)) â†’ motive qâ‚ qâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "âˆ€ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.cons",
   "Finset.instMembershipFinset",
   "Not",
   "Finset.cons_induction"],
  "name": "Finset.cons_induction_on",
  "constType":
  "âˆ€ {Î± : Type u_4} {p : Finset Î± â†’ Prop} (s : Finset Î±),\n  p âˆ… â†’ (âˆ€ â¦ƒa : Î±â¦„ {s : Finset Î±} (h : Â¬a âˆˆ s), p s â†’ p (Finset.cons a s h)) â†’ p s",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "exists_or.match_2",
   "exists_or.match_1",
   "Exists.intro"],
  "name": "exists_or",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆƒ x, p x âˆ¨ q x) â†” (âˆƒ x, p x) âˆ¨ âˆƒ x, q x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.IsUpperSet.mk",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "TopologicalSpace",
   "Preorder",
   "rfl",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name":
  "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsUpperSet (Topology.WithUpperSet Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.nodup_zero",
   "Multiset.instZeroMultiset",
   "Finset",
   "Multiset",
   "Finset.mk"],
  "name": "Finset.empty",
  "constType": "{Î± : Type u_1} â†’ Finset Î±",
  "constCategory": "Definition"},
 {"references": ["True.intro", "forall_prop_of_true", "Iff", "True"],
  "name": "forall_true_left",
  "constType": "âˆ€ (p : True â†’ Prop), (âˆ€ (x : True), p x) â†” p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "TopologicalSpace.generateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Set",
   "Function.comp",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "GaloisCoinsertion.liftCompleteLattice",
   "Equiv.instFunLikeEquiv",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "OrderDual.completeLattice",
   "TopologicalSpace",
   "OrderDual",
   "TopologicalSpace.gciGenerateFrom",
   "IsOpen"],
  "name": "TopologicalSpace.instCompleteLatticeTopologicalSpace",
  "constType": "{Î± : Type u} â†’ CompleteLattice (TopologicalSpace Î±)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "TopologicalSpace",
   "coinduced_le_iff_le_induced",
   "TopologicalSpace.induced",
   "TopologicalSpace.coinduced"],
  "name": "gc_coinduced_induced",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²),\n  GaloisConnection (TopologicalSpace.coinduced f) (TopologicalSpace.induced f)",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) â†’ [inst : Add G] â†’ Prop",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{Î± : Type u_1} â†’ [inst : One Î±] â†’ OfNat Î± 1",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Inf.mk",
   "And.right",
   "Or",
   "DistribLattice",
   "Or.inl",
   "Prop.distribLattice.proof_3",
   "Or.inr",
   "Prop.distribLattice.proof_1",
   "DistribLattice.mk",
   "Prop.distribLattice.proof_2",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Prop.partialOrder",
   "And.left",
   "Sup.mk"],
  "name": "Prop.distribLattice",
  "constType": "DistribLattice Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "IsRightCancelAdd",
   "Add",
   "Eq"],
  "name": "add_right_cancel",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] {a b c : G}, a + b = c + b â†’ a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Set.Elem", "Finset.toSet", "Finset", "Finset.Subtype.fintype"],
  "name": "FinsetCoe.fintype",
  "constType": "{Î± : Type u_1} â†’ (s : Finset Î±) â†’ Fintype â†‘â†‘s",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.instHasSubsetSet",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HasSubset.Subset",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "sSup_le",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.sUnion_subset",
  "constType":
  "âˆ€ {Î± : Type u_1} {S : Set (Set Î±)} {t : Set Î±}, (âˆ€ t' âˆˆ S, t' âŠ† t) â†’ â‹ƒâ‚€ S âŠ† t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "And.right",
   "Prod.snd",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Prod.fst",
   "Exists.intro",
   "Set.instMembershipSet",
   "Set.Nonempty.fst.match_1"],
  "name": "Set.Nonempty.snd",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, Set.Nonempty (s Ã—Ë¢ t) â†’ Set.Nonempty t",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec", "Exists", "Classical.choose", "Exists.intro"],
  "name": "Classical.axiomOfChoice",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {r : (x : Î±) â†’ Î² x â†’ Prop}, (âˆ€ (x : Î±), âˆƒ y, r x y) â†’ âˆƒ f, âˆ€ (x : Î±), r x (f x)",
  "constCategory": "Theorem"},
 {"references": ["IsAssociative", "IsAssociative.assoc", "Eq"],
  "name": "instIsAssociative.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {op : Î± â†’ Î± â†’ Î±} [inst : IsAssociative Î± op] (a b c : Î±), op (op a b) c = op a (op b c)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.nil"],
  "name": "List.rec",
  "constType":
  "{Î± : Type u} â†’\n  {motive : List Î± â†’ Sort u_1} â†’\n    motive [] â†’ ((head : Î±) â†’ (tail : List Î±) â†’ motive tail â†’ motive (head :: tail)) â†’ (t : List Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["outParam", "SetLike", "Function.Injective", "Set"],
  "name": "SetLike.mk",
  "constType":
  "{A : Type u_1} â†’ {B : outParam (Type u_2)} â†’ (coe : A â†’ Set B) â†’ Function.Injective coe â†’ SetLike A B",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Exists", "False", "Exists.intro", "Exists.casesOn"],
  "name": "exists_false.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (motive : (âˆƒ _a, False) â†’ Prop) (x : âˆƒ _a, False),\n  (âˆ€ (w : Î±) (h : False), motive (_ : âˆƒ _a, False)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mpr",
   "Eq.ndrec",
   "Function.sometimes_eq",
   "Function.sometimes",
   "Eq.refl",
   "Nonempty",
   "Eq",
   "id"],
  "name": "Function.sometimes_spec",
  "constType":
  "âˆ€ {p : Prop} {Î± : Sort u_1} [inst : Nonempty Î±] (P : Î± â†’ Prop) (f : p â†’ Î±) (a : p), P (f a) â†’ P (Function.sometimes f)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "OrderedCancelAddCommMonoid",
   "le_of_add_le_add_left",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Eq.ge",
   "Eq.le",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.to_contravariantClass_le_left",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] (a b c : Î±), a + b = a + c â†’ b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.Perm.dedup",
   "DecidableEq",
   "List.dedup",
   "List",
   "List.isSetoid",
   "Quot",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.dedup.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (x x_1 : List Î±),\n  Setoid.r x x_1 â†’ Quot.mk Setoid.r (List.dedup x) = Quot.mk Setoid.r (List.dedup x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "And.left",
   "implies_congr",
   "instLTNat",
   "Eq",
   "List.get_cons_drop",
   "Iff.mp",
   "List.Sublist.consâ‚‚",
   "Nat",
   "Eq.trans",
   "Nat.min_eq_left",
   "List.nil_sublist",
   "Fin.val",
   "eq_of_heq",
   "List.length",
   "And",
   "instHAppend",
   "eq_true",
   "HEq.refl",
   "of_eq_true",
   "HAppend.hAppend",
   "LT.lt",
   "List.length_take",
   "Eq.mp",
   "congrArg",
   "Fin",
   "HEq",
   "List.instMembershipList",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.append",
   "List.Pairwise.of_cons",
   "List.nil_append",
   "List.take",
   "rfl",
   "True",
   "instLENat",
   "List.rec",
   "forall_congr",
   "Eq.rec",
   "instOfNatNat",
   "List.nil",
   "Eq.symm",
   "List.take_append_drop",
   "Fin.isLt",
   "id",
   "Std.Data.List.Lemmas._auxLemma.29",
   "eq_self",
   "Membership.mem",
   "List.drop_append_of_le_length",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "implies_true",
   "List.drop",
   "Init.Data.Nat.Basic._auxLemma.1",
   "LE.le",
   "List.Pairwise",
   "Eq.ndrec",
   "List.instAppendList",
   "List.pairwise_cons",
   "List",
   "List.Mem.head",
   "List.map",
   "Eq.casesOn",
   "Nat.le_of_lt",
   "List.get",
   "instMinNat"],
  "name": "List.map_get_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {is : List (Fin (List.length l))},\n  List.Pairwise (fun x x_1 â†¦ â†‘x < â†‘x_1) is â†’ List.Sublist (List.map (List.get l) is) l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "disjoint_assoc",
   "Inf.inf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.62",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a b c : Î±}, Disjoint (a âŠ“ b) c = Disjoint a (b âŠ“ c)",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "HEq",
   "compl_compl",
   "Set",
   "eq_of_heq",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "HEq.refl",
   "LE",
   "Eq.casesOn",
   "IsLowerSet.compl",
   "Eq.symm",
   "IsUpperSet.compl",
   "id"],
  "name": "isUpperSet_compl",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s : Set Î±}, IsUpperSet sá¶œ â†” IsLowerSet s",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "CompleteAtomicBooleanAlgebra",
   "CompleteLattice.toTop",
   "HasCompl.compl",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.top_le_sup_compl",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (x : Î±), âŠ¤ â‰¤ x âŠ” xá¶œ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "List.pairwise_pwFilter",
   "DecidableEq",
   "List.dedup",
   "List",
   "instDecidableNot",
   "Eq"],
  "name": "List.nodup_dedup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] (l : List Î±), List.Nodup (List.dedup l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Not"],
  "name": "List.decidableBAll.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Prop) (x : Î±) (xs : List Î±), (Â¬âˆ€ x âˆˆ xs, p x) â†’ (âˆ€ x_1 âˆˆ x :: xs, p x_1) â†’ False",
  "constCategory": "Theorem"},
 {"references": ["Bot", "Bot.bot", "Bot.mk"],
  "name": "Pi.instBotForAll",
  "constType":
  "{Î¹ : Type u_3} â†’ {Î±' : Î¹ â†’ Type u_4} â†’ [inst : (i : Î¹) â†’ Bot (Î±' i)] â†’ Bot ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references":
  ["Codisjoint",
   "PartialOrder.toPreorder",
   "Disjoint",
   "IsCompl",
   "BoundedOrder.toOrderTop",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : BoundedOrder Î±] {x y : Î±},\n  Disjoint x y â†’ Codisjoint x y â†’ IsCompl x y",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.not_succ_le_self.match_1",
   "LE.le",
   "Nat.not_succ_le_zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "PUnit",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.not_succ_le_self",
  "constType": "âˆ€ (n : â„•), Â¬Nat.succ n â‰¤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "List.Pairwise.nil",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_zero",
  "constType": "âˆ€ {Î± : Type u_1}, Multiset.Nodup 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "List.forall_mem_map_iff",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.69",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {l : List Î±} {P : Î² â†’ Prop}, (âˆ€ i âˆˆ List.map f l, P i) = âˆ€ j âˆˆ l, P (f j)",
  "constCategory": "Theorem"},
 {"references": ["Top", "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toTop",
  "constType": "{Î± : Type u_4} â†’ [self : GeneralizedHeytingAlgebra Î±] â†’ Top Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "Function.comp",
   "Set",
   "Filter.Tendsto",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.Tendsto.comp",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {f : Î± â†’ Î²} {g : Î² â†’ Î³} {x : Filter Î±} {y : Filter Î²} {z : Filter Î³},\n  Filter.Tendsto g y z â†’ Filter.Tendsto f x y â†’ Filter.Tendsto (g âˆ˜ f) x z",
  "constCategory": "Theorem"},
 {"references": ["Inf", "TopologicalSpace"],
  "name": "ContinuousInf",
  "constType":
  "(L : Type u_1) â†’ [inst : TopologicalSpace L] â†’ [inst : Inf L] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Set", "LE", "LE.le", "Set.instMembershipSet"],
  "name": "IsUpperSet",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop â†’ Prop â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Array.mkArray2",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node2",
  "constType":
  "Lean.SourceInfo â†’ Lean.SyntaxNodeKind â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.33",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {l : List Î±}, (a âˆˆ b :: l) = (a = b âˆ¨ a âˆˆ l)",
  "constCategory": "Theorem"},
 {"references": ["False", "False.casesOn"],
  "name": "List.Sublist.eq_of_length.match_1",
  "constType": "âˆ€ (motive : False â†’ Prop) (x : False), motive x",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "List.erase.match_1",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ (Unit â†’ motive true) â†’ (Unit â†’ motive false) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper.instInhabitedWithUpper._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpper.instInhabitedWithUpper._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.cons",
   "List.instMembershipList",
   "Unit",
   "HasSubset.Subset",
   "List.subset_nil.match_1",
   "rfl",
   "Eq",
   "Iff.intro",
   "Iff",
   "List.Subset.refl",
   "List",
   "List.Mem.head",
   "List.not_mem_nil.match_1",
   "List.nil",
   "List.subset_nil.match_2"],
  "name": "List.subset_nil",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, l âŠ† [] â†” l = []",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOnâ‚‚",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "List.append_assoc",
   "Nat",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Multiset.instZeroMultiset",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "instHAppend",
   "Setoid.r",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "Zero.mk",
   "Quotient.inductionOnâ‚ƒ",
   "Quotient.inductionOn",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
  "constType": "âˆ€ {Î± : Type u_1} (s t : Multiset Î±), s + t = t + s",
  "constCategory": "Theorem"},
 {"references": ["Iff", "False", "Not", "iff_of_false", "id"],
  "name": "iff_false_intro",
  "constType": "âˆ€ {a : Prop}, Â¬a â†’ (a â†” False)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Nat.right_distrib",
  "constType": "âˆ€ (n m k : â„•), (n + m) * k = n * k + m * k",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq â„•",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Exists",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Nat",
   "congrArg",
   "Eq.trans",
   "LE.le",
   "Eq"],
  "name": "Nat.add_le_add_left",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ âˆ€ (k : â„•), k + n â‰¤ k + m",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "MonadReader",
  "constType": "outParam (Type u) â†’ (Type u â†’ Type v) â†’ Type v",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "instOfNatNat",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "True",
   "Fin.succ_pos",
   "Fin",
   "Eq"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.15",
  "constType": "âˆ€ {n : â„•} (a : Fin n), (0 < Fin.succ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_succ",
   "Nat.succ_le_of_lt",
   "instLENat",
   "Nat.lt_of_succ_le",
   "instAddNat",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat",
   "Nat.add_le_add_left",
   "Eq"],
  "name": "Nat.add_lt_add_left",
  "constType": "âˆ€ {n m : â„•}, n < m â†’ âˆ€ (k : â„•), k + n < k + m",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "instHAppend",
   "PProd.fst",
   "List.cons",
   "List.instAppendList",
   "List.Perm",
   "List.rec",
   "List.below",
   "List.brecOn",
   "HAppend.hAppend",
   "List",
   "PUnit",
   "List.Perm.append_left.match_1",
   "List.nil",
   "List.Perm.cons"],
  "name": "List.Perm.append_left",
  "constType":
  "âˆ€ {Î± : Type uu} {tâ‚ tâ‚‚ : List Î±} (l : List Î±), tâ‚ ~ tâ‚‚ â†’ l ++ tâ‚ ~ l ++ tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Unit",
   "Unit.unit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.beq.match_1",
  "constType":
  "(motive : Lean.Name â†’ Lean.Name â†’ Sort u_1) â†’\n  (x x_1 : Lean.Name) â†’\n    (Unit â†’ motive Lean.Name.anonymous Lean.Name.anonymous) â†’\n      ((pâ‚ : Lean.Name) â†’\n          (sâ‚ : String) â†’ (pâ‚‚ : Lean.Name) â†’ (sâ‚‚ : String) â†’ motive (Lean.Name.str pâ‚ sâ‚) (Lean.Name.str pâ‚‚ sâ‚‚)) â†’\n        ((pâ‚ : Lean.Name) â†’\n            (nâ‚ : â„•) â†’ (pâ‚‚ : Lean.Name) â†’ (nâ‚‚ : â„•) â†’ motive (Lean.Name.num pâ‚ nâ‚) (Lean.Name.num pâ‚‚ nâ‚‚)) â†’\n          ((x x_2 : Lean.Name) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Fin.ne_of_val_ne",
   "instDecidableEqFin.match_1",
   "DecidableEq",
   "Fin.eq_of_val_eq",
   "Decidable.isFalse",
   "Fin.val",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Nat",
   "decEq",
   "instDecidableEqNat",
   "Fin",
   "Eq"],
  "name": "instDecidableEqFin",
  "constType": "(n : â„•) â†’ DecidableEq (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.to_contravariantClass_le_left.proof_1",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "ContravariantClass",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.to_contravariantClass_le_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : OrderedCancelAddCommMonoid Î±], ContravariantClass Î± Î± (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references": ["Unit", "SeqLeft"],
  "name": "SeqLeft.seqLeft",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : SeqLeft f] â†’ {Î± Î² : Type u} â†’ f Î± â†’ (Unit â†’ f Î²) â†’ f Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Topology.WithLower",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "Eq.rec", "rfl", "Eq"],
  "name": "List.hasDecEq.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (as : List Î±) (b : Î±) (bs : List Î±), a = b â†’ as = bs â†’ a :: as = b :: bs",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom", "Set", "InfSet.sInf", "sInfHom.mk", "InfSet", "Set.image", "Eq"],
  "name": "sInfHom.rec",
  "constType":
  "{Î± : Type u_8} â†’\n  {Î² : Type u_9} â†’\n    [inst : InfSet Î±] â†’\n      [inst_1 : InfSet Î²] â†’\n        {motive : sInfHom Î± Î² â†’ Sort u} â†’\n          ((toFun : Î± â†’ Î²) â†’\n              (map_sInf' : âˆ€ (s : Set Î±), toFun (sInf s) = sInf (toFun '' s)) â†’\n                motive { toFun := toFun, map_sInf' := map_sInf' }) â†’\n            (t : sInfHom Î± Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "isOpen_induced_iff",
   "Set.preimage",
   "propext",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "IsOpen",
   "Eq"],
  "name": "Mathlib.Topology.Order._auxLemma.15",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [t : TopologicalSpace Î²] {s : Set Î±} {f : Î± â†’ Î²},\n  IsOpen s = âˆƒ t_1, IsOpen t_1 âˆ§ f â»Â¹' t_1 = s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "âˆ€ {Î± : Type u} [self : StrictOrderedSemiring Î±] (a b c : Î±), a + b â‰¤ a + c â†’ b â‰¤ c",
  "constCategory": "Definition"},
 {"references":
  ["eq_false_of_ne_true.match_1",
   "False.elim",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "rfl",
   "Eq"],
  "name": "eq_false_of_ne_true",
  "constType": "âˆ€ {b : Bool}, Â¬b = true â†’ b = false",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "trivial", "Set", "Set.univ", "Set.instMembershipSet"],
  "name": "Set.mem_univ",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), x âˆˆ Set.univ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Lean.Data.AC.ContextInformation", "Bool", "Nat"],
  "name": "Lean.Data.AC.ContextInformation.mk",
  "constType":
  "{Î± : Sort u} â†’ (Î± â†’ â„• â†’ Bool) â†’ (Î± â†’ Bool) â†’ (Î± â†’ Bool) â†’ Lean.Data.AC.ContextInformation Î±",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "OrderBot.bot_le",
   "GaloisInsertion.liftBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "GaloisInsertion",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_7",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±]\n  (gi : GaloisInsertion l u) (a : Î²), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "eq_self",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "True",
   "Eq",
   "Nat.succ_sub_succ",
   "Nat.rec",
   "of_eq_true",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.add_sub_add_right",
  "constType": "âˆ€ (n k m : â„•), n + k - (m + k) = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.toLowerSet_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±},\n  â†‘Topology.WithLowerSet.toLowerSet a â‰¤ â†‘Topology.WithLowerSet.toLowerSet b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Covariant",
  "constType":
  "(M : Type u_1) â†’ (N : Type u_2) â†’ (M â†’ N â†’ N) â†’ (N â†’ N â†’ Prop) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "mem_lowerClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {x : Î±}, x âˆˆ lowerClosure s â†” âˆƒ a âˆˆ s, x â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "setOf",
   "Set.subset_sInter",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "IsClosed"],
  "name": "subset_closure",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, s âŠ† closure s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.num",
   "List",
   "String",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.MacroScope",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractMacroScopesAux.match_1",
  "constType":
  "(motive : Lean.Name â†’ List Lean.MacroScope â†’ Sort u_1) â†’\n  (x : Lean.Name) â†’\n    (x_1 : List Lean.MacroScope) â†’\n      ((p : Lean.Name) â†’ (scp : â„•) â†’ (acc : List Lean.MacroScope) â†’ motive (Lean.Name.num p scp) acc) â†’\n        ((p : Lean.Name) â†’ (str : String) â†’ (acc : List Lean.MacroScope) â†’ motive (Lean.Name.str p str) acc) â†’\n          ((x : Lean.Name) â†’ (x_2 : List Lean.MacroScope) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "Iff",
   "forall_swap",
   "Function.comp",
   "Monotone",
   "OrderDual",
   "FunLike.coe",
   "Preorder",
   "Antitone",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "antitone_comp_ofDual_iff",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Antitone (f âˆ˜ â†‘OrderDual.ofDual) â†” Monotone f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "propext",
   "Continuous",
   "continuous_iff_le_induced",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order._auxLemma.26",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ : TopologicalSpace Î²},\n  Continuous f = (tâ‚ â‰¤ TopologicalSpace.induced f tâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.mem_replicate.match_1",
   "Std.Data.List.Lemmas._auxLemma.2",
   "Std.Data.Nat.Lemmas._auxLemma.3",
   "HAdd.hAdd",
   "eq_true_of_decide",
   "optParam",
   "instLTNat",
   "instDecidableEqNat",
   "Eq",
   "PProd",
   "Eq.mpr",
   "Iff",
   "Bool.true",
   "PUnit",
   "Std.Logic._auxLemma.42",
   "or_false",
   "Nat",
   "Eq.trans",
   "false_or",
   "Nat.brecOn",
   "Or",
   "List.range'",
   "Std.Logic._auxLemma.48",
   "Std.Logic._auxLemma.38",
   "exists_comm",
   "And",
   "instHMul",
   "Std.Logic._auxLemma.30",
   "PProd.fst",
   "Nat.rec",
   "Nat.zero",
   "of_eq_true",
   "propext",
   "Nat.noConfusion",
   "LT.lt",
   "instInhabitedNat",
   "congr",
   "congrArg",
   "congrFun",
   "Std.Data.List.Lemmas._auxLemma.105",
   "Nat.add_assoc",
   "Exists",
   "Nat.add_comm",
   "false_and",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.8",
   "Eq.refl",
   "True",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "instLENat",
   "Std.Data.List.Lemmas._auxLemma.103",
   "eq_false'",
   "instOfNatNat",
   "List.nil",
   "Eq.symm",
   "Nat.succ",
   "instNonempty",
   "id",
   "Membership.mem",
   "funext",
   "Nat.below",
   "List.cons",
   "False",
   "instAddNat",
   "instHAdd",
   "Unit",
   "Init.Data.Nat.Basic._auxLemma.1",
   "Nat.succ.injEq",
   "LE.le",
   "Eq.ndrec",
   "Std.Data.List.Lemmas._auxLemma.106",
   "List",
   "HMul.hMul",
   "Bool",
   "instMulNat",
   "Std.Data.List.Lemmas._auxLemma.104",
   "Nat.casesOn"],
  "name": "List.mem_range'",
  "constType":
  "âˆ€ {m s step n : â„•}, m âˆˆ List.range' s n step â†” âˆƒ i < n, m = s + step * i",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "LT.lt", "Nat", "Nat.succ", "LE.le", "instLTNat"],
  "name": "Nat.succ_le_of_lt",
  "constType": "âˆ€ {n m : â„•}, n < m â†’ Nat.succ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ordering",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["sInfHom",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Prod.infSet",
   "Prod.snd",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Inf.inf",
   "sInfHom.mk",
   "Prod",
   "infsInfHom.proof_1",
   "Prod.fst"],
  "name": "infsInfHom",
  "constType":
  "{Î± : Type u_2} â†’ [inst : CompleteLattice Î±] â†’ sInfHom (Î± Ã— Î±) Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_6",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PLift.up",
   "Function.Surjective",
   "Equiv.surjective",
   "Equiv.plift",
   "PLift",
   "Equiv.symm"],
  "name": "PLift.up_surjective",
  "constType": "âˆ€ {Î± : Sort u}, Function.Surjective PLift.up",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "bot_le", "IsBot"],
  "name": "isBot_bot",
  "constType": "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderBot Î±], IsBot âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Filter.map.proof_2",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "Filter.map.proof_1",
   "Filter",
   "Filter.univ_mem"],
  "name": "Filter.map",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Filter Î± â†’ Filter Î²",
  "constCategory": "Definition"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} â†’ [dp : Decidable p] â†’ Decidable Â¬p",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "OfNat.ofNat",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "List.length",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Eq",
   "Quot.liftOn",
   "Zero.toOfNat0",
   "Setoid.r",
   "AddZeroClass.toZero",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "List",
   "Multiset",
   "Nat"],
  "name": "Multiset.card.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1},\n  (fun s â†¦ Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚)) 0 =\n    (fun s â†¦ Quot.liftOn s List.length (_ : âˆ€ (_lâ‚ _lâ‚‚ : List Î±), _lâ‚ ~ _lâ‚‚ â†’ List.length _lâ‚ = List.length _lâ‚‚)) 0",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_8",
  "constType": "âˆ€ {Î± : Type u_1} (x : Set Î±), âŠ¤ â‰¤ x âŠ” xá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Set.instHasSubsetSet",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.instUnionSet",
   "Or.rec",
   "Set.instMembershipSet"],
  "name": "Set.union_subset",
  "constType": "âˆ€ {Î± : Type u} {s t r : Set Î±}, s âŠ† r â†’ t âŠ† r â†’ s âˆª t âŠ† r",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "Set.Elem",
   "Set",
   "Finset",
   "Function.Embedding.subtype",
   "Subtype",
   "Set.instMembershipSet"],
  "name": "Set.toFinset",
  "constType": "{Î± : Type u_1} â†’ (s : Set Î±) â†’ [inst : Fintype â†‘s] â†’ Finset Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Exists",
   "Nat.add_succ",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "Nat.add_sub_cancel_left",
   "instLENat",
   "Eq.ndrec",
   "Nat.le.dest",
   "Nat.succ_sub.match_1",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_sub",
  "constType": "âˆ€ {m n : â„•}, n â‰¤ m â†’ Nat.succ m - n = Nat.succ (m - n)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter.mem_inf_iff",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.42",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, (s âˆˆ f âŠ“ g) = âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, s = tâ‚ âˆ© tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.iUnion_eq_univ_iff",
   "Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.28",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Set Î±}, (â‹ƒ i, f i = Set.univ) = âˆ€ (x : Î±), âˆƒ i, x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "LE.le", "Preorder.toLE", "Eq", "PartialOrder"],
  "name": "PartialOrder.le_antisymm",
  "constType":
  "âˆ€ {Î± : Type u} [self : PartialOrder Î±] (a b : Î±), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.rec._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom.mk", "ZeroHom", "Eq"],
  "name": "ZeroHom.rec",
  "constType":
  "{M : Type u_9} â†’\n  {N : Type u_10} â†’\n    [inst : Zero M] â†’\n      [inst_1 : Zero N] â†’\n        {motive : ZeroHom M N â†’ Sort u} â†’\n          ((toFun : M â†’ N) â†’ (map_zero' : toFun 0 = 0) â†’ motive { toFun := toFun, map_zero' := map_zero' }) â†’\n            (t : ZeroHom M N) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "nhds",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "interior_eq_nhds",
   "instTransPropIff_1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "Iff.symm",
   "Filter.principal",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Iff",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "interior",
   "subset_interior_iff_isOpen",
   "id"],
  "name": "isOpen_iff_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen s â†” âˆ€ a âˆˆ s, nhds a â‰¤ Filter.principal s",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "eq_true",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "True",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (a â‰¤ a âŠ” b) = True",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset", "Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{Î± : Type u_1} â†’ [inst : Fintype Î±] â†’ Finset Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "GaloisConnection.monotone_u",
   "LE.le",
   "Preorder.toLE",
   "TopologicalSpace.gc_generateFrom",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsOpen"],
  "name": "TopologicalSpace.generateFrom_anti",
  "constType":
  "âˆ€ {Î± : Type u_1} {gâ‚ gâ‚‚ : Set (Set Î±)}, gâ‚ âŠ† gâ‚‚ â†’ TopologicalSpace.generateFrom gâ‚‚ â‰¤ TopologicalSpace.generateFrom gâ‚",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsClosed_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["EStateM", "EStateM.Result.error"],
  "name": "EStateM.throw",
  "constType": "{Îµ Ïƒ Î± : Type u} â†’ Îµ â†’ EStateM Îµ Ïƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "CovariantClass.elim"],
  "name": "add_le_add_left",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Add Î±] [inst_1 : LE Î±] [inst_2 : CovariantClass Î± Î± (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1]\n  {b c : Î±}, b â‰¤ c â†’ âˆ€ (a : Î±), a + b â‰¤ a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Or",
   "Eq.refl",
   "Classical.em",
   "Or.casesOn",
   "LE.le",
   "ite_congr",
   "Eq",
   "ite",
   "Std.Data.Nat.Lemmas._auxLemma.5",
   "if_pos",
   "Eq.mpr",
   "instLENat",
   "congr",
   "Not",
   "Nat",
   "instMinNat",
   "congrArg",
   "Nat.succ",
   "if_neg",
   "Nat.decLe",
   "id",
   "congrFun"],
  "name": "Nat.min_succ_succ",
  "constType":
  "âˆ€ (x y : â„•), min (Nat.succ x) (Nat.succ y) = Nat.succ (min x y)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "PartialOrder.le_antisymm",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_4",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Î± â†’ Prop), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ Î± Ã— Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "nonempty_subtype.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (motive : (âˆƒ a, p a) â†’ Prop) (x : âˆƒ a, p a),\n  (âˆ€ (a : Î±) (h : p a), motive (_ : âˆƒ a, p a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Char.val",
   "Char.mk",
   "UInt32",
   "Char",
   "Char.eq_of_val_eq.match_1",
   "rfl",
   "UInt32.isValidChar",
   "Eq"],
  "name": "Char.eq_of_val_eq",
  "constType": "âˆ€ {c d : Char}, c.val = d.val â†’ c = d",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "OrderDual.instPreorder",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "OrderDual",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Set.Ici_subset_Ici",
   "Preorder.toLE"],
  "name": "Set.Iic_subset_Iic",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, Set.Iic a âŠ† Set.Iic b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["Nat.modCore._unary", "PSigma.mk", "Nat"],
  "name": "Nat.modCore",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage", "Continuous", "Set", "TopologicalSpace", "IsOpen"],
  "name": "Continuous.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  (âˆ€ (s : Set Î²), IsOpen s â†’ IsOpen (f â»Â¹' s)) â†’ Continuous f",
  "constCategory": "Other"},
 {"references":
  ["Set.image_eq_preimage_of_inverse",
   "Set.instBooleanAlgebraSet",
   "Set.preimage",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Eq"],
  "name": "Set.compl_image",
  "constType": "âˆ€ {Î± : Type u_1}, Set.image compl = Set.preimage compl",
  "constCategory": "Theorem"},
 {"references": ["Trunc.induction_on", "Trunc.mk", "Trunc"],
  "name": "Trunc.induction_onâ‚‚",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {C : Trunc Î± â†’ Trunc Î² â†’ Prop} (qâ‚ : Trunc Î±) (qâ‚‚ : Trunc Î²),\n  (âˆ€ (a : Î±) (b : Î²), C (Trunc.mk a) (Trunc.mk b)) â†’ C qâ‚ qâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd", "Sup", "Prod.mk", "Sup.sup", "Prod", "Prod.fst", "Sup.mk"],
  "name": "Prod.instSupProd",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : Sup Î±] â†’ [inst : Sup Î²] â†’ Sup (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.instUnionSet",
   "Iff.mpr",
   "Set.union_eq_right",
   "Eq"],
  "name": "Set.union_eq_self_of_subset_left",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, s âŠ† t â†’ s âˆª t = t",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_const.match_1",
  "constType":
  "âˆ€ {b : Prop} (Î± : Sort u_1) (motive : (âˆƒ x, b) â†’ Prop) (x : âˆƒ x, b), (âˆ€ (w : Î±) (h : b), motive (_ : âˆƒ x, b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLowerSet.toLowerSet_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±}, â†‘Topology.WithLowerSet.toLowerSet a = â†‘Topology.WithLowerSet.toLowerSet b â†” a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} â†’ {motive : a âˆ§ b â†’ Sort u} â†’ (t : a âˆ§ b) â†’ ((left : a) â†’ (right : b) â†’ motive (_ : a âˆ§ b)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(Â¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["And.right",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "not_le_of_gt",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a > b â†’ Â¬a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termI^_Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "Set.instSupSetSet",
   "And.intro",
   "Exists.intro",
   "SupSet.sSup",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)) (a : Î±) (motive : a âˆˆ sSup s â†’ Prop) (x : a âˆˆ sSup s),\n  (âˆ€ (t' : Set Î±) (t'_in : t' âˆˆ s) (a_in : a âˆˆ t'), motive (_ : âˆƒ t âˆˆ s, a âˆˆ t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Unit",
   "Unit.unit",
   "EStateM.bind.match_1",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.seqRight",
  "constType":
  "{Îµ Ïƒ Î± Î² : Type u} â†’ EStateM Îµ Ïƒ Î± â†’ (Unit â†’ EStateM Îµ Ïƒ Î²) â†’ EStateM Îµ Ïƒ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Codisjoint",
   "PartialOrder.toPreorder",
   "IsCompl",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.codisjoint",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, IsCompl x y â†’ Codisjoint x y",
  "constCategory": "Definition"},
 {"references": ["Bot", "CompleteLattice"],
  "name": "CompleteLattice.toBot",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ Bot Î±",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(Î± : Type u) â†’ [inst : LE Î±] â†’ Type u",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace"],
  "name": "Inducing",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [tÎ± : TopologicalSpace Î±] â†’ [tÎ² : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Other"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HAdd Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "List.Sublist",
   "List.sublist_append_right",
   "Exists.casesOn",
   "Eq",
   "Iff.intro",
   "instHAppend",
   "Iff",
   "List.instAppendList",
   "Eq.ndrec",
   "List.Sublist.subset",
   "List.Sublist.trans",
   "List",
   "HAppend.hAppend",
   "List.Sublist.consâ‚‚",
   "List.append_of_mem",
   "List.nil",
   "List.mem_singleton_self",
   "Eq.symm"],
  "name": "List.singleton_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±}, List.Sublist [a] l â†” a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Array.append._rarg",
   "Lean.Name.str._override",
   "Lean.Syntax.atom",
   "Lean.SourceInfo.fromRef",
   "_neutral",
   "Lean.Syntax.node4",
   "Lean.Syntax.node"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_2._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj â†’ _obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Unit", "Bool"],
  "name": "cond",
  "constType": "{Î± : Type u} â†’ Bool â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.mem_attach.match_1",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "Exists.casesOn",
   "List.attach",
   "Eq",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff.mp",
   "List",
   "List.attach_map_val",
   "List.map",
   "And.casesOn",
   "Subtype",
   "Subtype.mk",
   "id",
   "Subtype.casesOn"],
  "name": "List.mem_attach",
  "constType":
  "âˆ€ {Î± : Type u} (l : List Î±) (x : { x // x âˆˆ l }), x âˆˆ List.attach l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "UpperSet.Ici",
   "iInf",
   "UpperSet.instInfSetUpperSet",
   "upperClosure",
   "Set",
   "Preorder",
   "Eq.symm",
   "UpperSet",
   "Preorder.toLE",
   "Eq",
   "UpperSet.iInf_Ici",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (s : Set Î±), upperClosure s = â¨… a âˆˆ s, UpperSet.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "not_forall_of_exists_not",
   "Decidable",
   "Not",
   "Exists.intro",
   "Decidable.not_imp_symm"],
  "name": "Decidable.not_forall",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} [inst : Decidable (âˆƒ x, Â¬p x)] [inst : (x : Î±) â†’ Decidable (p x)],\n  (Â¬âˆ€ (x : Î±), p x) â†” âˆƒ x, Â¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Eq.ndrec",
   "Bool.casesOn",
   "Bool.false",
   "and",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Bool",
   "instDecidableAnd",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.and_eq_true",
  "constType": "âˆ€ (a b : Bool), ((a && b) = true) = (a = true âˆ§ b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_HomotopyGroup_Pi_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["NonemptyType"],
  "name": "_private.Init.Prelude.0.Lean.Macro.MethodsRefPointed",
  "constType": "NonemptyType",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_1"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "Set",
   "le_trans",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds_mono_mem",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} â¦ƒa b : Î±â¦„, a â‰¤ b â†’ a âˆˆ upperBounds s â†’ b âˆˆ upperBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "List.pmap",
   "List.instMembershipList",
   "Eq.refl",
   "List.pmap._sunfold.proof_1",
   "List.pmap._sunfold.proof_2",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.map_pmap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} {p : Î± â†’ Prop} (g : Î² â†’ Î³) (f : (a : Î±) â†’ p a â†’ Î²) (l : List Î±)\n  (H : âˆ€ a âˆˆ l, p a), List.map g (List.pmap f l H) = List.pmap (fun a h â†¦ g (f a h)) l H",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["Set", "LE", "UpperSet.mk", "IsUpperSet", "UpperSet"],
  "name": "UpperSet.rec",
  "constType":
  "{Î± : Type u_6} â†’\n  [inst : LE Î±] â†’\n    {motive : UpperSet Î± â†’ Sort u} â†’\n      ((carrier : Set Î±) â†’ (upper' : IsUpperSet carrier) â†’ motive { carrier := carrier, upper' := upper' }) â†’\n        (t : UpperSet Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{Î± : Sort u} â†’ Î± â†’ Inhabited Î±",
  "constCategory": "Other"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Inhabited", "Topology.WithLower"],
  "name": "Topology.WithLower.instInhabitedWithLower",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "IsAntisymm",
   "And.right",
   "Iff",
   "IsRefl",
   "HasSubset.Subset",
   "HasSubset.Subset.antisymm",
   "And.intro",
   "HasSubset",
   "Eq.superset",
   "And.left",
   "Eq.subset'",
   "Eq"],
  "name": "subset_antisymm_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1]\n  [inst_2 : IsAntisymm Î± fun x x_1 â†¦ x âŠ† x_1], a = b â†” a âŠ† b âˆ§ b âŠ† a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "SemilatticeInf.toPartialOrder",
   "OrderDual.semilatticeSup",
   "sup_le_sup",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_inf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b c d : Î±}, a â‰¤ b â†’ c â‰¤ d â†’ a âŠ“ c â‰¤ b âŠ“ d",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace", "Inducing", "TopologicalSpace.induced", "Eq"],
  "name": "Inducing.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  tÎ± = TopologicalSpace.induced f tÎ² â†’ Inducing f",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Topology.WithUpperSet",
   "Set",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Topology.WithUpperSet.toUpperSet",
   "Preorder.toLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.isUpperSet_toUpperSet_preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set (Topology.WithUpperSet Î±)},\n  IsUpperSet (â†‘Topology.WithUpperSet.toUpperSet â»Â¹' s) â†” IsOpen s",
  "constCategory": "Theorem"},
 {"references":
  ["isUpperSet_Ici",
   "UpperSet.mk",
   "Set.Ici",
   "Preorder",
   "UpperSet",
   "Preorder.toLE"],
  "name": "UpperSet.Ici",
  "constType": "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â†’ UpperSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Classical.axiomOfChoice",
   "Exists.intro",
   "Classical.skolem.match_1"],
  "name": "Classical.skolem",
  "constType":
  "âˆ€ {Î± : Sort u} {b : Î± â†’ Sort v} {p : (x : Î±) â†’ b x â†’ Prop}, (âˆ€ (x : Î±), âˆƒ y, p x y) â†” âˆƒ f, âˆ€ (x : Î±), p x (f x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Iff",
   "List.instMembershipList",
   "List",
   "Eq.rec",
   "Not",
   "Eq.symm",
   "rfl",
   "Eq"],
  "name": "List.forall_mem_ne",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {l : List Î±}, (âˆ€ a' âˆˆ l, Â¬a = a') â†” Â¬a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Finite.casesOn", "Finite.intro", "Finite", "Nat", "Fin"],
  "name": "finite_iff_exists_equiv_fin.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (motive : Finite Î± â†’ Prop) (x : Finite Î±),\n  (âˆ€ (n : â„•) (e : Î± â‰ƒ Fin n), motive (_ : Finite Î±)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "outParam",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHomClass.mk",
  "constType":
  "{F : Type u_9} â†’\n  {M : outParam (Type u_10)} â†’\n    {N : outParam (Type u_11)} â†’\n      [inst : AddZeroClass M] â†’\n        [inst_1 : AddZeroClass N] â†’\n          [toAddHomClass : AddHomClass F M N] â†’ (âˆ€ (f : F), â†‘f 0 = 0) â†’ AddMonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "List.erase_cons",
   "List.cons",
   "Eq.refl",
   "instBEq",
   "List.erase",
   "instDecidableTrue",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Not",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.erase_cons_head",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (l : List Î±), List.erase (a :: l) a = l",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Variable", "Lean.IsNeutral", "Option"],
  "name": "Lean.Data.AC.Variable.mk",
  "constType":
  "{Î± : Sort u} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ (value : Î±) â†’ Option (Lean.IsNeutral op value) â†’ Lean.Data.AC.Variable op",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.semilatticeInf",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_4",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Lattice Î±] (a b : Î±áµ’áµˆ), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.rec",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Topology.WithUpper Î± â†’ Sort u_1} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithUpper.toUpper a)) â†’ (a : Topology.WithUpper Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "le_inf",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "SemilatticeInf",
   "GaloisConnection.l_le",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeInf Î±],\n  GaloisInsertion l u â†’ âˆ€ (a b : Î²), u (l (u a âŠ“ u b)) â‰¤ u a âŠ“ u b",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "BooleanAlgebra.sdiff_eq",
  "constType":
  "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x y : Î±), x \\ y = x âŠ“ yá¶œ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.casesOn",
   "List.nil"],
  "name": "List.pmap.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  {p : Î± â†’ Prop} â†’\n    (motive : (x : List Î±) â†’ (âˆ€ a âˆˆ x, p a) â†’ Sort u_2) â†’\n      (x : List Î±) â†’\n        (x_1 : âˆ€ a âˆˆ x, p a) â†’\n          ((x : âˆ€ a âˆˆ [], p a) â†’ motive [] x) â†’\n            ((a : Î±) â†’ (l : List Î±) â†’ (H : âˆ€ a_1 âˆˆ a :: l, p a_1) â†’ motive (a :: l) H) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Set.instAlternativeSet",
   "Fintype",
   "Set.Elem",
   "Set.fintypeSingleton",
   "Set",
   "Alternative.toApplicative",
   "Pure.pure",
   "Applicative.toPure"],
  "name": "Set.fintypePure",
  "constType": "{Î± : Type u} â†’ (a : Î±) â†’ Fintype â†‘(pure a)",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "Equiv",
   "OrderDual.toDual",
   "sSupHom.mk",
   "sSupHom",
   "Function.comp",
   "OrderDual.infSet",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sSupHom.map_sSup'",
   "rfl",
   "sInfHom.ext",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "SupSet",
   "sSupHomClass.toFunLike",
   "sSupHom.instSSupHomClassSSupHom",
   "OrderDual.ofDual",
   "sInfHom.map_sInf'",
   "OrderDual",
   "sInfHom.mk",
   "sInfHom.instSInfHomClassSInfHom"],
  "name": "sSupHom.dual.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : SupSet Î±] [inst_1 : SupSet Î²] (x : sInfHom Î±áµ’áµˆ Î²áµ’áµˆ),\n  (fun f â†¦\n        { toFun := â†‘OrderDual.toDual âˆ˜ â†‘f âˆ˜ â†‘OrderDual.ofDual,\n          map_sInf' := (_ : âˆ€ (s : Set Î±), sSupHom.toFun f (sSup s) = sSup (f.toFun '' s)) })\n      ((fun f â†¦\n          { toFun := â†‘OrderDual.ofDual âˆ˜ â†‘f âˆ˜ â†‘OrderDual.toDual,\n            map_sSup' := (_ : âˆ€ (s : Set Î±áµ’áµˆ), sInfHom.toFun f (sInf s) = sInf (f.toFun '' s)) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Topology.WithUpper.ofUpper",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithUpper.to_WithUpper_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithUpper.toUpper.symm = Topology.WithUpper.ofUpper",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.eq_of_mem_singleton.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} (motive : (b : Î±) â†’ a âˆˆ [b] â†’ Prop) (b : Î±) (x : a âˆˆ [b]),\n  (Unit â†’ motive a (_ : List.Mem a [a])) â†’ motive b x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.ball_image_iff",
   "Set",
   "Function.comp",
   "Set.forall_range_iff",
   "Set.image",
   "Set.mem_range_self",
   "Set.Subset.antisymm",
   "Iff.mpr",
   "Eq",
   "Set.mem_image_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.range_comp",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} (g : Î± â†’ Î²) (f : Î¹ â†’ Î±), Set.range (g âˆ˜ f) = g '' Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Exists",
   "Equiv.toHomeomorphOfInducing",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Set",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "Equiv.refl",
   "Topology.IsLower",
   "lcProof",
   "Homeomorph",
   "Topology.WithLower.ofLower",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.IsLower.WithLowerHomeomorph._cstage1",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsLower Î±] â†’ Topology.WithLower Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_trans.match_1",
  "constType":
  "âˆ€ {n m : â„•} (motive : (k : â„•) â†’ n â‰¤ m â†’ m â‰¤ k â†’ Prop) (k : â„•) (x : n â‰¤ m) (x_1 : m â‰¤ k),\n  (âˆ€ (h : n â‰¤ m), motive m h (_ : Nat.le m m)) â†’\n    (âˆ€ (hâ‚ : n â‰¤ m) (m_1 : â„•) (hâ‚‚ : Nat.le m m_1), motive (Nat.succ m_1) hâ‚ (_ : Nat.le m (Nat.succ m_1))) â†’\n      motive k x x_1",
  "constCategory": "Definition"},
 {"references":
  ["sInf_singleton",
   "Set.instSingletonSet",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "Singleton.singleton",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.sInter",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_singleton",
  "constType": "âˆ€ {Î± : Type u_1} (s : Set Î±), â‹‚â‚€ {s} = s",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{Î± : Type u} â†’ Î± â†’ Top Î±",
  "constCategory": "Other"},
 {"references": ["BEq.beq", "BEq", "List", "Nat", "List.countP"],
  "name": "List.count",
  "constType": "{Î± : Type u_1} â†’ [inst : BEq Î±] â†’ Î± â†’ List Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "Continuous.isOpen_preimage",
   "TopologicalSpace",
   "IsOpen"],
  "name": "IsOpen.preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ âˆ€ {s : Set Î²}, IsOpen s â†’ IsOpen (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "superset_of_eq", "HasSubset.Subset", "HasSubset", "Eq"],
  "name": "Eq.superset",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1], a = b â†’ b âŠ† a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_10",
  "constType": "âˆ€ {Î± : Type u_1} (a b c : Î± â†’ Prop), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "EmptyCollection.emptyCollection",
   "Set.instBooleanAlgebraSet",
   "inf_compl_eq_bot",
   "Set",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Set.instInterSet",
   "Eq"],
  "name": "Set.inter_compl_self",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±), s âˆ© sá¶œ = âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "Decidable.not_and_iff_or_not.match_1",
  "constType":
  "âˆ€ (p q : Prop) (motive : Decidable p â†’ Decidable q â†’ Prop) (dâ‚ : Decidable p) (dâ‚‚ : Decidable q),\n  (âˆ€ (hâ‚ : p) (hâ‚‚ : q), motive (isTrue hâ‚) (isTrue hâ‚‚)) â†’\n    (âˆ€ (x : Decidable p) (hâ‚‚ : Â¬q), motive x (isFalse hâ‚‚)) â†’\n      (âˆ€ (hâ‚ : Â¬p) (x : Decidable q), motive (isFalse hâ‚) x) â†’ motive dâ‚ dâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero",
   "Bool.false",
   "Nat.beq",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.ne_of_beq_eq_false.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ Nat.beq x x_1 = false â†’ x = x_1 â†’ Prop) (x x_1 : â„•) (x_2 : Nat.beq x x_1 = false)\n  (x_3 : x = x_1),\n  (âˆ€ (hâ‚ : Nat.beq Nat.zero Nat.zero = false) (x : Nat.zero = Nat.zero), motive Nat.zero Nat.zero hâ‚ x) â†’\n    (âˆ€ (n : â„•) (x : Nat.beq Nat.zero (Nat.succ n) = false) (hâ‚‚ : Nat.zero = Nat.succ n),\n        motive Nat.zero (Nat.succ n) x hâ‚‚) â†’\n      (âˆ€ (n : â„•) (x : Nat.beq (Nat.succ n) Nat.zero = false) (hâ‚‚ : Nat.succ n = Nat.zero),\n          motive (Nat.succ n) Nat.zero x hâ‚‚) â†’\n        (âˆ€ (n m : â„•) (hâ‚ : Nat.beq (Nat.succ n) (Nat.succ m) = false) (hâ‚‚ : Nat.succ n = Nat.succ m),\n            motive (Nat.succ n) (Nat.succ m) hâ‚ hâ‚‚) â†’\n          motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["UInt32.mk", "UInt32", "Eq.rec", "UInt32.size", "rfl", "Fin", "Eq"],
  "name": "UInt32.decEq.proof_1",
  "constType": "âˆ€ (n m : Fin UInt32.size), n = m â†’ { val := n } = { val := m }",
  "constCategory": "Theorem"},
 {"references":
  ["exists_comm.match_1",
   "Iff.intro",
   "Exists",
   "Iff",
   "exists_comm.match_2",
   "Exists.intro"],
  "name": "exists_comm",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {p : Î± â†’ Î² â†’ Prop}, (âˆƒ a, âˆƒ b, p a b) â†” âˆƒ b, âˆƒ a, p a b",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "outParam",
   "Function.RightInverse",
   "EquivLike.inv"],
  "name": "EquivLike.right_inv",
  "constType":
  "âˆ€ {E : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EquivLike E Î± Î²] (e : E),\n  Function.RightInverse (EquivLike.inv e) (EquivLike.coe e)",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) â†’ (N : Type u_10) â†’ [inst : Zero M] â†’ [inst : Zero N] â†’ Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis",
   "Set",
   "Filter",
   "Set.Subset.rfl",
   "instMembershipSetFilter",
   "Filter.HasBasis.mem_of_superset"],
  "name": "Filter.HasBasis.mem_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {i : Î¹},\n  Filter.HasBasis l p s â†’ p i â†’ s i âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "CompleteSemilatticeInf.mk",
  "constType":
  "{Î± : Type u_9} â†’\n  [toPartialOrder : PartialOrder Î±] â†’\n    [toInfSet : InfSet Î±] â†’\n      (âˆ€ (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a) â†’\n        (âˆ€ (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s) â†’ CompleteSemilatticeInf Î±",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Nat.decLt",
   "LT.lt",
   "Unit",
   "PUnit",
   "Lean.Data.AC.insert.match_1",
   "List.nil",
   "Nat",
   "instLTNat",
   "ite"],
  "name": "Lean.Data.AC.insert",
  "constType": "â„• â†’ List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "List.Perm.symm",
   "Exists",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro"],
  "name": "List.Perm.subperm",
  "constType": "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ lâ‚ <+~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["ClosedIciTopology.isClosed_ge'",
   "TopologicalSpace",
   "IsClosed",
   "Set.Ici",
   "Preorder",
   "ClosedIciTopology"],
  "name": "isClosed_Ici",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [t : ClosedIciTopology Î±] {a : Î±}, IsClosed (Set.Ici a)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "sup_of_le_left",
   "Sup.sup",
   "OrderBot",
   "bot_le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "sup_bot_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] [inst_1 : OrderBot Î±] {a : Î±}, a âŠ” âŠ¥ = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Prop) â†’ Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["UInt32.decEq", "UInt32", "DecidableEq"],
  "name": "instDecidableEqUInt32",
  "constType": "DecidableEq UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "Topology.isUpper_orderDual",
   "OrderDual.instPreorder",
   "Iff",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "Topology.isLower_orderDual",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±], Topology.IsLower Î±áµ’áµˆ â†” Topology.IsUpper Î±",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsIdempotent", "Eq"],
  "name": "Lean.IsIdempotent.idempotent",
  "constType":
  "âˆ€ {Î± : Sort u} {op : Î± â†’ Î± â†’ Î±} [self : Lean.IsIdempotent op] (x : Î±), op x x = x",
  "constCategory": "Definition"},
 {"references": ["Mod"],
  "name": "Mod.mod",
  "constType": "{Î± : Type u} â†’ [self : Mod Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeSup.le_sSup",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "le_sSup",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeSup Î±] {s : Set Î±} {a : Î±}, a âˆˆ s â†’ a â‰¤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "OrderDual.orderBot",
   "OrderBot.toBot",
   "inferInstanceAs",
   "OrderDual",
   "OrderBot.bot_le",
   "LE",
   "OrderBot",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "BoundedOrder"],
  "name": "OrderDual.boundedOrder.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : LE Î±] [inst_1 : BoundedOrder Î±] (a : Î±áµ’áµˆ), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.casesOn", "Multiset", "Finset", "Multiset.Nodup", "Finset.mk"],
  "name": "Finset.cons_induction.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : Finset Î± â†’ Prop) (x : Finset Î±),\n  (âˆ€ (s : Multiset Î±) (nd : Multiset.Nodup s), motive { val := s, nodup := nd }) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
   "AddSemigroup.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
   "nsmulRec",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
   "Multiset.instAddMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "Zero.toOfNat0",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
   "AddCommMonoid.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
   "Multiset",
   "OrderedCancelAddCommMonoid.mk",
   "Zero.mk",
   "Add.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset",
  "constType": "{Î± : Type u_1} â†’ OrderedCancelAddCommMonoid (Multiset Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "Decidable.byCases.match_1",
  "constType":
  "{p : Prop} â†’\n  (motive : Decidable p â†’ Sort u_1) â†’\n    (dec : Decidable p) â†’ ((h : p) â†’ motive (isTrue h)) â†’ ((h : Â¬p) â†’ motive (isFalse h)) â†’ motive dec",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "âˆ€ {a b : Prop}, a âˆ§ b â†’ b",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidablePred",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Prop) â†’ Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelCommMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_7",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b c : (Filter Î±)áµ’áµˆáµ’áµˆ), a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "Equiv",
   "Equiv.toFun",
   "Equiv.right_inv",
   "Function.comp",
   "Inducing",
   "FunLike.coe",
   "Iff.mpr",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Eq.mpr",
   "Equiv.invFun",
   "Inducing.continuous_iff",
   "Equiv.self_comp_symm",
   "Continuous",
   "TopologicalSpace",
   "Equiv.mk",
   "Equiv.left_inv",
   "congrArg",
   "Equiv.symm",
   "id"],
  "name": "Equiv.toHomeomorphOfInducing.proof_2",
  "constType":
  "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : X â‰ƒ Y),\n  Inducing â†‘f â†’\n    Continuous\n      { toFun := f.toFun, invFun := f.invFun, left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n          right_inv := (_ : Function.RightInverse f.invFun f.toFun) }.invFun",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“Ë¢Â»._closed_3",
   "Topology.Â«termð“Ë¢Â»._closed_5"],
  "name": "Topology.Â«termð“Ë¢Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.WF.0.InvImage.accAux", "InvImage", "Acc", "rfl"],
  "name": "InvImage.accessible.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {r : Î² â†’ Î² â†’ Prop} {a : Î±} (f : Î± â†’ Î²), Acc r (f a) â†’ Acc (InvImage r f) a",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{Î± : Type u} â†’ (x : â„•) â†’ [self : OfNat Î± x] â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["UInt32", "UInt32.size", "Fin"],
  "name": "UInt32.mk",
  "constType": "Fin UInt32.size â†’ UInt32",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.ofLower._cstage1",
  "constType": "{Î± : Type u_1} â†’ Topology.WithLower Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.comp",
   "Topology.WithLowerSet",
   "ContinuousMap.comp",
   "Topology.WithLowerSet.map",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderHom",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "Eq"],
  "name": "Topology.WithLowerSet.map_comp",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : Preorder Î³]\n  (g : Î² â†’o Î³) (f : Î± â†’o Î²),\n  Topology.WithLowerSet.map (OrderHom.comp g f) =\n    ContinuousMap.comp (Topology.WithLowerSet.map g) (Topology.WithLowerSet.map f)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Sup",
   "SemilatticeInf.toInf",
   "OrderDual.semilatticeSup.proof_1",
   "SemilatticeInf.toPartialOrder",
   "instSupOrderDual",
   "SemilatticeSup.mk",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "SemilatticeSup",
   "SemilatticeInf.le_inf",
   "OrderDual",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_left",
   "SemilatticeInf.inf_le_right",
   "Sup.sup",
   "SemilatticeInf"],
  "name": "OrderDual.semilatticeSup",
  "constType":
  "(Î± : Type u_1) â†’ [inst : SemilatticeInf Î±] â†’ SemilatticeSup Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[_]_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{Î± : Type u} â†’ [self : NonAssocSemiring Î±] â†’ NatCast Î±",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] (a : Î±), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.lift.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "Preorder",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift",
  "constType":
  "{Î± : Type u_3} â†’ {Î² : Type u_4} â†’ [inst : PartialOrder Î²] â†’ (f : Î± â†’ Î²) â†’ Function.Injective f â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "DistribLattice.toLattice",
   "Iff",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "IsCompl.disjoint_right_iff",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "IsCompl.le_left_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y z : Î±}, IsCompl x y â†’ (z â‰¤ x â†” Disjoint z y)",
  "constCategory": "Theorem"},
 {"references": ["Finset", "Finset.val", "Multiset.Nodup"],
  "name": "Finset.nodup",
  "constType": "âˆ€ {Î± : Type u_4} (self : Finset Î±), Multiset.Nodup self.val",
  "constCategory": "Definition"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{Î± : Type u} â†’ [self : Semiring Î±] â†’ One Î±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{Î± : Type u} â†’ [inst : LT Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "BooleanAlgebra.toHasCompl",
   "Set.Set.completeAtomicBooleanAlgebra.proof_8",
   "BooleanAlgebra.toBot",
   "Set.Set.completeAtomicBooleanAlgebra.proof_12",
   "Preorder.toLE",
   "BooleanAlgebra",
   "CompletelyDistribLattice.mk",
   "CompleteAtomicBooleanAlgebra.mk",
   "BooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra",
   "Set.Set.completeAtomicBooleanAlgebra.proof_10",
   "Set.Set.completeAtomicBooleanAlgebra.proof_3",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Set.Set.completeAtomicBooleanAlgebra.proof_7",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra.proof_5",
   "Set.Set.completeAtomicBooleanAlgebra.proof_11",
   "Set.Set.completeAtomicBooleanAlgebra.proof_2",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.proof_6",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.instBooleanAlgebraSet",
   "Set.Set.completeAtomicBooleanAlgebra.proof_1",
   "Set.Set.completeAtomicBooleanAlgebra.proof_9",
   "Set.Set.completeAtomicBooleanAlgebra.proof_4",
   "Set.instInfSetSet",
   "BooleanAlgebra.toSDiff"],
  "name": "Set.Set.completeAtomicBooleanAlgebra",
  "constType": "{Î± : Type u_1} â†’ CompleteAtomicBooleanAlgebra (Set Î±)",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.13",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b âˆ§ c) = (b âˆ§ a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Bot.bot",
   "propext",
   "SProd.sprod",
   "Prod",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.instSProd",
   "Filter.prod_eq_bot",
   "Filter.instCompleteLatticeFilter",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.31",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Filter Î±} {g : Filter Î²}, (f Ã—Ë¢ g = âŠ¥) = (f = âŠ¥ âˆ¨ g = âŠ¥)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[<]_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.preimage",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Set Î² â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Eq.rec",
   "Set.mem_image",
   "And.intro",
   "Set.image",
   "Eq.symm",
   "And.casesOn",
   "id"],
  "name": "Set.image_congr",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {s : Set Î±}, (âˆ€ a âˆˆ s, f a = g a) â†’ f '' s = g '' s",
  "constCategory": "Theorem"},
 {"references": ["Option.getD", "List", "List.get?", "Nat"],
  "name": "List.getD",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ â„• â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn"],
  "name": "exists_and_left.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop} (motive : (âˆƒ x, b âˆ§ p x) â†’ Prop) (x : âˆƒ x, b âˆ§ p x),\n  (âˆ€ (x : Î±) (h : b) (hp : p x), motive (_ : âˆƒ x, b âˆ§ p x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "Top",
   "Top.top",
   "OrderBot.toBot",
   "OrderTop",
   "OrderDual.top",
   "inferInstanceAs",
   "OrderDual",
   "LE",
   "OrderBot",
   "bot_le",
   "Top.mk",
   "OrderDual.instLEOrderDual"],
  "name": "OrderDual.orderTop",
  "constType":
  "(Î± : Type u) â†’ [inst : LE Î±] â†’ [inst_1 : OrderBot Î±] â†’ OrderTop Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Pure"],
  "name": "Applicative.toPure",
  "constType": "{f : Type u â†’ Type v} â†’ [self : Applicative f] â†’ Pure f",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.rfl",
   "List.instMembershipList",
   "Eq.refl",
   "Std.Data.List.Pairwise._auxLemma.4",
   "Eq",
   "Std.Data.List.Pairwise._auxLemma.5",
   "Iff.intro",
   "List.Pairwise",
   "instHAppend",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "List.instAppendList",
   "propext",
   "List",
   "HAppend.hAppend",
   "congr",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "List.pairwise_append_comm",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop},\n  (âˆ€ {x y : Î±}, R x y â†’ R y x) â†’ âˆ€ {lâ‚ lâ‚‚ : List Î±}, List.Pairwise R (lâ‚ ++ lâ‚‚) â†” List.Pairwise R (lâ‚‚ ++ lâ‚)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "T0Space",
  "constType": "(Î± : Type u) â†’ [inst : TopologicalSpace Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} â†’ [self : AddCancelMonoid M] â†’ AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "Set.subset_univ",
   "Set.instMembershipSet"],
  "name": "Filter.principal",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.swap",
  "constType":
  "{Î± : Sort uâ‚} â†’ {Î² : Sort uâ‚‚} â†’ {Ï† : Î± â†’ Î² â†’ Sort uâ‚ƒ} â†’ ((x : Î±) â†’ (y : Î²) â†’ Ï† x y) â†’ (y : Î²) â†’ (x : Î±) â†’ Ï† x y",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "TopologicalSpace",
   "IsClosed",
   "Set.sInter",
   "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.closure._eq_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), closure s = â‹‚â‚€ {t | IsClosed t âˆ§ s âŠ† t}",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Topology.WithLower.rec._rarg", "_neutral"],
  "name": "Topology.WithLower.rec._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "List.getD",
   "Lean.Data.AC.Context",
   "Option.none",
   "Lean.Data.AC.Context.arbitrary",
   "Lean.IsNeutral",
   "Nat",
   "Lean.Data.AC.Context.vars"],
  "name": "Lean.Data.AC.Context.var",
  "constType":
  "{Î± : Sort u_1} â†’ (ctx : Lean.Data.AC.Context Î±) â†’ â„• â†’ Lean.Data.AC.Variable ctx.op",
  "constCategory": "Definition"},
 {"references": ["False", "propext", "Not", "True", "Eq", "not_false_iff"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.17",
  "constType": "(Â¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.eventually_of_forall",
   "Filter.Eventually.mp",
   "Filter",
   "Filter.Eventually"],
  "name": "Filter.Eventually.mono",
  "constType":
  "âˆ€ {Î± : Type u} {p q : Î± â†’ Prop} {f : Filter Î±}, (âˆ€á¶  (x : Î±) in f, p x) â†’ (âˆ€ (x : Î±), p x â†’ q x) â†’ âˆ€á¶  (x : Î±) in f, q x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Or",
   "Iff",
   "forall_eq",
   "Set",
   "and_congr_left'",
   "Iff.trans",
   "Insert.insert",
   "ball_or_left",
   "Set.instInsertSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.ball_insert_iff",
  "constType":
  "âˆ€ {Î± : Type u} {P : Î± â†’ Prop} {a : Î±} {s : Set Î±}, (âˆ€ x âˆˆ insert a s, P x) â†” P a âˆ§ âˆ€ x âˆˆ s, P x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Topology.IsUpper.toContinuousInf.proof_1",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Topology.IsUpper",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ContinuousSup"],
  "name": "Topology.IsUpper.toContinuousInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±], ContinuousSup Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "iInf_range",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "Set.iInter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.biInter_range",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {g : Î± â†’ Set Î²}, â‹‚ x âˆˆ Set.range f, g x = â‹‚ y, g (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.cons",
   "Singleton",
   "Singleton.mk"],
  "name": "Multiset.instSingletonMultiset",
  "constType": "{Î± : Type u_1} â†’ Singleton Î± (Multiset Î±)",
  "constCategory": "Definition"},
 {"references": ["Sup", "Inf", "Inf.inf", "OrderDual", "Sup.mk"],
  "name": "instSupOrderDual",
  "constType": "(Î± : Type u_1) â†’ [inst : Inf Î±] â†’ Sup Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Preorder.le_trans",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b c : (Filter Î±)áµ’áµˆáµ’áµˆ), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.val", "Subtype.eq.match_1", "rfl", "Subtype.mk", "Subtype", "Eq"],
  "name": "Subtype.eq",
  "constType":
  "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {a1 a2 : { x // p x }}, â†‘a1 = â†‘a2 â†’ a1 = a2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "Top",
   "HImp.himp",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "Inf.inf",
   "Lattice",
   "GeneralizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedHeytingAlgebra.mk",
  "constType":
  "{Î± : Type u_4} â†’\n  [toLattice : Lattice Î±] â†’\n    [toTop : Top Î±] â†’\n      [toHImp : HImp Î±] â†’ (âˆ€ (a : Î±), a â‰¤ âŠ¤) â†’ (âˆ€ (a b c : Î±), a â‰¤ b â‡¨ c â†” a âŠ“ b â‰¤ c) â†’ GeneralizedHeytingAlgebra Î±",
  "constCategory": "Other"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Function.Surjective.forall.match_1",
   "Function.Surjective",
   "Eq.rec",
   "Eq"],
  "name": "Function.Surjective.forall",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²},\n  Function.Surjective f â†’ âˆ€ {p : Î² â†’ Prop}, (âˆ€ (y : Î²), p y) â†” âˆ€ (x : Î±), p (f x)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "False", "imp.swap", "Not"],
  "name": "imp_not_comm",
  "constType": "âˆ€ {a b : Prop}, a â†’ Â¬b â†” b â†’ Â¬a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_6",
  "constType": "3 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.insert.match_1",
  "constType":
  "(motive : List â„• â†’ Sort u_1) â†’\n  (x : List â„•) â†’ (Unit â†’ motive []) â†’ ((a : â„•) â†’ (as : List â„•) â†’ motive (a :: as)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.node4",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.erase_cons",
   "OfNat.ofNat",
   "List.below",
   "instSubNat",
   "List.brecOn",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "List.erase",
   "True",
   "ite",
   "Eq",
   "PProd",
   "Eq.mpr",
   "List.rec",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.add_zero",
   "Eq.symm",
   "Eq.trans",
   "if_neg",
   "id",
   "instHSub",
   "eq_self",
   "List.cons",
   "instAddNat",
   "List.count_cons",
   "instHAdd",
   "Unit",
   "eq_comm",
   "HSub.hSub",
   "instBEq",
   "Nat.zero_sub",
   "List.countP_map.match_1",
   "PProd.fst",
   "if_pos",
   "Eq.ndrec",
   "DecidableEq",
   "of_eq_true",
   "propext",
   "List",
   "Eq.mp",
   "Nat.sub_zero",
   "Not",
   "List.count",
   "congrArg",
   "Nat.add_sub_cancel"],
  "name": "List.count_erase",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a b : Î±) (l : List Î±),\n  List.count a (List.erase l b) = List.count a l - if a = b then 1 else 0",
  "constCategory": "Theorem"},
 {"references": ["And", "Iff", "And.comm"],
  "name": "and_comm",
  "constType": "âˆ€ {a b : Prop}, a âˆ§ b â†” b âˆ§ a",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{Î± : Type u_1} â†’ [inst : Mul Î±] â†’ HMul Î± Î± Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "And", "Exists", "Set", "Set.instMembershipSet"],
  "name": "DirectedOn",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Prop) â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "GeneralizedHeytingAlgebra.le_top",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : GeneralizedHeytingAlgebra Î±] (a : Î±), a â‰¤ âŠ¤",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelCommMonoid.mk",
  "constType":
  "{M : Type u} â†’ [toAddLeftCancelMonoid : AddLeftCancelMonoid M] â†’ (âˆ€ (a b : M), a + b = b + a) â†’ AddCancelCommMonoid M",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.add_left_cancel",
  "constType":
  "âˆ€ {G : Type u} [inst : Add G] [self : IsLeftCancelAdd G] (a b c : G), a + b = a + c â†’ b = c",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "Prod.snd",
   "Prod.mk",
   "Prod",
   "Prod.fst",
   "PProd.snd",
   "PProd.mk",
   "rfl",
   "Eq"],
  "name": "Equiv.pprodEquivProd.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (x : Î± Ã— Î²),\n  (fun x â†¦ (x.fst, x.snd)) ((fun x â†¦ { fst := x.1, snd := x.2 }) x) =\n    (fun x â†¦ (x.fst, x.snd)) ((fun x â†¦ { fst := x.1, snd := x.2 }) x)",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "sInfHom.casesOn",
   "sInfHom.toFun",
   "Eq.ndrec",
   "Eq.rec",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "sInfHom.mk",
   "InfSet",
   "Set.image",
   "Eq.symm",
   "Eq"],
  "name": "sInfHom.instSInfHomClassSInfHom.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : InfSet Î±] [inst_1 : InfSet Î²] (f g : sInfHom Î± Î²), f.toFun = g.toFun â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.completeLattice.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : CompleteLattice Î±] (a b : Î±áµ’áµˆ), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_2",
  "constType": "1 < UInt32.size",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "Unit", "Eq.to_iff.match_1", "Eq"],
  "name": "Eq.to_iff",
  "constType": "âˆ€ {a b : Prop}, a = b â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List.Perm.refl",
   "List",
   "List.Perm.rec",
   "List.nil",
   "List.recOn"],
  "name": "List.perm_induction_on",
  "constType":
  "âˆ€ {Î± : Type uu} {P : List Î± â†’ List Î± â†’ Prop} {lâ‚ lâ‚‚ : List Î±},\n  lâ‚ ~ lâ‚‚ â†’\n    P [] [] â†’\n      (âˆ€ (x : Î±) (lâ‚ lâ‚‚ : List Î±), lâ‚ ~ lâ‚‚ â†’ P lâ‚ lâ‚‚ â†’ P (x :: lâ‚) (x :: lâ‚‚)) â†’\n        (âˆ€ (x y : Î±) (lâ‚ lâ‚‚ : List Î±), lâ‚ ~ lâ‚‚ â†’ P lâ‚ lâ‚‚ â†’ P (y :: x :: lâ‚) (x :: y :: lâ‚‚)) â†’\n          (âˆ€ (lâ‚ lâ‚‚ lâ‚ƒ : List Î±), lâ‚ ~ lâ‚‚ â†’ lâ‚‚ ~ lâ‚ƒ â†’ P lâ‚ lâ‚‚ â†’ P lâ‚‚ lâ‚ƒ â†’ P lâ‚ lâ‚ƒ) â†’ P lâ‚ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "_private.Std.Data.List.Count.0.List.findIdx.go.match_1.splitter",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ â„• â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : â„•) â†’ ((n : â„•) â†’ motive [] n) â†’ ((a : Î±) â†’ (l : List Î±) â†’ (n : â„•) â†’ motive (a :: l) n) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le_of_le",
   "iInf_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInfâ‚‚_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {Îº : Î¹ â†’ Sort u_7} [inst : CompleteLattice Î±] {f : (i : Î¹) â†’ Îº i â†’ Î±} (i : Î¹) (j : Îº i),\n  â¨… i, â¨… j, f i j â‰¤ f i j",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithUpperSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpperSet.toUpperSet_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±}, â†‘Topology.WithUpperSet.toUpperSet a = â†‘Topology.WithUpperSet.toUpperSet b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "exists_exists_eq_and.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î² â†’ Prop} (motive : (âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b) â†’ Prop)\n  (x : âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b),\n  (âˆ€ (w : Î²) (a : Î±) (ha : f a = w) (hb : p w), motive (_ : âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.ofUpperSetOrderIso._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["forall_imp"],
  "name": "forallâ‚‚_imp",
  "constType":
  "âˆ€ {Î± : Sort u_5} {Î² : Î± â†’ Sort u_1} {p q : (a : Î±) â†’ Î² a â†’ Prop},\n  (âˆ€ (a : Î±) (b : Î² a), p a b â†’ q a b) â†’ (âˆ€ (a : Î±) (b : Î² a), p a b) â†’ âˆ€ (a : Î±) (b : Î² a), q a b",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Pure.pure",
   "Applicative.toPure"],
  "name": "ReaderT.read",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ ReaderT Ï m Ï",
  "constCategory": "Definition"},
 {"references":
  ["Set.image_pair",
   "Bool.univ_eq",
   "Set",
   "Eq.refl",
   "Set.image_univ",
   "Insert.insert",
   "Set.univ",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "Bool.false",
   "Bool.true",
   "Singleton.singleton",
   "Bool",
   "Set.image",
   "Eq.symm",
   "Set.instInsertSet",
   "id"],
  "name": "Bool.range_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} (f : Bool â†’ Î±), Set.range f = {f false, f true}",
  "constCategory": "Theorem"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ Lattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
   "autoParam",
   "Eq"],
  "name": "AddRightCancelMonoid.mk",
  "constType":
  "{M : Type u} â†’\n  [toAddRightCancelSemigroup : AddRightCancelSemigroup M] â†’\n    [toZero : Zero M] â†’\n      (âˆ€ (a : M), 0 + a = a) â†’\n        (âˆ€ (a : M), a + 0 = a) â†’\n          (nsmul : â„• â†’ M â†’ M) â†’\n            autoParam (âˆ€ (x : M), nsmul 0 x = 0) _autoâœ â†’\n              autoParam (âˆ€ (n : â„•) (x : M), nsmul (n + 1) x = x + nsmul n x) _autoâœÂ¹ â†’ AddRightCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Filter.join.proof_2",
   "Membership.mem",
   "setOf",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.join.proof_3",
   "Filter.join.proof_1",
   "instMembershipSetFilter"],
  "name": "Filter.join",
  "constType": "{Î± : Type u} â†’ Filter (Filter Î±) â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "instIsCommutativeSupToSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "sup_assoc",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.Variable",
   "Iff",
   "SemilatticeSup.toSup",
   "SDiff.mk",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "inf_sdiff_self_left",
   "sup_of_le_left",
   "Nat",
   "instIsIdempotent",
   "SemilatticeSup.toPartialOrder",
   "instIsIdempotentSupToSup",
   "sup_le_sup_right",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_sup_self'",
   "Lean.Data.AC.eval",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "SDiff.sdiff",
   "sup_comm",
   "bot_le",
   "Iff.intro",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "instIsAssociative",
   "bot_sup_eq",
   "OrderBot.toBot",
   "instTransEq",
   "congr",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "le_of_inf_le_sup_le",
   "Lean.Data.AC.Expr.op",
   "inf_of_le_right",
   "Eq.refl",
   "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_le'",
   "Lean.IsNeutral",
   "le_of_eq",
   "sup_idem",
   "Lattice.toInf",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Context",
   "instOfNatNat",
   "Option.some",
   "List.nil",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GeneralizedBooleanAlgebra.toBot",
   "id",
   "Bot.bot",
   "List.cons",
   "inf_sdiff_self_right",
   "instTransLeToLE",
   "SemilatticeInf.toPartialOrder",
   "instIsCommutative",
   "Lean.IsIdempotent",
   "LE.le",
   "le_sup_left",
   "inf_sup_right",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "Lean.IsCommutative",
   "le_refl",
   "GeneralizedBooleanAlgebra",
   "inf_eq_right",
   "Sup.sup",
   "Bool",
   "instIsAssociativeSupToSup"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : GeneralizedBooleanAlgebra Î±] (y x z : Î±), y \\ x â‰¤ z â†” y â‰¤ x âŠ” z",
  "constCategory": "Theorem"},
 {"references": ["Bot", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toBot",
  "constType": "{Î± : Type u} â†’ [self : BooleanAlgebra Î±] â†’ Bot Î±",
  "constCategory": "Definition"},
 {"references": ["Bool", "Lean.Data.AC.ContextInformation"],
  "name": "Lean.Data.AC.ContextInformation.isComm",
  "constType":
  "{Î± : Sort u} â†’ [self : Lean.Data.AC.ContextInformation Î±] â†’ Î± â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.instMembershipList",
   "List",
   "List.Mem.head",
   "Not"],
  "name": "List.decidableBAll.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Prop) (x : Î±) (xs : List Î±), Â¬p x â†’ (âˆ€ x_1 âˆˆ x :: xs, p x_1) â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Continuous",
   "TopologicalSpace",
   "Iff.trans",
   "gc_coinduced_induced",
   "TopologicalSpace.induced",
   "LE.le",
   "Preorder.toLE",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced"],
  "name": "continuous_iff_le_induced",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ : TopologicalSpace Î²},\n  Continuous f â†” tâ‚ â‰¤ TopologicalSpace.induced f tâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termI^_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsIdempotent.mk",
   "SemilatticeInf.toInf",
   "IsIdempotent",
   "Inf.inf",
   "inf_idem",
   "SemilatticeInf"],
  "name": "instIsIdempotentInfToInf.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±], IsIdempotent Î± fun x x_1 â†¦ x âŠ“ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "CompleteAtomicBooleanAlgebra",
   "CompleteLattice.toInfSet",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteAtomicBooleanAlgebra.iInf_sup_le_sup_sInf",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (a : Î±) (s : Set Î±), â¨… b âˆˆ s, a âŠ” b â‰¤ a âŠ” sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.IsLowerSet",
   "Preorder",
   "rfl",
   "Topology.IsLowerSet.mk"],
  "name":
  "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsLowerSet (Topology.WithLowerSet Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Eq.refl",
   "sup_assoc",
   "Sup.sup",
   "sup_comm",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "sup_left_comm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] (a b c : Î±), a âŠ” (b âŠ” c) = b âŠ” (a âŠ” c)",
  "constCategory": "Theorem"},
 {"references": ["CompleteSemilatticeSup", "PartialOrder"],
  "name": "CompleteSemilatticeSup.toPartialOrder",
  "constType":
  "{Î± : Type u_9} â†’ [self : CompleteSemilatticeSup Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadExcept"],
  "name": "MonadExcept.throw",
  "constType":
  "{Îµ : outParam (Type u)} â†’ {m : Type v â†’ Type w} â†’ [self : MonadExcept Îµ m] â†’ {Î± : Type v} â†’ Îµ â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Multiset.Le",
   "List.Subperm.trans",
   "Iff.rfl",
   "List.isSetoid",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "Setoid.r",
   "And",
   "List",
   "List.Subperm.refl",
   "LT.lt",
   "Quot.ind",
   "List.Subperm.antisymm",
   "Multiset",
   "Not",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_4",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Multiset Î±), a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["and.match_1", "Bool.false", "Unit", "Bool"],
  "name": "and",
  "constType": "Bool â†’ Bool â†’ Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasEquiv",
  "constType": "Sort u â†’ Sort (max u (v + 1))",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.namespace",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_4"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsAssociative.mk",
   "Set",
   "IsAssociative",
   "Inter.inter",
   "Set.inter_assoc",
   "Set.instInterSet"],
  "name": "Set.inter_isAssoc.proof_1",
  "constType": "âˆ€ {Î± : Type u_1}, IsAssociative (Set Î±) fun x x_1 â†¦ x âˆ© x_1",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{Î± : Type u_1} â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_of_ball",
   "Set",
   "lowerBounds",
   "Monotone",
   "Set.image",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Monotone.mem_lowerBounds_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  Monotone f â†’ âˆ€ {a : Î±} {s : Set Î±}, a âˆˆ lowerBounds s â†’ f a âˆˆ lowerBounds (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "âˆ€ {Î± : Type u} [self : Semiring Î±] (a : Î±), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{Î± : Type u} â†’ Î± â†’ One Î±",
  "constCategory": "Other"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "âˆ€ {a b : Prop}, b â†’ a âˆ¨ b",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Fin.rec", "Nat", "instLTNat", "Fin.mk", "Fin"],
  "name": "Fin.casesOn",
  "constType":
  "{n : â„•} â†’\n  {motive : Fin n â†’ Sort u} â†’\n    (t : Fin n) â†’ ((val : â„•) â†’ (isLt : val < n) â†’ motive { val := val, isLt := isLt }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "rfl",
   "absurd",
   "ite",
   "Eq"],
  "name": "if_neg",
  "constType":
  "âˆ€ {c : Prop} {h : Decidable c}, Â¬c â†’ âˆ€ {Î± : Sort u} {t e : Î±}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "BooleanAlgebra",
   "Eq"],
  "name": "sdiff_eq",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : BooleanAlgebra Î±], x \\ y = x âŠ“ yá¶œ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references":
  ["outParam", "RelHomClass", "FunLike.coe", "RelHomClass.toFunLike"],
  "name": "RelHomClass.map_rel",
  "constType":
  "âˆ€ {F : Type u_5} {Î± : outParam (Type u_6)} {Î² : outParam (Type u_7)} {r : outParam (Î± â†’ Î± â†’ Prop)}\n  {s : outParam (Î² â†’ Î² â†’ Prop)} [self : RelHomClass F r s] (f : F) {a b : Î±}, r a b â†’ s (â†‘f a) (â†‘f b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "upperClosure.proof_1",
   "UpperSet.mk",
   "Preorder",
   "UpperSet",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperClosure",
  "constType": "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ UpperSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "Nat.modCore",
   "HSub.hSub",
   "Eq.refl",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "Nat.instModNat",
   "And",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "instLENat",
   "LT.lt",
   "HMod.hMod",
   "Nat.modCore_eq_mod",
   "instOfNatNat",
   "Nat",
   "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
   "Eq.symm",
   "Nat.decLe",
   "id"],
  "name": "Nat.mod_eq",
  "constType": "âˆ€ (x y : â„•), x % y = if 0 < y âˆ§ y â‰¤ x then (x - y) % y else x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "mem_upperClosure",
   "Preorder",
   "LE.le",
   "UpperSet",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.UpperLower.Basic._auxLemma.94",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {x : Î±}, (x âˆˆ upperClosure s) = âˆƒ a âˆˆ s, a â‰¤ x",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim.match_1", "Nonempty"],
  "name": "Nonempty.elim.proof_1",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Prop}, Nonempty Î± â†’ (Î± â†’ p) â†’ p",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Multiset.instAddMultiset",
   "Eq",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
  "constType": "âˆ€ {Î± : Type u_1} (x : Multiset Î±), nsmulRec 0 x = nsmulRec 0 x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "List.instMembershipList",
   "List.Pairwise.rec",
   "List.Pairwise.below",
   "List",
   "List.Pairwise.below.nil"],
  "name": "List.Pairwise.brecOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop} {a : List Î±}\n  (x : List.Pairwise R a), (âˆ€ (a : List Î±) (x : List.Pairwise R a), List.Pairwise.below x â†’ motive a x) â†’ motive a x",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.sub_le_sub_right.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ Prop) (x : â„•), (Unit â†’ motive 0) â†’ (âˆ€ (z : â„•), motive (Nat.succ z)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "And.right",
   "propext",
   "And.intro",
   "True",
   "Eq"],
  "name": "true_and",
  "constType": "âˆ€ (p : Prop), (True âˆ§ p) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddLeftCancelSemigroup",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} â†’ {B : outParam (Type u_2)} â†’ [self : SetLike A B] â†’ A â†’ Set B",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.heytingAlgebra",
   "BooleanAlgebra",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "Pi.booleanAlgebra.proof_4",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (a : (i : Î¹) â†’ Î± i), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.WithLowerSet.instInhabitedWithLowerSet._rarg", "_neutral"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["PProd"],
  "name": "PProd.mk",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ Î± â†’ Î² â†’ PProd Î± Î²",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{Î± : Type u} â†’ [self : LT Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["BEq.beq", "BEq", "LawfulBEq", "Bool.true", "Bool", "Eq"],
  "name": "LawfulBEq.mk",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BEq Î±], (âˆ€ {a b : Î±}, (a == b) = true â†’ a = b) â†’ (âˆ€ {a : Î±}, (a == a) = true) â†’ LawfulBEq Î±",
  "constCategory": "Other"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "false_or.match_1",
  "constType":
  "âˆ€ (p : Prop) (motive : False âˆ¨ p â†’ Prop) (x : False âˆ¨ p), (âˆ€ (h : p), motive (_ : False âˆ¨ p)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Function.swap", "Iff"],
  "name": "forall_swap",
  "constType":
  "âˆ€ {Î± : Sort u_3} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop}, (âˆ€ (x : Î±) (y : Î²), p x y) â†” âˆ€ (y : Î²) (x : Î±), p x y",
  "constCategory": "Theorem"},
 {"references": ["Iff", "imp_true_iff", "True"],
  "name": "forall_true_iff",
  "constType": "âˆ€ {Î± : Sort u_2}, Î± â†’ True â†” True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.instInhabitedMacroScopesView",
   "cond.match_1",
   "List.cons",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "Lean.MacroScopesView",
   "String",
   "Unit",
   "instBEq",
   "Lean.MacroScope",
   "Eq",
   "_private.Init.Prelude.0.Lean.assembleParts",
   "PProd",
   "namedPattern",
   "Lean.Name.rec",
   "PProd.fst",
   "BEq.beq",
   "List",
   "PUnit",
   "Lean.MacroScopesView.mk",
   "panic",
   "Bool",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "_private.Init.Prelude.0.Lean.extractImported.match_1",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractImported",
  "constType":
  "List Lean.MacroScope â†’ Lean.Name â†’ Lean.Name â†’ List Lean.Name â†’ Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "âˆ€ {Î± : Type u} [self : Lattice Î±] (a b : Î±), a âŠ“ b â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["PSigma",
   "Eq.ndrec",
   "Quot.ind",
   "PSigma.fst",
   "Quot.indepCoherent",
   "Quot.lift",
   "Quot",
   "rfl",
   "Quot.indep",
   "Quot.sound",
   "Eq",
   "Quot.mk"],
  "name": "Quot.liftIndepPr1",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {motive : Quot r â†’ Sort v} (f : (a : Î±) â†’ motive (Quot.mk r a))\n  (h : âˆ€ (a b : Î±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) â–¸ f a = f b) (q : Quot r),\n  (Quot.lift (Quot.indep f) (_ : âˆ€ (a b : Î±), r a b â†’ Quot.indep f a = Quot.indep f b) q).fst = q",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "LawfulBEq",
   "LawfulBEq.mk",
   "of_decide_eq_true",
   "instBEq",
   "of_decide_eq_self_eq_true",
   "Eq"],
  "name": "instLawfulBEqInstBEq.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±], LawfulBEq Î±",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_of_le_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, a â‰¤ b â†’ a âŠ“ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "propext",
   "Continuous",
   "TopologicalSpace",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced"],
  "name": "Mathlib.Topology.Order._auxLemma.27",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ : TopologicalSpace Î²},\n  Continuous f = (TopologicalSpace.coinduced f tâ‚ â‰¤ tâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithUpperSet",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {Î´ : Sort w} â†’ (Î² â†’ Î´) â†’ (Î± â†’ Î²) â†’ Î± â†’ Î´",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Decidable.decide",
   "propext",
   "decide_eq_true",
   "Bool.true",
   "of_decide_eq_true",
   "Decidable",
   "Bool",
   "Eq"],
  "name": "decide_eq_true_eq",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], (decide p = true) = p",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Inf.inf",
   "OrderDual.completeLattice",
   "OrderDual",
   "iSup_sup_eq",
   "Eq"],
  "name": "iInf_inf_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f g : Î¹ â†’ Î±}, â¨… x, f x âŠ“ g x = (â¨… x, f x) âŠ“ â¨… x, g x",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Prop.booleanAlgebra",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_16",
  "constType": "âˆ€ {Î± : Type u_1} (x y : Î± â†’ Prop), x \\ y = x âŠ“ yá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_9",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "DecidableEq",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Bool",
   "of_decide_eq_self_eq_true.match_1",
   "absurd",
   "rfl",
   "Eq"],
  "name": "of_decide_eq_self_eq_true",
  "constType":
  "âˆ€ {Î± : Sort u_1} [inst : DecidableEq Î±] (a : Î±), decide (a = a) = true",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_6",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_4",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Finset.univ",
   "Fintype",
   "Set.Elem",
   "DecidableEq",
   "PLift.down",
   "Function.comp",
   "Finset.image",
   "PLift",
   "Set.fintypeRange.proof_1",
   "Fintype.ofFinset"],
  "name": "Set.fintypeRange",
  "constType":
  "{Î± : Type u} â†’ {Î¹ : Sort w} â†’ [inst : DecidableEq Î±] â†’ (f : Î¹ â†’ Î±) â†’ [inst : Fintype (PLift Î¹)] â†’ Fintype â†‘(Set.range f)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.le_inf",
  "constType":
  "âˆ€ {Î± : Type u} [self : SemilatticeInf Î±] (a b c : Î±), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.IsOpen",
   "Set",
   "TopologicalSpace",
   "Inter.inter",
   "Set.instInterSet"],
  "name": "TopologicalSpace.isOpen_inter",
  "constType":
  "âˆ€ {Î± : Type u} [self : TopologicalSpace Î±] (s t : Set Î±),\n  TopologicalSpace.IsOpen s â†’ TopologicalSpace.IsOpen t â†’ TopologicalSpace.IsOpen (s âˆ© t)",
  "constCategory": "Definition"},
 {"references":
  ["supsSupHom",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "instTopologicalSpaceProd",
   "Topology.IsUpper",
   "CompleteLattice.toBoundedOrder",
   "ConditionallyCompleteLattice.toLattice",
   "Topology.instIsUpperProd",
   "Prod.completeLattice",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "CompleteLattice",
   "ContinuousSup.mk",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "sSupHom.continuous",
   "ContinuousSup"],
  "name": "Topology.IsUpper.toContinuousInf.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±], ContinuousSup Î±",
  "constCategory": "Theorem"},
 {"references": ["IsIdempotent", "IsIdempotent.idempotent", "Eq"],
  "name": "instIsIdempotent.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {op : Î± â†’ Î± â†’ Î±} [inst : IsIdempotent Î± op] (a : Î±), op a a = a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "funext",
   "Or",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.47",
   "congrArg",
   "Eq.trans",
   "Std.Logic._auxLemma.46",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.38",
   "congrFun",
   "Eq"],
  "name": "exists_eq_or_imp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a",
  "constCategory": "Theorem"},
 {"references": ["List", "String", "Lean.Syntax.Preresolved", "Lean.Name"],
  "name": "Lean.Syntax.Preresolved.decl",
  "constType": "Lean.Name â†’ List String â†’ Lean.Syntax.Preresolved",
  "constCategory": "Other"},
 {"references":
  ["Option.none", "Option.some", "Option.casesOn", "String.Pos", "Option"],
  "name": "Lean.SourceInfo.fromRef.match_1",
  "constType":
  "(motive : Option String.Pos â†’ Option String.Pos â†’ Sort u_1) â†’\n  (x x_1 : Option String.Pos) â†’\n    ((pos tailPos : String.Pos) â†’ motive (some pos) (some tailPos)) â†’\n      ((x x_2 : Option String.Pos) â†’ motive x x_2) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "Decidable.isTrue",
  "constType": "{p : Prop} â†’ p â†’ Decidable p",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower",
   "Set",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsLower.WithLowerHomeomorph._spec_1",
  "constType":
  "(Î± : Type u_1) â†’\n  (inst : Preorder Î±) â†’\n    (inst_1 : TopologicalSpace Î±) â†’\n      let _x_1 :=\n        { IsOpen := TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s},\n          isOpen_univ := (_ : TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s} Set.univ),\n          isOpen_inter :=\n            (_ :\n              âˆ€ (s t : Set Î±),\n                TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s} s â†’\n                  TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s} t â†’\n                    TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s} (Inter.interâœ s t)),\n          isOpen_sUnion :=\n            (_ :\n              âˆ€ (S : Set (Set Î±)),\n                (âˆ€ s âˆˆ S, TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s} s) â†’\n                  TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Ici a) = s} (â‹ƒâ‚€ S)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithLower Î± â‰ƒ Î±) â†’ Inducing â†‘f â†’ Topology.WithLower Î± â‰ƒâ‚œ Î±",
  "constCategory": "Axiom"},
 {"references": ["Multiset", "List.nil", "Multiset.ofList"],
  "name": "Multiset.zero",
  "constType": "{Î± : Type u_1} â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instLENat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "LE.le",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.112",
  "constType": "âˆ€ (n : â„•), (0 â‰¤ n) = True",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "or_imp.match_1",
  "constType":
  "âˆ€ {a b c : Prop} (motive : (a â†’ c) âˆ§ (b â†’ c) â†’ Prop) (x : (a â†’ c) âˆ§ (b â†’ c)),\n  (âˆ€ (ha : a â†’ c) (hb : b â†’ c), motive (_ : (a â†’ c) âˆ§ (b â†’ c))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsOpen",
   "Iff.mpr",
   "continuous_def",
   "id"],
  "name": "continuous_id",
  "constType": "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±], Continuous id",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PSigma",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Sort v) â†’ Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.rec._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set.mem_singleton",
   "Set.Nonempty",
   "Inter.inter",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Filter.instPureFilter",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "mem_closure_iff",
   "Filter",
   "Iff.trans",
   "And.casesOn",
   "IsOpen",
   "HasCompl.compl",
   "HasSubset.Subset",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "nhds_basis_opens",
   "List.Chain.cons",
   "Set.instMembershipSet",
   "And",
   "isClosed_closure",
   "Specializes",
   "propext",
   "Filter.instPartialOrderFilter",
   "List.Chain.nil",
   "Not",
   "Singleton.singleton",
   "IsClosed",
   "closure",
   "Filter.HasBasis.ge_iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "IsOpen.mem_nhds",
   "of_not_not",
   "Pure.pure",
   "Filter.principal",
   "Set.instSingletonSet",
   "IsClosed.isOpen_compl",
   "TopologicalSpace",
   "List.nil",
   "Filter.principal_singleton",
   "List.TFAE",
   "id",
   "instMembershipSetFilter",
   "Membership.mem",
   "pure_le_nhds",
   "List.cons",
   "Set.singleton_subset_iff",
   "nhds",
   "LE.le.trans",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed.closure_subset_iff",
   "subset_closure",
   "LE.le",
   "mem_closure_iff_clusterPt",
   "ClusterPt",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "List.tfae_of_cycle",
   "Set.instInterSet"],
  "name": "specializes_TFAE",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] (x y : X),\n  List.TFAE\n    [x â¤³ y, pure x â‰¤ nhds y, âˆ€ (s : Set X), IsOpen s â†’ y âˆˆ s â†’ x âˆˆ s, âˆ€ (s : Set X), IsClosed s â†’ x âˆˆ s â†’ y âˆˆ s,\n      y âˆˆ closure {x}, closure {y} âŠ† closure {x}, ClusterPt y (pure x)]",
  "constCategory": "Theorem"},
 {"references":
  ["le_sInf_iff",
   "Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "propext",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.CompleteLattice._auxLemma.3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {s : Set Î±} {a : Î±}, (a â‰¤ sInf s) = âˆ€ b âˆˆ s, a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.instPureFilter",
   "Iff",
   "Iff.rfl",
   "Set",
   "Filter",
   "Pure.pure",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_pure",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {s : Set Î±}, s âˆˆ pure a â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Prod.snd",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "inf_assoc",
   "Prod.fst",
   "Filter.instSProd",
   "inf_left_comm",
   "True",
   "Eq",
   "inf_comm",
   "CompleteLattice.toLattice",
   "of_eq_true",
   "SProd.sprod",
   "Filter.instInfFilter",
   "Filter.comap",
   "congr",
   "Filter",
   "Prod",
   "Filter.comap_inf",
   "congrArg",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.prod_inf_prod",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Filter Î²}, fâ‚ Ã—Ë¢ gâ‚ âŠ“ fâ‚‚ Ã—Ë¢ gâ‚‚ = (fâ‚ âŠ“ fâ‚‚) Ã—Ë¢ (gâ‚ âŠ“ gâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "Lean.Syntax.matchesNull",
   "cond",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "Nat.sub",
   "Lean.Syntax.node4",
   "Monad.toBind",
   "ite",
   "Eq",
   "instMonadExcept",
   "ReaderT.instMonadExceptOfReaderT",
   "Bool.true",
   "Array.append",
   "PUnit",
   "Bind.bind",
   "Nat",
   "Array.extract",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntaxArray.raw",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "Lean.Syntax",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "Lean.SourceInfo",
   "Array.mkArray0",
   "GE.ge",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "instLENat",
   "Unit.unit",
   "Lean.mkNullNode",
   "instOfNatNat",
   "List.nil",
   "Applicative.toPure",
   "Nat.decLe",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntaxArray",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.Syntax.getNumArgs",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.MacroScope",
   "Lean.Syntax.node",
   "EStateM.instMonadEStateM",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.EvalInformation.mk",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.EvalInformation",
   "Lean.Data.AC.Context.arbitrary",
   "Lean.Data.AC.Variable.value",
   "Nat",
   "Lean.Data.AC.Context.var"],
  "name": "Lean.Data.AC.instEvalInformationContext",
  "constType":
  "{Î± : Sort u_1} â†’ Lean.Data.AC.EvalInformation (Lean.Data.AC.Context Î±) Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Topology.IsUpper.t0Space.proof_1",
   "Topology.IsUpper",
   "TopologicalSpace",
   "T0Space",
   "PartialOrder"],
  "name": "Topology.IsUpper.t0Space",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsUpper Î±], T0Space Î±",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "forall_exists_index.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (motive : (âˆƒ x, p x) â†’ Prop) (x : âˆƒ x, p x),\n  (âˆ€ (x : Î±) (hpx : p x), motive (_ : âˆƒ x, p x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.cat", "_obj", "Topology.IsOpen_of._closed_9"],
  "name": "Topology.IsOpen_of._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_left",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.termÎ©._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Finite",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Order.Frame.inf_sSup_le_iSup_inf",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "Set.instMembershipSet",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_11",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Set Î±) (s : Set (Set Î±)), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "closure_minimal",
   "Set.Subset.trans",
   "IsClosed",
   "subset_closure"],
  "name": "IsClosed.closure_subset_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, IsClosed t â†’ (closure s âŠ† t â†” s âŠ† t)",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "TopologicalSpace",
   "IsClosed",
   "Preorder",
   "ClosedIciTopology",
   "LE.le",
   "Preorder.toLE"],
  "name": "ClosedIciTopology.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±],\n  (âˆ€ (a : Î±), IsClosed {b | a â‰¤ b}) â†’ ClosedIciTopology Î±",
  "constCategory": "Other"},
 {"references": ["LE.mk", "Prod.casesOn", "Prod.mk", "LE", "Prod", "LE.le"],
  "name": "Prod.instPreorderProd.match_4",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) (src : LE (Î± Ã— Î²)) (x : Î± Ã— Î²) (a : Î±) (b : Î²)\n  (motive : (x_1 : Î± Ã— Î²) â†’ x_1 â‰¤ x â†’ (a, b) â‰¤ x_1 â†’ Prop) (x_1 : Î± Ã— Î²) (x_2 : x_1 â‰¤ x) (x_3 : (a, b) â‰¤ x_1),\n  (âˆ€ (c : Î±) (d : Î²) (x : (c, d) â‰¤ x) (x_4 : (a, b) â‰¤ (c, d)), motive (c, d) x x_4) â†’ motive x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace.GenerateOpen", "Set.univ"],
  "name": "TopologicalSpace.GenerateOpen.univ",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)}, TopologicalSpace.GenerateOpen g Set.univ",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "Membership.mem",
   "Filter.HasBasis",
   "Iff",
   "Set.Nonempty.mono",
   "Set",
   "Set.Nonempty",
   "Iff.trans",
   "Filter",
   "Filter.HasBasis.forall_iff",
   "Filter.NeBot",
   "Filter.forall_mem_nonempty_iff_neBot",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.neBot_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ (Filter.NeBot l â†” âˆ€ {i : Î¹}, p i â†’ Set.Nonempty (s i))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Sublist.subset",
   "List.instMembershipList",
   "List",
   "List.Sublist",
   "List.nil",
   "List.Pairwise.cons",
   "List.Pairwise.sublist.match_1._@.Std.Data.List.Lemmas._hyg.28830",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Pairwise.sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} {R : Î± â†’ Î± â†’ Prop}, List.Sublist lâ‚ lâ‚‚ â†’ List.Pairwise R lâ‚‚ â†’ List.Pairwise R lâ‚",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.le_top",
  "constType": "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (a : Î±), a â‰¤ âŠ¤",
  "constCategory": "Definition"},
 {"references":
  ["UInt32.decEq.proof_1",
   "UInt32.mk",
   "UInt32",
   "Decidable.isFalse",
   "UInt32.decEq.proof_2",
   "Decidable",
   "instDecidableEqFin",
   "Not",
   "Decidable.isTrue",
   "dite",
   "UInt32.size",
   "UInt32.decEq.match_1",
   "Fin",
   "Eq"],
  "name": "UInt32.decEq",
  "constType": "(a b : UInt32) â†’ Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Finset.mem_image",
   "DecidableEq",
   "propext",
   "Finset.image",
   "Finset",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.24",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DecidableEq Î²] {f : Î± â†’ Î²} {s : Finset Î±} {b : Î²},\n  (b âˆˆ Finset.image f s) = âˆƒ a âˆˆ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "instBEq",
   "Exists.intro",
   "Exists.casesOn",
   "List.erase",
   "Eq",
   "And",
   "instHAppend",
   "List.instAppendList",
   "DecidableEq",
   "List",
   "HAppend.hAppend",
   "Not",
   "And.intro",
   "And.casesOn"],
  "name": "List.perm_cons_erase.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}\n  (motive : (âˆƒ lâ‚, âˆƒ lâ‚‚, Â¬a âˆˆ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.erase l a = lâ‚ ++ lâ‚‚) â†’ Prop)\n  (x : âˆƒ lâ‚, âˆƒ lâ‚‚, Â¬a âˆˆ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.erase l a = lâ‚ ++ lâ‚‚),\n  (âˆ€ (_lâ‚ _lâ‚‚ : List Î±) (left : Â¬a âˆˆ _lâ‚) (eâ‚ : l = _lâ‚ ++ a :: _lâ‚‚) (eâ‚‚ : List.erase l a = _lâ‚ ++ _lâ‚‚),\n      motive (_ : âˆƒ lâ‚, âˆƒ lâ‚‚, Â¬a âˆˆ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.erase l a = lâ‚ ++ lâ‚‚)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Monad", "ReaderT", "Bind.bind", "Monad.toBind"],
  "name": "ReaderT.bind",
  "constType":
  "{Ï : Type u} â†’\n  {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ {Î± Î² : Type u} â†’ ReaderT Ï m Î± â†’ (Î± â†’ ReaderT Ï m Î²) â†’ ReaderT Ï m Î²",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set.instHasSubsetSet",
   "Mathlib.Order.Filter.Basic._auxLemma.120",
   "of_eq_true",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter"],
  "name": "Filter.comap.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (m : Î± â†’ Î²) (f : Filter Î²), âˆƒ t âˆˆ f, m â»Â¹' t âŠ† Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.sSup",
   "GaloisInsertion.isLUB_of_u_image",
   "GaloisInsertion",
   "CompleteSemilatticeSup.toSupSet",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "CompleteLattice",
   "isLUB_sSup",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±],\n  GaloisInsertion l u â†’ âˆ€ (s : Set Î²), l (sSup (u '' s)) âˆˆ lowerBounds (upperBounds s)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpper", "Preorder"],
  "name": "Topology.WithUpper.instPreorderWithUpper._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} â†’ [self : AddMonoid M] â†’ Zero M",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Prod.snd",
   "Prod.instLEProd",
   "Prod.fst",
   "Prod.instPreorderProd.proof_3",
   "Preorder",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Preorder.mk",
   "And",
   "Prod.instPreorderProd.proof_2",
   "LE",
   "inferInstanceAs",
   "Prod.instPreorderProd.proof_1",
   "Prod",
   "Not"],
  "name": "Prod.instPreorderProd",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ Preorder (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references": ["instLENat", "Nat", "LE.le", "Nat.succ", "Nat.pred_le_pred"],
  "name": "Nat.le_of_succ_le_succ",
  "constType": "âˆ€ {n m : â„•}, Nat.succ n â‰¤ Nat.succ m â†’ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "if_pos",
   "List.decidableBAll",
   "List.instMembershipList",
   "List",
   "List.foldr",
   "List.pwFilter",
   "List.nil",
   "Eq",
   "ite",
   "DecidableRel"],
  "name": "List.pwFilter_cons_of_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [inst : DecidableRel R] {a : Î±} {l : List Î±},\n  (âˆ€ b âˆˆ List.pwFilter R l, R a b) â†’ List.pwFilter R (a :: l) = a :: List.pwFilter R l",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Equiv.mk",
   "Topology.WithLower.toDualHomeomorph._closed_1",
   "_neutral"],
  "name": "Topology.WithLower.toDualHomeomorph._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsAntisymm",
   "Set.instHasSubsetSet",
   "Set",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet.proof_1",
   "HasSubset.Subset"],
  "name": "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
  "constType": "âˆ€ {Î± : Type u}, IsAntisymm (Set Î±) fun x x_1 â†¦ x âŠ† x_1",
  "constCategory": "Definition"},
 {"references":
  ["Bool.of_not_eq_true.match_1",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "Eq"],
  "name": "Bool.of_not_eq_true",
  "constType": "âˆ€ {b : Bool}, Â¬b = true â†’ b = false",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.map",
   "Finset.univ",
   "Fintype.ofBijective.proof_2",
   "Fintype.mk",
   "Fintype",
   "Function.Bijective",
   "Function.Embedding.mk",
   "Fintype.ofBijective.proof_1"],
  "name": "Fintype.ofBijective",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : Fintype Î±] â†’ (f : Î± â†’ Î²) â†’ Function.Bijective f â†’ Fintype Î²",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "instSubNat",
   "HSub.hSub",
   "Nat",
   "Nat.succ",
   "Nat.succ_sub_succ_eq_sub",
   "Eq"],
  "name": "Nat.succ_sub_succ",
  "constType": "âˆ€ (n m : â„•), Nat.succ n - Nat.succ m = n - m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["Pure"],
  "name": "Pure.pure",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : Pure f] â†’ {Î± : Type u} â†’ Î± â†’ f Î±",
  "constCategory": "Definition"},
 {"references": ["Exists", "eq_false", "False", "exists_false", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.86",
  "constType": "âˆ€ {Î± : Sort u_1}, (âˆƒ _a, False) = False",
  "constCategory": "Theorem"},
 {"references": ["String", "String.toSubstring", "Substring"],
  "name": "String.toSubstring'",
  "constType": "String â†’ Substring",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Std.Logic._auxLemma.34",
   "Or",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Std.Logic._auxLemma.43",
   "congrArg",
   "Std.Logic._auxLemma.44",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "forall_eq_or_imp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ (a : Î±), q a â†’ p a",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "â„• â†’ â„• â†’ Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["lt_of_le_not_le",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "dite",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "Decidable.lt_or_eq_of_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : DecidableRel fun x x_1 â†¦ x â‰¤ x_1] {a b : Î±}, a â‰¤ b â†’ a < b âˆ¨ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.eq_nil_of_length_eq_zero.match_1",
   "List",
   "instOfNatNat",
   "List.nil",
   "List.length",
   "Nat",
   "rfl",
   "Eq"],
  "name": "List.eq_nil_of_length_eq_zero",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, List.length l = 0 â†’ l = []",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "SDiff"],
  "name": "CompleteAtomicBooleanAlgebra.toSDiff",
  "constType":
  "{Î± : Type u} â†’ [self : CompleteAtomicBooleanAlgebra Î±] â†’ SDiff Î±",
  "constCategory": "Definition"},
 {"references": ["UInt64"],
  "name": "mixHash",
  "constType": "UInt64 â†’ UInt64 â†’ UInt64",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "Option.none",
   "List",
   "PUnit",
   "Option.some",
   "Nat",
   "List.get!.match_1",
   "Option"],
  "name": "List.get?",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ â„• â†’ Option Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "setOf",
   "Set",
   "InfSet",
   "Set.instMembershipSet"],
  "name": "Set.instInfSetSet",
  "constType": "{Î± : Type u_1} â†’ InfSet (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["UInt32",
   "Eq.ndrec",
   "UInt32.noConfusionType",
   "Eq.refl",
   "UInt32.size",
   "UInt32.casesOn",
   "Fin",
   "Eq"],
  "name": "UInt32.noConfusion",
  "constType":
  "{P : Sort u} â†’ {v1 v2 : UInt32} â†’ v1 = v2 â†’ UInt32.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.68",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±},\n  List.Pairwise R (a :: l) = ((âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "âˆ€ {Î± : Sort u} (a : Î±), HEq a a",
  "constCategory": "Other"},
 {"references": ["Exists", "propext", "exists_const", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.30",
  "constType": "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆƒ x, b) = b",
  "constCategory": "Theorem"},
 {"references": ["And", "Iff", "iff_of_eq", "and_self"],
  "name": "and_self_iff",
  "constType": "âˆ€ (p : Prop), p âˆ§ p â†” p",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.ofLowerSet_le_iff",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Topology.WithLowerSet.ofLowerSetOrderIso",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithLowerSet Î± â‰ƒo Î±",
  "constCategory": "Definition"},
 {"references": ["Set.iUnion", "Set", "Set.iUnion_congr", "Eq"],
  "name": "Set.iUnionâ‚‚_congr",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {Îº : Î¹ â†’ Sort u_7} {s t : (i : Î¹) â†’ Îº i â†’ Set Î±},\n  (âˆ€ (i : Î¹) (j : Îº i), s i j = t i j) â†’ â‹ƒ i, â‹ƒ j, s i j = â‹ƒ i, â‹ƒ j, t i j",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Not",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (a b : (Filter Î±)áµ’áµˆáµ’áµˆ), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax.Preresolved.namespace",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelMonoid.toZero",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_zero",
  "constType":
  "âˆ€ {M : Type u} [self : AddRightCancelMonoid M] (x : M), AddRightCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "And.right",
   "setOf",
   "Set",
   "LE.le.trans",
   "Exists.imp",
   "And.intro",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerClosure.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (s : Set Î±) (x x_1 : Î±), x_1 â‰¤ x â†’ x âˆˆ {x | âˆƒ a âˆˆ s, x â‰¤ a} â†’ âˆƒ a âˆˆ s, x_1 â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_rfl",
   "sup_le_sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ b â†’ âˆ€ (c : Î±), a âŠ” c â‰¤ b âŠ” c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "eq_of_heq",
   "List.Mem.tail",
   "List.Mem",
   "Eq.refl",
   "Eq",
   "And",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.forall_mem_cons.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {l : List Î±} (x : Î±) (motive : (a : Î±) â†’ x âˆˆ a :: l â†’ (p a âˆ§ âˆ€ x âˆˆ l, p x) â†’ p a â†’ Prop)\n  (a : Î±) (x_1 : x âˆˆ a :: l) (x_2 : p a âˆ§ âˆ€ x âˆˆ l, p x) (Hâ‚ : p a),\n  (âˆ€ (x_3 : p x âˆ§ âˆ€ x âˆˆ l, p x) (Hâ‚ : p x), motive x (_ : List.Mem x (x :: l)) x_3 Hâ‚) â†’\n    (âˆ€ (a : Î±) (h : List.Mem x l) (x_3 : p a âˆ§ âˆ€ x âˆˆ l, p x) (Hâ‚ : p a), motive a (_ : List.Mem x (a :: l)) x_3 Hâ‚) â†’\n      motive a x_1 x_2 Hâ‚",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff.mp",
   "Iff",
   "And.symm.match_1",
   "And.intro",
   "Iff.mpr"],
  "name": "and_congr_right",
  "constType": "âˆ€ {a b c : Prop}, (a â†’ (b â†” c)) â†’ (a âˆ§ b â†” a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "ite"],
  "name": "List.insert",
  "constType": "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ Î± â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompletelyDistribLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{Î± : Type u} â†’ [self : CompletelyDistribLattice Î±] â†’ CompleteLattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Std.Data.List.Lemmas._auxLemma.2",
   "HAdd.hAdd",
   "List.casesOn",
   "dite",
   "List.Perm.cons",
   "List.erase",
   "instLTNat",
   "Eq",
   "List.perm_cons_erase",
   "Eq.mpr",
   "Iff",
   "Iff.mp",
   "true_or",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "Or",
   "Mathlib.Algebra.Group.Defs._auxLemma.4",
   "Iff.intro",
   "DecidableEq",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "Nat.noConfusion",
   "propext",
   "LT.lt",
   "Eq.mp",
   "congr",
   "List.Perm.trans",
   "Not",
   "List.count_erase_of_ne",
   "congrArg",
   "List.count",
   "congrFun",
   "List.count_pos_iff_mem",
   "instSubNat",
   "List.instMembershipList",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "Eq.refl",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "List.Perm.symm",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "List.rec",
   "List.count_cons_of_ne",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "List.Perm.count_eq",
   "List.nil",
   "Eq.symm",
   "id",
   "eq_self",
   "Membership.mem",
   "List.cons",
   "False",
   "instAddNat",
   "List.Perm.refl",
   "instHAdd",
   "HSub.hSub",
   "instBEq",
   "List.count_cons_self",
   "eq_false",
   "List.Perm",
   "Eq.ndrec",
   "List",
   "List.count_erase_self"],
  "name": "List.perm_iff_count",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†” âˆ€ (a : Î±), List.count a lâ‚ = List.count a lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Eq",
   "Topology.WithUpper.ofUpper",
   "Equiv.symm"],
  "name": "Topology.WithUpper.of_WithUpper_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithUpper.ofUpper.symm = Topology.WithUpper.toUpper",
  "constCategory": "Theorem"},
 {"references":
  ["List.hasDecEq.match_1",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.hasDecEq.proof_2",
   "List.hasDecEq.match_3",
   "List.hasDecEq.proof_4",
   "Unit",
   "List.hasDecEq.match_2",
   "List.hasDecEq.proof_3",
   "Decidable.isTrue",
   "decEq",
   "Eq",
   "PProd",
   "PProd.fst",
   "List.rec",
   "DecidableEq",
   "List",
   "Decidable.isFalse",
   "PUnit",
   "Decidable",
   "Not",
   "List.nil",
   "List.hasDecEq.proof_1",
   "List.hasDecEq.proof_6",
   "List.hasDecEq.proof_5"],
  "name": "List.hasDecEq",
  "constType":
  "{Î± : Type u} â†’ [inst : DecidableEq Î±] â†’ (a b : List Î±) â†’ Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "PartialOrder"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{Î± : Type u} â†’ [self : SemilatticeSup Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeSup.sup_le",
   "OrderDual",
   "Sup.sup",
   "OrderDual.semilatticeSup",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Lattice Î±] (a b c : Î±áµ’áµˆ), a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.evalList.match_1",
  "constType":
  "(motive : List â„• â†’ Sort u_1) â†’\n  (x : List â„•) â†’ (Unit â†’ motive []) â†’ ((x : â„•) â†’ motive [x]) â†’ ((x : â„•) â†’ (xs : List â„•) â†’ motive (x :: xs)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLowerSet.instPreorderWithLowerSet._rarg", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Eq.ndrec",
   "Finite.Set.finite_union",
   "Set.Elem",
   "Union.union",
   "Set",
   "Eq.refl",
   "Eq.symm",
   "Finite.of_fintype",
   "Set.toFinite",
   "Set.instUnionSet",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.union",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, Set.Finite s â†’ Set.Finite t â†’ Set.Finite (s âˆª t)",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{Î± : Type u} â†’ [self : Sub Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "Homeomorph",
  "constType":
  "(X : Type u_4) â†’ (Y : Type u_5) â†’ [inst : TopologicalSpace X] â†’ [inst : TopologicalSpace Y] â†’ Type (max u_4 u_5)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "Set.mem_inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {x y : Set Î±}, x âˆˆ {s | âˆ€ (x : Î±), x âˆˆ s} â†’ y âˆˆ {s | âˆ€ (x : Î±), x âˆˆ s} â†’ âˆ€ (x_1 : Î±), x_1 âˆˆ x âˆ© y",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "ClosedIicTopology",
  "constType":
  "(Î± : Type u_1) â†’ [inst : TopologicalSpace Î±] â†’ [inst : Preorder Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.instSingletonSet",
   "Iff.mp",
   "Set.mem_singleton_iff",
   "Eq.rec",
   "Set",
   "Singleton.singleton",
   "Set.range_const_subset",
   "Eq.symm",
   "Set.mem_range_self",
   "Set.Subset.antisymm",
   "Set.range_const.match_1",
   "Nonempty",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.range_const",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : Nonempty Î¹] {c : Î±}, (Set.range fun x â†¦ c) = {c}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.TSyntax",
   "Array",
   "List.cons",
   "Lean.SourceInfo.none",
   "Lean.SyntaxNodeKind",
   "Lean.TSyntax.mk",
   "List.nil",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.mkNode",
  "constType": "(k : Lean.SyntaxNodeKind) â†’ Array Lean.Syntax â†’ Lean.TSyntax k",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLower.toLower._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.WithUpperSet.instInhabitedWithUpperSet._rarg", "_neutral"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "List.Chain.cons",
   "Iff.intro",
   "And",
   "Iff",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Chain.casesOn",
   "List.Chain.nil",
   "List.nil",
   "And.intro",
   "List.noConfusion",
   "List.chain_cons.match_1",
   "List.Chain",
   "Eq.symm"],
  "name": "List.chain_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a b : Î±} {l : List Î±}, List.Chain R a (b :: l) â†” R a b âˆ§ List.Chain R b l",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim.proof_1", "Nonempty"],
  "name": "Nonempty.elim",
  "constType": "âˆ€ {Î± : Sort u} {p : Prop}, Nonempty Î± â†’ (Î± â†’ p) â†’ p",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SProd",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Inhabited", "Nonempty", "Inhabited.default"],
  "name": "instNonempty.proof_1",
  "constType": "âˆ€ {Î± : Sort u_1} [inst : Inhabited Î±], Nonempty Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "closure",
   "mem_interior_iff_mem_nhds",
   "setOf",
   "Iff.rfl",
   "nhds",
   "Set",
   "closure_eq_compl_interior_compl",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "_private.Mathlib.Topology.Basic.0.Filter.Eventually._eq_1",
   "Filter.Eventually",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "_private.Mathlib.Topology.Basic.0.Filter.Frequently._eq_1",
   "Filter.Frequently",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "Not",
   "Filter",
   "Eq.symm",
   "interior",
   "instMembershipSetFilter",
   "id"],
  "name": "mem_closure_iff_frequently",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {a : Î±}, a âˆˆ closure s â†” âˆƒá¶  (x : Î±) in nhds a, x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "LE.le.trans", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_le_of_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b = c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "eq_true",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.12",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, (a âŠ“ b â‰¤ b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Prod.snd",
   "Iff",
   "Iff.rfl",
   "SProd.sprod",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.instMembershipSet"],
  "name": "Set.mem_prod",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²} {p : Î± Ã— Î²}, p âˆˆ s Ã—Ë¢ t â†” p.1 âˆˆ s âˆ§ p.2 âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.semilatticeInf",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_6",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Lattice Î±] (a b c : Î±áµ’áµˆ), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype",
   "Multiset",
   "Finset.val",
   "Finset.mem_univ",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.mem_univ_val",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] (x : Î±), x âˆˆ Finset.univ.val",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.below",
   "List.brecOn",
   "Eq.refl",
   "dite",
   "List.indexOf",
   "instLTNat",
   "True",
   "Eq",
   "ite",
   "PProd",
   "List.rec",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "PUnit",
   "List.indexOf_get.match_1",
   "instOfNatNat",
   "Nat",
   "List.indexOf_cons",
   "Eq.trans",
   "Nat.succ",
   "if_false",
   "Fin.mk",
   "eq_self",
   "List.cons",
   "False",
   "instBEq",
   "List.length",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "PProd.fst",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "of_eq_true",
   "DecidableEq",
   "List",
   "LT.lt",
   "congr",
   "Not",
   "List.get",
   "congrArg",
   "Fin",
   "congrFun"],
  "name": "List.indexOf_get",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] {a : Î±} {l : List Î±} (h : List.indexOf a l < List.length l),\n  List.get l { val := List.indexOf a l, isLt := h } = a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "Set",
   "HasSubset.Subset",
   "Set.univ",
   "True",
   "Set.subset_univ",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.120",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±), (s âŠ† Set.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.empty", "EmptyCollection.mk", "Finset", "EmptyCollection"],
  "name": "Finset.instEmptyCollectionFinset",
  "constType": "{Î± : Type u_1} â†’ EmptyCollection (Finset Î±)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.closure_of._closed_2",
   "Topology.closure_of._closed_6",
   "Lean.ParserDescr.node",
   "_obj"],
  "name": "Topology.closure_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "List.length", "Nat", "Nat.succ", "rfl", "Eq"],
  "name": "List.length_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (as : List Î±), List.length (a :: as) = Nat.succ (List.length as)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {x y : Set Î±}, x âˆˆ {s | âˆ€ (x : Î±), x âˆˆ s} â†’ x âŠ† y â†’ âˆ€ (a : Î±), a âˆˆ y",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_rfl",
   "sup_le_sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ b â†’ âˆ€ (c : Î±), c âŠ” a â‰¤ c âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Set.instBooleanAlgebraSet.proof_5",
   "Prop.booleanAlgebra",
   "EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "Set",
   "Inter.inter",
   "Set.instBooleanAlgebraSet.proof_17",
   "Lattice.mk",
   "LT.mk",
   "HasCompl.mk",
   "Sup.mk",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "inferInstance",
   "Inf.mk",
   "BooleanAlgebra.toHImp",
   "SDiff.mk",
   "Set.instBooleanAlgebraSet.proof_9",
   "Set.instBooleanAlgebraSet.proof_1",
   "Set.instBooleanAlgebraSet.proof_8",
   "Set.instBooleanAlgebraSet.proof_13",
   "Set.instBooleanAlgebraSet.proof_6",
   "Membership.mem",
   "Set.instBooleanAlgebraSet.proof_16",
   "setOf",
   "Union.union",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.instBooleanAlgebraSet.proof_4",
   "Set.univ",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "Set.instBooleanAlgebraSet.proof_7",
   "And",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet.proof_3",
   "Set.instBooleanAlgebraSet.proof_14",
   "Set.instBooleanAlgebraSet.proof_10",
   "Pi.booleanAlgebra",
   "Bot.mk",
   "Set.instBooleanAlgebraSet.proof_11",
   "Set.instBooleanAlgebraSet.proof_2",
   "Not",
   "Set.instBooleanAlgebraSet.proof_12",
   "Top.mk",
   "Set.instUnionSet",
   "Set.instBooleanAlgebraSet.proof_15",
   "Set.instInterSet"],
  "name": "Set.instBooleanAlgebraSet",
  "constType": "{Î± : Type u} â†’ BooleanAlgebra (Set Î±)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["MonadWithReaderOf",
   "MonadWithReader",
   "withTheReader",
   "MonadWithReader.mk"],
  "name": "instMonadWithReader",
  "constType":
  "(Ï : Type u) â†’ (m : Type u â†’ Type v) â†’ [inst : MonadWithReaderOf Ï m] â†’ MonadWithReader Ï m",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.subperm_right",
   "instHasEquiv",
   "propext",
   "List",
   "List.Subperm",
   "List.isSetoid",
   "Iff.trans",
   "HasEquiv.Equiv",
   "Eq",
   "List.Perm.subperm_left"],
  "name": "Multiset.Le.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (x x_1 x_2 x_3 : List Î±), x â‰ˆ x_2 â†’ x_1 â‰ˆ x_3 â†’ (x <+~ x_1) = (x_2 <+~ x_3)",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "DecidableEq",
   "List.dedup",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.dedup.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.dedup",
  "constType":
  "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ Multiset Î± â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Continuous_of._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.Context", "Lean.Syntax"],
  "name": "Lean.Macro.Context.ref",
  "constType": "Lean.Macro.Context â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.39",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{Î± : Type u} â†’ Î± â†’ List Î± â†’ List Î±",
  "constCategory": "Other"},
 {"references":
  ["Exists", "propext", "Exists.intro", "forall_exists_index", "Eq"],
  "name": "Std.Logic._auxLemma.29",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q (_ : âˆƒ x, p x)",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "BoundedOrder",
  "constType": "(Î± : Type u) â†’ [inst : LE Î±] â†’ Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Option",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "setOf",
   "propext",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter",
   "Filter.mem_inf_principal",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.35",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s t : Set Î±}, (s âˆˆ f âŠ“ Filter.principal t) = ({x | x âˆˆ t â†’ x âˆˆ s} âˆˆ f)",
  "constCategory": "Theorem"},
 {"references": ["IsRefl", "HasSubset.Subset", "HasSubset", "refl"],
  "name": "subset_rfl",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1], a âŠ† a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "cond",
   "HAdd.hAdd",
   "Bool.cond_eq_ite",
   "Eq.refl",
   "List.indexOf",
   "List.findIdx",
   "True",
   "ite",
   "Eq",
   "instLawfulBEqInstBEq",
   "BEq.beq",
   "Bool.true",
   "instOfNatNat",
   "List.findIdx_cons",
   "Nat",
   "Eq.trans",
   "Nat.succ",
   "Mathlib.Data.List.Basic._auxLemma.32",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "instBEq",
   "ite_congr",
   "of_eq_true",
   "DecidableEq",
   "List",
   "congr",
   "Not",
   "Bool",
   "congrArg"],
  "name": "List.indexOf_cons",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DecidableEq Î±] (a b : Î±) (l : List Î±),\n  List.indexOf a (b :: l) = if a = b then 0 else Nat.succ (List.indexOf a l)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Decidable",
   "Not",
   "not_not_intro",
   "Decidable.of_not_not"],
  "name": "Decidable.not_not",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], Â¬Â¬p â†” p",
  "constCategory": "Theorem"},
 {"references": ["And", "Not", "And.intro", "And.casesOn"],
  "name": "and_not_self.match_1",
  "constType":
  "âˆ€ {a : Prop} (motive : a âˆ§ Â¬a â†’ Prop) (x : a âˆ§ Â¬a), (âˆ€ (ha : a) (hn : Â¬a), motive (_ : a âˆ§ Â¬a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "âˆ€ (n : â„•), Nat.succ n â‰  0",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm", "Classical.not_not", "Iff", "Iff.trans", "Not", "Iff.not"],
  "name": "Iff.not_right",
  "constType": "âˆ€ {a b : Prop}, (Â¬a â†” b) â†’ (a â†” Â¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet.proof_1",
   "Preorder",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name":
  "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsUpperSet (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Eq.ndrec",
   "Set.Elem",
   "Set",
   "Eq.refl",
   "Set.image",
   "Eq.symm",
   "Finite.of_fintype",
   "Finite.Set.finite_image",
   "Set.toFinite",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {s : Set Î±} (f : Î± â†’ Î²), Set.Finite s â†’ Set.Finite (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "if_pos.match_1",
  "constType":
  "âˆ€ {c : Prop} (motive : Decidable c â†’ Prop) (h : Decidable c),\n  (âˆ€ (h : c), motive (isTrue h)) â†’ (âˆ€ (hnc : Â¬c), motive (isFalse hnc)) â†’ motive h",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "âˆ€ {Î± : Sort u} {a : Î±}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.symm",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "imp_iff_right",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "Set.univ",
   "Set.univ_subset_iff",
   "forall_congr'",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_iff_forall",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s = Set.univ â†” âˆ€ (x : Î±), x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.mem_def",
  "constType": "âˆ€ {Î± : Type u_1} {a : Î±} {s : Finset Î±}, a âˆˆ s â†” a âˆˆ s.val",
  "constCategory": "Theorem"},
 {"references": ["PUnit.unit", "_obj", "_neutral", "EStateM.Result.error"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.Subtype._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result.ok", "EStateM.Result", "EStateM.Result.error"],
  "name": "EStateM.Result.rec",
  "constType":
  "{Îµ Ïƒ Î± : Type u} â†’\n  {motive : EStateM.Result Îµ Ïƒ Î± â†’ Sort u_1} â†’\n    ((a : Î±) â†’ (a_1 : Ïƒ) â†’ motive (EStateM.Result.ok a a_1)) â†’\n      ((a : Îµ) â†’ (a_1 : Ïƒ) â†’ motive (EStateM.Result.error a a_1)) â†’ (t : EStateM.Result Îµ Ïƒ Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray1",
  "constType": "{Î± : Type u} â†’ Î± â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_8",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Exists.intro",
   "Filter.map_le_iff_le_comap.match_1",
   "LE.le",
   "Set.Subset.rfl",
   "Preorder.toLE",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter",
   "And.intro",
   "instMembershipSetFilter"],
  "name": "Filter.map_le_iff_le_comap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Filter Î±} {g : Filter Î²} {m : Î± â†’ Î²}, Filter.map m f â‰¤ g â†” f â‰¤ Filter.comap m g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Filter.Eventually",
   "implies_congr",
   "Filter.Frequently",
   "Set.instMembershipSet",
   "Eq",
   "and_comm",
   "And",
   "Eq.mpr",
   "Iff",
   "propext",
   "forall_congr",
   "Mathlib.Order.Filter.Basic._auxLemma.87",
   "Filter",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "congrFun"],
  "name": "Filter.frequently_iff",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {P : Î± â†’ Prop}, (âˆƒá¶  (x : Î±) in f, P x) â†” âˆ€ {U : Set Î±}, U âˆˆ f â†’ âˆƒ x âˆˆ U, P x",
  "constCategory": "Theorem"},
 {"references": ["Nat.le.step", "instLENat", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_step",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ n â‰¤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPreorder",
   "Set.preimage",
   "Continuous",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Set.Iic",
   "IsClosed",
   "Topology.IsLower.continuous_of_Ici",
   "Preorder"],
  "name": "Topology.IsUpper.continuous_of_Iic",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±]\n  [inst_3 : TopologicalSpace Î²] {f : Î² â†’ Î±}, (âˆ€ (a : Î±), IsClosed (f â»Â¹' Set.Iic a)) â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[_]_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "LinearOrder.toPartialOrder",
   "Preorder.le_trans",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_2",
  "constType": "âˆ€ (a b c : â„•), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Sublist", "List.Sublist.cons"],
  "name": "List.sublist_cons_of_sublist",
  "constType":
  "âˆ€ {Î± : Type u} (a : Î±) {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist lâ‚ (a :: lâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Or",
   "EmptyCollection.emptyCollection",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.instEmptyCollectionSet",
   "Prod",
   "Set.prod_eq_empty_iff",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.22",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²}, (s Ã—Ë¢ t = âˆ…) = (s = âˆ… âˆ¨ t = âˆ…)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Setoid",
  "constType": "Sort u â†’ Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1",
   "Multiset",
   "CovariantClass",
   "LE.le",
   "Multiset.instAddMultiset",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
  "constType":
  "âˆ€ {Î± : Type u_1}, CovariantClass (Multiset Î±) (Multiset Î±) (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "RelIso.mk",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Topology.WithUpperSet.toUpperSet_le_iff"],
  "name": "Topology.WithUpperSet.toUpperSetOrderIso",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â‰ƒo Topology.WithUpperSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "List.Sublist.length_le",
   "Nat.le",
   "List.cons",
   "Std.Data.List.Lemmas._auxLemma.39",
   "List.Sublist",
   "List.length_replicate",
   "List.length",
   "LE.le",
   "Nat.le.rec",
   "Iff.intro",
   "eq_true",
   "Iff",
   "instLENat",
   "of_eq_true",
   "List.replicate",
   "Eq.mp",
   "congr",
   "Nat",
   "congrArg"],
  "name": "List.replicate_sublist_replicate",
  "constType":
  "âˆ€ {Î± : Type u_1} {m n : â„•} (a : Î±), List.Sublist (List.replicate m a) (List.replicate n a) â†” m â‰¤ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SupSet",
  "constType": "Type u_9 â†’ Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "Eq.refl",
   "sup_comm",
   "iSup",
   "SupSet.sSup",
   "sSup_pair",
   "Insert.insert",
   "Eq",
   "CompleteLattice.toLattice",
   "Set.range",
   "Bool.range_eq",
   "Set.instSingletonSet",
   "Eq.mpr",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "CompleteLattice",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "Bool.false",
   "Bool.true",
   "Singleton.singleton",
   "Sup.sup",
   "Bool",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "Set.instInsertSet",
   "id"],
  "name": "iSup_bool_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {f : Bool â†’ Î±}, â¨† b, f b = f true âŠ” f false",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadReader"],
  "name": "MonadReader.read",
  "constType":
  "{Ï : outParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadReader Ï m] â†’ m Ï",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "LE",
   "Inter.inter",
   "And.imp",
   "LE.le",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "IsLowerSet.inter",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s t : Set Î±}, IsLowerSet s â†’ IsLowerSet t â†’ IsLowerSet (s âˆ© t)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper", "Topology.upper", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsUpper.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±] [inst : Preorder Î±], t = Topology.upper Î± â†’ Topology.IsUpper Î±",
  "constCategory": "Other"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.49",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ§ b) âˆ§ c) = (a âˆ§ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Functor",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{Î± : Type u_1} â†’ [toLattice : Lattice Î±] â†’ (âˆ€ (x y z : Î±), (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z) â†’ DistribLattice Î±",
  "constCategory": "Other"},
 {"references": ["ULift"],
  "name": "ULift.up",
  "constType": "{Î± : Type s} â†’ Î± â†’ ULift.{r, s} Î±",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommSemigroup.add_comm",
   "Eq"],
  "name": "add_comm",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Multiset",
   "Multiset.nodup_dedup",
   "Multiset.Nodup",
   "Multiset.dedup"],
  "name": "Multiset.toFinset.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (s : Multiset Î±), Multiset.Nodup (Multiset.dedup s)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "eq_self",
   "Eq.refl",
   "LE.le",
   "instDecidableTrue",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "eq_true",
   "instLENat",
   "of_eq_true",
   "Not",
   "Nat",
   "instMinNat",
   "congrArg",
   "Eq.trans",
   "Nat.decLe",
   "congrFun"],
  "name": "Nat.min_eq_left",
  "constType": "âˆ€ {a b : â„•}, a â‰¤ b â†’ min a b = a",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "LE"],
  "name": "Prop.le",
  "constType": "LE Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "Mathlib.Order.Lattice._auxLemma.2",
   "and_true",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Iff.trans",
   "Sup.sup",
   "Mathlib.Order.Lattice._auxLemma.3",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "le_antisymm_iff",
   "congrFun"],
  "name": "sup_eq_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a âŠ” b = b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Filter.HasBasis.prod",
   "nhds_prod_eq",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "Set",
   "Eq.refl",
   "Prod.fst",
   "Filter.instSProd",
   "Eq",
   "Filter.HasBasis",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Prod.mk",
   "SProd.sprod",
   "TopologicalSpace",
   "Prod",
   "Filter",
   "id"],
  "name": "Filter.HasBasis.prod_nhds",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {Î¹a : Type u_5} {Î¹b : Type u_6}\n  {pa : Î¹a â†’ Prop} {pb : Î¹b â†’ Prop} {sa : Î¹a â†’ Set Î±} {sb : Î¹b â†’ Set Î²} {a : Î±} {b : Î²},\n  Filter.HasBasis (nhds a) pa sa â†’\n    Filter.HasBasis (nhds b) pb sb â†’ Filter.HasBasis (nhds (a, b)) (fun i â†¦ pa i.1 âˆ§ pb i.2) fun i â†¦ sa i.1 Ã—Ë¢ sb i.2",
  "constCategory": "Theorem"},
 {"references": ["Pi.Nonempty.proof_1", "Nonempty"],
  "name": "Pi.Nonempty",
  "constType":
  "âˆ€ {Î¹ : Sort u_2} {Î± : Î¹ â†’ Sort u_3} [inst : âˆ€ (i : Î¹), Nonempty (Î± i)], Nonempty ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references": ["Function.Embedding"],
  "name": "Function.Embedding.toFun",
  "constType": "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (Î± â†ª Î²) â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLower.instPreorderWithLower",
   "Topology.IsLower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Preorder",
   "Topology.instIsLowerWithLowerInstTopologicalSpaceWithLowerInstPreorderWithLower.proof_1"],
  "name":
  "Topology.instIsLowerWithLowerInstTopologicalSpaceWithLowerInstPreorderWithLower",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsLower (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "HEq",
   "eq_of_heq",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "TopologicalSpace.casesOn",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "HEq.refl",
   "TopologicalSpace",
   "Set.sUnion",
   "Eq.casesOn",
   "Eq.symm",
   "IsOpen",
   "Set.instInterSet"],
  "name": "TopologicalSpace.ext.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x x_1 : TopologicalSpace Î±) â†’ IsOpen = IsOpen â†’ Prop) (x x_1 : TopologicalSpace Î±)\n  (x_2 : IsOpen = IsOpen),\n  (âˆ€ (IsOpen : Set Î± â†’ Prop) (isOpen_univ : IsOpen Set.univ)\n      (isOpen_inter : âˆ€ (s t : Set Î±), IsOpen s â†’ IsOpen t â†’ IsOpen (s âˆ© t))\n      (isOpen_sUnion : âˆ€ (s : Set (Set Î±)), (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹ƒâ‚€ s)) (isOpen_univ_1 : IsOpen Set.univ)\n      (isOpen_inter_1 : âˆ€ (s t : Set Î±), IsOpen s â†’ IsOpen t â†’ IsOpen (s âˆ© t))\n      (isOpen_sUnion_1 : âˆ€ (s : Set (Set Î±)), (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹ƒâ‚€ s)),\n      motive\n        { IsOpen := IsOpen, isOpen_univ := isOpen_univ, isOpen_inter := isOpen_inter, isOpen_sUnion := isOpen_sUnion }\n        { IsOpen := IsOpen, isOpen_univ := isOpen_univ_1, isOpen_inter := isOpen_inter_1,\n          isOpen_sUnion := isOpen_sUnion_1 }\n        (_ : _root_.IsOpen = _root_.IsOpen)) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro", "Fintype", "Set.Elem", "Set", "Set.Finite"],
  "name": "Set.Finite.rec",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {motive : Set.Finite s â†’ Prop},\n  (âˆ€ (a : Fintype â†‘s), motive (_ : Set.Finite s)) â†’ âˆ€ (t : Set.Finite s), motive t",
  "constCategory": "Other"},
 {"references":
  ["Codisjoint",
   "OrderTop.toTop",
   "Iff",
   "forall_swap",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "forall_congr'",
   "PartialOrder"],
  "name": "Codisjoint_comm",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] {a b : Î±}, Codisjoint a b â†” Codisjoint b a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsCommutative", "Eq"],
  "name": "Lean.IsCommutative.mk",
  "constType":
  "{Î± : Sort u} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ (âˆ€ (a b : Î±), op a b = op b a) â†’ Lean.IsCommutative op",
  "constCategory": "Other"},
 {"references": ["Zero", "ZeroHom"],
  "name": "ZeroHom.toFun",
  "constType":
  "{M : Type u_9} â†’ {N : Type u_10} â†’ [inst : Zero M] â†’ [inst_1 : Zero N] â†’ ZeroHom M N â†’ M â†’ N",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.rfl"],
  "name": "Filter.instPartialOrderFilter.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a : Filter Î±), a.sets âŠ† a.sets",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  (âˆ€ (t : Set Î±), t âˆˆ l â†” âˆƒ i, p i âˆ§ s i âŠ† t) â†’ Filter.HasBasis l p s",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[>]_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Substring",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Lean.Syntax.casesOn",
   "Array",
   "Lean.Syntax.missing",
   "List",
   "String",
   "Unit",
   "Unit.unit",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.getKind.match_1",
  "constType":
  "(motive : Lean.Syntax â†’ Sort u_1) â†’\n  (stx : Lean.Syntax) â†’\n    ((info : Lean.SourceInfo) â†’\n        (k : Lean.SyntaxNodeKind) â†’ (args : Array Lean.Syntax) â†’ motive (Lean.Syntax.node info k args)) â†’\n      (Unit â†’ motive Lean.Syntax.missing) â†’\n        ((info : Lean.SourceInfo) â†’ (v : String) â†’ motive (Lean.Syntax.atom info v)) â†’\n          ((info : Lean.SourceInfo) â†’\n              (rawVal : Substring) â†’\n                (val : Lean.Name) â†’\n                  (preresolved : List Lean.Syntax.Preresolved) â†’\n                    motive (Lean.Syntax.ident info rawVal val preresolved)) â†’\n            motive stx",
  "constCategory": "Definition"},
 {"references": ["Set", "InfSet.sInf", "Set.instInfSetSet"],
  "name": "Set.sInter",
  "constType": "{Î± : Type u_1} â†’ Set (Set Î±) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "OrderDual",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.giGenerate.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (x : (Filter Î±)áµ’áµˆ), âˆ€ x_1 âˆˆ x, Filter.GenerateSets x.sets x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name._impl",
   "String.hash",
   "Lean.Name.str._impl",
   "String",
   "Lean.Name",
   "mixHash",
   "unsafeCast",
   "Lean.Name.hash"],
  "name": "Lean.Name.str._override",
  "constType": "Lean.Name â†’ String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.comm.match_1",
  "constType":
  "âˆ€ {a b : Prop} (motive : a âˆ§ b â†’ Prop) (h : a âˆ§ b), (âˆ€ (hâ‚ : a) (hâ‚‚ : b), motive (_ : a âˆ§ b)) â†’ motive h",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Id",
  "constType": "Type u â†’ Type u",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["GaloisCoinsertion.choice",
   "Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "GaloisCoinsertion",
   "GaloisCoinsertion.choice_eq",
   "Function.comp",
   "OrderDual",
   "GaloisInsertion.mk",
   "GaloisCoinsertion.dual.proof_1",
   "FunLike.coe",
   "Preorder",
   "GaloisInsertion",
   "GaloisCoinsertion.u_l_le",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisCoinsertion.dual",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’\n        {l : Î± â†’ Î²} â†’\n          {u : Î² â†’ Î±} â†’\n            GaloisCoinsertion l u â†’\n              GaloisInsertion (â†‘OrderDual.toDual âˆ˜ u âˆ˜ â†‘OrderDual.ofDual) (â†‘OrderDual.toDual âˆ˜ l âˆ˜ â†‘OrderDual.ofDual)",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableIff.proof_4",
   "instDecidableIff.proof_2",
   "Iff",
   "Decidable.isFalse",
   "instDecidableIff.proof_1",
   "instDecidableIff.proof_3",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite"],
  "name": "instDecidableIff",
  "constType":
  "{p q : Prop} â†’ [inst : Decidable p] â†’ [inst : Decidable q] â†’ Decidable (p â†” q)",
  "constCategory": "Definition"},
 {"references":
  ["Char",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "Char.val_eq_of_eq.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : Char) â†’ x = x_1 â†’ Prop) (x x_1 : Char) (x_2 : x = x_1),\n  (âˆ€ (a : Char), motive a a (_ : a = a)) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "List.cons",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "rfl",
   "Eq"],
  "name": "List.cons_append",
  "constType":
  "âˆ€ {Î± : Type u} (a : Î±) (as bs : List Î±), a :: as ++ bs = a :: (as ++ bs)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.beq.match_1",
  "constType":
  "(motive : â„• â†’ â„• â†’ Sort u_1) â†’\n  (x x_1 : â„•) â†’\n    (Unit â†’ motive Nat.zero Nat.zero) â†’\n      ((n : â„•) â†’ motive Nat.zero (Nat.succ n)) â†’\n        ((n : â„•) â†’ motive (Nat.succ n) Nat.zero) â†’ ((n m : â„•) â†’ motive (Nat.succ n) (Nat.succ m)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace",
   "Filter",
   "wrapped._@.Mathlib.Topology.Basic._hyg.10536"],
  "name": "nhds",
  "constType": "{Î± : Type u_1} â†’ [inst : TopologicalSpace Î±] â†’ Î± â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Topology.IsLower",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Topology.IsLower.toContinuousInf.proof_1",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ContinuousInf"],
  "name": "Topology.IsLower.toContinuousInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±], ContinuousInf Î±",
  "constCategory": "Definition"},
 {"references":
  ["inf_inf_sdiff",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "sdiff_inf_sdiff",
   "Trans.trans",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "SDiff.sdiff",
   "Preorder.toLE",
   "Eq",
   "inf_comm",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "inf_sup_right",
   "sup_inf_sdiff",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "bot_sup_eq",
   "OrderBot.toBot",
   "GeneralizedBooleanAlgebra",
   "instTransEq",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GeneralizedBooleanAlgebra.toBot",
   "id"],
  "name": "inf_sdiff_self_right",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : GeneralizedBooleanAlgebra Î±], x âŠ“ y \\ x = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "le_rfl",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "GaloisConnection.l_le"],
  "name": "GaloisConnection.l_u_le",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ âˆ€ (a : Î²), l (u a) â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Continuous",
   "TopologicalSpace",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced"],
  "name": "continuous_coinduced_rng",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {t : TopologicalSpace Î±}, Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "Prod.snd",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Prod.fst",
   "Prod.instInfProd",
   "LE.le",
   "Preorder.toLE",
   "Inf.mk",
   "And",
   "Inf",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "SemilatticeInf"],
  "name": "Prod.semilatticeInf.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²] (x x_1 : Î± Ã— Î²),\n  (x âŠ“ x_1).1 â‰¤ x.1 âˆ§ (x âŠ“ x_1).2 â‰¤ x.2",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "IsLowerSet",
   "Set",
   "Set.instIsReflSetSubsetInstHasSubsetSet",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Topology.IsUpperSet",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
   "LowerSet.lower",
   "Iff.mp",
   "lowerClosure_min",
   "TopologicalSpace",
   "closure_minimal",
   "lowerClosure",
   "id",
   "HasSubset.Subset",
   "subset_antisymm_iff",
   "subset_lowerClosure",
   "Preorder",
   "subset_closure",
   "LowerSet",
   "And",
   "Set.instHasSubsetSet",
   "isClosed_closure",
   "Eq.ndrec",
   "propext",
   "LowerSet.instSetLikeLowerSet",
   "And.intro",
   "IsClosed",
   "Topology.IsUpperSet.isClosed_iff_isLower",
   "SetLike.coe"],
  "name": "Topology.IsUpperSet.closure_eq_lowerClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±] {s : Set Î±},\n  closure s = â†‘(lowerClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.succ_add",
  "constType": "âˆ€ (n m : â„•), Nat.succ n + m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM",
   "EStateM.bind.match_1",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.map",
  "constType": "{Îµ Ïƒ Î± Î² : Type u} â†’ (Î± â†’ Î²) â†’ EStateM Îµ Ïƒ Î± â†’ EStateM Îµ Ïƒ Î²",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.symbol",
  "constType": "String â†’ Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} â†’ [self : AddCommMonoid M] â†’ AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Inf.inf",
   "Set",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "Set.prod",
   "Iff",
   "SProd.sprod",
   "Filter",
   "And.casesOn",
   "Eq.symm",
   "instMembershipSetFilter",
   "id",
   "Filter.mem_prod_iff.match_1",
   "Set.instSProd",
   "Membership.mem",
   "Prod.snd",
   "Set.preimage",
   "HasSubset.Subset",
   "Prod.fst",
   "Filter.instSProd",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Filter.preimage_mem_comap",
   "Filter.mem_inf_of_inter",
   "Filter.instInfFilter",
   "Filter.comap",
   "Prod",
   "And.intro",
   "Set.instInterSet"],
  "name": "Filter.mem_prod_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²},\n  s âˆˆ f Ã—Ë¢ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ Ã—Ë¢ tâ‚‚ âŠ† s",
  "constCategory": "Theorem"},
 {"references": ["GE.ge", "le_trans", "Preorder", "Preorder.toLE"],
  "name": "ge_trans",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b c : Î±}, a â‰¥ b â†’ b â‰¥ c â†’ a â‰¥ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List.pmap",
   "Multiset.pmap.proof_1",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.recOn'",
   "Multiset.ofList",
   "Multiset.instMembershipMultiset",
   "Quot.mk"],
  "name": "Multiset.pmap",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type v} â†’ {p : Î± â†’ Prop} â†’ ((a : Î±) â†’ p a â†’ Î²) â†’ (s : Multiset Î±) â†’ (âˆ€ a âˆˆ s, p a) â†’ Multiset Î²",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set",
   "TopologicalSpace",
   "closure_minimal",
   "IsClosed",
   "subset_closure",
   "Set.Subset.antisymm",
   "Eq",
   "Set.Subset.refl"],
  "name": "IsClosed.closure_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsClosed s â†’ closure s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "List.cons",
   "Nat.le",
   "HEq",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "HEq.refl",
   "List",
   "Nat.noConfusion",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.exists_mem_of_length_pos.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x : List Î±) â†’ 0 < List.length x â†’ Prop) (x : List Î±) (x_1 : 0 < List.length x),\n  (âˆ€ (head : Î±) (tail : List Î±) (x : 0 < List.length (head :: tail)), motive (head :: tail) x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["outParam", "FunLike", "Inf", "Inf.inf", "FunLike.coe", "InfHomClass", "Eq"],
  "name": "InfHomClass.mk",
  "constType":
  "{F : Type u_7} â†’\n  {Î± : outParam (Type u_8)} â†’\n    {Î² : outParam (Type u_9)} â†’\n      [inst : Inf Î±] â†’\n        [inst_1 : Inf Î²] â†’\n          [toFunLike : FunLike F Î± fun x â†¦ Î²] â†’ (âˆ€ (f : F) (a b : Î±), â†‘f (a âŠ“ b) = â†‘f a âŠ“ â†‘f b) â†’ InfHomClass F Î± Î²",
  "constCategory": "Other"},
 {"references": ["Sup", "Sup.sup", "Sup.mk"],
  "name": "Pi.instSupForAll",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î±' : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ Sup (Î±' i)] â†’ Sup ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references": ["IsIdempotent", "Eq"],
  "name": "IsIdempotent.mk",
  "constType":
  "âˆ€ {Î± : Type u} {op : Î± â†’ Î± â†’ Î±}, (âˆ€ (a : Î±), op a a = a) â†’ IsIdempotent Î± op",
  "constCategory": "Other"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{Î± : Type u_1} â†’ {Î¹ : Sort u_4} â†’ (Î¹ â†’ Î±) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["And", "OfNat.ofNat", "Or", "LT.lt", "instOfNatNat", "Nat", "instLTNat"],
  "name": "Nat.isValidChar",
  "constType": "â„• â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv.refl",
   "_obj",
   "_neutral",
   "Equiv.toHomeomorphOfInducing._at.Topology.IsUpper.WithUpperHomeomorph._spec_1"],
  "name": "Topology.IsUpper.WithUpperHomeomorph._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Bool.true",
   "Eq.refl",
   "Not",
   "Eq.casesOn",
   "And.intro",
   "Bool",
   "Eq.symm",
   "And.casesOn",
   "Eq"],
  "name": "List.mem_filter.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {p : Î± â†’ Bool} (motive : (a : Î±) â†’ x = a âˆ§ p x = true â†’ Â¬p a = true â†’ Prop) (a : Î±)\n  (x_1 : x = a âˆ§ p x = true) (h : Â¬p a = true),\n  (âˆ€ (h' : p x = true) (h : Â¬p x = true), motive x (_ : x = x âˆ§ p x = true) h) â†’ motive a x_1 h",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "setOf",
   "Set",
   "And.intro",
   "Set.instMembershipSet"],
  "name": "Filter.instPureFilter.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (x : Î±) {x_1 y : Set Î±}, x_1 âˆˆ {s | x âˆˆ s} â†’ y âˆˆ {s | x âˆˆ s} â†’ x_1 âˆˆ {s | x âˆˆ s} âˆ§ y âˆˆ {s | x âˆˆ s}",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "HImp"],
  "name": "CompleteAtomicBooleanAlgebra.toHImp",
  "constType":
  "{Î± : Type u} â†’ [self : CompleteAtomicBooleanAlgebra Î±] â†’ HImp Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_cons",
   "Or",
   "propext",
   "Multiset",
   "Multiset.cons",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.6",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {s : Multiset Î±}, (a âˆˆ b ::â‚˜ s) = (a = b âˆ¨ a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Nat.zero_lt_succ",
   "LE.le",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "Nat.commSemiring",
   "instLENat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat.le_of_lt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.linearOrderedCommSemiring.proof_6",
  "constType": "0 â‰¤ 1",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ GeneralizedHeytingAlgebra (Î± i)] (a b c : (i : Î¹) â†’ Î± i),\n  a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "List.cons",
   "Iff",
   "List",
   "List.Mem.head",
   "List.tfae_cons_of_mem",
   "List.TFAE"],
  "name": "List.tfae_cons_cons",
  "constType":
  "âˆ€ {a b : Prop} {l : List Prop}, List.TFAE (a :: b :: l) â†” (a â†” b) âˆ§ List.TFAE (b :: l)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) â†’ Type v â†’ Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Eq",
   "Nat.zero_add",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.add_sub_add_right",
   "Eq.mp",
   "Nat.sub_zero",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "Nat.add_sub_cancel",
  "constType": "âˆ€ (n m : â„•), n + m - m = n",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "GE.ge",
   "Not",
   "Nat.lt_or_ge",
   "Or.resolve_right",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_of_not_le",
  "constType": "âˆ€ {a b : â„•}, Â¬a â‰¤ b â†’ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd",
   "IsRightCancelAdd",
   "AddCommSemigroup.toAddSemigroup",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
  "constType":
  "âˆ€ (M : Type u_1) [inst : AddCancelCommMonoid M], IsRightCancelAdd M",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{Î± : Type u} â†’ Î± â†’ Zero Î±",
  "constCategory": "Other"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : â„• â†’ Sort u} â†’ motive Nat.zero â†’ ((n : â„•) â†’ motive n â†’ motive (Nat.succ n)) â†’ (t : â„•) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ"],
  "name": "Nat.le.rec",
  "constType":
  "âˆ€ {n : â„•} {motive : (a : â„•) â†’ Nat.le n a â†’ Prop},\n  motive n (_ : Nat.le n n) â†’\n    (âˆ€ {m : â„•} (a : Nat.le n m), motive m a â†’ motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) â†’\n      âˆ€ {a : â„•} (t : Nat.le n a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.decide",
   "Decidable.casesOn",
   "Eq.ndrec",
   "Decidable.isFalse",
   "not",
   "instDecidableNot",
   "Decidable",
   "Eq.refl",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "Eq.symm",
   "Eq"],
  "name": "decide_not",
  "constType": "âˆ€ {p : Prop} [h : Decidable p], (decide Â¬p) = !decide p",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.closure_of._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.closure_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "EmbeddingLike.toFunLike",
   "true_and",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set.toFinset",
   "Set",
   "Eq.refl",
   "True",
   "iff_self",
   "Eq",
   "Iff.of_eq",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Finset",
   "Function.Embedding",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Subtype",
   "Membership.mem",
   "funext",
   "Std.Logic._auxLemma.39",
   "Finset.instMembershipFinset",
   "Function.Embedding.subtype",
   "FunLike.coe",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.map",
   "Mathlib.Data.Finset.Image._auxLemma.2",
   "Finset.univ",
   "And",
   "Function.instEmbeddingLikeEmbedding",
   "of_eq_true",
   "congrArg",
   "Subtype.mk",
   "congrFun",
   "exists_prop_congr'"],
  "name": "Set.mem_toFinset",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Set Î±} [inst : Fintype â†‘s] {a : Î±}, a âˆˆ Set.toFinset s â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
   "autoParam",
   "AddSemigroup",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} â†’\n  [toAddSemigroup : AddSemigroup M] â†’\n    [toZero : Zero M] â†’\n      (âˆ€ (a : M), 0 + a = a) â†’\n        (âˆ€ (a : M), a + 0 = a) â†’\n          (nsmul : â„• â†’ M â†’ M) â†’\n            autoParam (âˆ€ (x : M), nsmul 0 x = 0) _autoâœ â†’\n              autoParam (âˆ€ (n : â„•) (x : M), nsmul (n + 1) x = x + nsmul n x) _autoâœÂ¹ â†’ AddMonoid M",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Eq.refl",
   "sup_assoc",
   "Sup.sup",
   "sup_left_comm",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "sup_sup_sup_comm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] (a b c d : Î±), a âŠ” b âŠ” (c âŠ” d) = a âŠ” c âŠ” (b âŠ” d)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.sort.loop.match_1",
  "constType":
  "(motive : List â„• â†’ List â„• â†’ Sort u_1) â†’\n  (x x_1 : List â„•) â†’\n    ((acc : List â„•) â†’ motive acc []) â†’ ((acc : List â„•) â†’ (x : â„•) â†’ (xs : List â„•) â†’ motive acc (x :: xs)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.removeNeutrals.match_1",
  "constType":
  "(motive : List â„• â†’ Sort u_1) â†’ (x : List â„•) â†’ (Unit â†’ motive []) â†’ ((ys : List â„•) â†’ motive ys) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Filter", "instMembershipSetFilter"],
  "name": "Filter.Eventually",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Prop) â†’ Filter Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "TopologicalSpace.rec",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.casesOn",
  "constType":
  "{Î± : Type u} â†’\n  {motive : TopologicalSpace Î± â†’ Sort u_1} â†’\n    (t : TopologicalSpace Î±) â†’\n      ((IsOpen : Set Î± â†’ Prop) â†’\n          (isOpen_univ : IsOpen Set.univ) â†’\n            (isOpen_inter : âˆ€ (s t : Set Î±), IsOpen s â†’ IsOpen t â†’ IsOpen (s âˆ© t)) â†’\n              (isOpen_sUnion : âˆ€ (s : Set (Set Î±)), (âˆ€ t âˆˆ s, IsOpen t) â†’ IsOpen (â‹ƒâ‚€ s)) â†’\n                motive\n                  { IsOpen := IsOpen, isOpen_univ := isOpen_univ, isOpen_inter := isOpen_inter,\n                    isOpen_sUnion := isOpen_sUnion }) â†’\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "List.reverseAux.match_1"],
  "name": "List.append",
  "constType": "{Î± : Type u} â†’ List Î± â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "propext",
   "Set.Subset.antisymm_iff",
   "Set",
   "HasSubset.Subset",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.15",
  "constType": "âˆ€ {Î± : Type u} {a b : Set Î±}, (a = b) = (a âŠ† b âˆ§ b âŠ† a)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "List.instMembershipList", "List", "id"],
  "name": "List.attach.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), âˆ€ x âˆˆ l, x âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero", "instLENat", "Nat", "Nat.succ", "LE.le", "Nat.casesOn"],
  "name": "Nat.le.dest.match_2",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ x â‰¤ x_1 â†’ Prop) (x x_1 : â„•) (x_2 : x â‰¤ x_1),\n  (âˆ€ (x : Nat.zero â‰¤ Nat.zero), motive Nat.zero Nat.zero x) â†’\n    (âˆ€ (n : â„•) (x : Nat.zero â‰¤ Nat.succ n), motive Nat.zero (Nat.succ n) x) â†’\n      (âˆ€ (n : â„•) (h : Nat.succ n â‰¤ Nat.zero), motive (Nat.succ n) Nat.zero h) â†’\n        (âˆ€ (n m : â„•) (h : Nat.succ n â‰¤ Nat.succ m), motive (Nat.succ n) (Nat.succ m) h) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["MonadLiftT.mk", "MonadLiftT"],
  "name": "instMonadLiftT_1",
  "constType": "(m : Type u_1 â†’ Type u_2) â†’ MonadLiftT m m",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "or_and_right", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.46",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ¨ b) âˆ§ c) = (a âˆ§ c âˆ¨ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["Bool", "Lean.Data.AC.ContextInformation", "Nat"],
  "name": "Lean.Data.AC.ContextInformation.isNeutral",
  "constType":
  "{Î± : Sort u} â†’ [self : Lean.Data.AC.ContextInformation Î±] â†’ Î± â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "Unit",
   "String",
   "instBEqNat",
   "Lean.Name.beq.match_1",
   "instBEq",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "Lean.Name.rec",
   "Bool.false",
   "and",
   "Bool.true",
   "PUnit",
   "Bool",
   "Nat",
   "Lean.Name",
   "Lean.Name.anonymous",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "Lean.Name.beq",
  "constType": "Lean.Name â†’ Lean.Name â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsLower.topology_eq_lowerTopology",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsUpper.mk",
   "Preorder"],
  "name": "OrderDual.instIsUpper.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±], Topology.IsUpper Î±áµ’áµˆ",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "inf_sdiff_self_right",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "SDiff.sdiff",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "inf_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "GeneralizedBooleanAlgebra",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot",
   "id"],
  "name": "inf_sdiff_self_left",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : GeneralizedBooleanAlgebra Î±], y \\ x âŠ“ x = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Nodup",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "imp_not_comm",
   "Not",
   "List.Nodup.not_mem"],
  "name": "List.not_nodup_cons_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±} {a : Î±}, a âˆˆ l â†’ Â¬List.Nodup (a :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_3",
  "constType": "âˆ€ {Î± : Type u_1} (a : Set Î±), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.generateFrom",
   "setOf",
   "TopologicalSpace.mkOfClosure",
   "TopologicalSpace.ext",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.GenerateOpen",
   "Eq.symm",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure_sets",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set (Set Î±)} {hs : {u | TopologicalSpace.GenerateOpen s u} = s},\n  TopologicalSpace.mkOfClosure s hs = TopologicalSpace.generateFrom s",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Classical.propDecidable", "Not", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "âˆ€ {a : Prop}, Â¬Â¬a â†” a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{Î± : Type u} â†’ {x : â„•} â†’ Î± â†’ OfNat Î± x",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Set.instMembershipSet"],
  "name": "Set.mem_preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s : Set Î²} {a : Î±}, a âˆˆ f â»Â¹' s â†” f a âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result"],
  "name": "EStateM",
  "constType": "Type u â†’ Type u â†’ Type u â†’ Type u",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "GaloisInsertion.liftSemilatticeSup",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "GaloisInsertion",
   "PartialOrder",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "SemilatticeSup.le_sup_right",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.inf_le_right",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "GaloisInsertion.liftSemilatticeInf",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "GaloisInsertion.liftLattice",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’ {u : Î² â†’ Î±} â†’ [inst : PartialOrder Î²] â†’ [inst_1 : Lattice Î±] â†’ GaloisInsertion l u â†’ Lattice Î²",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "âˆ€ {Î± : Type u} [self : Semiring Î±] (n : â„•), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLower.instPreorderWithLower",
   "Topology.IsLower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.mk",
   "rfl"],
  "name":
  "Topology.instIsLowerWithLowerInstTopologicalSpaceWithLowerInstPreorderWithLower.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsLower (Topology.WithLower Î±)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Function.comp", "Or.elim"],
  "name": "Or.imp",
  "constType": "âˆ€ {a c b d : Prop}, (a â†’ c) â†’ (b â†’ d) â†’ a âˆ¨ b â†’ c âˆ¨ d",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Basic._auxLemma.39",
   "Or",
   "Set",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "True",
   "iff_self",
   "Mathlib.Data.Finset.Basic._auxLemma.4",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.32",
   "Iff",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Finset.cons",
   "Not",
   "congrArg",
   "Eq.trans",
   "Set.instInsertSet"],
  "name": "Finset.coe_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {s : Finset Î±} {h : Â¬a âˆˆ s}, â†‘(Finset.cons a s h) = insert a â†‘s",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.id",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.map",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "ContinuousMap.id",
   "Eq"],
  "name": "Topology.WithLowerSet.map_id",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.WithLowerSet.map OrderHom.id = ContinuousMap.id (Topology.WithLowerSet Î±)",
  "constCategory": "Theorem"},
 {"references": ["Set", "LE", "IsUpperSet", "UpperSet"],
  "name": "UpperSet.mk",
  "constType":
  "{Î± : Type u_6} â†’ [inst : LE Î±] â†’ (carrier : Set Î±) â†’ IsUpperSet carrier â†’ UpperSet Î±",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.concat.match_1",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil"],
  "name": "List.concat",
  "constType": "{Î± : Type u} â†’ List Î± â†’ Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Bot",
   "HImp.himp",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "HeytingAlgebra.mk",
  "constType":
  "{Î± : Type u_4} â†’\n  [toGeneralizedHeytingAlgebra : GeneralizedHeytingAlgebra Î±] â†’\n    [toBot : Bot Î±] â†’ [toHasCompl : HasCompl Î±] â†’ (âˆ€ (a : Î±), âŠ¥ â‰¤ a) â†’ (âˆ€ (a : Î±), a â‡¨ âŠ¥ = aá¶œ) â†’ HeytingAlgebra Î±",
  "constCategory": "Other"},
 {"references": ["Pure"],
  "name": "Pure.mk",
  "constType": "{f : Type u â†’ Type v} â†’ ({Î± : Type u} â†’ Î± â†’ f Î±) â†’ Pure f",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.appendCore.match_1",
  "constType":
  "(motive : Lean.Name â†’ Lean.Name â†’ Sort u_1) â†’\n  (x x_1 : Lean.Name) â†’\n    ((n : Lean.Name) â†’ motive n Lean.Name.anonymous) â†’\n      ((n p : Lean.Name) â†’ (s : String) â†’ motive n (Lean.Name.str p s)) â†’\n        ((n p : Lean.Name) â†’ (d : â„•) â†’ motive n (Lean.Name.num p d)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["funext",
   "Inf.inf",
   "DistribLattice.mk",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra",
   "Pi.heytingAlgebra",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.distribLattice",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SDiff.mk",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.sdiff",
   "BooleanAlgebra.toSDiff",
   "HeytingAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "sdiff_eq"],
  "name": "Pi.booleanAlgebra.proof_6",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] (x x_1 : (i : Î¹) â†’ Î± i), x \\ x_1 = x âŠ“ x_1á¶œ",
  "constCategory": "Theorem"},
 {"references": ["Subtype.val", "Subtype.ext", "Subtype", "Eq"],
  "name": "Function.Embedding.subtype.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (p : Î± â†’ Prop) (x x_1 : Subtype p), â†‘x = â†‘x_1 â†’ x = x_1",
  "constCategory": "Theorem"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.32",
  "constType": "âˆ€ {p q : Prop}, (Â¬(p âˆ¨ q)) = (Â¬p âˆ§ Â¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "OrderDual.instPreorder",
   "Set",
   "OrderDual",
   "Singleton.singleton",
   "isGreatest_singleton",
   "IsLeast",
   "Preorder"],
  "name": "isLeast_singleton",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsLeast {a} a",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "GetElem",
  "constType":
  "(cont : Type u) â†’ (idx : Type v) â†’ outParam (Type w) â†’ outParam (cont â†’ idx â†’ Prop) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Set.preimage", "Set", "Inter.inter", "rfl", "Eq", "Set.instInterSet"],
  "name": "Set.preimage_inter",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s t : Set Î²}, f â»Â¹' (s âˆ© t) = f â»Â¹' s âˆ© f â»Â¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["Set.preimage",
   "Set",
   "Function.comp",
   "Continuous",
   "TopologicalSpace",
   "IsOpen.preimage",
   "IsOpen",
   "Iff.mpr",
   "continuous_def"],
  "name": "Continuous.comp",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\n  [inst_2 : TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²}, Continuous g â†’ Continuous f â†’ Continuous (g âˆ˜ f)",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "isGreatest_univ_iff",
   "IsGreatest",
   "Preorder",
   "IsTop",
   "Set.univ",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.13",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsGreatest Set.univ a = IsTop a",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "bot_le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "bot_unique",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderBot Î±] {a : Î±}, a â‰¤ âŠ¥ â†’ a = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "âˆ€ {Î± : Sort u} {a b : Î±}, a â‰  b â†’ b â‰  a",
  "constCategory": "Theorem"},
 {"references": ["Lean.TSyntax", "Lean.SyntaxNodeKinds", "Lean.Syntax"],
  "name": "Lean.TSyntax.mk",
  "constType": "{ks : Lean.SyntaxNodeKinds} â†’ Lean.Syntax â†’ Lean.TSyntax ks",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Lattice.toInf",
   "HImp.himp",
   "Eq.mpr",
   "Iff",
   "himp_bot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "Eq.symm",
   "BoundedOrder.toOrderBot",
   "id",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "HeytingAlgebra.toBot",
   "Disjoint",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "le_himp_iff",
   "propext",
   "disjoint_iff_inf_le",
   "HeytingAlgebra.toBoundedOrder",
   "OrderBot.toBot"],
  "name": "Disjoint.le_compl_right",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, Disjoint a b â†’ a â‰¤ bá¶œ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAppend"],
  "name": "HAppend.mk",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ (Î± â†’ Î² â†’ Î³) â†’ HAppend Î± Î² Î³",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "Top.top",
   "OrderTop.le_top",
   "OrderTop",
   "inferInstanceAs",
   "Prod.instLEProd",
   "LE",
   "Prod",
   "BoundedOrder.toOrderTop",
   "Prod.orderTop",
   "LE.le",
   "BoundedOrder"],
  "name": "Prod.boundedOrder.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : LE Î±] [inst_1 : LE Î²] [inst_2 : BoundedOrder Î±] [inst_3 : BoundedOrder Î²]\n  (a : Î± Ã— Î²), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.upper", "Topology.IsUpper", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsUpper.topology_eq_upperTopology",
  "constType":
  "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±] [inst : Preorder Î±] [self : Topology.IsUpper Î±], t = Topology.upper Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Or",
   "False",
   "Multiset.instZeroMultiset",
   "Mathlib.Data.Multiset.Basic._auxLemma.6",
   "Multiset.instSingletonMultiset",
   "Multiset.instMembershipMultiset",
   "True",
   "iff_self",
   "Eq",
   "Mathlib.Data.Multiset.Basic._auxLemma.7",
   "Zero.toOfNat0",
   "Mathlib.Data.Multiset.Basic._auxLemma.13",
   "Iff",
   "of_eq_true",
   "Multiset",
   "Multiset.cons",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Multiset.mem_singleton",
  "constType": "âˆ€ {Î± : Type u_1} {a b : Î±}, b âˆˆ {a} â†” b = a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List.rec", "List", "List.nil"],
  "name": "List.recOn",
  "constType":
  "{Î± : Type u} â†’\n  {motive : List Î± â†’ Sort u_1} â†’\n    (t : List Î±) â†’ motive [] â†’ ((head : Î±) â†’ (tail : List Î±) â†’ motive tail â†’ motive (head :: tail)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "or_iff_left_iff_imp",
   "or_comm",
   "Eq",
   "id"],
  "name": "or_iff_right_iff_imp",
  "constType": "âˆ€ {a b : Prop}, (a âˆ¨ b â†” b) â†” a â†’ b",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.mk"],
  "name": "Trunc.mk",
  "constType": "{Î± : Sort u_1} â†’ Î± â†’ Trunc Î±",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "Function.Embedding.mk",
   "Function.Embedding.rec",
   "Function.Embedding"],
  "name": "Function.Embedding.casesOn",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {motive : (Î± â†ª Î²) â†’ Sort u} â†’\n      (t : Î± â†ª Î²) â†’\n        ((toFun : Î± â†’ Î²) â†’ (inj' : Function.Injective toFun) â†’ motive { toFun := toFun, inj' := inj' }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mem_sets",
   "Filter.sets",
   "Membership.mem",
   "propext",
   "Set",
   "Filter",
   "Eq",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s : Set Î±}, (s âˆˆ f.sets) = (s âˆˆ f)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "Function.Embedding.inj'",
   "EmbeddingLike.toFunLike",
   "Multiset.mem_map_of_injective",
   "Function.instEmbeddingLikeEmbedding",
   "Iff",
   "Function.Embedding.toFun",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Finset.mem_map'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†ª Î²) {a : Î±} {s : Finset Î±}, â†‘f a âˆˆ Finset.map f s â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Set.image2",
   "Iff",
   "Eq.rec",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.forall_image2_iff.match_1",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.forall_image2_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} {p : Î³ â†’ Prop},\n  (âˆ€ z âˆˆ Set.image2 f s t, p z) â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, p (f x y)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "List.filter",
   "DecidableEq",
   "List",
   "List.replicate",
   "instBEq",
   "List.count",
   "Eq",
   "List.filter_beq'"],
  "name": "List.filter_eq'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (l : List Î±) (a : Î±),\n  List.filter (fun x â†¦ decide (x = a)) l = List.replicate (List.count a l) a",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "And.left"],
  "name": "Fintype.ofBijective.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²), Function.Bijective f â†’ Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "List.Perm",
   "HAppend.hAppend",
   "List",
   "List.Perm.append_right",
   "List.Perm.trans",
   "List.Perm.append_left"],
  "name": "List.Perm.append",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ tâ‚ tâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ tâ‚ ~ tâ‚‚ â†’ lâ‚ ++ tâ‚ ~ lâ‚‚ ++ tâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Iic",
  "constType": "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["Exists", "Iff", "Exists.intro", "Exists.casesOn", "Iff.mpr"],
  "name": "exists_prop_congr.match_1",
  "constType":
  "âˆ€ {p p' : Prop} {q' : p â†’ Prop} (hp : p â†” p') (motive : (âˆƒ (h : p'), q' (_ : p)) â†’ Prop) (x : âˆƒ (h : p'), q' (_ : p)),\n  (âˆ€ (w : p') (h : q' (_ : p)), motive (_ : âˆƒ (h : p'), q' (_ : p))) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.rec"],
  "name": "Prop.distribLattice.proof_1",
  "constType": "âˆ€ (x x_1 x_2 : Prop), (x â†’ x_2) â†’ (x_1 â†’ x_2) â†’ x âˆ¨ x_1 â†’ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "ZeroHom.rec",
   "ZeroHom",
   "Eq"],
  "name": "ZeroHom.casesOn",
  "constType":
  "{M : Type u_9} â†’\n  {N : Type u_10} â†’\n    [inst : Zero M] â†’\n      [inst_1 : Zero N] â†’\n        {motive : ZeroHom M N â†’ Sort u} â†’\n          (t : ZeroHom M N) â†’\n            ((toFun : M â†’ N) â†’ (map_zero' : toFun 0 = 0) â†’ motive { toFun := toFun, map_zero' := map_zero' }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.instPreorderProd",
   "Preorder.le_refl",
   "inferInstanceAs",
   "Prod",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Prod.instPartialOrder.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (a : Î± Ã— Î²), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Option.casesOn",
   "Option"],
  "name": "List.filterMap.match_1",
  "constType":
  "{Î² : Type u_1} â†’\n  (motive : Option Î² â†’ Sort u_2) â†’ (x : Option Î²) â†’ (Unit â†’ motive none) â†’ ((b : Î²) â†’ motive (some b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "CompleteAtomicBooleanAlgebra",
   "Inf.inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.le_sup_inf",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (x y z : Î±), (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "propext",
   "Filter.map",
   "Set",
   "Filter",
   "Eq",
   "Filter.mem_map'",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.61",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Filter Î±} {m : Î± â†’ Î²} {t : Set Î²}, (t âˆˆ Filter.map m f) = ({x | m x âˆˆ t} âˆˆ f)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsClosed_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.le_sSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "CompleteLattice.sInf_le",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "OrderTop.toTop",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "OrderDual.completeLattice.proof_4",
   "CompleteLattice.sSup_le",
   "OrderDual.completeLattice.proof_1",
   "Lattice.toSemilatticeSup",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "OrderDual.completeLattice.proof_2",
   "OrderDual.infSet",
   "InfSet",
   "OrderDual.completeLattice.proof_5",
   "SupSet.sSup",
   "OrderDual.instLEOrderDual",
   "OrderDual.supSet",
   "OrderDual.boundedOrder",
   "SupSet",
   "InfSet.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice.proof_3",
   "OrderBot.toBot",
   "OrderDual",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderDual.lattice"],
  "name": "OrderDual.completeLattice",
  "constType":
  "(Î± : Type u_1) â†’ [inst : CompleteLattice Î±] â†’ CompleteLattice Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "Multiset.mem_cons",
   "Iff",
   "Finset",
   "Finset.cons",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Not",
   "Eq"],
  "name": "Finset.mem_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Finset Î±} {a b : Î±} {h : Â¬a âˆˆ s}, b âˆˆ Finset.cons a s h â†” b = a âˆ¨ b âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "congr_arg",
   "Subtype.val",
   "Multiset.Nodup.pmap",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Fintype.subtype.match_1",
   "rfl",
   "Multiset.instMembershipMultiset",
   "Iff.mpr",
   "Eq",
   "Finset.nodup",
   "Iff",
   "Iff.mp",
   "Finset",
   "Multiset",
   "Finset.val",
   "Multiset.pmap",
   "Finset.mk",
   "Multiset.mem_pmap",
   "Subtype",
   "Subtype.mk"],
  "name": "Fintype.subtype.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (s : Finset Î±) (H : âˆ€ (x : Î±), x âˆˆ s â†” p x) (x : { x // p x }),\n  x âˆˆ\n    { val := Multiset.pmap Subtype.mk s.val (_ : âˆ€ x âˆˆ s, p x),\n      nodup := (_ : Multiset.Nodup (Multiset.pmap Subtype.mk s.val (_ : âˆ€ x âˆˆ s, p x))) }",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ_of_le",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ n â‰¤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Ne",
   "List.cons",
   "False",
   "Eq.refl",
   "Lean.Data.AC.mergeIdem.loop",
   "instDecidableEqNat",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "instDecidableFalse",
   "eq_false",
   "of_eq_true",
   "List",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Lean.Data.AC.Context.mergeIdem_head2",
  "constType":
  "âˆ€ {x y : â„•} {ys : List â„•}, x â‰  y â†’ Lean.Data.AC.mergeIdem (x :: y :: ys) = x :: Lean.Data.AC.mergeIdem (y :: ys)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "Finset.instMembershipFinset",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] (x : Î±), (x âˆˆ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Or",
   "Bot.bot",
   "Mathlib.Order.Filter.Prod._auxLemma.31",
   "Mathlib.Order.Filter.Prod._auxLemma.30",
   "CompleteLattice.toBot",
   "Filter.instSProd",
   "Filter.NeBot",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Mathlib.Order.Filter.Prod._auxLemma.32",
   "Iff",
   "of_eq_true",
   "SProd.sprod",
   "congr",
   "Filter",
   "Prod",
   "Not",
   "congrArg",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.prod_neBot",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Filter Î±} {g : Filter Î²}, Filter.NeBot (f Ã—Ë¢ g) â†” Filter.NeBot f âˆ§ Filter.NeBot g",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "OfNat.ofNat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "instMinNat",
   "Nat.min_eq_left",
   "Eq"],
  "name": "Nat.zero_min",
  "constType": "âˆ€ (a : â„•), min 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet", "Inhabited"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Or",
   "Or.inl",
   "Or.inr",
   "Exists.intro",
   "Or.casesOn",
   "Exists.casesOn"],
  "name": "exists_or.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} (motive : (âˆƒ x, p x âˆ¨ q x) â†’ Prop) (x : âˆƒ x, p x âˆ¨ q x),\n  (âˆ€ (x : Î±) (h : p x), motive (_ : âˆƒ x, p x âˆ¨ q x)) â†’ (âˆ€ (x : Î±) (h : q x), motive (_ : âˆƒ x, p x âˆ¨ q x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "SemilatticeSup.mk",
   "And.intro",
   "Prop.partialOrder",
   "Sup.mk",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Or.rec"],
  "name": "Prop.distribLattice.proof_2",
  "constType": "âˆ€ (x x_1 x_2 : Prop), x â‰¤ x_1 â†’ x â‰¤ x_2 â†’ x â†’ x_1 âˆ§ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "Prod.lattice",
   "InfSet.sInf",
   "le_sInf",
   "Prod.fst",
   "Lattice.mk",
   "Lattice.le_inf",
   "And.left",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "InfSet.mk",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "And",
   "And.right",
   "Prod.infSet",
   "CompleteLattice",
   "Set.ball_image_of_ball",
   "CompleteLattice.toInfSet",
   "Prod",
   "And.intro",
   "Set.image",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.completeLattice.proof_7",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (x : Set (Î± Ã— Î²)) (x_1 : Î± Ã— Î²),\n  (âˆ€ b âˆˆ x, x_1 â‰¤ b) â†’ x_1.1 â‰¤ (sInf x).1 âˆ§ x_1.2 â‰¤ (sInf x).2",
  "constCategory": "Theorem"},
 {"references":
  ["Inhabited", "Lean.Name.anonymous", "Lean.Name", "Inhabited.mk"],
  "name": "Lean.instInhabitedName",
  "constType": "Inhabited Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "Lean.Data.AC.removeNeutrals.loop.match_1",
  "constType":
  "(motive : Bool â†’ Sort u_1) â†’ (x : Bool) â†’ (Unit â†’ motive true) â†’ (Unit â†’ motive false) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "MonadLift",
  "constType":
  "semiOutParam (Type u â†’ Type v) â†’ (Type u â†’ Type w) â†’ Type (max (max (u + 1) v) w)",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "And",
   "Set.iUnion",
   "Set",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_iUnion.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} {x : Î±} {s : Î¹ â†’ Set Î±} (motive : x âˆˆ â‹ƒ i, s i â†’ Prop) (x_1 : x âˆˆ â‹ƒ i, s i),\n  (âˆ€ (w : Set Î±) (a : Î¹) (t_eq : s a = w) (h : x âˆˆ w), motive (_ : âˆƒ t âˆˆ Set.range fun i â†¦ s i, x âˆˆ t)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "optParam",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "List",
   "List.range'.match_1",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.range'",
  "constType": "â„• â†’ â„• â†’ optParam â„• 1 â†’ List â„•",
  "constCategory": "Definition"},
 {"references": ["Nat", "String.Pos"],
  "name": "String.Pos.mk",
  "constType": "â„• â†’ String.Pos",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List.instMembershipList",
   "List",
   "List.pmap.proof_1",
   "PUnit",
   "List.pmap.proof_2",
   "List.nil",
   "List.pmap.match_1"],
  "name": "List.pmap",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ {p : Î± â†’ Prop} â†’ ((a : Î±) â†’ p a â†’ Î²) â†’ (l : List Î±) â†’ (âˆ€ a âˆˆ l, p a) â†’ List Î²",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_5",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Bot.bot",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.bot_le",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toBot",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_12",
  "constType": "âˆ€ {Î± : Type u_1} (x : (Filter Î±)áµ’áµˆáµ’áµˆ), âŠ¥ â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Subtype.mk", "Subtype"],
  "name": "Subtype.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {p : Î± â†’ Prop} â†’\n    {motive : Subtype p â†’ Sort u_1} â†’\n      ((val : Î±) â†’ (property : p val) â†’ motive { val := val, property := property }) â†’ (t : Subtype p) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["SDiff.mk", "SDiff.sdiff", "SDiff"],
  "name": "Pi.sdiff",
  "constType":
  "{Î¹ : Type u} â†’ {Î± : Î¹ â†’ Type v} â†’ [inst : (i : Î¹) â†’ SDiff (Î± i)] â†’ SDiff ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "Prod.lattice",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.mk",
   "SupSet.sSup",
   "Prod.fst",
   "Lattice.mk",
   "Lattice.le_inf",
   "And.left",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "And",
   "And.right",
   "CompleteLattice",
   "Set.ball_image_of_ball",
   "Prod.supSet",
   "CompleteSemilatticeSup.toPartialOrder",
   "Prod",
   "And.intro",
   "Set.image",
   "sSup_le",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.completeLattice.proof_5",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (x : Set (Î± Ã— Î²)) (x_1 : Î± Ã— Î²),\n  (âˆ€ b âˆˆ x, b â‰¤ x_1) â†’ (sSup x).1 â‰¤ x_1.1 âˆ§ (sSup x).2 â‰¤ x_1.2",
  "constCategory": "Theorem"},
 {"references": ["Option.none", "Option.some", "Option.casesOn", "Option"],
  "name":
  "_private.Std.Data.List.Lemmas.0.List.filterMap_cons.match_1.splitter",
  "constType":
  "{Î² : Type u_1} â†’ (motive : Option Î² â†’ Sort u_2) â†’ (x : Option Î²) â†’ motive none â†’ ((b : Î²) â†’ motive (some b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["False", "Iff.mp", "Iff", "Not"],
  "name": "instDecidableIff.proof_2",
  "constType": "âˆ€ {p q : Prop}, p â†’ Â¬q â†’ (p â†” q) â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["not_or_intro",
   "eq_self",
   "Min.min",
   "Or",
   "False",
   "Eq.refl",
   "Classical.em",
   "Or.casesOn",
   "LE.le",
   "Nat.le_total",
   "Eq",
   "ite",
   "Eq.mpr",
   "if_pos",
   "instLENat",
   "of_eq_true",
   "False.casesOn",
   "Not",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "congrArg",
   "if_neg",
   "Nat.decLe",
   "id",
   "congrFun"],
  "name": "Nat.min_comm",
  "constType": "âˆ€ (a b : â„•), min a b = min b a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Filter.principal",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Iff",
   "Filter.instPartialOrderFilter",
   "congr",
   "Filter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Mathlib.Order.Filter.Basic._auxLemma.36",
   "Eq.trans",
   "instMembershipSetFilter",
   "id"],
  "name": "Filter.principal_eq_iff_eq",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, Filter.principal s = Filter.principal t â†” s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Continuous_of._closed_5",
   "Topology.Continuous_of._closed_7"],
  "name": "Topology.Continuous_of._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq.symm", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.23",
  "constType": "âˆ€ {b a : Prop}, (a âˆ§ b) = âˆƒ (_ : a), b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.filter",
   "List",
   "Unit",
   "Eq.refl",
   "List.erase.match_1",
   "Bool",
   "Eq"],
  "name": "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
  "constType":
  "âˆ€ {Î± : Type u} (p : Î± â†’ Bool) (head : Î±) (tail : List Î±),\n  List.filter p (head :: tail) =\n    match p head with\n    | true => head :: List.filter p tail\n    | false => List.filter p tail",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Filter.join.match_1",
   "Filter.inter_mem",
   "Set",
   "Filter.mem_of_superset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.join.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (f : Filter (Filter Î±)) {x y : Set Î±},\n  x âˆˆ {s | {t | s âˆˆ t} âˆˆ f} â†’ y âˆˆ {s | {t | s âˆˆ t} âˆˆ f} â†’ {t | x âˆ© y âˆˆ t} âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["False", "Classical.propDecidable", "Not", "Decidable.by_contradiction"],
  "name": "by_contradiction",
  "constType": "âˆ€ {p : Prop}, (Â¬p â†’ False) â†’ p",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pred",
   "PUnit",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.sub",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["Nat.noConfusion", "Nat", "Nat.succ", "Eq"],
  "name": "Nat.succ.inj",
  "constType": "âˆ€ {n n_1 : â„•}, Nat.succ n = Nat.succ n_1 â†’ n = n_1",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Exists", "Set", "Set.instMembershipSet"],
  "name": "Set.Nonempty",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.le_trans",
   "Nat",
   "LE.le",
   "instLTNat",
   "Nat.succ"],
  "name": "Nat.lt_of_lt_of_le",
  "constType": "âˆ€ {n m k : â„•}, n < m â†’ m â‰¤ k â†’ n < k",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{Î± : Type u} â†’ [self : Semiring Î±] â†’ NonUnitalSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpperSet.ofUpperSet",
   "Topology.IsUpperSet",
   "Equiv.toHomeomorphOfInducing",
   "Topology.WithUpperSet",
   "Homeomorph",
   "TopologicalSpace",
   "Topology.IsUpperSet.WithUpperSetHomeomorph.proof_1",
   "Preorder",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsUpperSet Î±] â†’ Topology.WithUpperSet Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.pairwise_iff_forall_sublist.match_1",
   "List.singleton_sublist",
   "List.instMembershipList",
   "List.Sublist",
   "List.Sublist.cons",
   "Std.Data.List.Lemmas._auxLemma.3",
   "Eq.refl",
   "And.left",
   "implies_congr",
   "Iff.mpr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "List.Sublist.subset",
   "List.rec",
   "forall_congr",
   "eq_false'",
   "List.nil",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "Std.Data.List.Lemmas._auxLemma.37",
   "List.cons",
   "False",
   "List.cons_sublist_cons",
   "implies_true",
   "List.Pairwise",
   "Iff.intro",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "propext",
   "List.pairwise_cons",
   "congr",
   "And.intro",
   "List.noConfusion",
   "congrArg"],
  "name": "List.pairwise_iff_forall_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R l â†” âˆ€ {a b : Î±}, List.Sublist [a, b] l â†’ R a b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Prod.snd",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.mem_prod",
   "Prod",
   "Prod.fst",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Constructions._auxLemma.26",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²} {p : Î± Ã— Î²}, (p âˆˆ s Ã—Ë¢ t) = (p.1 âˆˆ s âˆ§ p.2 âˆˆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "Inter.inter",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "Preorder.toLE",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "top_inf_eq",
   "Set.instBooleanAlgebraSet",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instInterSet"],
  "name": "Set.univ_inter",
  "constType": "âˆ€ {Î± : Type u} (a : Set Î±), Set.univ âˆ© a = a",
  "constCategory": "Theorem"},
 {"references": ["Finset", "Multiset", "Multiset.Nodup"],
  "name": "Finset.mk",
  "constType":
  "{Î± : Type u_4} â†’ (val : Multiset Î±) â†’ Multiset.Nodup val â†’ Finset Î±",
  "constCategory": "Other"},
 {"references":
  ["List.tfae_singleton",
   "List.cons",
   "eq_true",
   "List.nil",
   "True",
   "List.TFAE",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.1",
  "constType": "âˆ€ (p : Prop), List.TFAE [p] = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "List.cons",
   "OfNat.ofNat",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "Nat.add",
   "instLENat",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get?_len_le.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x : List Î±) â†’ (x_1 : â„•) â†’ List.length x â‰¤ x_1 â†’ Prop) (x : List Î±) (x_1 : â„•)\n  (x_2 : List.length x â‰¤ x_1),\n  (âˆ€ (x : â„•) (x_3 : List.length [] â‰¤ x), motive [] x x_3) â†’\n    (âˆ€ (head : Î±) (l : List Î±) (n : â„•) (h : List.length (head :: l) â‰¤ n + 1), motive (head :: l) (Nat.succ n) h) â†’\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.inter_mem",
   "Set",
   "Inter.inter",
   "Filter",
   "nhdsAdjoint.match_1",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (f : Filter Î±) (_s _t : Set Î±),\n  (a âˆˆ _s â†’ _s âˆˆ f) â†’ (a âˆˆ _t â†’ _t âˆˆ f) â†’ a âˆˆ _s âˆ© _t â†’ _s âˆ© _t âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Equiv.toFun",
   "OrderDual.toDual",
   "continuous_coinduced_rng",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.coinduced",
   "OrderDual.ofDual",
   "Continuous",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithLower.toDualHomeomorph.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±],\n  Continuous\n    { toFun := â†‘OrderDual.toDual, invFun := â†‘OrderDual.ofDual,\n        left_inv := (_ : âˆ€ (a : Î±áµ’áµˆ), â†‘OrderDual.toDual (â†‘OrderDual.ofDual a) = a),\n        right_inv := (_ : âˆ€ (a : Topology.WithUpper Î±áµ’áµˆ), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a) }.toFun",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Or",
   "List.insert",
   "List.instUnionList",
   "False",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Union.union",
   "True",
   "Eq",
   "iff_self",
   "List.nil_union",
   "List.cons_union",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Iff",
   "DecidableEq",
   "List.rec",
   "of_eq_true",
   "propext",
   "List",
   "Std.Data.List.Lemmas._auxLemma.53",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "false_or",
   "Std.Data.List.Lemmas._auxLemma.10",
   "congrFun"],
  "name": "List.mem_union_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {x : Î±} {lâ‚ lâ‚‚ : List Î±}, x âˆˆ lâ‚ âˆª lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr2",
  "constType": "String â†’ String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Monad",
   "EStateM",
   "Function.comp",
   "Unit",
   "Function.const",
   "Functor.mk",
   "Monad.mk",
   "Applicative.mk",
   "EStateM.seqRight",
   "EStateM.bind",
   "EStateM.pure",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "SeqRight.mk",
   "EStateM.map",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "EStateM.instMonadEStateM",
  "constType": "{Îµ Ïƒ : Type u} â†’ Monad (EStateM Îµ Ïƒ)",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) â†’ Â¬b â†’ Â¬a",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Nonempty"],
  "name": "Nonempty.rec",
  "constType":
  "âˆ€ {Î± : Sort u} {motive : Nonempty Î± â†’ Prop}, (âˆ€ (val : Î±), motive (_ : Nonempty Î±)) â†’ âˆ€ (t : Nonempty Î±), motive t",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "True",
   "ite",
   "Eq",
   "Bool.of_not_eq_true",
   "Bool.true",
   "instOfNatNat",
   "List.countP",
   "Nat",
   "not_false_eq_true",
   "List.countP_cons_of_pos",
   "Eq.trans",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "False",
   "instAddNat",
   "instHAdd",
   "List.countP_cons_of_neg",
   "eq_false_of_decide",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "of_eq_true",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.countP_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (a : Î±) (l : List Î±),\n  List.countP p (a :: l) = List.countP p l + if p a = true then 1 else 0",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termI^_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_4",
   "_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[<]__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{Î± : Type u} â†’ [self : Union Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLowerSet.noConfusionType",
   "Eq.ndrec",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.casesOn",
   "Eq"],
  "name": "Topology.IsLowerSet.noConfusion",
  "constType":
  "{Î± : Type u_4} â†’\n  {t : TopologicalSpace Î±} â†’\n    {inst : Preorder Î±} â†’\n      {P : Sort u} â†’ {v1 v2 : Topology.IsLowerSet Î±} â†’ v1 = v2 â†’ Topology.IsLowerSet.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["propext", "forall_comm", "Eq"],
  "name": "Std.Logic._auxLemma.54",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {p : Î± â†’ Î² â†’ Prop}, (âˆ€ (a : Î±) (b : Î²), p a b) = âˆ€ (b : Î²) (a : Î±), p a b",
  "constCategory": "Theorem"},
 {"references": ["IsRefl"],
  "name": "IsRefl.mk",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop}, (âˆ€ (a : Î±), r a a) â†’ IsRefl Î± r",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.toLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "HasCompl.compl",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "CompleteAtomicBooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq"],
  "name": "CompleteAtomicBooleanAlgebra.himp_eq",
  "constType":
  "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (x y : Î±), x â‡¨ y = y âŠ” xá¶œ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.toLower_ofLower",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Topology.WithLower Î±), â†‘Topology.WithLower.toLower (â†‘Topology.WithLower.ofLower a) = a",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : â„•) â†’ OfNat â„• n",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.ofLowerSetOrderIso._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
   "interior_subset",
   "Set",
   "TopologicalSpace",
   "HasSubset.Subset.antisymm",
   "interior_maximal",
   "interior",
   "IsOpen",
   "Eq",
   "Set.Subset.refl"],
  "name": "IsOpen.interior_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen s â†’ interior s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "Topology.WithUpper",
   "OrderDual",
   "OrderDual.ofDual_toDual",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLower.toDualHomeomorph.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Topology.WithUpper Î±áµ’áµˆ), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "IsClosed",
   "And.casesOn",
   "Set.instMembershipSet"],
  "name": "mem_closure_iff.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {s : Set Î±} (x : Set Î±) (motive : x âˆˆ {t | IsClosed t âˆ§ s âŠ† t} â†’ Prop)\n  (x_1 : x âˆˆ {t | IsClosed t âˆ§ s âŠ† t}), (âˆ€ (hâ‚ : IsClosed x) (hâ‚‚ : s âŠ† x), motive (_ : IsClosed x âˆ§ s âŠ† x)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op", "Lean.Data.AC.Context", "Lean.IsAssociative"],
  "name": "Lean.Data.AC.Context.assoc",
  "constType":
  "{Î± : Sort u} â†’ (self : Lean.Data.AC.Context Î±) â†’ Lean.IsAssociative self.op",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Iff.intro",
   "List.cons",
   "Iff",
   "List",
   "List.Chain.pairwise",
   "List.Pairwise.chain",
   "IsTrans",
   "List.Chain"],
  "name": "List.chain_iff_pairwise",
  "constType":
  "âˆ€ {Î± : Type u} {R : Î± â†’ Î± â†’ Prop} [inst : IsTrans Î± R] {a : Î±} {l : List Î±}, List.Chain R a l â†” List.Pairwise R (a :: l)",
  "constCategory": "Theorem"},
 {"references": ["CoheytingAlgebra", "GeneralizedCoheytingAlgebra"],
  "name": "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
  "constType":
  "{Î± : Type u_4} â†’ [self : CoheytingAlgebra Î±] â†’ GeneralizedCoheytingAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "sInfHomClass.toFunLike",
   "InfSet",
   "FunLike.ext",
   "FunLike.coe",
   "sInfHom.instSInfHomClassSInfHom",
   "Eq"],
  "name": "sInfHom.ext",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : InfSet Î±] [inst_1 : InfSet Î²] {f g : sInfHom Î± Î²},\n  (âˆ€ (a : Î±), â†‘f a = â†‘g a) â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLower.toDualHomeomorph._lambda_1",
   "_obj",
   "Equiv.mk",
   "_neutral"],
  "name": "Topology.WithLower.toDualHomeomorph._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} â†’ [toAddSemigroup : AddSemigroup G] â†’ (âˆ€ (a b c : G), a + b = a + c â†’ b = c) â†’ AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references": ["IsTrans"],
  "name": "IsTrans.mk",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop}, (âˆ€ (a b c : Î±), r a b â†’ r b c â†’ r a c) â†’ IsTrans Î± r",
  "constCategory": "Other"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.ofUpperSet",
  "constType": "{Î± : Type u_1} â†’ Topology.WithUpperSet Î± â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.neg_resolve_left",
  "constType": "âˆ€ {a b : Prop}, Â¬a âˆ¨ b â†’ a â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["PLift.up",
   "cast",
   "PLift.down",
   "ULift.up",
   "PLift",
   "ULift.down",
   "ULift",
   "unsafeCast.proof_1"],
  "name": "unsafeCast",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«termð“[â‰¥]_Â»._closed_2",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“[â‰¥]_Â»._closed_5"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "propext", "Eq"],
  "name": "Eq.propIntro",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) â†’ (b â†’ a) â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.zero_lt_succ",
   "instLTNat"],
  "name": "Nat.zero_lt_one",
  "constType": "0 < 1",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["outParam",
   "Inf",
   "Inf.inf",
   "InfHomClass.toFunLike",
   "FunLike.coe",
   "Eq",
   "InfHomClass"],
  "name": "InfHomClass.map_inf",
  "constType":
  "âˆ€ {F : Type u_7} {Î± : outParam (Type u_8)} {Î² : outParam (Type u_9)} [inst : Inf Î±] [inst_1 : Inf Î²]\n  [self : InfHomClass F Î± Î²] (f : F) (a b : Î±), â†‘f (a âŠ“ b) = â†‘f a âŠ“ â†‘f b",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†’ Â¬a â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "OfNat.ofNat",
   "List.countP_pos",
   "List.instMembershipList",
   "propext",
   "List",
   "Bool.true",
   "LT.lt",
   "instOfNatNat",
   "Bool",
   "List.countP",
   "Nat",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.6",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {l : List Î±}, (0 < List.countP p l) = âˆƒ a âˆˆ l, p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.Syntax.getHeadInfo?",
   "Unit",
   "Lean.SourceInfo",
   "Lean.Syntax.getHeadInfo?.loop.match_1",
   "Lean.Syntax",
   "Option"],
  "name": "Lean.Syntax.getHeadInfo",
  "constType": "Lean.Syntax â†’ Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Union.union",
   "Classical.propDecidable",
   "Finite",
   "Eq.refl",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Eq.ndrec",
   "Set.Elem",
   "Eq.symm",
   "Finite.of_fintype",
   "Set.instUnionSet",
   "nonempty_fintype",
   "Set.fintypeUnion"],
  "name": "Finite.Set.finite_union.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (s t : Set Î±) [inst : Finite â†‘s] [inst : Finite â†‘t], Finite â†‘(s âˆª t)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.casesOn",
   "List.nil",
   "Eq"],
  "name": "List.eq_replicate_of_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} (motive : (x : List Î±) â†’ (âˆ€ b âˆˆ x, b = a) â†’ Prop) (x : List Î±) (x_1 : âˆ€ b âˆˆ x, b = a),\n  (âˆ€ (x : âˆ€ b âˆˆ [], b = a), motive [] x) â†’\n    (âˆ€ (b : Î±) (l : List Î±) (H : âˆ€ b_1 âˆˆ b :: l, b_1 = a), motive (b :: l) H) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["isLUB_pair",
   "CompleteLattice.toLattice",
   "IsLUB.sSup_eq",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "CompleteLattice",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Sup.sup",
   "Singleton.singleton",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "Insert.insert",
   "CompleteLattice.toSupSet",
   "Eq",
   "Set.instInsertSet"],
  "name": "sSup_pair",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {a b : Î±}, sSup {a, b} = a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.attach.proof_1",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "rfl",
   "List.attach",
   "Eq",
   "List.map_pmap",
   "Subtype.property",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.map",
   "List.pmap_congr",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "List.pmap_eq_map_attach",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {p : Î± â†’ Prop} (f : (a : Î±) â†’ p a â†’ Î²) (l : List Î±) (H : âˆ€ a âˆˆ l, p a),\n  List.pmap f l H = List.map (fun x â†¦ f â†‘x (_ : p â†‘x)) (List.attach l)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Filter.mkOfClosure.proof_1",
   "Filter.mk",
   "Filter.mkOfClosure.proof_3",
   "Set",
   "Filter.generate",
   "Filter",
   "Filter.mkOfClosure.proof_2",
   "Eq"],
  "name": "Filter.mkOfClosure",
  "constType":
  "{Î± : Type u} â†’ (s : Set (Set Î±)) â†’ (Filter.generate s).sets = s â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.instMembershipList",
   "implies_true",
   "Eq.refl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "false_implies",
   "List.Pairwise",
   "Std.Data.List.Lemmas._auxLemma.1",
   "And",
   "Std.Data.List.Basic._auxLemma.3",
   "of_eq_true",
   "List",
   "forall_congr",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "and_self"],
  "name": "List.pairwise_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} (R : Î± â†’ Î± â†’ Prop) (a : Î±), List.Pairwise R [a]",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Context", "Lean.MacroScope"],
  "name": "Lean.Macro.Context.currMacroScope",
  "constType": "Lean.Macro.Context â†’ Lean.MacroScope",
  "constCategory": "Definition"},
 {"references": ["CompleteBooleanAlgebra", "BooleanAlgebra"],
  "name": "CompleteBooleanAlgebra.toBooleanAlgebra",
  "constType":
  "{Î± : Type u_1} â†’ [self : CompleteBooleanAlgebra Î±] â†’ BooleanAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_1"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace"],
  "name": "TopologicalSpace.IsTopologicalBasis",
  "constType": "{Î± : Type u} â†’ [t : TopologicalSpace Î±] â†’ Set (Set Î±) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsIdempotent",
   "Sup.sup",
   "instIsIdempotentSupToSup.proof_1"],
  "name": "instIsIdempotentSupToSup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±], IsIdempotent Î± fun x x_1 â†¦ x âŠ” x_1",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "âˆ€ {Î± : Sort u} {a b c : Î±}, a = b â†’ b = c â†’ a = c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "And.intro",
   "Exists.intro",
   "Nat",
   "And.casesOn",
   "Exists.casesOn",
   "instLTNat",
   "Eq"],
  "name": "List.mem_range'_1.match_1",
  "constType":
  "âˆ€ {m s n : â„•} (motive : (âˆƒ i < n, m = s + i) â†’ Prop) (x : âˆƒ i < n, m = s + i),\n  (âˆ€ (i : â„•) (h : i < n) (e : m = s + i), motive (_ : âˆƒ i < n, m = s + i)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["HEq", "HEq.refl"],
  "name": "HEq.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {a : Î±} â†’\n    {motive : {Î² : Sort u} â†’ (a_1 : Î²) â†’ HEq a a_1 â†’ Sort u_1} â†’\n      motive a (_ : HEq a a) â†’ {Î² : Sort u} â†’ {a_1 : Î²} â†’ (t : HEq a a_1) â†’ motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["And",
   "OrderDual.instPreorder",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "inferInstanceAs",
   "OrderDual",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PartialOrder Î±] (a b : Î±áµ’áµˆ), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.sUnion",
   "TopologicalSpace.GenerateOpen",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.sUnion",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} (S : Set (Set Î±)),\n  (âˆ€ s âˆˆ S, TopologicalSpace.GenerateOpen g s) â†’ TopologicalSpace.GenerateOpen g (â‹ƒâ‚€ S)",
  "constCategory": "Other"},
 {"references":
  ["Set.preimage",
   "Set",
   "Monotone",
   "IsUpperSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "IsUpperSet.preimage",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] {s : Set Î±},\n  IsUpperSet s â†’ âˆ€ {f : Î² â†’ Î±}, Monotone f â†’ IsUpperSet (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["beq_iff_eq",
   "BEq.beq",
   "BEq",
   "propext",
   "Bool.true",
   "LawfulBEq",
   "Bool",
   "Eq"],
  "name": "Init.Core._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [inst_1 : LawfulBEq Î±] (a b : Î±), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.refl",
   "Equiv.toHomeomorphOfInducing._at.Topology.IsLowerSet.WithLowerSetHomeomorph._spec_1",
   "_obj",
   "_neutral"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "autoParam",
   "LE.le",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toPartialOrder : PartialOrder Î±] â†’\n    [toMin : Min Î±] â†’\n      [toMax : Max Î±] â†’\n        [toOrd : Ord Î±] â†’\n          (âˆ€ (a b : Î±), a â‰¤ b âˆ¨ b â‰¤ a) â†’\n            (decidableLE : DecidableRel fun x x_1 â†¦ x â‰¤ x_1) â†’\n              (decidableEq : DecidableEq Î±) â†’\n                (decidableLT : DecidableRel fun x x_1 â†¦ x < x_1) â†’\n                  autoParam (âˆ€ (a b : Î±), min a b = if a â‰¤ b then a else b) _autoâœ â†’\n                    autoParam (âˆ€ (a b : Î±), max a b = if a â‰¤ b then b else a) _autoâœÂ¹ â†’\n                      autoParam (âˆ€ (a b : Î±), compare a b = compareOfLessAndEq a b) _autoâœÂ² â†’ LinearOrder Î±",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "Nat.sub_ne_zero_of_lt.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ x < x_1 â†’ Prop) (x x_1 : â„•) (x_2 : x < x_1),\n  (âˆ€ (h : 0 < 0), motive 0 0 h) â†’\n    (âˆ€ (b : â„•) (x : 0 < Nat.succ b), motive 0 (Nat.succ b) x) â†’\n      (âˆ€ (a : â„•) (h : Nat.succ a < 0), motive (Nat.succ a) 0 h) â†’\n        (âˆ€ (a b : â„•) (h : Nat.succ a < Nat.succ b), motive (Nat.succ a) (Nat.succ b) h) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.filterMap.match_1",
   "of_eq_true",
   "List.filterMap",
   "Option.none",
   "List",
   "Unit",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq",
   "Option"],
  "name": "List.filterMap_cons_none",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Option Î²} (a : Î±) (l : List Î±),\n  f a = none â†’ List.filterMap f (a :: l) = List.filterMap f l",
  "constCategory": "Theorem"},
 {"references": ["HImp"],
  "name": "HImp.mk",
  "constType": "{Î± : Type u_4} â†’ (Î± â†’ Î± â†’ Î±) â†’ HImp Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.instMembershipList",
   "List",
   "HasSubset.Subset"],
  "name": "List.Subset.refl",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), l âŠ† l",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "eq_of_heq",
   "Eq.refl",
   "List.Pairwise.cons",
   "Eq",
   "List.Pairwise",
   "List.Pairwise.casesOn",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.pairwise_cons.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±} (motive : List.Pairwise R (a :: l) â†’ Prop)\n  (x : List.Pairwise R (a :: l)),\n  (âˆ€ (hâ‚ : âˆ€ a' âˆˆ l, R a a') (hâ‚‚ : List.Pairwise R l), motive (_ : List.Pairwise R (a :: l))) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Inf Î±",
  "constCategory": "Other"},
 {"references": ["Fintype", "Set.Elem", "Set", "Set.Finite"],
  "name": "Set.Finite.intro",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Fintype â†‘s â†’ Set.Finite s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.45",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.node6",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Array.mkEmpty",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Nonempty.rec", "Nonempty"],
  "name": "Nonempty.casesOn",
  "constType":
  "âˆ€ {Î± : Sort u} {motive : Nonempty Î± â†’ Prop} (t : Nonempty Î±), (âˆ€ (val : Î±), motive (_ : Nonempty Î±)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name": "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "Eq.ge",
   "Inf.inf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Lattice.toInf",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HImp.himp",
   "himp_bot",
   "Iff.mp",
   "le_himp_iff",
   "disjoint_iff_inf_le",
   "OrderBot.toBot",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "disjoint_compl_left",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a : Î±}, Disjoint aá¶œ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Backtrackable.save",
   "EStateM",
   "EStateM.tryCatch.match_1",
   "EStateM.Backtrackable.restore",
   "EStateM.Backtrackable",
   "EStateM.Result"],
  "name": "EStateM.tryCatch",
  "constType":
  "{Îµ Ïƒ Î´ : Type u} â†’\n  [inst : EStateM.Backtrackable Î´ Ïƒ] â†’ {Î± : Type u} â†’ EStateM Îµ Ïƒ Î± â†’ (Îµ â†’ EStateM Îµ Ïƒ Î±) â†’ EStateM Îµ Ïƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Filter.le_principal_iff",
   "propext",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.35",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {f : Filter Î±}, (f â‰¤ Filter.principal s) = (s âˆˆ f)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.toBiheytingAlgebra",
   "IsCompl.compl_eq",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "BooleanAlgebra.toDistribLattice",
   "IsCompl.symm",
   "BiheytingAlgebra.toHeytingAlgebra",
   "BooleanAlgebra",
   "Eq"],
  "name": "compl_compl",
  "constType": "âˆ€ {Î± : Type u} [inst : BooleanAlgebra Î±] (x : Î±), xá¶œá¶œ = x",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.brecOn",
   "Nat.below",
   "Nat.sub_le_sub_right.match_1",
   "instSubNat",
   "Unit",
   "HSub.hSub",
   "Nat.sub",
   "LE.le",
   "Nat.pred_le_pred",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.sub_le_sub_right",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ âˆ€ (k : â„•), n - k â‰¤ m - k",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "False",
   "List",
   "List.nil",
   "List.noConfusion",
   "List.noConfusionType",
   "Eq"],
  "name": "List.hasDecEq.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (head : Î±) (tail : List Î±), head :: tail = [] â†’ List.noConfusionType False (head :: tail) []",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.subset",
   "List",
   "List.Sublist",
   "List.eq_nil_of_subset_nil",
   "List.nil",
   "Eq"],
  "name": "List.eq_nil_of_sublist_nil",
  "constType": "âˆ€ {Î± : Type u} {l : List Î±}, List.Sublist l [] â†’ l = []",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelSemigroup", "AddSemigroup"],
  "name": "AddRightCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} â†’ [self : AddRightCancelSemigroup G] â†’ AddSemigroup G",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Setoid.mk", "True", "true_equivalence"],
  "name": "trueSetoid",
  "constType": "{Î± : Sort u_1} â†’ Setoid Î±",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Lattice._auxLemma.12",
   "and_true",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_eq_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b : Î±}, a âŠ“ b = b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Nat.le_trans", "Nat", "Nat.le_step", "Nat.succ", "instLTNat"],
  "name": "Nat.lt_trans",
  "constType": "âˆ€ {n m k : â„•}, n < m â†’ m < k â†’ n < k",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.closure_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {motive : Exists p â†’ Prop},\n  (âˆ€ (w : Î±) (h : p w), motive (_ : Exists p)) â†’ âˆ€ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references": ["List.findIdx.go", "Eq.refl", "List.nil", "Bool", "Nat", "Eq"],
  "name": "_private.Std.Data.List.Lemmas.0.List.findIdx.go._eq_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (x : â„•), List.findIdx.go p [] x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Exists",
   "Classical.indefiniteDescription.match_1",
   "Subtype.mk",
   "Subtype",
   "Nonempty"],
  "name": "Classical.indefiniteDescription.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (p : Î± â†’ Prop), (âˆƒ x, p x) â†’ Nonempty { x // p x }",
  "constCategory": "Theorem"},
 {"references":
  ["Char",
   "String.noConfusionType",
   "Eq.ndrec",
   "List",
   "String",
   "String.casesOn",
   "Eq.refl",
   "Eq"],
  "name": "String.noConfusion",
  "constType":
  "{P : Sort u} â†’ {v1 v2 : String} â†’ v1 = v2 â†’ String.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Filter.tendsto_comap_iff",
   "nhds",
   "Iff.rfl",
   "Function.comp",
   "Eq.refl",
   "Inducing",
   "Inducing.nhds_eq_comap",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Filter.Tendsto",
   "id"],
  "name": "Inducing.tendsto_nhds_iff",
  "constType":
  "âˆ€ {Î² : Type u_2} {Î³ : Type u_3} [inst : TopologicalSpace Î²] [inst_1 : TopologicalSpace Î³] {Î¹ : Type u_5} {f : Î¹ â†’ Î²}\n  {g : Î² â†’ Î³} {a : Filter Î¹} {b : Î²}, Inducing g â†’ (Filter.Tendsto f a (nhds b) â†” Filter.Tendsto (g âˆ˜ f) a (nhds (g b)))",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Nat.succ_lt_succ",
   "Iff",
   "Nat.lt_of_succ_lt_succ",
   "LT.lt",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.succ_lt_succ_iff",
  "constType": "âˆ€ {a b : â„•}, Nat.succ a < Nat.succ b â†” a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Topology.IsLower.rec",
   "Preorder",
   "Topology.IsLower.mk",
   "Eq"],
  "name": "Topology.IsLower.recOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsLower Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsLower Î±) â†’\n          ((topology_eq_lowerTopology : t = Topology.lower Î±) â†’ motive (_ : Topology.IsLower Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.tail",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} (b : Î±) {as : List Î±}, List.Mem a as â†’ List.Mem a (b :: as)",
  "constCategory": "Other"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Array.foldlM.loop.match_1",
  "constType":
  "(motive : â„• â†’ Sort u_1) â†’ (i : â„•) â†’ (Unit â†’ motive 0) â†’ ((i' : â„•) â†’ motive (Nat.succ i')) â†’ motive i",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "PProd",
   "PProd.fst",
   "Prod.snd",
   "Prod.mk",
   "Equiv.pprodEquivProd.proof_2",
   "Equiv.pprodEquivProd.proof_1",
   "Equiv.mk",
   "Prod",
   "Prod.fst",
   "PProd.snd",
   "PProd.mk"],
  "name": "Equiv.pprodEquivProd",
  "constType": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ PProd Î± Î² â‰ƒ Î± Ã— Î²",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.Perm",
   "List.rec",
   "List.Perm.nil",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Perm.refl.match_1",
   "List.nil",
   "List.Perm.cons"],
  "name": "List.Perm.refl",
  "constType": "âˆ€ {Î± : Type uu} (l : List Î±), l ~ l",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Name.mkStr1"],
  "name": "Lean.identKind",
  "constType": "Lean.SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : â„• â†’ Sort u} â†’ â„• â†’ Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.below",
   "List.brecOn",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "True",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "PProd",
   "Iff",
   "List.rec",
   "PUnit",
   "List.nil",
   "Eq.trans",
   "Membership.mem",
   "List.mem_map.match_1",
   "funext",
   "List.cons",
   "Or",
   "False",
   "Unit",
   "eq_comm",
   "Std.Logic._auxLemma.32",
   "Std.Logic._auxLemma.48",
   "And",
   "PProd.fst",
   "of_eq_true",
   "List",
   "propext",
   "congr",
   "List.map",
   "congrArg",
   "congrFun"],
  "name": "List.mem_map",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {b : Î²} {f : Î± â†’ Î²} {l : List Î±}, b âˆˆ List.map f l â†” âˆƒ a âˆˆ l, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "cond",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "Subtype.val",
   "instInhabitedPUnit",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "CompletelyDistribLattice",
   "le_iSup",
   "iSup",
   "True",
   "Preorder.toLE",
   "Iff.of_eq",
   "Eq",
   "Subtype.property",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "iSup_congr_Prop",
   "Set.Elem",
   "iSup_const",
   "Bool.true",
   "iSup_subtype",
   "PUnit",
   "le_trans",
   "Lattice.toSemilatticeSup",
   "Eq.trans",
   "Subtype",
   "instNonempty",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompletelyDistribLattice.toCompleteDistribLattice.match_1",
   "SupSet.sSup",
   "iSup_le",
   "LE.le",
   "Set.instMembershipSet",
   "of_eq_true",
   "iInf",
   "iInf_bool_eq",
   "CompleteLattice.toInfSet",
   "Bool.false",
   "sSup_eq_iSup",
   "le_refl",
   "instTransEq",
   "iInf_iSup_eq",
   "Bool",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Subtype.mk",
   "congrFun"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompletelyDistribLattice Î±] (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Membership.mk",
   "Membership",
   "Set.instMembershipSet"],
  "name": "instMembershipSetFilter",
  "constType": "{Î± : Type u_1} â†’ Membership (Set Î±) (Filter Î±)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Name.mkStr2",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Filter.le_principal_iff",
   "propext",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.50",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {f : Filter Î±}, (f â‰¤ Filter.principal s) = (s âˆˆ f)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.mk",
  "constType":
  "{M : Type u_9} â†’\n  {N : Type u_10} â†’\n    [inst : AddZeroClass M] â†’\n      [inst_1 : AddZeroClass N] â†’\n        (toZeroHom : ZeroHom M N) â†’\n          (âˆ€ (x y : M), ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) â†’\n            M â†’+ N",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Function.Involutive",
  "constType": "{Î± : Sort u_1} â†’ (Î± â†’ Î±) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "exists_eq_left.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±} (motive : (âˆƒ a, a = a' âˆ§ p a) â†’ Prop) (x : âˆƒ a, a = a' âˆ§ p a),\n  (âˆ€ (w : Î±) (e : w = a') (h : p w), motive (_ : âˆƒ a, a = a' âˆ§ p a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.inf_le_right",
  "constType": "âˆ€ {Î± : Type u} [self : SemilatticeInf Î±] (a b : Î±), a âŠ“ b â‰¤ b",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.findIdx.go",
   "_private.Std.Data.List.Lemmas.0.List.findIdx.go._eq_1",
   "Eq",
   "Eq.ndrec",
   "List",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat",
   "_private.Std.Data.List.Lemmas.0.List.findIdx.go.match_1.splitter",
   "Eq.symm",
   "id"],
  "name": "_private.Std.Data.List.Lemmas.0.List.findIdx.go._unfold",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (x : List Î±) (x_1 : â„•),\n  List.findIdx.go p x x_1 =\n    match x, x_1 with\n    | [], n => n\n    | a :: l, n => bif p a then n else List.findIdx.go p l (n + 1)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.concat.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ Î± â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : Î±) â†’ ((b : Î±) â†’ motive [] b) â†’ ((a : Î±) â†’ (as : List Î±) â†’ (b : Î±) â†’ motive (a :: as) b) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "of_eq_true",
   "List.rec",
   "List",
   "List.nil",
   "List.map",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "id",
   "Eq"],
  "name": "List.map_id",
  "constType": "âˆ€ {Î± : Type u_1} (l : List Î±), List.map id l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Or", "Iff", "Decidable.imp_iff_or_not", "Classical.propDecidable", "Not"],
  "name": "imp_iff_or_not",
  "constType": "âˆ€ {b a : Prop}, b â†’ a â†” a âˆ¨ Â¬b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "isLowerSet_sUnion",
   "Set",
   "Set.sUnion",
   "Preorder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Topology.lowerSet.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Preorder Î±] (x : Set (Set Î±)), (âˆ€ s âˆˆ x, IsLowerSet s) â†’ IsLowerSet (â‹ƒâ‚€ x)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "forall_congr'"],
  "name": "ball_congr",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {P Q : (x : Î±) â†’ p x â†’ Prop},\n  (âˆ€ (x : Î±) (h : p x), P x h â†” Q x h) â†’ ((âˆ€ (x : Î±) (h : p x), P x h) â†” âˆ€ (x : Î±) (h : p x), Q x h)",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] (a b : Î±), a â‰¤ b âˆ¨ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "âˆ€ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Not", "by_contra"],
  "name": "of_not_not",
  "constType": "âˆ€ {a : Prop}, Â¬Â¬a â†’ a",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.mk",
  "constType": "{Î± : Type u_9} â†’ (Set Î± â†’ Î±) â†’ SupSet Î±",
  "constCategory": "Other"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "Subtype.val",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "List.Nodup.pmap.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Prop} {f : (a : Î±) â†’ p a â†’ Î²} {l : List Î±} {H : âˆ€ a âˆˆ l, p a}\n  (x : { x // x âˆˆ l }) (motive : (x_1 : { x // x âˆˆ l }) â†’ f â†‘x_1 (_ : p â†‘x_1) = f â†‘x (_ : p â†‘x) â†’ Prop)\n  (x_1 : { x // x âˆˆ l }) (h : f â†‘x_1 (_ : p â†‘x_1) = f â†‘x (_ : p â†‘x)),\n  (âˆ€ (a : Î±) (ha : a âˆˆ l) (h : f â†‘{ val := a, property := ha } (_ : p â†‘{ val := a, property := ha }) = f â†‘x (_ : p â†‘x)),\n      motive { val := a, property := ha } h) â†’\n    motive x_1 h",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLower", "Nonempty"],
  "name": "Topology.WithLower.instNonemptyWithLower",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Nonempty Î±], Nonempty (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "funext",
   "Function.RightInverse",
   "Set.preimage_subset_image_of_inverse",
   "Set.preimage",
   "Set",
   "Set.image_subset_preimage_of_inverse",
   "Set.image",
   "Set.Subset.antisymm",
   "Eq"],
  "name": "Set.image_eq_preimage_of_inverse",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {g : Î² â†’ Î±},\n  Function.LeftInverse g f â†’ Function.RightInverse g f â†’ Set.image f = Set.preimage g",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "MonadWithReaderOf",
  "constType":
  "semiOutParam (Type u) â†’ (Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.le_sup_left",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_5",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Î± â†’ Prop), a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} â†’ [self : AddZeroClass M] â†’ Add M",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.below.consâ‚‚",
   "List.Sublist.below.cons",
   "List",
   "List.Sublist",
   "List.Sublist.below.slnil",
   "List.Sublist.rec",
   "List.Sublist.below"],
  "name": "List.Sublist.brecOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop} {a a_1 : List Î±} (x : List.Sublist a a_1),\n  (âˆ€ (a a_2 : List Î±) (x : List.Sublist a a_2), List.Sublist.below x â†’ motive a a_2 x) â†’ motive a a_1 x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Set",
   "CompleteLattice.toBoundedOrder",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "bot_unique",
   "Preorder.toLE",
   "Eq",
   "Filter.principal",
   "Filter.instPartialOrderFilter",
   "OrderBot.toBot",
   "Set.empty_subset",
   "Filter",
   "BoundedOrder.toOrderBot",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.principal_empty",
  "constType": "âˆ€ {Î± : Type u}, Filter.principal âˆ… = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["GeneralizedCoheytingAlgebra", "Lattice"],
  "name": "GeneralizedCoheytingAlgebra.toLattice",
  "constType":
  "{Î± : Type u_4} â†’ [self : GeneralizedCoheytingAlgebra Î±] â†’ Lattice Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_11",
  "constType":
  "âˆ€ {Î± : Type u_1} (x y z : Î± â†’ Prop), (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.noConfusionType", "Eq.ndrec", "Eq.refl", "Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusion",
  "constType":
  "{P : Sort u} â†’ {v1 v2 : â„•} â†’ v1 = v2 â†’ Nat.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "instAddNat",
   "Nat.le_add_right",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le.intro",
  "constType": "âˆ€ {n m k : â„•}, n + k = m â†’ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "setOf",
   "Set",
   "And.intro",
   "And.casesOn",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.nhds_generateFrom.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {g : Set (Set Î±)} {a : Î±} (s : Set Î±) (motive : s âˆˆ {s | a âˆˆ s âˆ§ s âˆˆ g} â†’ Prop)\n  (x : s âˆˆ {s | a âˆˆ s âˆ§ s âˆˆ g}), (âˆ€ (as : a âˆˆ s) (sg : s âˆˆ g), motive (_ : a âˆˆ s âˆ§ s âˆˆ g)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["MonadStateOf.modifyGet",
   "getThe",
   "MonadState.mk",
   "MonadStateOf.set",
   "MonadState",
   "Prod",
   "MonadStateOf"],
  "name": "instMonadState",
  "constType":
  "(Ïƒ : Type u) â†’ (m : Type u â†’ Type v) â†’ [inst : MonadStateOf Ïƒ m] â†’ MonadState Ïƒ m",
  "constCategory": "Definition"},
 {"references":
  ["BEq.beq",
   "instLENat",
   "List.Sublist.countP_le",
   "DecidableEq",
   "List",
   "List.Sublist",
   "instBEq",
   "Nat",
   "List.count",
   "LE.le"],
  "name": "List.Sublist.count_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±},\n  List.Sublist lâ‚ lâ‚‚ â†’ âˆ€ (a : Î±), List.count a lâ‚ â‰¤ List.count a lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_assoc",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_assoc",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b c : Î±}, a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons",
   "List.Sublist.below"],
  "name": "List.Sublist.below.cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop} {lâ‚ lâ‚‚ : List Î±} (a : Î±)\n  {a_1 : List.Sublist lâ‚ lâ‚‚},\n  List.Sublist.below a_1 â†’ motive lâ‚ lâ‚‚ a_1 â†’ List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚))",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Array",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.node6",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ Î± Ã— Î² â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.GenerateOpen.basic",
   "TopologicalSpace.GenerateOpen.univ",
   "TopologicalSpace.GenerateOpen.inter",
   "Set",
   "TopologicalSpace.GenerateOpen.sUnion",
   "Set.sUnion",
   "Inter.inter",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.rec",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {motive : (a : Set Î±) â†’ TopologicalSpace.GenerateOpen g a â†’ Prop},\n  (âˆ€ (s : Set Î±) (a : s âˆˆ g), motive s (_ : TopologicalSpace.GenerateOpen g s)) â†’\n    motive Set.univ (_ : TopologicalSpace.GenerateOpen g Set.univ) â†’\n      (âˆ€ (s t : Set Î±) (a : TopologicalSpace.GenerateOpen g s) (a_1 : TopologicalSpace.GenerateOpen g t),\n          motive s a â†’ motive t a_1 â†’ motive (s âˆ© t) (_ : TopologicalSpace.GenerateOpen g (s âˆ© t))) â†’\n        (âˆ€ (S : Set (Set Î±)) (a : âˆ€ s âˆˆ S, TopologicalSpace.GenerateOpen g s),\n            (âˆ€ (s : Set Î±) (a_1 : s âˆˆ S), motive s (_ : TopologicalSpace.GenerateOpen g s)) â†’\n              motive (â‹ƒâ‚€ S) (_ : TopologicalSpace.GenerateOpen g (â‹ƒâ‚€ S))) â†’\n          âˆ€ {a : Set Î±} (t : TopologicalSpace.GenerateOpen g a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["sInfHom",
   "sInfHom.rec",
   "Set",
   "InfSet.sInf",
   "sInfHom.mk",
   "InfSet",
   "Set.image",
   "Eq"],
  "name": "sInfHom.casesOn",
  "constType":
  "{Î± : Type u_8} â†’\n  {Î² : Type u_9} â†’\n    [inst : InfSet Î±] â†’\n      [inst_1 : InfSet Î²] â†’\n        {motive : sInfHom Î± Î² â†’ Sort u} â†’\n          (t : sInfHom Î± Î²) â†’\n            ((toFun : Î± â†’ Î²) â†’\n                (map_sInf' : âˆ€ (s : Set Î±), toFun (sInf s) = sInf (toFun '' s)) â†’\n                  motive { toFun := toFun, map_sInf' := map_sInf' }) â†’\n              motive t",
  "constCategory": "Definition"},
 {"references":
  ["funext",
   "Set.preimage",
   "TopologicalSpace.ext",
   "Set",
   "Exists.intro",
   "rfl",
   "Eq",
   "Iff.intro",
   "And",
   "propext",
   "induced_id.match_1",
   "Eq.rec",
   "TopologicalSpace",
   "And.intro",
   "TopologicalSpace.induced",
   "IsOpen",
   "id"],
  "name": "induced_id",
  "constType":
  "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±], TopologicalSpace.induced id t = t",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "LE.le",
   "SemilatticeInf",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toInf : Inf Î±] â†’\n    [toPartialOrder : PartialOrder Î±] â†’\n      (âˆ€ (a b : Î±), a âŠ“ b â‰¤ a) â†’\n        (âˆ€ (a b : Î±), a âŠ“ b â‰¤ b) â†’ (âˆ€ (a b c : Î±), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c) â†’ SemilatticeInf Î±",
  "constCategory": "Other"},
 {"references":
  ["Array.mkArray3",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node3",
  "constType":
  "Lean.SourceInfo â†’ Lean.SyntaxNodeKind â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.rec",
   "List.instMembershipList",
   "List",
   "List.mem_cons_of_mem",
   "List.mem_cons_self",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.imp_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {R S : Î± â†’ Î± â†’ Prop},\n  (âˆ€ {a b : Î±}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b) â†’ List.Pairwise R l â†’ List.Pairwise S l",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Nat.le_of_succ_le_succ",
   "LT.lt",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.lt_of_succ_lt_succ",
  "constType": "âˆ€ {n m : â„•}, Nat.succ n < Nat.succ m â†’ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma",
   "instHSub",
   "And",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "LT.lt",
   "HSub.hSub",
   "PSigma.mk",
   "Nat.div.inductionOn._unary",
   "Not",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div.inductionOn",
  "constType":
  "{motive : â„• â†’ â„• â†’ Sort u} â†’\n  (x y : â„•) â†’\n    ((x y : â„•) â†’ 0 < y âˆ§ y â‰¤ x â†’ motive (x - y) y â†’ motive x y) â†’\n      ((x y : â„•) â†’ Â¬(0 < y âˆ§ y â‰¤ x) â†’ motive x y) â†’ motive x y",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.lt.base", "Nat", "Nat.succ", "instLTNat"],
  "name": "Nat.lt_succ_self",
  "constType": "âˆ€ (n : â„•), n < Nat.succ n",
  "constCategory": "Theorem"},
 {"references": ["IsCommutative", "Eq"],
  "name": "IsCommutative.mk",
  "constType":
  "âˆ€ {Î± : Type u} {op : Î± â†’ Î± â†’ Î±}, (âˆ€ (a b : Î±), op a b = op b a) â†’ IsCommutative Î± op",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "Eq.ndrec",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.add_sub_add_left",
   "Eq.refl",
   "Nat.sub_zero",
   "instOfNatNat",
   "Nat",
   "id",
   "Eq"],
  "name": "Nat.add_sub_cancel_left",
  "constType": "âˆ€ (n m : â„•), n + m - n = m",
  "constCategory": "Theorem"},
 {"references":
  ["Not.elim", "Or", "Iff", "or_iff_right_iff_imp", "Not", "Iff.mpr"],
  "name": "or_iff_right",
  "constType": "âˆ€ {a b : Prop}, Â¬a â†’ (a âˆ¨ b â†” b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.finite_range",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "Topology.IsLower",
   "Set.Elem",
   "Set.image_subset_iff",
   "Set.image",
   "And.casesOn",
   "Eq.trans",
   "Set.compl_iUnion",
   "Subtype",
   "TopologicalSpace.IsTopologicalBasis",
   "setOf",
   "Subtype.forall'",
   "eq_of_heq",
   "Set.sInter_eq_iInter",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "HEq.refl",
   "of_eq_true",
   "propext",
   "Eq.mp",
   "Set.iInter",
   "Set.Finite.to_subtype",
   "And.intro",
   "congrArg",
   "SetLike.coe",
   "congrFun",
   "Classical.choose_spec",
   "Exists",
   "Classical.choose",
   "HEq",
   "coe_upperClosure",
   "Subtype.val",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.biInter_range",
   "Exists.intro",
   "Set.Ici",
   "UpperSet",
   "rfl",
   "True",
   "Topology.IsLower.topology_eq",
   "Set.ext",
   "Set.range",
   "Set.Finite.image",
   "upperClosure",
   "TopologicalSpace",
   "Eq.symm",
   "Topology.IsLower.lowerBasis",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.subset_def",
   "funext",
   "TopologicalSpace.isTopologicalBasis_of_subbasis",
   "Set.preimage",
   "Set.sInter_image",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Finite",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Eq.casesOn",
   "Set.sInter"],
  "name": "Topology.IsLower.isTopologicalBasis",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±],\n  TopologicalSpace.IsTopologicalBasis (Topology.IsLower.lowerBasis Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "IsLowerSet",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.lowerSet._cstage1",
  "constType": "(Î± : Type u_4) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references": ["Filter"],
  "name": "Filter.NeBot",
  "constType": "{Î± : Type u} â†’ Filter Î± â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ Nat.succ n â‰¤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace", "T0Space.mk", "T0Space", "Inseparable", "Eq"],
  "name": "T0Space.rec",
  "constType":
  "{Î± : Type u} â†’\n  [inst : TopologicalSpace Î±] â†’\n    {motive : T0Space Î± â†’ Sort u_1} â†’\n      ((t0 : âˆ€ â¦ƒx y : Î±â¦„, Inseparable x y â†’ x = y) â†’ motive (_ : T0Space Î±)) â†’ (t : T0Space Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["Setoid", "List.Perm", "List", "Setoid.mk", "List.Perm.eqv"],
  "name": "List.isSetoid",
  "constType": "(Î± : Type u_1) â†’ Setoid (List Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsRefl",
  "constType": "(Î± : Type u) â†’ (Î± â†’ Î± â†’ Prop) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "nhds",
   "propext",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Order._auxLemma.34",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {a : Î±} {s : Set Î±}, (s âˆˆ nhds a) = âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "OfNat.ofNat",
   "Nat.le.step",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Nat.zero",
   "Eq.ndrec",
   "HEq.refl",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "Nat.pred_le_pred.match_1",
  "constType":
  "âˆ€ (motive : (x x_1 : â„•) â†’ x â‰¤ x_1 â†’ Prop) (x x_1 : â„•) (x_2 : x â‰¤ x_1),\n  (âˆ€ (n : â„•), motive n n (_ : Nat.le n n)) â†’\n    (âˆ€ (n : â„•) (h : Nat.le 0 n), motive 0 (Nat.succ n) (_ : Nat.le 0 (Nat.succ n))) â†’\n      (âˆ€ (n n_1 : â„•) (h : Nat.le (Nat.succ n) n_1),\n          motive (Nat.succ n) (Nat.succ n_1) (_ : Nat.le (Nat.succ n) (Nat.succ n_1))) â†’\n        motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Specializes",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.toUpperSet_specializes_toUpperSet",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Topology.WithUpperSet.toUpperSet",
   "Preorder.toLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSet_le_ofUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Topology.WithUpperSet Î±},\n  â†‘Topology.WithUpperSet.ofUpperSet a â‰¤ â†‘Topology.WithUpperSet.ofUpperSet b â†” b â¤³ a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.WithLower.instPreorderWithLower._rarg", "_neutral"],
  "name": "Topology.WithLower.instPreorderWithLower._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Filter.univ_mem'", "setOf", "Filter", "Filter.Eventually"],
  "name": "Filter.eventually_of_forall",
  "constType":
  "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {f : Filter Î±}, (âˆ€ (x : Î±), p x) â†’ âˆ€á¶  (x : Î±) in f, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_inter_iff",
   "Membership.mem",
   "And",
   "propext",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.43",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), (x âˆˆ a âˆ© b) = (x âˆˆ a âˆ§ x âˆˆ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[_]_Â»._closed_9",
   "Topology.Â«termð“[_]_Â»._closed_8"],
  "name": "Topology.Â«termð“[_]_Â»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Char",
   "List",
   "String.utf8ByteSize.go",
   "String",
   "Nat",
   "String.utf8ByteSize.match_1"],
  "name": "String.utf8ByteSize",
  "constType": "String â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf.inf",
   "Eq.refl",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "inf_top_eq",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Eq.mpr",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "Disjoint.eq_bot",
   "BoundedOrder.toOrderBot",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder",
   "id",
   "inf_le_inf_right",
   "Bot.bot",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "le_sup_left",
   "Codisjoint",
   "DistribLattice.toLattice",
   "sup_inf_right",
   "Eq.ndrec",
   "bot_sup_eq",
   "OrderBot.toBot",
   "Sup.sup",
   "Codisjoint.eq_top"],
  "name": "Disjoint.le_of_codisjoint",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {a b c : Î±}, Disjoint a b â†’ Codisjoint b c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "HasCompl.compl",
   "LE",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "IsLowerSet.compl",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s : Set Î±}, IsLowerSet s â†’ IsUpperSet sá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["List",
   "Unit",
   "Lean.Data.AC.insert.match_1",
   "List.nil",
   "Nat",
   "Lean.Data.AC.mergeIdem.loop"],
  "name": "Lean.Data.AC.mergeIdem",
  "constType": "List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_left",
  "constType": "âˆ€ {a b c : Prop}, (a â†’ b) â†’ a âˆ¨ c â†’ b âˆ¨ c",
  "constCategory": "Theorem"},
 {"references": ["HMod.mk", "Mod.mod", "HMod", "Mod"],
  "name": "instHMod",
  "constType": "{Î± : Type u_1} â†’ [inst : Mod Î±] â†’ HMod Î± Î± Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLowerSet.rec",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.mk",
   "Eq"],
  "name": "Topology.IsLowerSet.casesOn",
  "constType":
  "{Î± : Type u_4} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsLowerSet Î± â†’ Sort u} â†’\n        (t_1 : Topology.IsLowerSet Î±) â†’\n          ((topology_eq_lowerSetTopology : t = Topology.lowerSet Î±) â†’ motive (_ : Topology.IsLowerSet Î±)) â†’ motive t_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "closure",
   "Membership.mem",
   "Filter.principal",
   "Iff",
   "nhds",
   "clusterPt_principal_iff_frequently",
   "Set",
   "TopologicalSpace",
   "Iff.trans",
   "mem_closure_iff_frequently",
   "ClusterPt",
   "Filter.Frequently",
   "Set.instMembershipSet"],
  "name": "mem_closure_iff_clusterPt",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {a : Î±}, a âˆˆ closure s â†” ClusterPt a (Filter.principal s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_5",
   "List.cons",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[_]__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.sSup",
  "constType": "{Î± : Type u_9} â†’ [self : SupSet Î±] â†’ Set Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet", "Filter.GenerateSets", "Set", "HasSubset.Subset"],
  "name": "Filter.GenerateSets.superset",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {s t : Set Î±}, Filter.GenerateSets g s â†’ s âŠ† t â†’ Filter.GenerateSets g t",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.semilatticeInf",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "SemilatticeInf.inf_le_right",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_5",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Lattice Î±] (a b : Î±áµ’áµˆ), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpper",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.WithUpper.instPreorderWithUpper",
   "Topology.IsUpper.mk",
   "Preorder",
   "rfl"],
  "name":
  "Topology.instIsUpperWithUpperInstTopologicalSpaceWithUpperInstPreorderWithUpper.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsUpper (Topology.WithUpper Î±)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.instMembershipList",
   "propext",
   "List",
   "List.replicate",
   "List.eq_replicate",
   "List.length",
   "Nat",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.9",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {n : â„•} {l : List Î±}, (l = List.replicate n a) = (List.length l = n âˆ§ âˆ€ b âˆˆ l, b = a)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "List.instMembershipList", "List"],
  "name": "List.Subset",
  "constType": "{Î± : Type u_1} â†’ List Î± â†’ List Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Function.RightInverse",
   "Equiv.rec",
   "Equiv.mk"],
  "name": "Equiv.casesOn",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {motive : Î± â‰ƒ Î² â†’ Sort u} â†’\n      (t : Î± â‰ƒ Î²) â†’\n        ((toFun : Î± â†’ Î²) â†’\n            (invFun : Î² â†’ Î±) â†’\n              (left_inv : Function.LeftInverse invFun toFun) â†’\n                (right_inv : Function.RightInverse invFun toFun) â†’\n                  motive { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) â†’\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "And",
   "instHAppend",
   "List.eraseP",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Bool.true",
   "Not",
   "Bool",
   "And.intro",
   "And.casesOn"],
  "name": "List.exists_of_eraseP.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} (l : List Î±)\n  (motive :\n    (âˆƒ a, âˆƒ lâ‚, âˆƒ lâ‚‚, (âˆ€ b âˆˆ lâ‚, Â¬p b = true) âˆ§ p a = true âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.eraseP p l = lâ‚ ++ lâ‚‚) â†’ Prop)\n  (x : âˆƒ a, âˆƒ lâ‚, âˆƒ lâ‚‚, (âˆ€ b âˆˆ lâ‚, Â¬p b = true) âˆ§ p a = true âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.eraseP p l = lâ‚ ++ lâ‚‚),\n  (âˆ€ (c : Î±) (lâ‚ lâ‚‚ : List Î±) (hâ‚ : âˆ€ b âˆˆ lâ‚, Â¬p b = true) (hâ‚‚ : p c = true) (hâ‚ƒ : l = lâ‚ ++ c :: lâ‚‚)\n      (hâ‚„ : List.eraseP p l = lâ‚ ++ lâ‚‚),\n      motive\n        (_ : âˆƒ a, âˆƒ lâ‚, âˆƒ lâ‚‚, (âˆ€ b âˆˆ lâ‚, Â¬p b = true) âˆ§ p a = true âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.eraseP p l = lâ‚ ++ lâ‚‚)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_5",
  "constType": "âˆ€ {Î± : Type u_1} (a b : (Filter Î±)áµ’áµˆáµ’áµˆ), a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.ofLower_toLower",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±), â†‘Topology.WithLower.ofLower (â†‘Topology.WithLower.toLower a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set.sInter_subset_of_mem",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "IsClosed"],
  "name": "closure_minimal",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s t : Set Î±}, s âŠ† t â†’ IsClosed t â†’ closure s âŠ† t",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "cond",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.findIdx.go",
   "List.findIdx_cons.findIdx_go_succ",
   "List.findIdx",
   "True",
   "Eq",
   "Nat.zero_add",
   "Bool.casesOn",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Bool.false",
   "Bool.true",
   "congr",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.findIdx_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) (b : Î±) (l : List Î±), List.findIdx p (b :: l) = bif p b then 0 else List.findIdx p l + 1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "Inf", "InfHomClass"],
  "name": "InfHomClass.toFunLike",
  "constType":
  "{F : Type u_7} â†’\n  {Î± : outParam (Type u_8)} â†’\n    {Î² : outParam (Type u_9)} â†’ [inst : Inf Î±] â†’ [inst_1 : Inf Î²] â†’ [self : InfHomClass F Î± Î²] â†’ FunLike F Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.pred_le.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ Prop) (x : â„•), (Unit â†’ motive Nat.zero) â†’ (âˆ€ (n : â„•), motive (Nat.succ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Subtype.val",
   "propext",
   "Subtype.exists'",
   "Subtype",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.24",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (x : Î±) â†’ p x â†’ Prop}, (âˆƒ x, âˆƒ (h : p x), q x h) = âˆƒ x, q â†‘x (_ : p â†‘x)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "IsAssociative",
   "instIsAssociativeInfToInf.proof_1",
   "SemilatticeInf"],
  "name": "instIsAssociativeInfToInf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±], IsAssociative Î± fun x x_1 â†¦ x âŠ“ x_1",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "âˆ€ {a b : Prop} {motive : a âˆ¨ b â†’ Prop},\n  (âˆ€ (h : a), motive (_ : a âˆ¨ b)) â†’ (âˆ€ (h : b), motive (_ : a âˆ¨ b)) â†’ âˆ€ (t : a âˆ¨ b), motive t",
  "constCategory": "Other"},
 {"references": ["MonadWithReaderOf", "semiOutParam"],
  "name": "MonadWithReaderOf.mk",
  "constType":
  "{Ï : semiOutParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ ({Î± : Type u} â†’ (Ï â†’ Ï) â†’ m Î± â†’ m Î±) â†’ MonadWithReaderOf Ï m",
  "constCategory": "Other"},
 {"references": ["Exists", "Exists.intro", "forall_exists_index.match_1"],
  "name": "Exists.imp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (a : Î±), p a â†’ q a) â†’ (âˆƒ a, p a) â†’ âˆƒ a, q a",
  "constCategory": "Theorem"},
 {"references": ["List", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.range.loop.match_1",
  "constType":
  "(motive : â„• â†’ List â„• â†’ Sort u_1) â†’\n  (x : â„•) â†’\n    (x_1 : List â„•) â†’ ((ns : List â„•) â†’ motive 0 ns) â†’ ((n : â„•) â†’ (ns : List â„•) â†’ motive (Nat.succ n) ns) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Functor"],
  "name": "Applicative.toFunctor",
  "constType": "{f : Type u â†’ Type v} â†’ [self : Applicative f] â†’ Functor f",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.Â«termð“[>]_Â»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[>]_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "Inf.inf",
   "Filter.instInfFilter",
   "Filter.comap",
   "Prod",
   "Filter",
   "Prod.fst"],
  "name": "Filter.prod",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ Filter Î± â†’ Filter Î² â†’ Filter (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.not_mem_nil.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (motive : a âˆˆ [] â†’ Prop) (a : a âˆˆ []), motive a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "instLENat",
   "Nat.le_of_lt_succ",
   "LT.lt",
   "Nat.lt_succ_of_le",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.lt_succ",
  "constType": "âˆ€ {m n : â„•}, m < Nat.succ n â†” m â‰¤ n",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "IsOpen",
   "Eq"],
  "name": "isOpen_induced_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [t : TopologicalSpace Î²] {s : Set Î±} {f : Î± â†’ Î²},\n  IsOpen s â†” âˆƒ t_1, IsOpen t_1 âˆ§ f â»Â¹' t_1 = s",
  "constCategory": "Theorem"},
 {"references": ["Char", "List", "String", "String.casesOn", "Eq"],
  "name": "String.noConfusionType",
  "constType": "Sort u â†’ String â†’ String â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Nat.decLt",
   "LT.lt",
   "Array.get",
   "Not",
   "dite",
   "Nat",
   "Array.size",
   "instLTNat",
   "Fin.mk"],
  "name": "Array.getD",
  "constType": "{Î± : Type u_1} â†’ Array Î± â†’ â„• â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "âˆ€ {Î± : Type u} [self : Lattice Î±] (a b : Î±), a âŠ“ b â‰¤ b",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Iff",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpper.ofUpper_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Topology.WithUpper Î±}, â†‘Topology.WithUpper.ofUpper a = â†‘Topology.WithUpper.ofUpper b â†” a = b",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.upper._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "List.Pairwise.nil",
   "List.Pairwise.below",
   "List",
   "List.nil"],
  "name": "List.Pairwise.below.nil",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop},\n  List.Pairwise.below (_ : List.Pairwise R [])",
  "constCategory": "Other"},
 {"references": ["outParam", "TopologicalSpace"],
  "name": "ContinuousMapClass",
  "constType":
  "Type u_1 â†’\n  (Î± : outParam (Type u_2)) â†’\n    (Î² : outParam (Type u_3)) â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ Type (max (max u_1 u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "OfNat.ofNat",
   "Trans.trans",
   "instIsCommutativeSupToSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "Lean.IsNeutral",
   "instIsIdempotentInfToInf",
   "Eq",
   "Lattice.toInf",
   "sup_inf_self",
   "instIsAssociativeInfToInf",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "instOfNatNat",
   "Option.some",
   "List.nil",
   "Nat",
   "Lattice.toSemilatticeSup",
   "instIsIdempotent",
   "Eq.trans",
   "instIsIdempotentSupToSup",
   "id",
   "List.cons",
   "Lattice.toSemilatticeInf",
   "Lean.Data.AC.eval",
   "SDiff.sdiff",
   "instIsCommutative",
   "instIsCommutativeInfToInf",
   "Lean.IsIdempotent",
   "DistribLattice.toLattice",
   "sup_inf_sdiff",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "instIsAssociative",
   "Lean.IsCommutative",
   "GeneralizedBooleanAlgebra",
   "instTransEq",
   "congr",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Bool",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "congrFun",
   "instIsAssociativeSupToSup"],
  "name": "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_sup_self'",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : GeneralizedBooleanAlgebra Î±], y \\ x âŠ” x = y âŠ” x",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "Eq.rec", "HasSubset.Subset", "HasSubset", "subset_rfl", "Eq"],
  "name": "superset_of_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1], a = b â†’ b âŠ† a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Lean.Data.AC.Expr.op",
   "PProd.fst",
   "List.append",
   "List.cons",
   "Lean.Data.AC.Expr",
   "List",
   "PUnit",
   "Lean.Data.AC.Expr.rec",
   "Lean.Data.AC.Expr.below",
   "Lean.Data.AC.Expr.brecOn",
   "List.nil",
   "PProd.snd",
   "Nat",
   "Lean.Data.AC.Expr.var",
   "_private.Init.Data.AC.0.Lean.Data.AC.reprExpr.match_1._@.Init.Data.AC._hyg.40"],
  "name": "Lean.Data.AC.Expr.toList",
  "constType": "Lean.Data.AC.Expr â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Nat.min_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "Eq.refl",
   "Nat",
   "instMinNat",
   "Nat.min_eq_left",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.min_eq_right",
  "constType": "âˆ€ {a b : â„•}, b â‰¤ a â†’ min a b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "OrderDual.distribLattice",
   "IsCompl",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "OrderDual.boundedOrder",
   "DistribLattice.toLattice",
   "Iff.intro",
   "Lattice.toInf",
   "IsCompl.dual",
   "Iff",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "IsCompl.inf_left_le_of_le_sup_right",
   "OrderDual",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "IsCompl.symm",
   "BoundedOrder"],
  "name": "IsCompl.le_sup_right_iff_inf_left_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y a b : Î±},\n  IsCompl x y â†’ (a â‰¤ b âŠ” y â†” a âŠ“ x â‰¤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "Set",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.forall_image2_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_3} {Î² : Type u_2} {Î³ : Type u_1} {f : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} (x : Î³)\n  (motive : x âˆˆ Set.image2 f s t â†’ Prop) (x_1 : x âˆˆ Set.image2 f s t),\n  (âˆ€ (x_2 : Î±) (y : Î²) (hx : x_2 âˆˆ s) (hy : y âˆˆ t) (hz : f x_2 y = x),\n      motive (_ : âˆƒ a, âˆƒ b, a âˆˆ s âˆ§ b âˆˆ t âˆ§ f a b = x)) â†’\n    motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Lean.Name.rec",
   "PProd.fst",
   "Lean.Name.below",
   "Lean.Name.brecOn",
   "Lean.Name.num",
   "Lean.Name.appendCore.match_1",
   "String",
   "PUnit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.str"],
  "name": "Lean.Name.appendCore",
  "constType": "Lean.Name â†’ Lean.Name â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt_wfRel.proof_1",
   "WellFoundedRelation",
   "Nat.lt",
   "Nat",
   "WellFoundedRelation.mk"],
  "name": "Nat.lt_wfRel",
  "constType": "WellFoundedRelation â„•",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.closure_of._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.closure_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists.fst.match_1",
   "Exists",
   "Iff.mp",
   "Iff",
   "exists_prop_congr.match_1",
   "Exists.intro",
   "Iff.mpr"],
  "name": "exists_prop_congr",
  "constType":
  "âˆ€ {p p' : Prop} {q q' : p â†’ Prop}, (âˆ€ (h : p), q h â†” q' h) â†’ âˆ€ (hp : p â†” p'), Exists q â†” âˆƒ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteLattice",
   "Set.Elem",
   "Subtype.val",
   "Set",
   "iSup_subtype",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "iSup_subtype''",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {Î¹ : Type u_9} (s : Set Î¹) (f : Î¹ â†’ Î±), â¨† i, f â†‘i = â¨† t âˆˆ s, f t",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "âˆ€ {pâ‚ pâ‚‚ : Sort u} {qâ‚ qâ‚‚ : Sort v}, pâ‚ = pâ‚‚ â†’ qâ‚ = qâ‚‚ â†’ (pâ‚ â†’ qâ‚) = (pâ‚‚ â†’ qâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "funext",
   "setOf",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "Filter.principal",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "congrArg",
   "interior_eq_nhds'",
   "Eq.trans",
   "interior",
   "Mathlib.Topology.Basic._auxLemma.50",
   "instMembershipSetFilter"],
  "name": "interior_eq_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, interior s = {a | nhds a â‰¤ Filter.principal s}",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{Î± : Type u} â†’ [self : Inter Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.mk",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  {motive : Filter Î± â†’ Sort u} â†’\n    ((sets : Set (Set Î±)) â†’\n        (univ_sets : Set.univ âˆˆ sets) â†’\n          (sets_of_superset : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets) â†’\n            (inter_sets : âˆ€ {x y : Set Î±}, x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets) â†’\n              motive\n                { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset,\n                  inter_sets := inter_sets }) â†’\n      (t : Filter Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Iff",
   "List.mem_map_of_injective.match_1",
   "Function.Injective",
   "List.mem_map_of_mem",
   "List.instMembershipList",
   "List",
   "Eq.rec",
   "List.map",
   "List.exists_of_mem_map",
   "Eq"],
  "name": "List.mem_map_of_injective",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²}, Function.Injective f â†’ âˆ€ {a : Î±} {l : List Î±}, f a âˆˆ List.map f l â†” a âˆˆ l",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn", "Eq"],
  "name": "Fintype.ofBijective.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (b : Î²) (motive : (âˆƒ a, f a = b) â†’ Prop) (x : âˆƒ a, f a = b),\n  (âˆ€ (w : Î±) (e : f w = b), motive (_ : âˆƒ a, f a = b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "LE", "Pi.hasLe", "LE.le"],
  "name": "Pi.le_def",
  "constType":
  "âˆ€ {Î¹ : Type u} {Î± : Î¹ â†’ Type v} [inst : (i : Î¹) â†’ LE (Î± i)] {x y : (i : Î¹) â†’ Î± i}, x â‰¤ y â†” âˆ€ (i : Î¹), x i â‰¤ y i",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "BooleanAlgebra.toTop",
   "top_unique"],
  "name": "sup_compl_eq_top",
  "constType": "âˆ€ {Î± : Type u} {x : Î±} [inst : BooleanAlgebra Î±], x âŠ” xá¶œ = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "List.cons", "List.Nodup", "List.pairwise_singleton", "List.nil"],
  "name": "List.nodup_singleton",
  "constType": "âˆ€ {Î± : Type u} (a : Î±), List.Nodup [a]",
  "constCategory": "Theorem"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.coe",
  "constType":
  "{E : Sort u_1} â†’ {Î± : outParam (Sort u_2)} â†’ {Î² : outParam (Sort u_3)} â†’ [self : EquivLike E Î± Î²] â†’ E â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references": ["Or", "False", "Not", "Or.elim"],
  "name": "not_or_intro",
  "constType": "âˆ€ {a b : Prop}, Â¬a â†’ Â¬b â†’ Â¬(a âˆ¨ b)",
  "constCategory": "Theorem"},
 {"references": ["IsAssociative", "Eq"],
  "name": "IsAssociative.assoc",
  "constType":
  "âˆ€ {Î± : Type u} {op : Î± â†’ Î± â†’ Î±} [self : IsAssociative Î± op] (a b c : Î±), op (op a b) c = op a (op b c)",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "inferInstanceAs",
   "OrderDual",
   "Preorder.le_trans",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PartialOrder Î±] (a b c : Î±áµ’áµˆ), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.List.Dedup._auxLemma.2",
  "constType": "âˆ€ {a : Prop}, (Â¬Â¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "Iff",
   "decide_eq_true_eq",
   "of_eq_true",
   "Bool.true",
   "Decidable",
   "Bool",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "decide_eq_true_iff",
  "constType": "âˆ€ (p : Prop) [inst : Decidable p], decide p = true â†” p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.cat", "_obj", "Topology.IsOpen_of._closed_9"],
  "name": "Topology.Â«termð“[_]_Â»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Prop.booleanAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.inf_compl_le_bot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_12",
  "constType": "âˆ€ {Î± : Type u_1} (x : Î± â†’ Prop), x âŠ“ xá¶œ â‰¤ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "OfNat.ofNat",
   "Nat.succ_le_of_lt",
   "instAddNat",
   "instHAdd",
   "Nat.lt_of_lt_of_le",
   "HAdd.hAdd",
   "Nat.add_lt_add_left",
   "LE.le",
   "instLTNat",
   "Eq",
   "GT.gt",
   "instHMul",
   "instLENat",
   "Nat.mul_le_mul_left",
   "LT.lt",
   "Eq.rec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.mul_lt_mul_of_pos_left",
  "constType": "âˆ€ {n m k : â„•}, n < m â†’ k > 0 â†’ k * n < k * m",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded.fixF", "Acc.inv", "Acc", "WellFounded.fixFEq.proof_1", "Eq"],
  "name": "WellFounded.fixFEq",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {C : Î± â†’ Sort v} (F : (x : Î±) â†’ ((y : Î±) â†’ r y x â†’ C y) â†’ C x) (x : Î±)\n  (acx : Acc r x), WellFounded.fixF F x acx = F x fun y p â†¦ WellFounded.fixF F y (_ : Acc (fun y x â†¦ r y x) y)",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "le_sup_of_le_right",
   "Sup.sup",
   "sup_le",
   "le_sup_of_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c d : Î±}, a â‰¤ b â†’ c â‰¤ d â†’ a âŠ” c â‰¤ b âŠ” d",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "iInf_inf_eq",
   "funext",
   "Prod.snd",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Prod.fst",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "sInf_image",
   "Prod.infSet",
   "Eq.mpr",
   "CompleteLattice",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Prod",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "infsInfHom.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] (s : Set (Î± Ã— Î±)),\n  (fun x â†¦ x.1 âŠ“ x.2) (sInf s) = sInf ((fun x â†¦ x.1 âŠ“ x.2) '' s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Pure",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Eq.refl",
   "List.Mem",
   "Exists.intro",
   "List.cons_append",
   "rfl",
   "Eq",
   "PProd",
   "instHAppend",
   "List.append_of_mem.match_2",
   "Eq.mpr",
   "PProd.fst",
   "Eq.ndrec",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "List.nil",
   "List.append_of_mem.match_1",
   "id"],
  "name": "List.append_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±}, a âˆˆ l â†’ âˆƒ s, âˆƒ t, l = s ++ a :: t",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(Î± : Sort u) â†’ [i : Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.hMod",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HMod Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List",
   "List.Chain.nil",
   "List.nil",
   "List.Chain",
   "List.Chain.cons"],
  "name": "List.Chain.rec",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : Î±) â†’ (a_1 : List Î±) â†’ List.Chain R a a_1 â†’ Prop},\n  (âˆ€ {a : Î±}, motive a [] (_ : List.Chain R a [])) â†’\n    (âˆ€ {a b : Î±} {l : List Î±} (a_1 : R a b) (a_2 : List.Chain R b l),\n        motive b l a_2 â†’ motive a (b :: l) (_ : List.Chain R a (b :: l))) â†’\n      âˆ€ {a : Î±} {a_1 : List Î±} (t : List.Chain R a a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "And",
   "Iff.mp",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "Continuous",
   "continuous_prod_mk",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "And.left"],
  "name": "continuous_fst",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], Continuous Prod.fst",
  "constCategory": "Theorem"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.mk",
  "constType": "{Î± : Type u_9} â†’ (Set Î± â†’ Î±) â†’ InfSet Î±",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[>]_Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Continuous",
   "TopologicalSpace",
   "ContinuousMap",
   "autoParam",
   "_auto._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.6"],
  "name": "ContinuousMap.mk",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : TopologicalSpace Î±] â†’\n      [inst_1 : TopologicalSpace Î²] â†’ (toFun : Î± â†’ Î²) â†’ autoParam (Continuous toFun) _autoâœ â†’ C(Î±, Î²)",
  "constCategory": "Other"},
 {"references": ["And", "and_imp", "Iff", "False", "Not"],
  "name": "not_and",
  "constType": "âˆ€ {a b : Prop}, Â¬(a âˆ§ b) â†” a â†’ Â¬b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "AddZeroClass"],
  "name": "AddMonoidHomClass",
  "constType":
  "Type u_9 â†’\n  (M : outParam (Type u_10)) â†’\n    (N : outParam (Type u_11)) â†’ [inst : AddZeroClass M] â†’ [inst : AddZeroClass N] â†’ Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["Quot.rec", "Eq.ndrec", "Quot", "Quot.sound", "Eq", "Quot.mk"],
  "name": "Quot.recOn'",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : Quot r â†’ Sort v} â†’\n      (q : Quot r) â†’\n        (f : (a : Î±) â†’ motive (Quot.mk r a)) â†’\n          (âˆ€ (a b : Î±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) â–¸ f a = f b) â†’ motive q",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpper.rec._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpper.rec._cstage2",
  "constType": "_neutral â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["trivial", "eq_true", "True", "Eq"],
  "name": "implies_true",
  "constType": "âˆ€ (Î± : Sort u), (Î± â†’ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "False.casesOn",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet"],
  "name": "Set.empty_subset.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (a : Î±) â†’ a âˆˆ âˆ… â†’ Prop) (a : Î±) (a_1 : a âˆˆ âˆ…), motive a a_1",
  "constCategory": "Definition"},
 {"references": ["Function.comp", "rfl", "Eq", "id"],
  "name": "Function.comp.right_id",
  "constType": "âˆ€ {Î± : Sort uâ‚} {Î² : Sort uâ‚‚} (f : Î± â†’ Î²), f âˆ˜ id = f",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsClosed_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Data.AC.EvalInformation",
  "constType": "Sort u â†’ Sort v â†’ Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["SupSet", "CompleteBooleanAlgebra"],
  "name": "CompleteBooleanAlgebra.toSupSet",
  "constType": "{Î± : Type u_1} â†’ [self : CompleteBooleanAlgebra Î±] â†’ SupSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "t0Space_iff_inseparable.match_1",
   "TopologicalSpace",
   "T0Space.mk",
   "T0Space",
   "Inseparable",
   "Eq"],
  "name": "t0Space_iff_inseparable",
  "constType":
  "âˆ€ (Î± : Type u) [inst : TopologicalSpace Î±], T0Space Î± â†” âˆ€ (x y : Î±), Inseparable x y â†’ x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "Eq.refl",
   "Symmetric",
   "Exists.casesOn",
   "Iff.mpr",
   "Eq",
   "List.Perm.symm",
   "Eq.mpr",
   "List.Perm.cons_inv",
   "Iff",
   "List.Pairwise.rec",
   "List.perm_middle",
   "List.nil",
   "Eq.symm",
   "id",
   "Membership.mem",
   "List.cons",
   "List.mem_split",
   "List.pairwise_middle",
   "Iff.intro",
   "List.Pairwise",
   "List.Perm.subset",
   "instHAppend",
   "And",
   "Eq.ndrec",
   "List.Perm",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "List.pairwise_cons",
   "List.mem_cons_self",
   "List.Perm.trans",
   "And.intro",
   "List.Perm.nil_eq"],
  "name": "List.Perm.pairwise_iff",
  "constType":
  "âˆ€ {Î± : Type uu} {R : Î± â†’ Î± â†’ Prop},\n  Symmetric R â†’ âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (List.Pairwise R lâ‚ â†” List.Pairwise R lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat"],
  "name": "UInt64.size",
  "constType": "â„•",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "inferInstanceAs",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.le_inf",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.distribLattice.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : DistribLattice Î±] (a b c : Î±áµ’áµˆ), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.mk",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î³ : Type v} â†’ (Î± â†’ Î³ â†’ Î³) â†’ Insert Î± Î³",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.mem_range_self",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} (i : Î¹), f i âˆˆ Set.range f",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "LE", "LE.le"],
  "name": "Pi.hasLe",
  "constType":
  "{Î¹ : Type u} â†’ {Î± : Î¹ â†’ Type v} â†’ [inst : (i : Î¹) â†’ LE (Î± i)] â†’ LE ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references":
  ["Char.val",
   "Decidable.casesOn",
   "UInt32",
   "Char",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "instDecidableEqChar.match_1",
  "constType":
  "(c d : Char) â†’\n  (motive : Decidable (c.val = d.val) â†’ Sort u_1) â†’\n    (x : Decidable (c.val = d.val)) â†’\n      ((h : c.val = d.val) â†’ motive (isTrue h)) â†’ ((h : Â¬c.val = d.val) â†’ motive (isFalse h)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.SourceInfo", "Substring", "String.Pos"],
  "name": "Lean.SourceInfo.original",
  "constType":
  "Substring â†’ String.Pos â†’ Substring â†’ String.Pos â†’ Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec",
   "Eq.rec",
   "Continuous",
   "Eq.refl",
   "TopologicalSpace",
   "ContinuousMap",
   "Eq.symm",
   "autoParam",
   "_auto._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.6",
   "ContinuousMap.casesOn",
   "ContinuousMap.toFun",
   "ContinuousMap.mk",
   "Eq"],
  "name": "ContinuousMap.toContinuousMapClass.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (f g : C(Î±, Î²)),\n  f.toFun = g.toFun â†’ f = g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsIdempotent",
  "constType": "(Î± : Type u) â†’ (Î± â†’ Î± â†’ Î±) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "LE",
   "Set.univ",
   "LE.le",
   "Set.instMembershipSet",
   "id"],
  "name": "isLowerSet_univ",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±], IsLowerSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "setOf",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "TopologicalSpace.mkOfClosure_sets",
   "TopologicalSpace.mkOfClosure",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.Subset.antisymm",
   "IsOpen"],
  "name": "TopologicalSpace.gciGenerateFrom.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (x : (Set (Set Î±))áµ’áµˆ) (x_1 : x â‰¤ â†‘OrderDual.toDual {s | IsOpen s}),\n  TopologicalSpace.mkOfClosure x (_ : {u | TopologicalSpace.GenerateOpen x u} = x) = TopologicalSpace.generateFrom x",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "OrderDual.instPreorder",
   "Iff",
   "Topology.IsLower",
   "OrderDual.instIsUpper",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "Topology.isUpper_orderDual",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±], Topology.IsUpper Î±áµ’áµˆ â†” Topology.IsLower Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_2",
  "constType":
  "âˆ€ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M â†’+ N), ZeroHom.toFun (â†‘f) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet", "Set", "HasSubset.Subset", "Set.Subset.refl"],
  "name": "Set.Subset.rfl",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s âŠ† s",
  "constCategory": "Theorem"},
 {"references": ["And", "False", "Not", "and_not_self.match_1"],
  "name": "and_not_self",
  "constType": "âˆ€ {a : Prop}, Â¬(a âˆ§ Â¬a)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Prod.casesOn", "Prod.mk", "LE", "Prod", "LE.le"],
  "name": "Prod.instPreorderProd.match_5",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) (src : LE (Î± Ã— Î²)) (x : Î± Ã— Î²) (motive : (x_1 : Î± Ã— Î²) â†’ x_1 â‰¤ x â†’ Prop) (x_1 : Î± Ã— Î²)\n  (x_2 : x_1 â‰¤ x), (âˆ€ (a : Î±) (b : Î²) (x : (a, b) â‰¤ x), motive (a, b) x) â†’ motive x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.IsUpper.WithUpperHomeomorph._rarg", "_neutral"],
  "name": "Topology.IsUpper.WithUpperHomeomorph._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["PSigma",
   "Eq.ndrec",
   "Quot",
   "PSigma.eta",
   "Quot.indep",
   "Quot.sound",
   "Eq",
   "Quot.mk"],
  "name": "Quot.indepCoherent",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop} {motive : Quot r â†’ Sort v} (f : (a : Î±) â†’ motive (Quot.mk r a)),\n  (âˆ€ (a b : Î±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) â–¸ f a = f b) â†’\n    âˆ€ (a b : Î±), r a b â†’ Quot.indep f a = Quot.indep f b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "And.left",
   "Iff.mpr",
   "List.Pairwise",
   "And",
   "Iff.mp",
   "List.chain_cons",
   "List",
   "List.pairwise_cons",
   "List.Pairwise.rec",
   "Eq.mp",
   "List.Chain.nil",
   "List.nil",
   "And.intro",
   "List.Chain",
   "Std.Data.List.Lemmas._auxLemma.101",
   "List.Pairwise.chain.match_1"],
  "name": "List.Pairwise.chain",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±}, List.Pairwise R (a :: l) â†’ List.Chain R a l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "Iff.symm",
   "And",
   "Iff",
   "Filter.eq_sInf_of_mem_iff_exists_mem",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter",
   "Iff.trans",
   "Set.exists_range_iff",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.eq_iInf_of_mem_iff_exists_mem",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ Filter Î±} {l : Filter Î±}, (âˆ€ {s : Set Î±}, s âˆˆ l â†” âˆƒ i, s âˆˆ f i) â†’ l = iInf f",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le", "bot_le"],
  "name": "Pi.orderBot.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ LE (Î±' i)] [inst_1 : (i : Î¹) â†’ OrderBot (Î±' i)]\n  (x : (i : Î¹) â†’ Î±' i) (x_1 : Î¹), âŠ¥ â‰¤ x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "Eq.refl",
   "implies_congr",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Filter.principal",
   "Iff",
   "CompleteLattice.toConditionallyCompleteLattice",
   "forall_congr",
   "TopologicalSpace",
   "Filter",
   "Eq.trans",
   "IsOpen",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "nhds",
   "Std.Logic._auxLemma.23",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "nhds_def",
   "And",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Mathlib.Order.CompleteLattice._auxLemma.8",
   "congrFun"],
  "name": "le_nhds_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : Filter Î±} {a : Î±}, f â‰¤ nhds a â†” âˆ€ (s : Set Î±), a âˆˆ s â†’ IsOpen s â†’ s âˆˆ f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "GeneralizedCoheytingAlgebra",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_13",
   "Topology.IsOpen_of._closed_11"],
  "name": "Topology.IsOpen_of._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List",
   "Multiset.attach",
   "List.isSetoid",
   "Multiset",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "List.mem_attach"],
  "name": "Multiset.mem_attach",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Multiset Î±) (x : { x // x âˆˆ s }), x âˆˆ Multiset.attach s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Iff",
   "Inf.inf",
   "Set",
   "Set.Nonempty",
   "Filter.instInfFilter",
   "Filter.basis_sets",
   "Inter.inter",
   "Filter",
   "Filter.NeBot",
   "Filter.HasBasis.inf_principal_neBot_iff",
   "Set.instInterSet",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.inf_principal_neBot_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : Filter Î±} {s : Set Î±}, Filter.NeBot (l âŠ“ Filter.principal s) â†” âˆ€ U âˆˆ l, Set.Nonempty (U âˆ© s)",
  "constCategory": "Theorem"},
 {"references": ["GeneralizedCoheytingAlgebra", "SDiff"],
  "name": "GeneralizedCoheytingAlgebra.toSDiff",
  "constType":
  "{Î± : Type u_4} â†’ [self : GeneralizedCoheytingAlgebra Î±] â†’ SDiff Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "And.right",
   "Iff",
   "forall_and.match_1",
   "And.intro",
   "And.left"],
  "name": "forall_and",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (x : Î±), p x âˆ§ q x) â†” (âˆ€ (x : Î±), p x) âˆ§ âˆ€ (x : Î±), q x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.instInhabitedMacroScopesView",
   "cond.match_1",
   "List.cons",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "Lean.MacroScopesView",
   "String",
   "Unit",
   "instBEq",
   "Lean.MacroScope",
   "Eq",
   "_private.Init.Prelude.0.Lean.extractImported",
   "_private.Init.Prelude.0.Lean.assembleParts",
   "PProd",
   "namedPattern",
   "Lean.Name.rec",
   "PProd.fst",
   "BEq.beq",
   "List",
   "PUnit",
   "Lean.MacroScopesView.mk",
   "panic",
   "List.nil",
   "Bool",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "_private.Init.Prelude.0.Lean.extractImported.match_1",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractMainModule",
  "constType":
  "List Lean.MacroScope â†’ Lean.Name â†’ List Lean.Name â†’ Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.closure_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termI^_Â»._closed_11",
   "Topology.Â«termI^_Â»._closed_3"],
  "name": "Topology.Â«termI^_Â»._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Directed",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "Iff.of_eq",
   "ball_congr",
   "Mathlib.Data.Subtype._auxLemma.1",
   "Eq.mpr",
   "Iff",
   "Iff.mp",
   "forall_congr",
   "Mathlib.Order.Directed._auxLemma.2",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Subtype",
   "id",
   "Membership.mem",
   "funext",
   "Mathlib.Order.Directed._auxLemma.1",
   "DirectedOn",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.40",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "DirectedOn.directed_val",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±}, DirectedOn r s â†’ Directed r Subtype.val",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteSemilatticeSup",
  "constType": "Type u_9 â†’ Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Filter.filter_eq.match_1",
   "Set.instHasSubsetSet",
   "Filter.mk",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.univ",
   "rfl",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.filter_eq",
  "constType": "âˆ€ {Î± : Type u} {f g : Filter Î±}, f.sets = g.sets â†’ f = g",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Eq.refl", "Nat", "instMinNat", "Eq"],
  "name": "Nat.linearOrder.proof_1",
  "constType": "âˆ€ (a b : â„•), min a b = min a b",
  "constCategory": "Theorem"},
 {"references": ["Set", "Filter"],
  "name": "Filter.sets",
  "constType": "{Î± : Type u_1} â†’ Filter Î± â†’ Set (Set Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "LE.mk",
   "And",
   "propext",
   "Iff.rfl",
   "LT.lt",
   "Function.comp",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder.proof_2",
  "constType": "âˆ€ (x x_1 : Prop), x â‰¤ x_1 â†’ x_1 â‰¤ x â†’ x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["LowerSet",
   "Topology.IsLower.isClosed_upperClosure",
   "OrderDual.instPreorder",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "IsClosed",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "lowerClosure",
   "Preorder.toLE",
   "Set.Finite",
   "SetLike.coe"],
  "name": "Topology.IsUpper.isClosed_lowerClosure",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±] {s : Set Î±},\n  Set.Finite s â†’ IsClosed â†‘(lowerClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "nhds",
   "propext",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.49",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {a : Î±} {s : Set Î±}, (s âˆˆ nhds a) = âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.Nonempty",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Inter.inter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "mem_closure_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Set Î±} (x : Set Î±) (motive : Set.Nonempty (xá¶œ âˆ© s) â†’ Prop) (x_1 : Set.Nonempty (xá¶œ âˆ© s)),\n  (âˆ€ (w : Î±) (hc : w âˆˆ xá¶œ) (hs : w âˆˆ s), motive (_ : âˆƒ x_2, x_2 âˆˆ xá¶œ âˆ© s)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.toSup",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.top_le_sup_compl",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop"],
  "name": "Set.instBooleanAlgebraSet.proof_13",
  "constType": "âˆ€ {Î± : Type u_1} (x : Î± â†’ Prop), âŠ¤ â‰¤ x âŠ” xá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.induced.proof_2",
   "TopologicalSpace.mk",
   "And",
   "Exists",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced.proof_3",
   "IsOpen",
   "TopologicalSpace.induced.proof_1",
   "Eq"],
  "name": "TopologicalSpace.induced",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ TopologicalSpace Î² â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteBooleanAlgebra.toInfSet",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.le_sInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "EmbeddingLike",
  "constType":
  "Sort u_1 â†’ outParam (Sort u_2) â†’ outParam (Sort u_3) â†’ Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Eq.mpr",
   "Topology.IsUpperSet",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "TopologicalSpace",
   "Topology.IsUpperSet.topology_eq",
   "Topology.upperSet",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Eq",
   "id"],
  "name": "Topology.IsUpperSet.isOpen_iff_isUpperSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±] {s : Set Î±},\n  IsOpen s â†” IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Top.top",
   "LE.le.trans",
   "le_top",
   "Preorder",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "PartialOrder",
   "Eq",
   "OrderTop.toTop",
   "Eq.mpr",
   "GaloisInsertion.le_l_u",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "GaloisConnection.monotone_l",
   "OrderTop",
   "congrArg",
   "Top.mk",
   "id"],
  "name": "GaloisInsertion.liftOrderTop.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : Preorder Î±]\n  [inst_2 : OrderTop Î±] (gi : GaloisInsertion l u) (a : Î²), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.brecOn",
   "List.below",
   "List.Perm.refl",
   "List.perm_middle.match_1",
   "List.Perm.swap",
   "List.Perm.cons",
   "instHAppend",
   "PProd",
   "PProd.fst",
   "List.Perm",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "List.Perm.trans",
   "List.nil"],
  "name": "List.perm_middle",
  "constType":
  "âˆ€ {Î± : Type uu} {a : Î±} {lâ‚ lâ‚‚ : List Î±}, lâ‚ ++ a :: lâ‚‚ ~ a :: (lâ‚ ++ lâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["PLift.up", "PLift.down", "rfl", "Eq"],
  "name": "PLift.down_up",
  "constType": "âˆ€ {Î± : Sort u} (a : Î±), { down := a }.down = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.Chain.rec",
   "List.cons",
   "List",
   "List.Chain.nil",
   "List.nil",
   "List.Chain",
   "List.Chain.cons"],
  "name": "List.Chain.casesOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : Î±) â†’ (a_1 : List Î±) â†’ List.Chain R a a_1 â†’ Prop} {a : Î±}\n  {a_1 : List Î±} (t : List.Chain R a a_1),\n  (âˆ€ {a : Î±}, motive a [] (_ : List.Chain R a [])) â†’\n    (âˆ€ {a b : Î±} {l : List Î±} (a_2 : R a b) (a_3 : List.Chain R b l), motive a (b :: l) (_ : List.Chain R a (b :: l))) â†’\n      motive a a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_le.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ Prop) (x : â„•), (Unit â†’ motive Nat.zero) â†’ (âˆ€ (n : â„•), motive (Nat.succ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "Std.Logic._auxLemma.13",
   "of_eq_true",
   "Std.Logic._auxLemma.7",
   "congr",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun"],
  "name": "and_congr_left_iff",
  "constType": "âˆ€ {a c b : Prop}, (a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "Inf.inf",
   "disjoint_iff",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "BoundedOrder.toOrderTop",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "codisjoint_iff",
   "Codisjoint",
   "Lattice.toInf",
   "OrderTop.toTop",
   "SemilatticeSup.toSup",
   "OrderBot.toBot",
   "Sup.sup",
   "IsCompl.mk",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "IsCompl.of_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, x âŠ“ y = âŠ¥ â†’ x âŠ” y = âŠ¤ â†’ IsCompl x y",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Or",
   "List.insert",
   "Or.inr",
   "Iff.rfl",
   "List.instMembershipList",
   "List.mem_cons",
   "Eq.refl",
   "dite",
   "Eq",
   "List.mem_insert_iff.match_1",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "List.insert_of_not_mem",
   "DecidableEq",
   "propext",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Not",
   "List.insert_of_mem",
   "id"],
  "name": "List.mem_insert_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a b : Î±} {l : List Î±}, a âˆˆ List.insert b l â†” a = b âˆ¨ a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "Inter.inter",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "Preorder.toLE",
   "inf_top_eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.instBooleanAlgebraSet",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instInterSet"],
  "name": "Set.inter_univ",
  "constType": "âˆ€ {Î± : Type u} (a : Set Î±), a âˆ© Set.univ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "Eq.ndrec",
   "Topology.IsUpperSet.noConfusionType",
   "TopologicalSpace",
   "Topology.upperSet",
   "Topology.IsUpperSet.casesOn",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.noConfusion",
  "constType":
  "{Î± : Type u_4} â†’\n  {t : TopologicalSpace Î±} â†’\n    {inst : Preorder Î±} â†’\n      {P : Sort u} â†’ {v1 v2 : Topology.IsUpperSet Î±} â†’ v1 = v2 â†’ Topology.IsUpperSet.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Nat.decLt",
   "Eq.refl",
   "Classical.em",
   "eq_true_of_decide",
   "instLTNat",
   "True",
   "Eq",
   "ite",
   "Eq.mpr",
   "List.rec",
   "eq_false'",
   "instDecidableNot",
   "Bool.true",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "if_neg",
   "id",
   "Ne",
   "List.cons",
   "Or",
   "False",
   "Lean.Data.AC.insert",
   "Or.casesOn",
   "instDecidableFalse",
   "if_pos",
   "of_eq_true",
   "List",
   "LT.lt",
   "Not",
   "Bool",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.insert_nonEmpty",
  "constType": "âˆ€ {x : â„•} {xs : List â„•}, Lean.Data.AC.insert x xs â‰  []",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Iff.intro",
   "Exists",
   "Set.mem_iInter.match_1",
   "Iff",
   "setOf",
   "Eq.rec",
   "Set",
   "Set.iInter",
   "Exists.intro",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_iInter",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {x : Î±} {s : Î¹ â†’ Set Î±}, x âˆˆ â‹‚ i, s i â†” âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {l : List Î±}, (a âˆˆ b :: l) = (a = b âˆ¨ a âˆˆ l)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sSup",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteLattice Î±] (s : Set Î±), âˆ€ a âˆˆ s, a â‰¤ sSup s",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} â†’ [self : CommSemiring R] â†’ Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "Prod.instLEProd",
   "OrderBot.bot_le",
   "Prod",
   "Prod.boundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_9",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (a : Î± Ã— Î²), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma", "Eq.ndrec", "Eq.rec", "Eq.refl", "PSigma.mk", "rfl", "Eq"],
  "name": "PSigma.eta",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {aâ‚ aâ‚‚ : Î±} {bâ‚ : Î² aâ‚} {bâ‚‚ : Î² aâ‚‚} (hâ‚ : aâ‚ = aâ‚‚),\n  hâ‚ â–¸ bâ‚ = bâ‚‚ â†’ { fst := aâ‚, snd := bâ‚ } = { fst := aâ‚‚, snd := bâ‚‚ }",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.mem_def",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.15",
  "constType": "âˆ€ {Î± : Type u_1} {a : Î±} {s : Finset Î±}, (a âˆˆ s) = (a âˆˆ s.val)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î³ : Type v} â†’ (Î± â†’ Î³ â†’ Prop) â†’ Membership Î± Î³",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "Membership.mem",
   "Filter.HasBasis",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter.exists_mem_subset_iff",
   "Filter",
   "Filter.HasBasis.mk",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.basis_sets",
  "constType":
  "âˆ€ {Î± : Type u_1} (l : Filter Î±), Filter.HasBasis l (fun s â†¦ s âˆˆ l) id",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Exists",
   "Iff.mp",
   "Finite",
   "Nat",
   "finite_iff_exists_equiv_fin",
   "Fin",
   "Nonempty"],
  "name": "Finite.exists_equiv_fin",
  "constType": "âˆ€ (Î± : Sort u_3) [h : Finite Î±], âˆƒ n, Nonempty (Î± â‰ƒ Fin n)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Topology.WithLowerSet",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Definition"},
 {"references":
  ["Set.fintypePure",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set",
   "Singleton.singleton",
   "Finite.of_fintype",
   "Set.Finite",
   "Set.toFinite"],
  "name": "Set.finite_singleton",
  "constType": "âˆ€ {Î± : Type u} (a : Î±), Set.Finite {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "Set.sUnion",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.nhds_generateFrom.match_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} (S : Set (Set Î±)) (motive : a âˆˆ â‹ƒâ‚€ S â†’ Prop) (ha : a âˆˆ â‹ƒâ‚€ S),\n  (âˆ€ (t : Set Î±) (htS : t âˆˆ S) (hat : a âˆˆ t), motive (_ : âˆƒ t âˆˆ S, a âˆˆ t)) â†’ motive ha",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.upperSet._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "IsGLB",
   "EmptyCollection.emptyCollection",
   "isGLB_empty_iff",
   "Top.top",
   "Set",
   "isTop_top",
   "OrderTop",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "IsTop",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "isGLB_empty",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : OrderTop Î±], IsGLB âˆ… âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["subset_trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "HasSubset.Subset.trans",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] [inst_1 : IsTrans Î± fun x x_1 â†¦ x âŠ† x_1] {a b c : Î±}, a âŠ† b â†’ b âŠ† c â†’ a âŠ† c",
  "constCategory": "Theorem"},
 {"references":
  ["Inducing.continuous",
   "Equiv",
   "Continuous",
   "TopologicalSpace",
   "Inducing",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.toHomeomorphOfInducing.proof_1",
  "constType":
  "âˆ€ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : X â‰ƒ Y),\n  Inducing â†‘f â†’ Continuous â†‘f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_ndunion",
   "Or",
   "Iff",
   "DecidableEq",
   "Union.union",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Finset.instUnionFinset"],
  "name": "Finset.mem_union",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {s t : Finset Î±} {a : Î±}, a âˆˆ s âˆª t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["List.attach.proof_1",
   "Membership.mem",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Eq.refl",
   "List.attach",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (l : List Î±), List.attach l = List.pmap Subtype.mk l (_ : âˆ€ x âˆˆ l, x âˆˆ l)",
  "constCategory": "Theorem"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Topology.Bases._auxLemma.1",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ§ b) âˆ§ c) = (a âˆ§ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instLTOrderDual",
   "Preorder.toLT",
   "LE.le.trans",
   "le_refl",
   "OrderDual",
   "Preorder",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "OrderDual.instPreorder",
  "constType": "(Î± : Type u_3) â†’ [inst : Preorder Î±] â†’ Preorder Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SeqRight", "Unit"],
  "name": "SeqRight.seqRight",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : SeqRight f] â†’ {Î± Î² : Type u} â†’ f Î± â†’ (Unit â†’ f Î²) â†’ f Î²",
  "constCategory": "Definition"},
 {"references": ["Bot", "GeneralizedBooleanAlgebra"],
  "name": "GeneralizedBooleanAlgebra.toBot",
  "constType": "{Î± : Type u} â†’ [self : GeneralizedBooleanAlgebra Î±] â†’ Bot Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“Ë¢Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLower.WithLowerHomeomorph.proof_1",
   "Equiv.toHomeomorphOfInducing",
   "Topology.IsLower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Homeomorph",
   "Topology.WithLower.ofLower",
   "TopologicalSpace",
   "Preorder"],
  "name": "Topology.IsLower.WithLowerHomeomorph",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : Preorder Î±] â†’ [inst_1 : TopologicalSpace Î±] â†’ [inst_2 : Topology.IsLower Î±] â†’ Topology.WithLower Î± â‰ƒâ‚œ Î±",
  "constCategory": "Definition"},
 {"references": ["PLift"],
  "name": "PLift.up",
  "constType": "{Î± : Sort u} â†’ Î± â†’ PLift Î±",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termð“[<]_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind", "Nat", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.node",
  "constType": "Lean.SyntaxNodeKind â†’ â„• â†’ Lean.ParserDescr â†’ Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_7"],
  "name": "Topology.IsOpen_of._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.mem_def",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.22",
  "constType": "âˆ€ {Î± : Type u_1} {a : Î±} {s : Finset Î±}, (a âˆˆ s) = (a âˆˆ s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["List.below",
   "List.brecOn",
   "List.Sublist",
   "Eq.refl",
   "Nat.succ.inj",
   "instLTNat",
   "rfl",
   "Iff.mpr",
   "Eq",
   "PProd",
   "Eq.mpr",
   "instLENat",
   "List.Sublist.eq_of_length.match_2",
   "Nat.lt_succ_self",
   "List.rec",
   "Eq.rec",
   "PUnit",
   "List.nil",
   "List.Sublist.eq_of_length.match_1",
   "Nat",
   "Eq.symm",
   "id",
   "List.Sublist.length_le",
   "List.cons",
   "False",
   "Nat.not_lt",
   "List.length",
   "LE.le",
   "PProd.fst",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "Not"],
  "name": "List.Sublist.eq_of_length",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.length lâ‚ = List.length lâ‚‚ â†’ lâ‚ = lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Sub Î±",
  "constCategory": "Other"},
 {"references": [],
  "name": "String.Pos",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Sup"],
  "name": "Sup.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Sup Î±",
  "constCategory": "Other"},
 {"references":
  ["le_bot_iff",
   "Bot.bot",
   "Iff",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "disjoint_iff_inf_le",
   "Inf.inf",
   "OrderBot.toBot",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "Iff.trans",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "disjoint_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a b : Î±}, Disjoint a b â†” a âŠ“ b = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.toFun", "Equiv.invFun", "Function.RightInverse"],
  "name": "Equiv.right_inv",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (self : Î± â‰ƒ Î²), Function.RightInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.instIsReflSetSubsetInstHasSubsetSet",
   "Set",
   "Mathlib.Topology.Inseparable._auxLemma.9",
   "HasSubset.Subset",
   "Mathlib.Topology.Inseparable._auxLemma.19",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
   "Iff",
   "of_eq_true",
   "Specializes",
   "Mathlib.Topology.Inseparable._auxLemma.18",
   "Mathlib.Topology.Inseparable._auxLemma.20",
   "congr",
   "TopologicalSpace",
   "Singleton.singleton",
   "Inseparable",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "inseparable_iff_closure_eq",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y â†” closure {x} = closure {y}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "False.elim",
   "EmptyCollection.emptyCollection",
   "Set",
   "iff_true_intro",
   "Set.instEmptyCollectionSet",
   "True",
   "Set.instMembershipSet"],
  "name": "Set.ball_empty_iff",
  "constType": "âˆ€ {Î± : Type u} {p : Î± â†’ Prop}, (âˆ€ x âˆˆ âˆ…, p x) â†” True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Specializes",
   "nhds",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "Inseparable",
   "le_antisymm_iff"],
  "name": "inseparable_iff_specializes_and",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y â†” x â¤³ y âˆ§ y â¤³ x",
  "constCategory": "Theorem"},
 {"references": ["And", "eq_false", "False", "And.left", "Eq"],
  "name": "false_and",
  "constType": "âˆ€ (p : Prop), (False âˆ§ p) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "Filter",
   "And.intro",
   "And.casesOn",
   "instMembershipSetFilter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.join.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {x y : Set Î±} (f : Filter Î±) (motive : f âˆˆ {t | x âˆˆ t} âˆ© {t | y âˆˆ t} â†’ Prop)\n  (x_1 : f âˆˆ {t | x âˆˆ t} âˆ© {t | y âˆˆ t}),\n  (âˆ€ (hâ‚ : f âˆˆ {t | x âˆˆ t}) (hâ‚‚ : f âˆˆ {t | y âˆˆ t}), motive (_ : f âˆˆ {t | x âˆˆ t} âˆ§ f âˆˆ {t | y âˆˆ t})) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat", "instHAdd", "HAdd.hAdd", "Nat", "Nat.succ", "rfl", "Eq"],
  "name": "Nat.add_succ",
  "constType": "âˆ€ (n m : â„•), n + Nat.succ m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["Array",
   "Array.foldlM",
   "OfNat.ofNat",
   "Id",
   "Id.run",
   "instOfNatNat",
   "Nat",
   "Array.size",
   "optParam",
   "Id.instMonadId"],
  "name": "Array.foldl",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î² â†’ Î± â†’ Î²) â†’ Î² â†’ (as : Array Î±) â†’ optParam â„• 0 â†’ optParam â„• (Array.size as) â†’ Î²",
  "constCategory": "Definition"},
 {"references": ["SupSet", "sSupHom", "Set", "SupSet.sSup", "Set.image", "Eq"],
  "name": "sSupHom.mk",
  "constType":
  "{Î± : Type u_8} â†’\n  {Î² : Type u_9} â†’\n    [inst : SupSet Î±] â†’\n      [inst_1 : SupSet Î²] â†’ (toFun : Î± â†’ Î²) â†’ (âˆ€ (s : Set Î±), toFun (sSup s) = sSup (toFun '' s)) â†’ sSupHom Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Iff",
   "Iff.rfl",
   "Filter.map",
   "Set",
   "Filter",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_map'",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Filter Î±} {m : Î± â†’ Î²} {t : Set Î²}, t âˆˆ Filter.map m f â†” {x | m x âˆˆ t} âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Mathlib.Order.Filter.Basic._auxLemma.13",
   "funext",
   "setOf",
   "of_eq_true",
   "Mathlib.Order.Filter.Basic._auxLemma.12",
   "Set",
   "Filter",
   "congrArg",
   "Set.univ",
   "Eq.trans",
   "True",
   "congrFun",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.join.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (f : Filter (Filter Î±)), Set.univ âˆˆ {x | {x_1 | x âˆˆ x_1} âˆˆ f}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.Continuous_of._closed_8",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.Continuous_of._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadWithReader"],
  "name": "MonadWithReader.withReader",
  "constType":
  "{Ï : outParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadWithReader Ï m] â†’ {Î± : Type u} â†’ (Ï â†’ Ï) â†’ m Î± â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Macro.State",
   "List",
   "String",
   "Prod",
   "Lean.Name",
   "Lean.MacroScope"],
  "name": "Lean.Macro.State.mk",
  "constType": "Lean.MacroScope â†’ List (Lean.Name Ã— String) â†’ Lean.Macro.State",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "List.cons",
   "List.insert",
   "List.instMembershipList",
   "True",
   "Eq",
   "ite",
   "if_pos",
   "DecidableEq",
   "of_eq_true",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Decidable",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.insert_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}, a âˆˆ l â†’ List.insert a l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.attach.proof_1",
   "Multiset",
   "Multiset.pmap",
   "Subtype.mk",
   "Multiset.instMembershipMultiset",
   "Subtype"],
  "name": "Multiset.attach",
  "constType": "{Î± : Type u_1} â†’ (s : Multiset Î±) â†’ Multiset { x // x âˆˆ s }",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.toLowerSetOrderIso._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "List.count_eq_length",
   "List.length_replicate",
   "List.replicate",
   "List.eq_of_mem_replicate",
   "instBEq",
   "List.length",
   "Nat",
   "Eq.symm",
   "List.count",
   "Eq.trans",
   "Iff.mpr",
   "Eq"],
  "name": "List.count_replicate_self",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (n : â„•), List.count a (List.replicate n a) = n",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "GetElem.getElem",
   "OfNat.ofNat",
   "Nat.decLt",
   "HAdd.hAdd",
   "dite",
   "Pure.pure",
   "instLTNat",
   "Monad.toBind",
   "Array",
   "PProd",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Bind.bind",
   "Nat.succ",
   "Applicative.toPure",
   "Array.foldlM.loop.proof_1",
   "Nat.below",
   "Nat.brecOn",
   "Monad.toApplicative",
   "instAddNat",
   "Array.foldlM.loop.match_1",
   "instHAdd",
   "Unit",
   "Array.size",
   "LE.le",
   "PProd.fst",
   "Nat.rec",
   "LT.lt",
   "Not",
   "instGetElemArrayNatLtInstLTNatSize"],
  "name": "Array.foldlM.loop",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {m : Type v â†’ Type w} â†’\n      [inst : Monad m] â†’ (Î² â†’ Î± â†’ m Î²) â†’ (as : Array Î±) â†’ (stop : â„•) â†’ stop â‰¤ Array.size as â†’ â„• â†’ â„• â†’ Î² â†’ m Î²",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "Filter.HasBasis.mem_iff'",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {t : Set Î±},\n  Filter.HasBasis l p s â†’ (t âˆˆ l â†” âˆƒ i, p i âˆ§ s i âŠ† t)",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKinds", "Lean.TSyntaxArray", "Lean.Syntax"],
  "name": "Lean.TSyntaxArray.raw",
  "constType":
  "{ks : Lean.SyntaxNodeKinds} â†’ Lean.TSyntaxArray ks â†’ Array Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "instHAppend",
   "List.instAppendList",
   "List.instMembershipList",
   "HAppend.hAppend",
   "propext",
   "List",
   "List.pairwise_append",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.4",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {lâ‚ lâ‚‚ : List Î±},\n  List.Pairwise R (lâ‚ ++ lâ‚‚) = (List.Pairwise R lâ‚ âˆ§ List.Pairwise R lâ‚‚ âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b)",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "IsClosed.preimage",
   "closure_mono",
   "subset_closure",
   "Eq",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "isClosed_closure",
   "Eq.ndrec",
   "Continuous",
   "TopologicalSpace",
   "IsClosed.closure_eq",
   "Set.preimage_mono",
   "Eq.symm",
   "id"],
  "name": "Continuous.closure_preimage_subset",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ âˆ€ (t : Set Î²), closure (f â»Â¹' t) âŠ† f â»Â¹' closure t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Set.Elem",
   "propext",
   "Set.toFinset",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.mem_toFinset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.23",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Set Î±} [inst : Fintype â†‘s] {a : Î±}, (a âˆˆ Set.toFinset s) = (a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_3",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "OrderDual"],
  "name": "OrderDual.toDual",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "TopologicalSpace.GenerateOpen.univ",
   "TopologicalSpace.GenerateOpen.inter",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.GenerateOpen.sUnion",
   "TopologicalSpace.GenerateOpen"],
  "name": "TopologicalSpace.generateFrom",
  "constType": "{Î± : Type u} â†’ Set (Set Î±) â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Â«termI^_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Top", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toTop",
  "constType": "{Î± : Type u} â†’ [self : BooleanAlgebra Î±] â†’ Top Î±",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "LE.le.trans",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "implies_congr",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "Eq",
   "GaloisConnection.l_le",
   "PartialOrder",
   "Inf.mk",
   "Eq.mpr",
   "GaloisInsertion.le_l_u",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "GaloisConnection.monotone_l",
   "le_inf",
   "PartialOrder.le_antisymm",
   "congrArg",
   "SemilatticeInf",
   "id"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeInf Î±]\n  (gi : GaloisInsertion l u) (a b c : Î²), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Theorem"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Order.Directed._auxLemma.2",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ§ b) âˆ§ c) = (a âˆ§ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î² â†’ Î±) â†’ Pow Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelMonoid.add_right_cancel",
  "constType":
  "âˆ€ {M : Type u} [self : AddCancelMonoid M] (a b c : M), a + b = c + b â†’ a = c",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "Eq.symm",
   "Eq.subset",
   "Set.Subset.antisymm",
   "Set.Subset.antisymm_iff.match_1",
   "Eq"],
  "name": "Set.Subset.antisymm_iff",
  "constType": "âˆ€ {Î± : Type u} {a b : Set Î±}, a = b â†” a âŠ† b âˆ§ b âŠ† a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] (a b : Î±), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Finite", "Nat", "Fin"],
  "name": "Finite.intro",
  "constType": "âˆ€ {Î± : Sort u_1} {n : â„•}, Î± â‰ƒ Fin n â†’ Finite Î±",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Function.Surjective",
   "Equiv.instEquivLikeEquiv",
   "EquivLike.surjective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.surjective",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} (e : Î± â‰ƒ Î²), Function.Surjective â†‘e",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instBooleanAlgebraSet",
   "Union.union",
   "compl_inf",
   "Set",
   "HasCompl.compl",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "Set.instUnionSet",
   "Set.instInterSet",
   "Eq"],
  "name": "Set.compl_inter",
  "constType": "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆ© t)á¶œ = sá¶œ âˆª tá¶œ",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "âˆ€ {a b : Prop}, a = b â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references": ["SizeOf", "sizeOfWFRel", "WellFoundedRelation"],
  "name": "instWellFoundedRelation",
  "constType": "{Î± : Sort u_1} â†’ [inst : SizeOf Î±] â†’ WellFoundedRelation Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.termÏ€_._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "semiOutParam"],
  "name": "MonadReaderOf.read",
  "constType":
  "{Ï : semiOutParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadReaderOf Ï m] â†’ m Ï",
  "constCategory": "Definition"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{Î± : Sort u} â†’ (c : Prop) â†’ [h : Decidable c] â†’ (c â†’ Î±) â†’ (Â¬c â†’ Î±) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "And.right",
   "upperBounds",
   "Set",
   "lowerBounds",
   "And.intro",
   "IsLeast",
   "Preorder",
   "And.left",
   "Set.instMembershipSet"],
  "name": "IsLeast.isGLB",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsLeast s a â†’ IsGLB s a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "CompleteLattice.toBoundedOrder",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "bot_unique",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.rec",
   "Set.empty_subset",
   "OrderBot.toBot",
   "Filter.instPartialOrderFilter",
   "Filter.mem_bot",
   "Filter",
   "Eq.symm",
   "BoundedOrder.toOrderBot",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.empty_mem_iff_bot",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±}, âˆ… âˆˆ f â†” f = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.fintypeEmpty",
   "Set.Elem",
   "Set",
   "Set.instEmptyCollectionSet",
   "Finite.of_fintype",
   "Set.Finite",
   "Set.toFinite"],
  "name": "Set.finite_empty",
  "constType": "âˆ€ {Î± : Type u}, Set.Finite âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset",
   "Finset",
   "Multiset.nodup_singleton",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Finset.mk",
   "Singleton",
   "Singleton.mk"],
  "name": "Finset.instSingletonFinset",
  "constType": "{Î± : Type u_1} â†’ Singleton Î± (Finset Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "OfNat.ofNat",
   "List.instMembershipList",
   "List.exists_mem_of_length_pos.match_1",
   "List",
   "LT.lt",
   "List.Mem.head",
   "instOfNatNat",
   "Exists.intro",
   "List.length",
   "Nat",
   "instLTNat"],
  "name": "List.exists_mem_of_length_pos",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, 0 < List.length l â†’ âˆƒ a, a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.Â«termð“[â‰ ]_Â»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Membership.mem",
   "OfNat.ofNat",
   "List.cons",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "Pure.pure",
   "LE.le",
   "ClusterPt",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "Set.instSingletonSet",
   "List.TFAE.out",
   "Filter.instPureFilter",
   "Iff",
   "Specializes",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "instOfNatNat",
   "Singleton.singleton",
   "Filter",
   "List.nil",
   "IsClosed",
   "List.get?",
   "Nat",
   "IsOpen",
   "specializes_TFAE",
   "Option"],
  "name": "specializes_iff_closure_subset",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x â¤³ y â†” closure {y} âŠ† closure {x}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_1"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "compl_le_compl",
   "compl_compl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Eq.mp",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "congrArg",
   "HeytingAlgebra.toHasCompl"],
  "name": "compl_le_of_compl_le",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : BooleanAlgebra Î±], yá¶œ â‰¤ x â†’ xá¶œ â‰¤ y",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo", "Lean.Syntax", "Option"],
  "name": "Lean.Syntax.getHeadInfo?",
  "constType": "Lean.Syntax â†’ Option Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "Filter.comap",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Set.Subset.rfl",
   "instMembershipSetFilter"],
  "name": "Filter.preimage_mem_comap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {g : Filter Î²} {m : Î± â†’ Î²} {t : Set Î²}, t âˆˆ g â†’ m â»Â¹' t âˆˆ Filter.comap m g",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ GeneralizedHeytingAlgebra (Î± i)] (a b : (i : Î¹) â†’ Î± i), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ Ord Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MonadRef",
  "constType": "(Type â†’ Type) â†’ Type 1",
  "constCategory": "Other"},
 {"references":
  ["GaloisConnection",
   "Filter.map_le_iff_le_comap",
   "PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter"],
  "name": "Filter.gc_map_comap",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (m : Î± â†’ Î²), GaloisConnection (Filter.map m) (Filter.comap m)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.erase.match_1",
   "List.nil",
   "Bool",
   "List.isEmpty.match_1"],
  "name": "List.filter",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Bool) â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set",
   "Sup.sup",
   "isLUB_singleton",
   "Singleton.singleton",
   "Insert.insert",
   "IsLUB.insert",
   "IsLUB",
   "SemilatticeSup.toPartialOrder",
   "Set.instInsertSet"],
  "name": "isLUB_pair",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeSup Î³] {a b : Î³}, IsLUB {a, b} (a âŠ” b)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Iff",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Equiv.refl",
   "lcProof",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "RelIso.mk",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.toUpperSetOrderIso._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â‰ƒo Topology.WithUpperSet Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Alternative",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HImp",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references": ["And", "propext", "and_true_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.4",
  "constType": "âˆ€ (p : Prop), (p âˆ§ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "of_decide_eq_true.match_1",
  "constType":
  "âˆ€ {p : Prop} (motive : Decidable p â†’ Prop) (inst : Decidable p),\n  (âˆ€ (hâ‚ : p), motive (isTrue hâ‚)) â†’ (âˆ€ (hâ‚ : Â¬p), motive (isFalse hâ‚)) â†’ motive inst",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ GeneralizedHeytingAlgebra (Î± i)] (a b : (i : Î¹) â†’ Î± i), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {Î³ : Sort u_3} â†’\n      (Î± â†’ Î² â†’ Sort u) â†’\n        (Î² â†’ Î³ â†’ Sort v) â†’ outParam (Î± â†’ Î³ â†’ Sort w) â†’ Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references": ["Max.mk", "LE", "Max", "LE.le", "ite", "DecidableRel"],
  "name": "maxOfLe",
  "constType":
  "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ [inst : DecidableRel LE.le] â†’ Max Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Lattice._auxLemma.27",
   "Set",
   "Mathlib.Data.Set.Lattice._auxLemma.2",
   "Set.univ",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set.sUnion",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.sUnion_eq_univ_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, â‹ƒâ‚€ c = Set.univ â†” âˆ€ (a : Î±), âˆƒ b âˆˆ c, a âˆˆ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termð“._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "âˆ€ {Î± : Sort u_1} (a : Î±), a = a",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "exists_congr",
   "And.left",
   "Filter.HasBasis.mem_iff",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "mem_nhds_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {a : Î±} {s : Set Î±}, s âˆˆ nhds a â†” âˆƒ t, t âŠ† s âˆ§ IsOpen t âˆ§ a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {x y : Î±}, x = y â†’ y â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "List.Pairwise.nil",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Data.List.Range._hyg.49",
   "instIsTransLtToLT",
   "optParam",
   "autoParam",
   "List.pairwise_lt_range'.match_1",
   "instLTNat",
   "List.Pairwise",
   "List.chain_iff_pairwise",
   "Nat.add",
   "Iff.mp",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "List.chain_lt_range'",
   "List.Chain",
   "Nat.strictOrderedSemiring"],
  "name": "List.pairwise_lt_range'",
  "constType":
  "âˆ€ (s n : â„•) (step : optParam â„• 1),\n  autoParam (0 < step) _autoâœ â†’ List.Pairwise (fun x x_1 â†¦ x < x_1) (List.range' s n step)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.inter_subset_right",
   "True",
   "Eq",
   "Set.instInterSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.27",
  "constType": "âˆ€ {Î± : Type u} (s t : Set Î±), (s âˆ© t âŠ† t) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "LE.le.trans",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf_le_of_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {a : Î±} (i : Î¹), f i â‰¤ a â†’ iInf f â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Function.LeftInverse",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Eq.rec",
   "Set",
   "HasSubset.Subset",
   "Set.image",
   "Eq.symm",
   "Set.image_subset_preimage_of_inverse.match_1",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image_subset_preimage_of_inverse",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {g : Î² â†’ Î±}, Function.LeftInverse g f â†’ âˆ€ (s : Set Î±), f '' s âŠ† g â»Â¹' s",
  "constCategory": "Theorem"},
 {"references": ["BEq.beq", "BEq", "Bool.true", "LawfulBEq", "Bool", "Eq"],
  "name": "LawfulBEq.eq_of_beq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BEq Î±] [self : LawfulBEq Î±] {a b : Î±}, (a == b) = true â†’ a = b",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "HImp.himp",
   "Eq.mpr",
   "Iff",
   "himp_bot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "Eq.symm",
   "BoundedOrder.toOrderBot",
   "id",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "HeytingAlgebra.toBot",
   "Disjoint",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "le_himp_iff",
   "propext",
   "disjoint_iff_inf_le",
   "HeytingAlgebra.toBoundedOrder",
   "OrderBot.toBot"],
  "name": "le_compl_iff_disjoint_right",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, a â‰¤ bá¶œ â†” Disjoint a b",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{Î± : Type u} â†’ [self : NonAssocSemiring Î±] â†’ NonUnitalNonAssocSemiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro",
   "Function.sometimes",
   "Classical.propDecidable",
   "dif_pos",
   "Not",
   "Classical.choice",
   "Nonempty",
   "Eq"],
  "name": "Function.sometimes_eq",
  "constType":
  "âˆ€ {p : Prop} {Î± : Sort u_1} [inst : Nonempty Î±] (f : p â†’ Î±) (a : p), Function.sometimes f = f a",
  "constCategory": "Theorem"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "Std.Logic._auxLemma.31",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆƒ x, p x) = âˆ€ (x : Î±), Â¬p x",
  "constCategory": "Theorem"},
 {"references": ["Bot", "Nonempty.intro", "Bot.bot", "Nonempty"],
  "name": "bot_nonempty.proof_1",
  "constType": "âˆ€ (Î± : Type u_1) [inst : Bot Î±], Nonempty Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "Set.finite_def.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Set Î±} (motive : Nonempty (Fintype â†‘s) â†’ Prop) (x : Nonempty (Fintype â†‘s)),\n  (âˆ€ (h : Fintype â†‘s), motive (_ : Nonempty (Fintype â†‘s))) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Not", "Filter", "Filter.Eventually"],
  "name": "Filter.Frequently",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Prop) â†’ Filter Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "funext",
   "Iff",
   "of_eq_true",
   "propext",
   "eq_comm",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.38",
   "congrFun",
   "Eq"],
  "name": "exists_eq_left'",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, a' = a âˆ§ p a) â†” p a'",
  "constCategory": "Theorem"},
 {"references":
  ["List.tfae_cons_cons",
   "And",
   "List.cons",
   "Iff",
   "propext",
   "List",
   "List.TFAE",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.2",
  "constType":
  "âˆ€ {a b : Prop} {l : List Prop}, List.TFAE (a :: b :: l) = ((a â†” b) âˆ§ List.TFAE (b :: l))",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.Injective",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Function.LeftInverse.injective"],
  "name": "EquivLike.toEmbeddingLike.proof_2",
  "constType":
  "âˆ€ {E : Sort u_3} {Î± : Sort u_1} {Î² : Sort u_2} [iE : EquivLike E Î± Î²] (e : E), Function.Injective (EquivLike.coe e)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Fin.val",
   "eq_of_heq",
   "LT.lt",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Fin.casesOn",
   "Eq"],
  "name": "Fin.eq_of_val_eq.match_1",
  "constType":
  "âˆ€ {n : â„•} (motive : (x x_1 : Fin n) â†’ â†‘x = â†‘x_1 â†’ Prop) (x x_1 : Fin n) (x_2 : â†‘x = â†‘x_1),\n  (âˆ€ (val : â„•) (isLt isLt_1 : val < n),\n      motive { val := val, isLt := isLt } { val := val, isLt := isLt_1 }\n        (_ : â†‘{ val := val, isLt := (_ : val < n) } = â†‘{ val := val, isLt := (_ : val < n) })) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE"],
  "name": "le_not_le_of_lt",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a < b â†’ a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image2",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_3} â†’ {Î³ : Type u_5} â†’ (Î± â†’ Î² â†’ Î³) â†’ Set Î± â†’ Set Î² â†’ Set Î³",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{Î± : Type u} â†’ [self : One Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "List.instMembershipList",
   "propext",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.length",
   "Nat",
   "List.length_pos_iff_exists_mem",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±}, (0 < List.length l) = âˆƒ a, a âˆˆ l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.mem_iInter",
   "propext",
   "Set",
   "Set.iInter",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.4",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "induced_id",
   "Topology.WithUpperSet.ofUpperSet",
   "Inducing.mk",
   "Topology.WithUpperSet",
   "Eq.refl",
   "Inducing",
   "Topology.upperSet",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Eq.ndrec",
   "TopologicalSpace",
   "Topology.IsUpperSet.topology_eq",
   "TopologicalSpace.induced",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "id"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±],\n  Inducing â†‘Topology.WithUpperSet.ofUpperSet",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result.ok", "EStateM", "PUnit.unit", "PUnit"],
  "name": "EStateM.set",
  "constType": "{Îµ Ïƒ : Type u} â†’ Ïƒ â†’ EStateM Îµ Ïƒ PUnit.{u + 1}",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le", "And", "Iff", "Iff.rfl", "LT.lt", "Multiset", "Not", "LT.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_3",
  "constType": "âˆ€ {Î± : Type u_1} (a b : Multiset Î±), a < b â†” a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "List.get?_mem",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.492",
   "List",
   "Option.some",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.531",
   "List.get?",
   "Nat",
   "autoParam",
   "List.TFAE",
   "Option",
   "Eq"],
  "name": "List.TFAE.out",
  "constType":
  "âˆ€ {l : List Prop},\n  List.TFAE l â†’\n    âˆ€ (nâ‚ nâ‚‚ : â„•) {a b : Prop},\n      autoParam (List.get? l nâ‚ = some a) _autoâœ â†’ autoParam (List.get? l nâ‚‚ = some b) _autoâœÂ¹ â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toSemiring : Semiring Î±] â†’\n    [toPartialOrder : PartialOrder Î±] â†’\n      (âˆ€ (a b : Î±), a â‰¤ b â†’ âˆ€ (c : Î±), c + a â‰¤ c + b) â†’\n        (âˆ€ (a b c : Î±), a + b â‰¤ a + c â†’ b â‰¤ c) â†’\n          [toNontrivial : Nontrivial Î±] â†’\n            0 â‰¤ 1 â†’\n              (âˆ€ (a b c : Î±), a < b â†’ 0 < c â†’ c * a < c * b) â†’\n                (âˆ€ (a b c : Î±), a < b â†’ 0 < c â†’ a * c < b * c) â†’ StrictOrderedSemiring Î±",
  "constCategory": "Other"},
 {"references": ["IsIdempotent", "Eq"],
  "name": "IsIdempotent.idempotent",
  "constType":
  "âˆ€ {Î± : Type u} {op : Î± â†’ Î± â†’ Î±} [self : IsIdempotent Î± op] (a : Î±), op a a = a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Array.mkArray4",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node4",
  "constType":
  "Lean.SourceInfo â†’ Lean.SyntaxNodeKind â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "compl_involutive",
   "HasCompl.compl",
   "Function.Involutive.injective",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra"],
  "name": "compl_injective",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BooleanAlgebra Î±], Function.Injective compl",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "PartialOrder.toPreorder",
   "Prod.snd",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Prod.fst",
   "Prod.instInfProd",
   "LE.le",
   "Preorder.toLE",
   "Inf.mk",
   "And",
   "Inf",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "SemilatticeInf"],
  "name": "Prod.semilatticeInf.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²] (x x_1 : Î± Ã— Î²),\n  (x âŠ“ x_1).1 â‰¤ x_1.1 âˆ§ (x âŠ“ x_1).2 â‰¤ x_1.2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "iSup_le.match_1",
   "CompleteLattice.toInfSet",
   "Eq.rec",
   "Set",
   "le_sInf",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "le_iInf",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {a : Î±}, (âˆ€ (i : Î¹), a â‰¤ f i) â†’ a â‰¤ iInf f",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.intro",
  "constType": "âˆ€ {Î± : Sort u}, (âˆ€ (a b : Î±), a = b) â†’ Subsingleton Î±",
  "constCategory": "Other"},
 {"references":
  ["List.instHasSubsetList",
   "List.pwFilter_sublist",
   "List.Sublist.subset",
   "List",
   "HasSubset.Subset",
   "List.pwFilter",
   "DecidableRel"],
  "name": "List.pwFilter_subset",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [inst : DecidableRel R] (l : List Î±), List.pwFilter R l âŠ† l",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{Î± : Type u} â†’ [self : PartialOrder Î±] â†’ Preorder Î±",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.semilatticeSup",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.lattice.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î±' : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Lattice (Î±' i)] (a b : (i : Î¹) â†’ Î±' i), a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.val", "Decidable", "instLEFin", "Nat", "LE.le", "Nat.decLe", "Fin"],
  "name": "Fin.decLe",
  "constType": "{n : â„•} â†’ (a b : Fin n) â†’ Decidable (a â‰¤ b)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_16._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["OrderHom", "Preorder"],
  "name": "OrderHom.toFun",
  "constType":
  "{Î± : Type u_6} â†’ {Î² : Type u_7} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Or.casesOn",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod_lt.match_1",
  "constType":
  "âˆ€ (x y : â„•) (motive : Â¬0 < y âˆ¨ Â¬y â‰¤ x â†’ Prop) (hâ‚ : Â¬0 < y âˆ¨ Â¬y â‰¤ x),\n  (âˆ€ (hâ‚ : Â¬0 < y), motive (_ : Â¬0 < y âˆ¨ Â¬y â‰¤ x)) â†’ (âˆ€ (hâ‚ : Â¬y â‰¤ x), motive (_ : Â¬0 < y âˆ¨ Â¬y â‰¤ x)) â†’ motive hâ‚",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List.rec",
   "List",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Lean.Data.AC.evalList.match_1",
   "absurd",
   "id",
   "Eq"],
  "name": "_private.Init.Data.AC.0.Lean.Data.AC.evalList.match_1.eq_3",
  "constType":
  "âˆ€ (motive : List â„• â†’ Sort u_1) (x : â„•) (xs : List â„•) (h_1 : Unit â†’ motive []) (h_2 : (x : â„•) â†’ motive [x])\n  (h_3 : (x : â„•) â†’ (xs : List â„•) â†’ motive (x :: xs)),\n  (xs = [] â†’ False) â†’\n    (match x :: xs with\n      | [] => h_1 ()\n      | [x] => h_2 x\n      | x :: xs => h_3 x xs) =\n      h_3 x xs",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_11",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.IsOpen_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Lean.Name", "Lean.MonadQuotation"],
  "name": "Lean.MonadQuotation.getMainModule",
  "constType":
  "{m : Type â†’ Type} â†’ [self : Lean.MonadQuotation m] â†’ m Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Continuous", "TopologicalSpace", "ContinuousMap", "ContinuousMap.toFun"],
  "name": "ContinuousMap.continuous_toFun",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] (self : C(Î±, Î²)),\n  Continuous self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpperSet.monotone_to_upperTopology_continuous",
   "Topology.IsLower",
   "Continuous",
   "OrderDual.instIsUpper",
   "OrderDual",
   "Monotone",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Monotone.dual",
   "OrderDual.instIsUpperSet",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.IsLowerSet.monotone_to_lowerTopology_continuous",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Topology.IsLowerSet Î±] [inst_5 : Topology.IsLower Î²] {f : Î± â†’ Î²},\n  Monotone f â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "Option.noConfusion",
   "Std.Logic._auxLemma.45",
   "List.find?_cons.match_1",
   "implies_congr",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "eq_false'",
   "Option.none",
   "forall_congr",
   "Bool.true",
   "Option.some",
   "List.nil",
   "_private.Std.Data.List.Lemmas.0.List.find?_cons.match_1.splitter",
   "Eq.symm",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "Option",
   "Membership.mem",
   "eq_self",
   "Bool.not_eq_true",
   "Or",
   "List.cons",
   "False",
   "Unit",
   "implies_true",
   "eq_false_of_decide",
   "And",
   "List.find?",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.find?_eq_none",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {l : List Î±}, List.find? p l = none â†” âˆ€ x âˆˆ l, Â¬p x = true",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.modCore",
   "Nat.mod.match_1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.mod",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«termð“[â‰¥]_Â»._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[â‰¥]_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«termð“[â‰ ]_Â»._closed_5",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“[â‰ ]_Â»._closed_2"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "And.imp_right",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "and_or_left.match_1",
   "And.intro",
   "Or.imp",
   "Or.rec"],
  "name": "and_or_left",
  "constType": "âˆ€ {a b c : Prop}, a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Multiset.instPartialOrderMultiset.proof_2",
   "Multiset.instPartialOrderMultiset.proof_4",
   "Multiset",
   "Multiset.instPartialOrderMultiset.proof_3",
   "Not",
   "Multiset.instPartialOrderMultiset.proof_1",
   "LT.mk",
   "PartialOrder",
   "Preorder.mk"],
  "name": "Multiset.instPartialOrderMultiset",
  "constType": "{Î± : Type u_1} â†’ PartialOrder (Multiset Î±)",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.70",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b âˆ§ c) = (b âˆ§ a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "continuous_coinduced_rng",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.coinduced",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Topology.WithLowerSet",
   "Equiv.invFun",
   "Continuous",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithUpperSet.toDualHomeomorph.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±],\n  Continuous\n    { toFun := â†‘OrderDual.toDual, invFun := â†‘OrderDual.ofDual,\n        left_inv := (_ : âˆ€ (a : Î±áµ’áµˆ), â†‘OrderDual.toDual (â†‘OrderDual.ofDual a) = a),\n        right_inv := (_ : âˆ€ (a : Topology.WithLowerSet Î±áµ’áµˆ), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a) }.invFun",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Multiset",
   "Finset.mk",
   "Multiset.toFinset.proof_1",
   "Multiset.dedup"],
  "name": "Multiset.toFinset",
  "constType":
  "{Î± : Type u_1} â†’ [inst : DecidableEq Î±] â†’ Multiset Î± â†’ Finset Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_inter_iff",
   "Membership.mem",
   "And",
   "propext",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.36",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), (x âˆˆ a âˆ© b) = (x âˆˆ a âˆ§ x âˆˆ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Monad",
   "Set",
   "Function.comp",
   "Unit",
   "Function.const",
   "Functor.mk",
   "Monad.mk",
   "Applicative.mk",
   "Set.seq",
   "Set.instMembershipSet",
   "Set.instSingletonSet",
   "Set.iUnion",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "Singleton.singleton",
   "Set.image",
   "SeqRight.mk",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "Set.monad",
  "constType": "Monad Set",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableAnd.match_1",
  "constType":
  "{q : Prop} â†’\n  (motive : Decidable q â†’ Sort u_1) â†’\n    (dq : Decidable q) â†’ ((hq : q) â†’ motive (isTrue hq)) â†’ ((hq : Â¬q) â†’ motive (isFalse hq)) â†’ motive dq",
  "constCategory": "Definition"},
 {"references": ["And", "Function.Surjective", "Function.Injective"],
  "name": "Function.Bijective",
  "constType": "{Î± : Sort uâ‚} â†’ {Î² : Sort uâ‚‚} â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set.ext",
   "Fintype",
   "Set.Elem",
   "Set.toFinset",
   "Finset.toSet",
   "Set",
   "Set.mem_toFinset",
   "Eq"],
  "name": "Set.coe_toFinset",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set Î±) [inst : Fintype â†‘s], â†‘(Set.toFinset s) = s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeInf.sInf_le",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteSemilatticeInf Î±] (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Not", "absurd"],
  "name": "instDecidableIff.proof_4",
  "constType": "âˆ€ {p q : Prop}, Â¬p â†’ Â¬q â†’ (p â†” q)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SeqLeft",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "Inf",
   "Inf.inf",
   "Continuous",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "ContinuousInf"],
  "name": "ContinuousInf.mk",
  "constType":
  "âˆ€ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Inf L], (Continuous fun p â†¦ p.1 âŠ“ p.2) â†’ ContinuousInf L",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "Nat.lt_of_lt_of_le",
   "Eq.refl",
   "instLTNat",
   "ite",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.decLe",
   "if_neg",
   "Nat.modCore_eq_mod.match_1",
   "id",
   "instHSub",
   "False",
   "Nat.modCore",
   "HSub.hSub",
   "instDecidableAnd",
   "LE.le",
   "And",
   "Nat.instModNat",
   "instHMod",
   "Eq.ndrec",
   "Nat.zero",
   "LT.lt",
   "HMod.hMod",
   "Nat.lt_irrefl",
   "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
   "Nat.casesOn"],
  "name": "Nat.modCore_eq_mod",
  "constType": "âˆ€ (x y : â„•), Nat.modCore x y = x % y",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "Filter.frequently_iff_forall_eventually_exists_and",
   "propext",
   "Filter",
   "Filter.Eventually",
   "Filter.Frequently",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.87",
  "constType":
  "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {f : Filter Î±},\n  (âˆƒá¶  (x : Î±) in f, p x) = âˆ€ {q : Î± â†’ Prop}, (âˆ€á¶  (x : Î±) in f, q x) â†’ âˆƒ x, p x âˆ§ q x",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "RelHomClass",
  "constType":
  "Type u_5 â†’\n  {Î± : outParam (Type u_6)} â†’\n    {Î² : outParam (Type u_7)} â†’ outParam (Î± â†’ Î± â†’ Prop) â†’ outParam (Î² â†’ Î² â†’ Prop) â†’ Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : Pow Î± Î²] â†’ HPow Î± Î² Î±",
  "constCategory": "Definition"},
 {"references":
  ["sup_inf_right",
   "Set.instBooleanAlgebraSet",
   "Union.union",
   "Set",
   "Inter.inter",
   "BooleanAlgebra.toDistribLattice",
   "Set.instUnionSet",
   "Set.instInterSet",
   "Eq"],
  "name": "Set.inter_union_distrib_right",
  "constType": "âˆ€ {Î± : Type u} {s t u : Set Î±}, s âˆ© t âˆª u = (s âˆª u) âˆ© (t âˆª u)",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "TopologicalSpace",
   "IsClosed",
   "Preorder",
   "LE.le",
   "ClosedIciTopology",
   "Preorder.toLE"],
  "name": "ClosedIciTopology.isClosed_ge'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : Preorder Î±] [self : ClosedIciTopology Î±] (a : Î±),\n  IsClosed {b | a â‰¤ b}",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.decidableBEx.match_5",
   "PProd.fst",
   "cond",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "Bool"],
  "name": "List.eraseP",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Bool) â†’ List Î± â†’ List Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "nhds",
   "propext",
   "Set",
   "Set.Nonempty",
   "clusterPt_principal_iff",
   "TopologicalSpace",
   "Inter.inter",
   "Filter",
   "ClusterPt",
   "Eq",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.41",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {x : Î±} {s : Set Î±},\n  ClusterPt x (Filter.principal s) = âˆ€ U âˆˆ nhds x, Set.Nonempty (U âˆ© s)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "lt_iff_le_not_le"],
  "name": "Preorder.lift.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î²] (f : Î± â†’ Î²) (x x_1 : Î±), f x < f x_1 â†” f x â‰¤ f x_1 âˆ§ Â¬f x_1 â‰¤ f x",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.toUpperSet._cstage1",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithUpperSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "GE.ge",
   "Eq.refl",
   "Preorder.toLE",
   "True",
   "Eq",
   "iff_self",
   "Iff.of_eq",
   "Set.ext",
   "Mathlib.Order.Filter.Basic._auxLemma.2",
   "Set.iUnion",
   "Iff",
   "Filter",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter",
   "Membership.mem",
   "Filter.sets",
   "funext",
   "DirectedOn",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "Order.Preimage",
   "And",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "propext",
   "Filter.instPartialOrderFilter",
   "congr",
   "Filter.mem_biInf_of_directed",
   "congrArg",
   "exists_prop_congr'"],
  "name": "Filter.biInf_sets_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î² â†’ Filter Î±} {s : Set Î²},\n  DirectedOn (f â»Â¹'o fun x x_1 â†¦ x â‰¥ x_1) s â†’ Set.Nonempty s â†’ (â¨… i âˆˆ s, f i).sets = â‹ƒ i âˆˆ s, (f i).sets",
  "constCategory": "Theorem"},
 {"references": ["CoheytingAlgebra", "Top"],
  "name": "CoheytingAlgebra.toTop",
  "constType": "{Î± : Type u_4} â†’ [self : CoheytingAlgebra Î±] â†’ Top Î±",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toBot",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "CompleteLattice.bot_le",
  "constType": "âˆ€ {Î± : Type u_9} [self : CompleteLattice Î±] (x : Î±), âŠ¥ â‰¤ x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[â‰¤]_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "IsClosed",
   "Set.sInter"],
  "name": "closure",
  "constType": "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "Set",
   "isBot_bot",
   "OrderBot.toBot",
   "OrderBot",
   "Set.Ici",
   "Preorder",
   "Set.univ",
   "Preorder.toLE",
   "Eq",
   "IsBot.Ici_eq"],
  "name": "Set.Ici_bot",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : OrderBot Î±], Set.Ici âŠ¥ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.eraseP",
   "List.cons",
   "cond",
   "of_eq_true",
   "List",
   "Bool.true",
   "Bool",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.eraseP_cons_of_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} (p : Î± â†’ Bool), p a = true â†’ List.eraseP p (a :: l) = l",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Context", "Nat"],
  "name": "Lean.Macro.Context.maxRecDepth",
  "constType": "Lean.Macro.Context â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["UInt32.val", "UInt32", "Fin.val", "Nat", "UInt32.size"],
  "name": "UInt32.toNat",
  "constType": "UInt32 â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.cons",
   "Lean.Data.AC.insert",
   "List.rec",
   "List",
   "Lean.Data.AC.sort.loop",
   "Lean.Data.AC.insert_nonEmpty",
   "List.nil",
   "Nat",
   "id"],
  "name": "Lean.Data.AC.Context.sort_loop_nonEmpty",
  "constType":
  "âˆ€ {ys : List â„•} (xs : List â„•), xs â‰  [] â†’ Lean.Data.AC.sort.loop xs ys â‰  []",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "propext",
   "SProd.sprod",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Prod",
   "Filter.instSProd",
   "Filter.mem_prod_iff",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.6",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set (Î± Ã— Î²)} {f : Filter Î±} {g : Filter Î²},\n  (s âˆˆ f Ã—Ë¢ g) = âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ Ã—Ë¢ tâ‚‚ âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "SupSet.sSup",
   "iSup",
   "Set.image_eq_range",
   "Eq",
   "Set.instMembershipSet",
   "SupSet",
   "Set.range",
   "Eq.mpr",
   "Eq.ndrec",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "Set.Elem",
   "Set.image",
   "id"],
  "name": "sSup_image'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : SupSet Î±] {s : Set Î²} {f : Î² â†’ Î±}, sSup (f '' s) = â¨† a, f â†‘a",
  "constCategory": "Theorem"},
 {"references": ["MonadLift", "semiOutParam"],
  "name": "MonadLift.monadLift",
  "constType":
  "{m : semiOutParam (Type u â†’ Type v)} â†’ {n : Type u â†’ Type w} â†’ [self : MonadLift m n] â†’ {Î± : Type u} â†’ m Î± â†’ n Î±",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.sup_le",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_7",
  "constType": "âˆ€ {Î± : Type u_1} (a b c : Î± â†’ Prop), a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Bool.true",
   "List.Mem.head",
   "Not",
   "List.Mem.casesOn",
   "Bool",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.exists_of_eraseP.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} (l : List Î±) (a : Î±) (motive : (b : Î±) â†’ a âˆˆ b :: l â†’ Â¬p b = true â†’ Prop) (b : Î±)\n  (al : a âˆˆ b :: l) (pb : Â¬p b = true),\n  (âˆ€ (pb : Â¬p a = true), motive a (_ : List.Mem a (a :: l)) pb) â†’\n    (âˆ€ (b : Î±) (al : List.Mem a l) (pb : Â¬p b = true), motive b (_ : List.Mem a (b :: l)) pb) â†’ motive b al pb",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "sdiff_le_comm",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.14",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : GeneralizedCoheytingAlgebra Î±] {a b c : Î±}, (a \\ b â‰¤ c) = (a \\ c â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{Î± : Type u} â†’ [self : Zero Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["WellFounded.apply", "WellFounded.fixF", "WellFounded"],
  "name": "WellFounded.fix",
  "constType":
  "{Î± : Sort u} â†’\n  {C : Î± â†’ Sort v} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ WellFounded r â†’ ((x : Î±) â†’ ((y : Î±) â†’ r y x â†’ C y) â†’ C x) â†’ (x : Î±) â†’ C x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.le_sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "le_sInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {s : Set Î±} {a : Î±}, (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "forallâ‚‚_imp",
   "LE",
   "IsUpperSet",
   "Set.sInter",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "isUpperSet_sInter",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {S : Set (Set Î±)}, (âˆ€ s âˆˆ S, IsUpperSet s) â†’ IsUpperSet (â‹‚â‚€ S)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lower", "Topology.WithLower", "TopologicalSpace", "Preorder"],
  "name": "Topology.WithLower.instTopologicalSpaceWithLower",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Exists",
   "OfNat.ofNat",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Lean.IsNeutral",
   "Exists.casesOn",
   "Eq",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Eq.mpr",
   "Filter.inter_mem",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "instOfNatNat",
   "Filter",
   "Option.some",
   "List.nil",
   "Nat",
   "Eq.symm",
   "And.casesOn",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "List.cons",
   "setOf",
   "Set.inter_isComm",
   "Lean.Data.AC.eval",
   "instIsCommutative",
   "Lean.IsIdempotent",
   "Set.instMembershipSet",
   "And",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "instIsAssociative",
   "Lean.IsCommutative",
   "congr",
   "Bool",
   "And.intro",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "Set.inter_isAssoc",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (f g : Filter Î±) {x y : Set Î±},\n  x âˆˆ {s | âˆƒ a âˆˆ f, âˆƒ b âˆˆ g, s = a âˆ© b} â†’\n    y âˆˆ {s | âˆƒ a âˆˆ f, âˆƒ b âˆˆ g, s = a âˆ© b} â†’ x âˆ© y âˆˆ {s | âˆƒ a âˆˆ f, âˆƒ b âˆˆ g, s = a âˆ© b}",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "Set",
   "InfSet.sInf",
   "sInfHomClass.toFunLike",
   "InfSet",
   "FunLike.coe",
   "Set.image",
   "sInfHomClass",
   "Eq"],
  "name": "sInfHomClass.map_sInf",
  "constType":
  "âˆ€ {F : Type u_8} {Î± : outParam (Type u_9)} {Î² : outParam (Type u_10)} [inst : InfSet Î±] [inst_1 : InfSet Î²]\n  [self : sInfHomClass F Î± Î²] (f : F) (s : Set Î±), â†‘f (sInf s) = sInf (â†‘f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : OrderedCancelAddCommMonoid Î±] (x : Î±), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.casesOn",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.length_pos_of_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} (motive : (x : List Î±) â†’ a âˆˆ x â†’ Prop) (x : List Î±) (x_1 : a âˆˆ x),\n  (âˆ€ (head : Î±) (tail : List Î±) (x : a âˆˆ head :: tail), motive (head :: tail) x) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Eq.mpr",
   "Set.iUnion",
   "isOpen_biUnion",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.preimage_sUnion",
   "congrArg",
   "IsOpen",
   "Eq",
   "id",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.coinduced.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (f : Î± â†’ Î²) (t : TopologicalSpace Î±) (s : Set (Set Î²)),\n  (âˆ€ t_1 âˆˆ s, (fun s â†¦ IsOpen (f â»Â¹' s)) t_1) â†’ (fun s â†¦ IsOpen (f â»Â¹' s)) (â‹ƒâ‚€ s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} â†’ [toAddMonoid : AddMonoid M] â†’ (âˆ€ (a b : M), a + b = b + a) â†’ AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["eq_true", "List.Chain.nil", "List.nil", "List.Chain", "True", "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.6",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±}, List.Chain R a [] = True",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "EquivLike",
  "constType":
  "Sort u_1 â†’ outParam (Sort u_2) â†’ outParam (Sort u_3) â†’ Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} â†’ [self : AddZeroClass M] â†’ Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{Î± : Sort u_1} â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": ["HasCompl", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHasCompl",
  "constType": "{Î± : Type u} â†’ [self : BooleanAlgebra Î±] â†’ HasCompl Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "Topology.WithLowerSet.toLowerSet_specializes_toLowerSet",
   "Iff",
   "Topology.WithLowerSet",
   "Specializes",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSet_le_ofLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Topology.WithLowerSet Î±},\n  â†‘Topology.WithLowerSet.ofLowerSet a â‰¤ â†‘Topology.WithLowerSet.ofLowerSet b â†” a â¤³ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Eq.refl",
   "List.length",
   "List.forall_mem_cons",
   "List.eq_replicate_of_mem.match_1",
   "rfl",
   "Eq",
   "PProd",
   "And",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff.mp",
   "List.rec",
   "List",
   "PUnit",
   "List.replicate",
   "List.nil",
   "List.eq_replicate_of_mem.match_2",
   "Nat",
   "Eq.symm",
   "_private.Std.Data.List.Lemmas.0.List.replicate._eq_2",
   "Nat.succ",
   "List.length_cons",
   "id"],
  "name": "List.eq_replicate_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±}, (âˆ€ b âˆˆ l, b = a) â†’ l = List.replicate (List.length l) a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsAssociative", "Eq"],
  "name": "Lean.IsAssociative.assoc",
  "constType":
  "âˆ€ {Î± : Sort u} {op : Î± â†’ Î± â†’ Î±} [self : Lean.IsAssociative op] (a b c : Î±), op (op a b) c = op a (op b c)",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Prop) â†’ Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Lean.PrettyPrinter.UnexpandM", "Lean.Syntax"],
  "name": "Lean.PrettyPrinter.Unexpander",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "GaloisInsertion.le_l_u",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "GaloisConnection.monotone_l",
   "LE.le.trans",
   "le_sup_right",
   "Sup.sup",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeSup Î±],\n  GaloisInsertion l u â†’ âˆ€ (x b : Î²), b â‰¤ l (u x âŠ” u b)",
  "constCategory": "Theorem"},
 {"references": ["Lean.MacroScopesView", "Lean.Name"],
  "name": "Lean.MacroScopesView.imported",
  "constType": "Lean.MacroScopesView â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Fintype.Basic._auxLemma.23",
   "Or",
   "Set",
   "Union.union",
   "Set.toFinset",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Fintype",
   "Iff",
   "DecidableEq",
   "Set.Elem",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "Mathlib.Data.Set.Basic._auxLemma.17",
   "Mathlib.Data.Finset.Basic._auxLemma.73",
   "congr",
   "congrArg",
   "Eq.trans",
   "Finset.instUnionFinset",
   "Set.instUnionSet"],
  "name": "Set.fintypeUnion.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (s t : Set Î±) [inst_1 : Fintype â†‘s] [inst_2 : Fintype â†‘t] (a : Î±),\n  a âˆˆ Set.toFinset s âˆª Set.toFinset t â†” a âˆˆ s âˆª t",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "OrderTop.le_top",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "Pi.hasLe",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Pi.orderTop",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_4",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ GeneralizedHeytingAlgebra (Î± i)] (a : (i : Î¹) â†’ Î± i), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["BEq.beq", "BEq", "Bool.true", "LawfulBEq", "Bool", "Eq"],
  "name": "LawfulBEq.rfl",
  "constType":
  "âˆ€ {Î± : Type u} [inst : BEq Î±] [self : LawfulBEq Î±] {a : Î±}, (a == a) = true",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "GeneralizedHeytingAlgebra"],
  "name": "HeytingAlgebra.toGeneralizedHeytingAlgebra",
  "constType":
  "{Î± : Type u_4} â†’ [self : HeytingAlgebra Î±] â†’ GeneralizedHeytingAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.Â«termI^_Â»._closed_4",
   "Lean.Name.str._override"],
  "name": "Topology.Â«termI^_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd.proof_1",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "IsLeftCancelAdd"],
  "name": "AddLeftCancelSemigroup.toIsLeftCancelAdd",
  "constType":
  "âˆ€ (G : Type u) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.map_add_range'.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ â„• â†’ â„• â†’ Prop) (x x_1 x_2 : â„•),\n  (âˆ€ (x x_3 : â„•), motive x 0 x_3) â†’ (âˆ€ (s n step : â„•), motive s (Nat.succ n) step) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["BEq", "BEq.mk", "Nat.beq", "Nat"],
  "name": "instBEqNat",
  "constType": "BEq â„•",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Sup",
   "Sup.sup",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toSup : Sup Î±] â†’\n    [toPartialOrder : PartialOrder Î±] â†’\n      (âˆ€ (a b : Î±), a â‰¤ a âŠ” b) â†’\n        (âˆ€ (a b : Î±), b â‰¤ a âŠ” b) â†’ (âˆ€ (a b c : Î±), a â‰¤ c â†’ b â‰¤ c â†’ a âŠ” b â‰¤ c) â†’ SemilatticeSup Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.mem_image",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "funext",
   "List.cons",
   "List.filterMap",
   "Function.comp",
   "Unit",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "List.filterMap_cons.match_1",
   "congr",
   "Option.some",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option"],
  "name": "List.filterMap_eq_map",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²), List.filterMap (some âˆ˜ f) = List.map f",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "Function.Injective", "FunLike.coe"],
  "name": "FunLike.coe_injective'",
  "constType":
  "âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Î± â†’ Sort u_3)} [self : FunLike F Î± Î²],\n  Function.Injective FunLike.coe",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iSup",
   "iSup_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "iSupâ‚‚_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {Îº : Î¹ â†’ Sort u_7} [inst : CompleteLattice Î±] {a : Î±} {f : (i : Î¹) â†’ Îº i â†’ Î±},\n  (âˆ€ (i : Î¹) (j : Îº i), f i j â‰¤ a) â†’ â¨† i, â¨† j, f i j â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "â„• â†’ â„•",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Nat",
   "instLTNat",
   "Nat.not_succ_le_zero"],
  "name": "Nat.not_lt_zero",
  "constType": "âˆ€ (n : â„•), Â¬n < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), y âˆˆ f '' s â†” âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_4",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Fintype", "Finset"],
  "name": "Fintype.elems",
  "constType": "{Î± : Type u_4} â†’ [self : Fintype Î±] â†’ Finset Î±",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "TopologicalSpace.generateFrom",
   "setOf",
   "Set",
   "TopologicalSpace",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Ici",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq"],
  "name": "Topology.lower",
  "constType": "(Î± : Type u_1) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_18._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List.Perm", "List", "List.nil", "List.perm_inv_core"],
  "name": "List.Perm.cons_inv",
  "constType":
  "âˆ€ {Î± : Type uu} {a : Î±} {lâ‚ lâ‚‚ : List Î±}, a :: lâ‚ ~ a :: lâ‚‚ â†’ lâ‚ ~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "sInf_eq_iInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Eq.symm",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteLattice Î±] {s : Set Î±}, â¨… a âˆˆ s, a = sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "OrderDual.semilatticeInf.proof_1",
   "LE.le",
   "Preorder.toLE",
   "le_sup_left",
   "PartialOrder",
   "SemilatticeSup",
   "Inf.mk",
   "instInfOrderDual",
   "SemilatticeSup.toSup",
   "Inf",
   "OrderDual",
   "inferInstanceAs",
   "sup_le",
   "le_sup_right",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "OrderDual.semilatticeInf",
  "constType":
  "(Î± : Type u_1) â†’ [inst : SemilatticeSup Î±] â†’ SemilatticeInf Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_exists_eq_and.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} {p : Î² â†’ Prop} (motive : (âˆƒ a, p (f a)) â†’ Prop) (x : âˆƒ a, p (f a)),\n  (âˆ€ (a : Î±) (ha : p (f a)), motive (_ : âˆƒ a, p (f a))) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_right",
  "constType": "âˆ€ {b c a : Prop}, (b â†’ c) â†’ a âˆ¨ b â†’ a âˆ¨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.NeBot.ne'",
   "Iff.intro",
   "Ne",
   "Bot.bot",
   "Iff",
   "Filter.NeBot.mk",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.neBot_iff",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±}, Filter.NeBot f â†” f â‰  âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.partialOrder.proof_2",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Function.comp",
   "LE",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Prop.partialOrder.proof_1",
   "PartialOrder",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder",
  "constType": "PartialOrder Prop",
  "constCategory": "Definition"},
 {"references": ["Bot", "Top", "Top.top", "OrderDual", "Bot.mk"],
  "name": "OrderDual.bot",
  "constType": "(Î± : Type u) â†’ [inst : Top Î±] â†’ Bot Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.perm_middle.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : List Î± â†’ List Î± â†’ Prop) (x x_1 : List Î±),\n  (âˆ€ (x : List Î±), motive [] x) â†’ (âˆ€ (b : Î±) (lâ‚ lâ‚‚ : List Î±), motive (b :: lâ‚) lâ‚‚) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasCompl",
  "constType": "Type u_3 â†’ Type u_3",
  "constCategory": "Other"},
 {"references":
  ["And",
   "BEq.beq",
   "List.instBEqList",
   "BEq",
   "List",
   "Bool.true",
   "And.intro",
   "Bool",
   "And.casesOn",
   "Eq"],
  "name": "List.instLawfulBEqListInstBEqList.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BEq Î±] (a : Î±) (as : List Î±) (b : Î±) (bs : List Î±) (motive : a = b âˆ§ (as == bs) = true â†’ Prop)\n  (h : a = b âˆ§ (as == bs) = true),\n  (âˆ€ (hâ‚ : a = b) (hâ‚‚ : (as == bs) = true), motive (_ : a = b âˆ§ (as == bs) = true)) â†’ motive h",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Prod.snd",
   "Set.preimage",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Prod.fst",
   "Filter.instSProd",
   "Mathlib.Order.Filter.Prod._auxLemma.19",
   "Filter.comap_principal",
   "Eq",
   "Filter.principal",
   "Eq.mpr",
   "Set.prod",
   "SProd.sprod",
   "Filter.instInfFilter",
   "congr",
   "Filter.comap",
   "Filter",
   "Prod",
   "Filter.inf_principal",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Set.instInterSet",
   "id"],
  "name": "Filter.prod_principal_principal",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²},\n  Filter.principal s Ã—Ë¢ Filter.principal t = Filter.principal (s Ã—Ë¢ t)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Or",
   "Nat.below",
   "Or.inr",
   "Unit",
   "GE.ge",
   "instLTNat",
   "Eq",
   "PProd",
   "Nat.lt_or_ge.match_2",
   "Nat.le_succ_of_le",
   "PProd.fst",
   "Nat.rec",
   "Or.inl",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "Eq.rec",
   "LT.lt",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.zero_le",
   "Nat.succ",
   "Nat.eq_or_lt_of_le",
   "Nat.lt_or_ge.match_1"],
  "name": "Nat.lt_or_ge",
  "constType": "âˆ€ (n m : â„•), n < m âˆ¨ n â‰¥ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_3 â†’ Type u_3",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set",
   "Set.mem_preimage",
   "Eq.refl",
   "Set.Iic",
   "closure_mono",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Topology.IsUpperSet",
   "Set.instSingletonSet",
   "Iff",
   "forall_congr",
   "Continuous",
   "Set.mem_of_mem_of_subset",
   "TopologicalSpace",
   "IsUpperSet.preimage",
   "Eq.symm",
   "IsOpen",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.2",
   "id",
   "Membership.mem",
   "Set.singleton_subset_iff",
   "Set.preimage",
   "Continuous.closure_preimage_subset",
   "HasSubset.Subset",
   "IsUpperSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
   "Preorder",
   "LE.le",
   "Set.mem_Iic",
   "Set.instMembershipSet",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.mem_singleton_iff",
   "propext",
   "Eq.mp",
   "Monotone",
   "Singleton.singleton",
   "Topology.IsUpperSet.closure_singleton"],
  "name": "Topology.IsUpperSet.monotone_iff_continuous",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Topology.IsUpperSet Î±] [inst_5 : Topology.IsUpperSet Î²] {f : Î± â†’ Î²},\n  Monotone f â†” Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Eq.rec",
   "Set",
   "Filter.generate",
   "Set.univ",
   "Filter.univ_mem",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)), (Filter.generate s).sets = s â†’ Set.univ âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Equivalence.mk", "Equivalence", "True"],
  "name": "true_equivalence",
  "constType": "âˆ€ {Î± : Sort u_1}, Equivalence fun x x â†¦ True",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "DistribLattice",
   "Pi.lattice",
   "DistribLattice.mk",
   "Pi.distribLattice.proof_1"],
  "name": "Pi.distribLattice",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î±' : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ DistribLattice (Î±' i)] â†’ DistribLattice ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.mem_of_elem_eq_true.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : List Î± â†’ Prop) (as : List Î±),\n  (Unit â†’ motive []) â†’ (âˆ€ (a' : Î±) (as : List Î±), motive (a' :: as)) â†’ motive as",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "Or", "propext", "exists_eq_or_imp", "Eq"],
  "name": "Std.Logic._auxLemma.48",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) = (p a' âˆ¨ âˆƒ a, q a âˆ§ p a)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "instLENat", "Fin.val", "LE", "Nat", "LE.le", "Fin"],
  "name": "instLEFin",
  "constType": "{n : â„•} â†’ LE (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "Nat.rec",
   "of_eq_true",
   "List.replicate",
   "instOfNatNat",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.length_replicate",
  "constType":
  "âˆ€ {Î± : Type u} (n : â„•) (a : Î±), List.length (List.replicate n a) = n",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "GaloisInsertion.liftBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_6",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : CompleteLattice Î±]\n  (gi : GaloisInsertion l u) (a : Î²), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "LE",
   "inferInstanceAs",
   "le_trans",
   "Pi.hasLe",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Pi.preorder.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ Preorder (Î± i)] (a b c : (i : Î¹) â†’ Î± i),\n  a â‰¤ b â†’ b â‰¤ c â†’ âˆ€ (i : Î¹), a i â‰¤ c i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.nodup_cons",
   "List.insert",
   "List.instMembershipList",
   "Eq.refl",
   "dite",
   "Eq",
   "And",
   "Eq.mpr",
   "List.Nodup",
   "Eq.ndrec",
   "DecidableEq",
   "List.insert_of_not_mem",
   "propext",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Not",
   "And.intro",
   "List.insert_of_mem",
   "id"],
  "name": "List.Nodup.insert",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±} {a : Î±} [inst : DecidableEq Î±], List.Nodup l â†’ List.Nodup (List.insert a l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Nodup",
   "Function.Injective",
   "List.instMembershipList",
   "List",
   "List.Nodup.map_on",
   "List.map",
   "Eq"],
  "name": "List.Nodup.map",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {l : List Î±} {f : Î± â†’ Î²}, Function.Injective f â†’ List.Nodup l â†’ List.Nodup (List.map f l)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithUpper",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsUpper.WithUpperHomeomorph._spec_1",
  "constType":
  "(Î± : Type u_1) â†’\n  (inst : Preorder Î±) â†’\n    (inst_1 : TopologicalSpace Î±) â†’\n      let _x_1 :=\n        { IsOpen := TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s},\n          isOpen_univ := (_ : TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s} Set.univ),\n          isOpen_inter :=\n            (_ :\n              âˆ€ (s t : Set Î±),\n                TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s} s â†’\n                  TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s} t â†’\n                    TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s} (Inter.interâœ s t)),\n          isOpen_sUnion :=\n            (_ :\n              âˆ€ (S : Set (Set Î±)),\n                (âˆ€ s âˆˆ S, TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s} s) â†’\n                  TopologicalSpace.GenerateOpen {s | âˆƒ a, HasCompl.complâœ (Set.Iic a) = s} (â‹ƒâ‚€ S)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithUpper Î± â‰ƒ Î±) â†’ Inducing â†‘f â†’ Topology.WithUpper Î± â‰ƒâ‚œ Î±",
  "constCategory": "Axiom"},
 {"references":
  ["sSup_singleton",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Eq.refl",
   "iSup",
   "SupSet.sSup",
   "Nonempty",
   "CompleteSemilatticeSup.toSupSet",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "Set.instSingletonSet",
   "CompleteLattice",
   "Eq.ndrec",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "Set.range_const",
   "Singleton.singleton",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "iSup_const",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {a : Î±} [inst_1 : Nonempty Î¹], â¨† x, a = a",
  "constCategory": "Theorem"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "mem_lowerClosure",
   "And",
   "Exists",
   "propext",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.UpperLower.Basic._auxLemma.95",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {x : Î±}, (x âˆˆ lowerClosure s) = âˆƒ a âˆˆ s, x â‰¤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "inferInstanceAs",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.distribLattice.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : DistribLattice Î±] (a b : Î±áµ’áµˆ), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "GaloisInsertion.liftBoundedOrder.proof_1",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "GaloisConnection.liftOrderBot",
   "OrderBot.bot_le",
   "Preorder",
   "LE.le",
   "GaloisInsertion",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftBoundedOrder.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : Preorder Î±]\n  [inst_2 : BoundedOrder Î±] (gi : GaloisInsertion l u) (a : Î²), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quotient", "Quot.mk"],
  "name": "Quotient.mk",
  "constType": "{Î± : Sort u} â†’ (s : Setoid Î±) â†’ Î± â†’ Quotient s",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.mul_zero",
  "constType": "âˆ€ (n : â„•), n * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "Nat",
   "instDecidableEqNat",
   "Eq",
   "ite",
   "Lean.Data.AC.mergeIdem.loop.match_1"],
  "name": "Lean.Data.AC.mergeIdem.loop",
  "constType": "â„• â†’ List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "sSupHom",
   "Set",
   "sSupHom.toFun",
   "SupSet.sSup",
   "Set.image",
   "Eq"],
  "name": "sSupHom.map_sSup'",
  "constType":
  "âˆ€ {Î± : Type u_8} {Î² : Type u_9} [inst : SupSet Î±] [inst_1 : SupSet Î²] (self : sSupHom Î± Î²) (s : Set Î±),\n  sSupHom.toFun self (sSup s) = sSup (self.toFun '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.GenerateOpen.basic",
   "Eq.mpr",
   "Eq.ndrec",
   "Set",
   "Eq.refl",
   "TopologicalSpace",
   "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
   "IsOpen",
   "Eq",
   "id",
   "Set.instMembershipSet",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.isOpen",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set Î±} {b : Set (Set Î±)},\n  TopologicalSpace.IsTopologicalBasis b â†’ s âˆˆ b â†’ IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Equivalence"],
  "name": "Setoid.mk",
  "constType": "{Î± : Sort u} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ Equivalence r â†’ Setoid Î±",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{Î± : Type u} â†’ [self : Inf Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Inducing.casesOn",
   "Inducing.mk",
   "TopologicalSpace",
   "Inducing",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "inducing_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [tÎ± : TopologicalSpace Î±] [tÎ² : TopologicalSpace Î²] (f : Î± â†’ Î²),\n  Inducing f â†” tÎ± = TopologicalSpace.induced f tÎ²",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Preorder.le_refl",
   "Prod.instPartialOrder.match_1",
   "Preorder.le_trans",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Preorder.mk",
   "Eq",
   "LE.le.antisymm",
   "Prod.instPreorderProd",
   "Preorder.toLT",
   "inferInstanceAs",
   "Prod",
   "Prod.ext",
   "Preorder.lt_iff_le_not_le",
   "Prod.instPartialOrder.match_2"],
  "name": "Prod.instPartialOrder.proof_4",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (x x_1 : Î± Ã— Î²),\n  x â‰¤ x_1 â†’ x_1 â‰¤ x â†’ x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "le_iInf_iff",
   "CompleteLattice.toInfSet",
   "propext",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.CompleteLattice._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {a : Î±}, (a â‰¤ iInf f) = âˆ€ (i : Î¹), a â‰¤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Not.elim",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "List.casesOn",
   "List.Perm.swap",
   "Exists.casesOn",
   "List.Perm.cons",
   "rfl",
   "True",
   "Eq",
   "List.Perm.symm",
   "Std.Data.List.Lemmas._auxLemma.11",
   "Eq.mpr",
   "true_or",
   "List.perm_middle",
   "List.nil",
   "Eq.symm",
   "List.perm_induction_on",
   "Eq.trans",
   "id",
   "Membership.mem",
   "eq_self",
   "List.Perm.swap'",
   "List.append",
   "List.cons",
   "Or",
   "List.mem_split",
   "List.not_mem_nil",
   "or_true",
   "List.Perm.subset",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "List.Perm",
   "of_eq_true",
   "HAppend.hAppend",
   "List",
   "List.Perm.trans",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "List.perm_inv_core",
  "constType":
  "âˆ€ {Î± : Type uu} {a : Î±} {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±}, lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "âˆ€ (n : â„•), 0 â‰¤ n",
  "constCategory": "Theorem"},
 {"references":
  ["List.nodup_singleton",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_singleton",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), Multiset.Nodup {a}",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "LawfulBEq",
   "Nat.eq_of_beq_eq_true",
   "implies_true",
   "instBEqNat",
   "True",
   "Eq",
   "BEq.beq",
   "of_eq_true",
   "forall_congr",
   "LawfulBEq.mk",
   "Bool.true",
   "Bool",
   "Nat.beq",
   "Nat",
   "congrArg",
   "Nat.beq_refl",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.instLawfulBEqNatInstBEqNat.proof_1",
  "constType": "LawfulBEq â„•",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.below.rec",
   "List.instMembershipList",
   "List.Pairwise.below",
   "List",
   "List.Pairwise.below.nil",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.below.casesOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop}\n  {motive_1 : {a : List Î±} â†’ (x : List.Pairwise R a) â†’ List.Pairwise.below x â†’ Prop} {a : List Î±}\n  {x : List.Pairwise R a} (t : List.Pairwise.below x),\n  motive_1 (_ : List.Pairwise R []) (_ : List.Pairwise.below (_ : List.Pairwise R [])) â†’\n    (âˆ€ {a : Î±} {l : List Î±} (a_1 : âˆ€ a' âˆˆ l, R a a') {a_2 : List.Pairwise R l} (a_3 : List.Pairwise.below a_2)\n        (a_4 : motive l a_2),\n        motive_1 (_ : List.Pairwise R (a :: l)) (_ : List.Pairwise.below (_ : List.Pairwise R (a :: l)))) â†’\n      motive_1 x t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.inter_mem_inf",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_inf_of_inter",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s t u : Set Î±}, s âˆˆ f â†’ t âˆˆ g â†’ s âˆ© t âŠ† u â†’ u âˆˆ f âŠ“ g",
  "constCategory": "Theorem"},
 {"references":
  ["inf_comm",
   "IsCommutative.mk",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf",
   "IsCommutative"],
  "name": "instIsCommutativeInfToInf.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±], IsCommutative Î± fun x x_1 â†¦ x âŠ“ x_1",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{Î± : Type u} â†’ [self : StrictOrderedSemiring Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.ble",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.ble_succ_eq_true.match_1",
   "rfl",
   "Nat.succ",
   "Eq"],
  "name": "Nat.ble_succ_eq_true",
  "constType":
  "âˆ€ {n m : â„•}, Nat.ble n m = true â†’ Nat.ble n (Nat.succ m) = true",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma",
   "Eq.ndrec",
   "PSigma.snd",
   "PSigma.fst",
   "Eq.ndrecOn",
   "Quot.liftIndepPr1",
   "Quot.indepCoherent",
   "Quot.lift",
   "Quot",
   "Quot.indep",
   "Quot.sound",
   "Eq",
   "Quot.mk"],
  "name": "Quot.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : Quot r â†’ Sort v} â†’\n      (f : (a : Î±) â†’ motive (Quot.mk r a)) â†’\n        (âˆ€ (a b : Î±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) â–¸ f a = f b) â†’ (q : Quot r) â†’ motive q",
  "constCategory": "Definition"},
 {"references": ["Ne", "List.Nodup", "List.Pairwise.nil", "List.nil"],
  "name": "List.nodup_nil",
  "constType": "âˆ€ {Î± : Type u}, List.Nodup []",
  "constCategory": "Theorem"},
 {"references":
  ["Or.resolve_left",
   "Iff.intro",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "Decidable",
   "dite",
   "Not"],
  "name": "Decidable.or_iff_not_imp_left",
  "constType": "âˆ€ {a b : Prop} [inst : Decidable a], a âˆ¨ b â†” Â¬a â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil"],
  "name": "List.Sublist.rec",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop},\n  motive [] [] (_ : List.Sublist [] []) â†’\n    (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) (a_1 : List.Sublist lâ‚ lâ‚‚),\n        motive lâ‚ lâ‚‚ a_1 â†’ motive lâ‚ (a :: lâ‚‚) (_ : List.Sublist lâ‚ (a :: lâ‚‚))) â†’\n      (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) (a_1 : List.Sublist lâ‚ lâ‚‚),\n          motive lâ‚ lâ‚‚ a_1 â†’ motive (a :: lâ‚) (a :: lâ‚‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))) â†’\n        âˆ€ {a a_1 : List Î±} (t : List.Sublist a a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references": ["Fin.val", "LT.lt", "LT", "LT.mk", "Nat", "instLTNat", "Fin"],
  "name": "instLTFin",
  "constType": "{n : â„•} â†’ LT (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_of_succ_le",
  "constType": "âˆ€ {n m : â„•}, Nat.succ n â‰¤ m â†’ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "HImp.himp",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "HeytingAlgebra.toHasCompl",
   "Eq"],
  "name": "HeytingAlgebra.himp_bot",
  "constType": "âˆ€ {Î± : Type u_4} [self : HeytingAlgebra Î±] (a : Î±), a â‡¨ âŠ¥ = aá¶œ",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "TopologicalSpace.GenerateOpen",
  "constType": "{Î± : Type u} â†’ Set (Set Î±) â†’ Set Î± â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "And",
   "Pi.preorder.proof_2",
   "Pi.preorder.proof_1",
   "inferInstanceAs",
   "LE",
   "Not",
   "Pi.preorder.proof_3",
   "LT.mk",
   "Pi.hasLe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Pi.preorder",
  "constType":
  "{Î¹ : Type u} â†’ {Î± : Î¹ â†’ Type v} â†’ [inst : (i : Î¹) â†’ Preorder (Î± i)] â†’ Preorder ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add â„•",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Lean.ParserDescr.symbol", "Topology.Â«termI^_Â»._closed_6"],
  "name": "Topology.Â«termI^_Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc", "WellFounded.apply.proof_1"],
  "name": "WellFounded.apply",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, WellFounded r â†’ âˆ€ (a : Î±), Acc r a",
  "constCategory": "Definition"},
 {"references":
  ["Directed.mono",
   "Function.comp",
   "directed_comp",
   "Directed",
   "Iff.mpr",
   "Order.Preimage"],
  "name": "Directed.mono_comp",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (r : Î± â†’ Î± â†’ Prop) {Î¹ : Sort u_1} {rb : Î² â†’ Î² â†’ Prop} {g : Î± â†’ Î²} {f : Î¹ â†’ Î±},\n  (âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ rb (g x) (g y)) â†’ Directed r f â†’ Directed rb (g âˆ˜ f)",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftSemilatticeInf.proof_1",
   "Inf.mk",
   "GaloisInsertion.liftSemilatticeInf.proof_3",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "PartialOrder.le_antisymm",
   "SemilatticeInf.toPartialOrder",
   "GaloisInsertion.liftSemilatticeInf.proof_4",
   "GaloisInsertion.choice",
   "GaloisInsertion",
   "GaloisInsertion.liftSemilatticeInf.proof_2",
   "SemilatticeInf.mk",
   "SemilatticeInf",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeInf",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    {l : Î± â†’ Î²} â†’\n      {u : Î² â†’ Î±} â†’ [inst : PartialOrder Î²] â†’ [inst_1 : SemilatticeInf Î±] â†’ GaloisInsertion l u â†’ SemilatticeInf Î²",
  "constCategory": "Definition"},
 {"references":
  ["Filter.principal",
   "nhds",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter"],
  "name": "nhdsWithin",
  "constType":
  "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Î± â†’ Set Î± â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references": ["PLift.up", "PLift.down", "PLift", "rfl", "Eq"],
  "name": "PLift.up_down",
  "constType": "âˆ€ {Î± : Sort u} (b : PLift Î±), { down := b.down } = b",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisCoinsertion.choice",
   "GaloisCoinsertion",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisCoinsertion.choice_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±}\n  (self : GaloisCoinsertion l u) (a : Î²) (h : a â‰¤ l (u a)), GaloisCoinsertion.choice self a h = u a",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Homotopy.termÎ©._closed_2",
   "_obj",
   "Lean.Name.mkStr3",
   "Topology.Â«termI^_Â»._closed_1",
   "Topology.Homotopy.termÎ©._closed_1"],
  "name": "Topology.Homotopy.termÎ©._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Top", "OrderTop", "LE"],
  "name": "OrderTop.toTop",
  "constType": "{Î± : Type u} â†’ [inst : LE Î±] â†’ [self : OrderTop Î±] â†’ Top Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "instHAppend",
   "List.Sublist.append_right.match_1._@.Std.Data.List.Lemmas._hyg.7596",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Sublist.append_right",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ âˆ€ (l : List Î±), List.Sublist (lâ‚ ++ l) (lâ‚‚ ++ l)",
  "constCategory": "Theorem"},
 {"references":
  ["Trans.trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "sup_inf_sdiff",
   "SemilatticeSup.toSup",
   "GeneralizedBooleanAlgebra",
   "le_sup_right",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup"],
  "name": "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_le'",
  "constType":
  "âˆ€ {Î± : Type u} {x y : Î±} [inst : GeneralizedBooleanAlgebra Î±], x \\ y â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.mk",
   "Eq"],
  "name": "Topology.IsLower.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  [t : TopologicalSpace Î±] â†’\n    [inst : Preorder Î±] â†’\n      {motive : Topology.IsLower Î± â†’ Sort u} â†’\n        ((topology_eq_lowerTopology : t = Topology.lower Î±) â†’ motive (_ : Topology.IsLower Î±)) â†’\n          (t : Topology.IsLower Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLower.of_WithLower_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithLower.ofLower.symm = Topology.WithLower.toLower",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.decidableBAll.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (a : Î±) â†’ a âˆˆ [] â†’ Prop) (a : Î±) (a_1 : a âˆˆ []), motive a a_1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLower",
   "TopologicalSpace",
   "Topology.IsLower.instClosedIciTopology.proof_1",
   "Preorder",
   "ClosedIciTopology"],
  "name": "Topology.IsLower.instClosedIciTopology",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±], ClosedIciTopology Î±",
  "constCategory": "Definition"},
 {"references": ["or_congr", "Or", "Iff", "Iff.rfl"],
  "name": "or_congr_left",
  "constType": "âˆ€ {a b c : Prop}, (a â†” b) â†’ (a âˆ¨ c â†” b âˆ¨ c)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "GetElem"],
  "name": "GetElem.getElem",
  "constType":
  "{cont : Type u} â†’\n  {idx : Type v} â†’\n    {elem : outParam (Type w)} â†’\n      {dom : outParam (cont â†’ idx â†’ Prop)} â†’\n        [self : GetElem cont idx elem dom] â†’ (xs : cont) â†’ (i : idx) â†’ dom xs i â†’ elem",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "EmbeddingLike"],
  "name": "EmbeddingLike.toFunLike",
  "constType":
  "{F : Sort u_1} â†’\n  {Î± : outParam (Sort u_2)} â†’ {Î² : outParam (Sort u_3)} â†’ [self : EmbeddingLike F Î± Î²] â†’ FunLike F Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.casesOn",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.noConfusion",
   "Eq.symm",
   "Eq"],
  "name": "List.pairwise_iff_forall_sublist.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (hd : Î±) (tl : List Î±) (motive : (x x_1 : Î±) â†’ List.Sublist [x, x_1] (hd :: tl) â†’ Prop) (x x_1 : Î±)\n  (x_2 : List.Sublist [x, x_1] (hd :: tl)),\n  (âˆ€ (a b : Î±) (hab : List.Sublist [a, b] tl), motive a b (_ : List.Sublist [a, b] (hd :: tl))) â†’\n    (âˆ€ (b : Î±) (hab : List.Sublist [b] tl), motive hd b (_ : List.Sublist [hd, b] (hd :: tl))) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List.rec",
   "List",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "Lean.Data.AC.removeNeutrals.match_1",
   "Nat",
   "absurd",
   "id",
   "Eq"],
  "name": "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.eq_2",
  "constType":
  "âˆ€ (motive : List â„• â†’ Sort u_1) (ys : List â„•) (h_1 : Unit â†’ motive []) (h_2 : (ys : List â„•) â†’ motive ys),\n  (ys = [] â†’ False) â†’\n    (match ys with\n      | [] => h_1 ()\n      | ys => h_2 ys) =\n      h_2 ys",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "Exists",
   "List.cons",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "Exists.intro",
   "Exists.casesOn",
   "Eq"],
  "name": "List.append_of_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} (as : List Î±) (motive : (âˆƒ s, âˆƒ t, as = s ++ a :: t) â†’ Prop) (x : âˆƒ s, âˆƒ t, as = s ++ a :: t),\n  (âˆ€ (s t : List Î±) (h' : as = s ++ a :: t), motive (_ : âˆƒ s, âˆƒ t, as = s ++ a :: t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["and_imp",
   "Bot.bot",
   "Prop.distribLattice",
   "GeneralizedHeytingAlgebra.toHImp",
   "OrderTop.le_top",
   "BoundedOrder.toOrderTop",
   "rfl",
   "Eq",
   "DistribLattice.toLattice",
   "OrderTop.toTop",
   "Iff.symm",
   "And",
   "HImp.himp",
   "HImp.mk",
   "OrderBot.toBot",
   "Prop.le",
   "BoundedOrder.toOrderBot",
   "Prop.boundedOrder",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Prop.heytingAlgebra.proof_4",
  "constType": "âˆ€ (x : Prop), x â‡¨ âŠ¥ = x â‡¨ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "OfNat.ofNat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "instMinNat",
   "Nat.min_eq_right",
   "Eq"],
  "name": "Nat.min_zero",
  "constType": "âˆ€ (a : â„•), min a 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Function.comp",
   "monotone_dual_iff",
   "Eq.refl",
   "instTopologicalSpaceOrderDual",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Topology.IsUpperSet.monotone_iff_continuous",
   "propext",
   "Continuous",
   "TopologicalSpace",
   "Monotone",
   "OrderDual",
   "OrderDual.instIsUpperSet",
   "Eq.symm",
   "id"],
  "name": "Topology.IsLowerSet.monotone_iff_continuous",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : TopologicalSpace Î±]\n  [inst_3 : TopologicalSpace Î²] [inst_4 : Topology.IsLowerSet Î±] [inst_5 : Topology.IsLowerSet Î²] {f : Î± â†’ Î²},\n  Monotone f â†” Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddSemigroup.toAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "IsLeftCancelAdd",
   "IsLeftCancelAdd.mk"],
  "name": "AddLeftCancelSemigroup.toIsLeftCancelAdd.proof_1",
  "constType":
  "âˆ€ (G : Type u_1) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Equiv.refl",
   "_obj",
   "Equiv.toHomeomorphOfInducing._at.Topology.IsLower.WithLowerHomeomorph._spec_1",
   "_neutral"],
  "name": "Topology.IsLower.WithLowerHomeomorph._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Nat.mod", "Mod.mk", "Nat", "Mod"],
  "name": "Nat.instModNat",
  "constType": "Mod â„•",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.mergeIdem.loop.match_1",
  "constType":
  "(motive : â„• â†’ List â„• â†’ Sort u_1) â†’\n  (x : â„•) â†’\n    (x_1 : List â„•) â†’\n      ((curr next : â„•) â†’ (rest : List â„•) â†’ motive curr (next :: rest)) â†’ ((curr : â„•) â†’ motive curr []) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Pow.mk", "Nat.pow", "Nat", "Pow"],
  "name": "instPowNat",
  "constType": "Pow â„• â„•",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Topology.lower",
   "Set.preimage",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Iff.rfl",
   "Topology.WithLower",
   "Set",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "Preorder",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.isOpen_preimage_ofLower",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, IsOpen (â†‘Topology.WithLower.ofLower â»Â¹' s) â†” TopologicalSpace.IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Functor"],
  "name": "Functor.mk",
  "constType":
  "{f : Type u â†’ Type v} â†’ ({Î± Î² : Type u} â†’ (Î± â†’ Î²) â†’ f Î± â†’ f Î²) â†’ ({Î± Î² : Type u} â†’ Î± â†’ f Î² â†’ f Î±) â†’ Functor f",
  "constCategory": "Other"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le.match_1",
  "constType":
  "âˆ€ {n : â„•} (motive : (m : â„•) â†’ n â‰¤ m â†’ Prop) (m : â„•) (h : n â‰¤ m),\n  (Unit â†’ motive n (_ : Nat.le n n)) â†’\n    (âˆ€ (m : â„•) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) â†’ motive m h",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "exists_prop.match_2",
   "And",
   "Exists",
   "Iff",
   "Exists.intro",
   "And.intro",
   "exists_prop.match_1"],
  "name": "exists_prop",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) â†” a âˆ§ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le.dest.match_1",
  "constType":
  "âˆ€ (n m : â„•) (motive : (âˆƒ k, n + k = m) â†’ Prop) (this : âˆƒ k, n + k = m),\n  (âˆ€ (k : â„•) (h : n + k = m), motive (_ : âˆƒ k, n + k = m)) â†’ motive this",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_left",
   "Prod",
   "Lattice",
   "Prod.semilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Prod.lattice.proof_4",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Lattice Î±] [inst_1 : Lattice Î²] (a b : Î± Ã— Î²), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Applicative", "Monad"],
  "name": "Monad.toApplicative",
  "constType": "{m : Type u â†’ Type v} â†’ [self : Monad m] â†’ Applicative m",
  "constCategory": "Definition"},
 {"references":
  ["not_exists",
   "Exists",
   "Iff.mp",
   "Filter.eventually_of_forall",
   "Classical.propDecidable",
   "Not",
   "Filter",
   "Decidable.byContradiction",
   "Filter.Frequently"],
  "name": "Filter.Frequently.exists",
  "constType":
  "âˆ€ {Î± : Type u} {p : Î± â†’ Prop} {f : Filter Î±}, (âˆƒá¶  (x : Î±) in f, p x) â†’ âˆƒ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "SemilatticeSup.le_sup_left",
  "constType": "âˆ€ {Î± : Type u} [self : SemilatticeSup Î±] (a b : Î±), a â‰¤ a âŠ” b",
  "constCategory": "Definition"},
 {"references":
  ["Lean.IsIdempotent.mk",
   "IsIdempotent",
   "Lean.IsIdempotent",
   "instIsIdempotent.proof_1"],
  "name": "instIsIdempotent",
  "constType":
  "{Î± : Type u_1} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ [inst : IsIdempotent Î± op] â†’ Lean.IsIdempotent op",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mem_top",
   "Membership.mem",
   "Filter.instTopFilter",
   "Top.top",
   "propext",
   "Set",
   "Filter",
   "Set.univ",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.18",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (s âˆˆ âŠ¤) = (s = Set.univ)",
  "constCategory": "Theorem"},
 {"references":
  ["List.nodup_attach",
   "Membership.mem",
   "Setoid.r",
   "Iff",
   "List",
   "Multiset.attach",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset",
   "Subtype"],
  "name": "Multiset.nodup_attach",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Multiset Î±}, Multiset.Nodup (Multiset.attach s) â†” Multiset.Nodup s",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Set",
   "Set.mem_preimage",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s : Set Î²} {a : Î±}, (a âˆˆ f â»Â¹' s) = (f a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "LT.lt",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Nat.mul_lt_mul_of_pos_left",
   "instLTNat",
   "Eq",
   "GT.gt"],
  "name": "Nat.mul_lt_mul_of_pos_right",
  "constType": "âˆ€ {n m k : â„•}, n < m â†’ k > 0 â†’ n * k < m * k",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.mkStr3",
   "Topology.Homotopy.Â«termÎ©^Â»._closed_1",
   "Topology.Â«termI^_Â»._closed_1",
   "Topology.Homotopy.termÎ©._closed_1"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Function.Injective", "Function.Embedding"],
  "name": "Function.Embedding.mk",
  "constType":
  "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (toFun : Î± â†’ Î²) â†’ Function.Injective toFun â†’ Î± â†ª Î²",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "True",
   "Std.Data.List.Basic._auxLemma.2",
   "iff_self",
   "List.Pairwise",
   "And",
   "Std.Data.List.Lemmas._auxLemma.69",
   "Iff",
   "List.rec",
   "of_eq_true",
   "propext",
   "Std.Data.List.Lemmas._auxLemma.68",
   "List",
   "congr",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans"],
  "name": "List.pairwise_map",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î±_1 : Type u_2} {f : Î± â†’ Î±_1} {R : Î±_1 â†’ Î±_1 â†’ Prop} {l : List Î±},\n  List.Pairwise R (List.map f l) â†” List.Pairwise (fun a b â†¦ R (f a) (f b)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_of_ball",
   "Function.comp",
   "Set",
   "Set.image",
   "Set.Subset.antisymm",
   "Eq",
   "Set.mem_image_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.image_comp",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î² â†’ Î³) (g : Î± â†’ Î²) (a : Set Î±), f âˆ˜ g '' a = f '' (g '' a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "propext",
   "Union.union",
   "Inf.inf",
   "Set",
   "Filter.mem_inf_principal'",
   "Filter.instInfFilter",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instUnionSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.63",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s t : Set Î±}, (s âˆˆ f âŠ“ Filter.principal t) = (tá¶œ âˆª s âˆˆ f)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Inter.inter",
   "And.intro",
   "And.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (a : Î±) (_s _t : Set Î±) (motive : a âˆˆ _s âˆ© _t â†’ Prop) (x : a âˆˆ _s âˆ© _t),\n  (âˆ€ (has : a âˆˆ _s) (hat : a âˆˆ _t), motive (_ : a âˆˆ _s âˆ§ a âˆˆ _t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Pi.semilatticeInf.proof_1",
   "Pi.semilatticeInf.proof_3",
   "SemilatticeInf.toInf",
   "Pi.partialOrder",
   "Pi.instInfForAll",
   "SemilatticeInf.toPartialOrder",
   "Pi.semilatticeInf.proof_2",
   "SemilatticeInf.mk",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î±' : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ SemilatticeInf (Î±' i)] â†’ SemilatticeInf ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "List.Mem.tail", "List.Mem.head", "List.Mem"],
  "name": "List.Mem.rec",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {motive : (a_1 : List Î±) â†’ List.Mem a a_1 â†’ Prop},\n  (âˆ€ (as : List Î±), motive (a :: as) (_ : List.Mem a (a :: as))) â†’\n    (âˆ€ (b : Î±) {as : List Î±} (a_1 : List.Mem a as), motive as a_1 â†’ motive (b :: as) (_ : List.Mem a (b :: as))) â†’\n      âˆ€ {a_1 : List Î±} (t : List.Mem a a_1), motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Array", "instLENat", "Nat.le_refl", "Nat", "Array.size", "LE.le"],
  "name": "Array.foldlM.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (as : Array Î±), Array.size as â‰¤ Array.size as",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "GaloisInsertion.liftOrderTop",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop.le_top",
   "Preorder",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftBoundedOrder.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : Preorder Î±]\n  [inst_2 : BoundedOrder Î±] (gi : GaloisInsertion l u) (a : Î²), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.foldl_eq_foldr.match_1",
   "eq_self",
   "List.cons",
   "Or",
   "Or.inr",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "List.mem_cons",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.3",
   "True",
   "Eq",
   "PProd",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "List.ilast'",
   "of_eq_true",
   "propext",
   "List",
   "PUnit",
   "List.nil",
   "Eq.trans",
   "id"],
  "name": "List.ilast'_mem",
  "constType": "âˆ€ {Î± : Type u} (a : Î±) (l : List Î±), List.ilast' a l âˆˆ a :: l",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "List.findIdx.go.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ â„• â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : â„•) â†’ ((n : â„•) â†’ motive [] n) â†’ ((a : Î±) â†’ (l : List Î±) â†’ (n : â„•) â†’ motive (a :: l) n) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.mem_replicate.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ Prop) (x : â„•), (Unit â†’ motive 0) â†’ (âˆ€ (n : â„•), motive (Nat.succ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Syntax.isNodeOf", "Bool", "Lean.nullKind", "Nat", "Lean.Syntax"],
  "name": "Lean.Syntax.matchesNull",
  "constType": "Lean.Syntax â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Finset.nodup",
   "Function.Embedding.inj'",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Multiset.Nodup.map",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Finset.map.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} (f : Î± â†ª Î²) (s : Finset Î±), Multiset.Nodup (Multiset.map (â†‘f) s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.mk",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toTop",
   "Preorder.toLE",
   "BooleanAlgebra",
   "BoundedOrder"],
  "name": "BooleanAlgebra.toBoundedOrder",
  "constType": "{Î± : Type u} â†’ [h : BooleanAlgebra Î±] â†’ BoundedOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["Prod.instPartialOrder.proof_3",
   "Prod.instPartialOrder.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.instPreorderProd",
   "inferInstanceAs",
   "Prod",
   "Preorder",
   "Prod.instPartialOrder.proof_2",
   "Prod.instPartialOrder.proof_4",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Prod.instPartialOrder",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : PartialOrder Î±] â†’ [inst : PartialOrder Î²] â†’ PartialOrder (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.mem_attach",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Finset Î±) (x : { x // x âˆˆ s }), x âˆˆ Finset.attach s",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.Syntax.node4",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{Î± : Sort u2} â†’ {a : Î±} â†’ {motive : Î± â†’ Sort u1} â†’ motive a â†’ {b : Î±} â†’ a = b â†’ motive b",
  "constCategory": "Definition"},
 {"references":
  ["IsTrans",
   "Preorder",
   "instIsTransLeToLE.proof_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "instIsTransLeToLE",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±], IsTrans Î± fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "OrderDual"],
  "name": "OrderDual.ofDual",
  "constType": "{Î± : Type u_1} â†’ Î±áµ’áµˆ â‰ƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring â„•",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "Eq",
   "GaloisConnection.l_le",
   "PartialOrder",
   "Inf.mk",
   "Eq.mpr",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "le_inf",
   "PartialOrder.le_antisymm",
   "congrArg",
   "SemilatticeInf",
   "congrFun",
   "id"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeInf Î±]\n  (gi : GaloisInsertion l u) (a b : Î²), a âŠ“ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Directed",
   "implies_congr",
   "True",
   "Eq",
   "Iff.of_eq",
   "ball_congr",
   "iff_self",
   "Mathlib.Data.Subtype._auxLemma.1",
   "Eq.mpr",
   "Iff",
   "forall_congr",
   "Mathlib.Order.Directed._auxLemma.2",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Subtype",
   "id",
   "Membership.mem",
   "funext",
   "Mathlib.Order.Directed._auxLemma.1",
   "DirectedOn",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.40",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "directedOn_iff_directed",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : Set Î±}, DirectedOn r s â†” Directed r Subtype.val",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Eq"],
  "name": "Function.Surjective",
  "constType": "{Î± : Sort uâ‚} â†’ {Î² : Sort uâ‚‚} â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{Î± : Type u} â†’ [self : Bot Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "rfl",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.subset_def",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, (s âŠ† t) = âˆ€ x âˆˆ s, x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "Nat.add_succ",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_mul",
  "constType": "âˆ€ (n m : â„•), Nat.succ n * m = n * m + m",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMod",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "isOpen_biUnion",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "implies_congr",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "Set.compl_sInter",
   "forall_congr",
   "Set.sUnion_image",
   "TopologicalSpace",
   "Set.sUnion",
   "IsClosed",
   "Set.image",
   "Mathlib.Topology.Basic._auxLemma.8",
   "congrArg",
   "Set.sInter",
   "Eq.trans",
   "IsOpen",
   "id"],
  "name": "isClosed_sInter",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set (Set Î±)}, (âˆ€ t âˆˆ s, IsClosed t) â†’ IsClosed (â‹‚â‚€ s)",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "Mathlib.Topology.Order._auxLemma.27",
   "ConditionallyCompleteLattice.toLattice",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "iff_self",
   "TopologicalSpace.coinduced",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "And",
   "Iff",
   "of_eq_true",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Continuous",
   "congr",
   "TopologicalSpace",
   "Mathlib.Topology.Order._auxLemma.31",
   "congrArg",
   "Eq.trans"],
  "name": "continuous_inf_rng",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {tâ‚ : TopologicalSpace Î±} {tâ‚‚ tâ‚ƒ : TopologicalSpace Î²},\n  Continuous f â†” Continuous f âˆ§ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "IsCompl.le_left_iff",
   "Iff",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "IsCompl.symm",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "IsCompl.le_right_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : BoundedOrder Î±] {x y z : Î±}, IsCompl x y â†’ (z â‰¤ y â†” Disjoint z x)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "Bool.false",
   "not",
   "Bool.true",
   "Eq.refl",
   "eq_true_of_decide",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_true'",
  "constType": "âˆ€ (b : Bool), ((!b) = true) = (b = false)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.upperSet._cstage1",
  "constType": "(Î± : Type u_4) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.casesOn",
   "Eq"],
  "name": "Topology.IsLower.noConfusionType",
  "constType":
  "{Î± : Type u_1} â†’\n  {t : TopologicalSpace Î±} â†’ {inst : Preorder Î±} â†’ Sort u â†’ Topology.IsLower Î± â†’ Topology.IsLower Î± â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.pwFilter_map.match_1",
  "constType":
  "âˆ€ {Î² : Type u_1} (motive : List Î² â†’ Prop) (x : List Î²),\n  (Unit â†’ motive []) â†’ (âˆ€ (x : Î²) (xs : List Î²), motive (x :: xs)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "FunLike",
  "constType":
  "Sort u_1 â†’ (Î± : outParam (Sort u_2)) â†’ outParam (Î± â†’ Sort u_3) â†’ Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Finset.eq_of_veq.match_1",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Multiset",
   "Finset",
   "Eq.refl",
   "Finset.val",
   "Multiset.Nodup",
   "Eq.casesOn",
   "Finset.mk",
   "Eq.symm",
   "Eq"],
  "name": "Finset.eq_of_veq",
  "constType": "âˆ€ {Î± : Type u_1} {s t : Finset Î±}, s.val = t.val â†’ s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.mem_iUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.47",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹ƒ i, s i) = âˆƒ i, x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["CoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Top.top",
   "CoheytingAlgebra.top_sdiff",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "CoheytingAlgebra.toHNot",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq"],
  "name": "top_sdiff'",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] (a : Î±), âŠ¤ \\ a = ï¿¢a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.Â«termð“[>]_Â»._closed_2",
   "Topology.Â«termð“[>]_Â»._closed_5"],
  "name": "Topology.Â«termð“[>]_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Option.none", "Option.some", "Option"],
  "name": "Option.rec",
  "constType":
  "{Î± : Type u} â†’\n  {motive : Option Î± â†’ Sort u_1} â†’ motive none â†’ ((val : Î±) â†’ motive (some val)) â†’ (t : Option Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.refl",
   "instLTNat",
   "Eq",
   "Nat.linearOrder",
   "Iff",
   "Preorder.toLT",
   "Iff.trans",
   "Nat",
   "Eq.symm",
   "Fin.mk",
   "Fin.casesOn",
   "Ne",
   "Or",
   "Fin.val",
   "List.pairwise_iff_get",
   "Nat.ne_of_lt",
   "List.length",
   "Or.casesOn",
   "instLTFin",
   "Iff.intro",
   "List.Pairwise",
   "Fin.veq_of_eq",
   "Eq.ndrec",
   "False.elim",
   "List.Nodup",
   "Function.Injective",
   "List",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "List.get",
   "Fin",
   "lt_trichotomy"],
  "name": "List.nodup_iff_injective_get",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±}, List.Nodup l â†” Function.Injective (List.get l)",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_succ",
  "constType":
  "âˆ€ {M : Type u} [self : AddRightCancelMonoid M] (n : â„•) (x : M),\n  AddRightCancelMonoid.nsmul (n + 1) x = x + AddRightCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "Set",
   "Set.inter_self",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "True",
   "Eq",
   "And",
   "of_eq_true",
   "Filter",
   "And.intro",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (f g : Filter Î±), âˆƒ a âˆˆ f, âˆƒ b âˆˆ g, Set.univ = a âˆ© b",
  "constCategory": "Theorem"},
 {"references":
  ["False", "Fin.val", "Fin.val_eq_of_eq", "Not", "Nat", "absurd", "Fin", "Eq"],
  "name": "Fin.ne_of_val_ne",
  "constType": "âˆ€ {n : â„•} {i j : Fin n}, Â¬â†‘i = â†‘j â†’ Â¬i = j",
  "constCategory": "Theorem"},
 {"references": ["Bind"],
  "name": "Bind.mk",
  "constType":
  "{m : Type u â†’ Type v} â†’ ({Î± Î² : Type u} â†’ m Î± â†’ (Î± â†’ m Î²) â†’ m Î²) â†’ Bind m",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "IsAssociative",
   "Inter.inter",
   "Set.instInterSet",
   "Set.inter_isAssoc.proof_1"],
  "name": "Set.inter_isAssoc",
  "constType": "âˆ€ {Î± : Type u}, IsAssociative (Set Î±) fun x x_1 â†¦ x âˆ© x_1",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "Inf.inf",
   "Filter.instInfFilter",
   "Filter.comap",
   "Eq.refl",
   "Filter.prod",
   "Prod",
   "Filter",
   "Prod.fst",
   "Eq"],
  "name": "_private.Mathlib.Topology.Constructions.0.Filter.prod._eq_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Filter Î±) (g : Filter Î²),\n  Filter.prod f g = Filter.comap Prod.fst f âŠ“ Filter.comap Prod.snd g",
  "constCategory": "Theorem"},
 {"references": ["SDiff", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toSDiff",
  "constType": "{Î± : Type u} â†’ [self : BooleanAlgebra Î±] â†’ SDiff Î±",
  "constCategory": "Definition"},
 {"references":
  ["Ord.mk",
   "Nat.decLt",
   "Nat",
   "compareOfLessAndEq",
   "instLTNat",
   "instDecidableEqNat",
   "Ord"],
  "name": "instOrdNat",
  "constType": "Ord â„•",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.Finite.image",
   "Set.ball_image_iff",
   "Set.sInter_image",
   "Set.Finite.isOpen_sInter",
   "Eq.rec",
   "Set",
   "Set.iInter",
   "TopologicalSpace",
   "Set.image",
   "Set.sInter",
   "IsOpen",
   "Iff.mpr",
   "Set.Finite",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.Finite.isOpen_biInter",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] {s : Set Î²} {f : Î² â†’ Set Î±},\n  Set.Finite s â†’ (âˆ€ i âˆˆ s, IsOpen (f i)) â†’ IsOpen (â‹‚ i âˆˆ s, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Std.Logic._auxLemma.39",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Set.ext",
   "And",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_id'",
  "constType": "âˆ€ {Î± : Type u_1} (s : Set Î±), (fun x â†¦ x) '' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Codisjoint",
  "constType":
  "{Î± : Type u_1} â†’ [inst : PartialOrder Î±] â†’ [inst : OrderTop Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.Perm",
   "instLENat",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "LE.le"],
  "name": "List.Subperm.perm_of_length_le.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (motive : lâ‚ <+~ lâ‚‚ â†’ List.length lâ‚‚ â‰¤ List.length lâ‚ â†’ Prop) (x : lâ‚ <+~ lâ‚‚)\n  (x_1 : List.length lâ‚‚ â‰¤ List.length lâ‚),\n  (âˆ€ (_l : List Î±) (p : _l ~ lâ‚) (s : List.Sublist _l lâ‚‚) (h : List.length lâ‚‚ â‰¤ List.length lâ‚),\n      motive (_ : âˆƒ l, âˆƒ (_ : l ~ lâ‚), List.Sublist l lâ‚‚) h) â†’\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.Â«termI^_Â»._closed_8",
   "Lean.Name.str._override"],
  "name": "Topology.Â«termI^_Â»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "ne_false_of_eq_true.match_1",
   "Bool.true",
   "Not",
   "Bool",
   "Eq"],
  "name": "ne_false_of_eq_true",
  "constType": "âˆ€ {b : Bool}, b = true â†’ Â¬b = false",
  "constCategory": "Theorem"},
 {"references": ["Array", "Nat", "List.length", "Array.data"],
  "name": "Array.size",
  "constType": "{Î± : Type u} â†’ Array Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_7",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_5",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_true",
   "OfNat.ofNat",
   "List.Nodup",
   "List.range'",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "optParam",
   "instLTNat",
   "True",
   "Eq",
   "List.nodup_range'"],
  "name": "Mathlib.Data.List.Range._auxLemma.2",
  "constType":
  "âˆ€ (s n : â„•) (step : optParam â„• 1), autoParam (0 < step) _autoâœ â†’ List.Nodup (List.range' s n step) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeSup.sSup_le",
  "constType":
  "âˆ€ {Î± : Type u_9} [self : CompleteSemilatticeSup Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_succ_of_le",
   "OfNat.ofNat",
   "List.Sublist.reverse.match_1._@.Std.Data.List.Lemmas._hyg.8887",
   "instLENat",
   "List",
   "Unit",
   "Nat.le_refl",
   "List.Sublist",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "List.length",
   "Nat",
   "LE.le",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Sublist.length_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, List.Sublist lâ‚ lâ‚‚ â†’ List.length lâ‚ â‰¤ List.length lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Subtype.mk", "Subtype", "Subtype.casesOn"],
  "name": "Subtype.forall.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (motive : { a // p a } â†’ Prop) (x : { a // p a }),\n  (âˆ€ (a : Î±) (b : p a), motive { val := a, property := b }) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "Setoid.r",
   "List.mem_map",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.mem_map",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {s : Multiset Î±}, b âˆˆ Multiset.map f s â†” âˆƒ a âˆˆ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Sublist"],
  "name": "List.Sublist.consâ‚‚",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (a : Î±), List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist (a :: lâ‚) (a :: lâ‚‚)",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.lower._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {b : Set (Set Î±)} (s t : Set Î±) (motive : (âˆƒ tâ‚ƒ âˆˆ b, a âˆˆ tâ‚ƒ âˆ§ tâ‚ƒ âŠ† s âˆ© t) â†’ Prop)\n  (x : âˆƒ tâ‚ƒ âˆˆ b, a âˆˆ tâ‚ƒ âˆ§ tâ‚ƒ âŠ† s âˆ© t),\n  (âˆ€ (u : Set Î±) (huâ‚ : u âˆˆ b) (huâ‚‚ : a âˆˆ u) (huâ‚ƒ : u âŠ† s âˆ© t), motive (_ : âˆƒ tâ‚ƒ âˆˆ b, a âˆˆ tâ‚ƒ âˆ§ tâ‚ƒ âŠ† s âˆ© t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Prod.fst",
   "And.left",
   "Prod.instInfProd",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "And",
   "Inf.mk",
   "And.right",
   "Inf",
   "le_inf",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "Prod",
   "And.intro",
   "SemilatticeInf"],
  "name": "Prod.semilatticeInf.proof_4",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : SemilatticeInf Î±] [inst_1 : SemilatticeInf Î²] (x x_1 x_2 : Î± Ã— Î²),\n  x â‰¤ x_1 â†’ x â‰¤ x_2 â†’ x.1 â‰¤ (x_1 âŠ“ x_2).1 âˆ§ x.2 â‰¤ (x_1 âŠ“ x_2).2",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "SemilatticeSup",
   "And",
   "Iff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "sup_le",
   "le_sup_right",
   "le_trans",
   "Sup.sup",
   "sup_le_iff.match_1",
   "And.intro",
   "LE.le",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, a âŠ” b â‰¤ c â†” a â‰¤ c âˆ§ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "Iff.mp", "False", "Iff", "propext", "Not", "Eq"],
  "name": "iff_false",
  "constType": "âˆ€ (p : Prop), (p â†” False) = Â¬p",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î³ : Type v} â†’ [self : Insert Î± Î³] â†’ Î± â†’ Î³ â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Mathlib.Topology.Order._auxLemma.15",
   "Mathlib.Topology.Order._auxLemma.34",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Set.Subset.rfl",
   "Eq",
   "Eq.mpr",
   "Iff",
   "TopologicalSpace",
   "Filter",
   "TopologicalSpace.induced",
   "And.casesOn",
   "IsOpen",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "Set.preimage",
   "nhds",
   "HasSubset.Subset.trans",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "congr",
   "And.intro",
   "Set.preimage_mono",
   "congrArg",
   "congrFun"],
  "name": "mem_nhds_induced",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [T : TopologicalSpace Î±] (f : Î² â†’ Î±) (a : Î²) (s : Set Î²),\n  s âˆˆ nhds a â†” âˆƒ u âˆˆ nhds (f a), f â»Â¹' u âŠ† s",
  "constCategory": "Theorem"},
 {"references":
  ["UInt32",
   "Decidable",
   "inferInstanceAs",
   "instLEFin",
   "instLEUInt32",
   "UInt32.size",
   "UInt32.decEq.match_1",
   "LE.le",
   "Fin",
   "Fin.decLe"],
  "name": "UInt32.decLe",
  "constType": "(a b : UInt32) â†’ Decidable (a â‰¤ b)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "eq_true",
   "Bool.true",
   "of_decide_eq_true",
   "Decidable",
   "Bool",
   "True",
   "Eq"],
  "name": "eq_true_of_decide",
  "constType": "âˆ€ {p : Prop} {x : Decidable p}, decide p = true â†’ p = True",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context",
   "Monad.toApplicative",
   "Lean.Macro.Context.currMacroScope",
   "Lean.MacroM",
   "Lean.MonadQuotation.mk",
   "Pure.pure",
   "Lean.Macro.withFreshMacroScope",
   "Lean.Macro.instMonadRefMacroM",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.Macro.State",
   "Lean.Macro.Context.mainModule",
   "Lean.Macro.Exception",
   "Lean.Name",
   "Lean.MonadQuotation",
   "Applicative.toPure"],
  "name": "Lean.Macro.instMonadQuotationMacroM",
  "constType": "Lean.MonadQuotation Lean.MacroM",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc"],
  "name": "WellFounded.intro",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, (âˆ€ (a : Î±), Acc r a) â†’ WellFounded r",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_4"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Ne",
   "List.cons",
   "False",
   "Lean.Data.AC.Expr",
   "Eq.refl",
   "List.casesOn",
   "True",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "of_eq_true",
   "HAppend.hAppend",
   "List",
   "eq_false'",
   "Lean.Data.AC.Expr.rec",
   "Not",
   "List.nil",
   "Nat",
   "List.noConfusion",
   "Eq.symm",
   "not_false_eq_true",
   "congrArg",
   "absurd",
   "Lean.Data.AC.Expr.toList",
   "Eq.trans",
   "id"],
  "name": "Lean.Data.AC.Context.toList_nonEmpty",
  "constType": "âˆ€ (e : Lean.Data.AC.Expr), Lean.Data.AC.Expr.toList e â‰  []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MonadQuotation",
  "constType": "(Type â†’ Type) â†’ Type 1",
  "constCategory": "Other"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "GaloisConnection",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set.preimage",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Eq.refl",
   "Preorder",
   "Std.Logic._auxLemma.23",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.57",
   "Eq",
   "Set.instMembershipSet",
   "Set.ext",
   "And",
   "upperBounds",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "GaloisConnection.upperBounds_l_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisConnection l u â†’ âˆ€ (s : Set Î±), upperBounds (l '' s) = u â»Â¹' upperBounds s",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“Ë¢Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HMul Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And.right",
   "upperBounds",
   "Set",
   "lowerBounds",
   "IsGreatest",
   "And.intro",
   "Preorder",
   "And.left",
   "IsLUB",
   "Set.instMembershipSet"],
  "name": "IsGreatest.isLUB",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsGreatest s a â†’ IsLUB s a",
  "constCategory": "Theorem"},
 {"references":
  ["ContravariantClass.elim",
   "instHAdd",
   "HAdd.hAdd",
   "LE",
   "Add",
   "LE.le",
   "ContravariantClass"],
  "name": "le_of_add_le_add_left",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Add Î±] [inst_1 : LE Î±]\n  [inst_2 : ContravariantClass Î± Î± (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1] {a b c : Î±}, a + b â‰¤ a + c â†’ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["WellFounded.fixF", "Acc.rec", "Acc.inv", "Acc.intro", "Acc", "rfl", "Eq"],
  "name": "WellFounded.fixFEq.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {r : Î± â†’ Î± â†’ Prop} {C : Î± â†’ Sort u_2} (F : (x : Î±) â†’ ((y : Î±) â†’ r y x â†’ C y) â†’ C x) (x : Î±)\n  (acx : Acc r x), WellFounded.fixF F x acx = F x fun y p â†¦ WellFounded.fixF F y (_ : Acc (fun y x â†¦ r y x) y)",
  "constCategory": "Theorem"},
 {"references": ["OrderHom.mk", "Monotone", "OrderHom", "Preorder"],
  "name": "OrderHom.rec",
  "constType":
  "{Î± : Type u_6} â†’\n  {Î² : Type u_7} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’\n        {motive : (Î± â†’o Î²) â†’ Sort u} â†’\n          ((toFun : Î± â†’ Î²) â†’ (monotone' : Monotone toFun) â†’ motive { toFun := toFun, monotone' := monotone' }) â†’\n            (t : Î± â†’o Î²) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["Multiset", "Add", "Multiset.add", "Add.mk"],
  "name": "Multiset.instAddMultiset",
  "constType": "{Î± : Type u_1} â†’ Add (Multiset Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.IsIdempotent",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Î±) â†’ Type",
  "constCategory": "Other"},
 {"references": ["UInt32.mk", "UInt32", "UInt32.size", "Fin", "UInt32.rec"],
  "name": "UInt32.casesOn",
  "constType":
  "{motive : UInt32 â†’ Sort u} â†’ (t : UInt32) â†’ ((val : Fin UInt32.size) â†’ motive { val := val }) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["List.Sublist", "List.nil"],
  "name": "List.Sublist.slnil",
  "constType": "âˆ€ {Î± : Type u_1}, List.Sublist [] []",
  "constCategory": "Other"},
 {"references":
  ["Topology.instIsUpperProd.proof_1",
   "instTopologicalSpaceProd",
   "Prod.instPreorderProd",
   "Topology.IsUpper",
   "OrderTop",
   "TopologicalSpace",
   "Prod",
   "Preorder",
   "Preorder.toLE"],
  "name": "Topology.instIsUpperProd",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±]\n  [inst_3 : OrderTop Î±] [inst_4 : Preorder Î²] [inst_5 : TopologicalSpace Î²] [inst_6 : Topology.IsUpper Î²]\n  [inst_7 : OrderTop Î²], Topology.IsUpper (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLowerSet.topology_eq_lowerSetTopology",
  "constType":
  "âˆ€ {Î± : Type u_4} [t : TopologicalSpace Î±] [inst : Preorder Î±] [self : Topology.IsLowerSet Î±], t = Topology.lowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.Range._hyg.236",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "true_and_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.9",
  "constType": "âˆ€ (p : Prop), (True âˆ§ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "And",
   "Filter.mem_sup",
   "SemilatticeSup.toSup",
   "propext",
   "Set",
   "Sup.sup",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.25",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±} {s : Set Î±}, (s âˆˆ f âŠ” g) = (s âˆˆ f âˆ§ s âˆˆ g)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "HasCompl.compl",
   "LE",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "IsUpperSet.compl",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s : Set Î±}, IsUpperSet s â†’ IsLowerSet sá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Lean.SourceInfo",
   "Option.casesOn",
   "Option"],
  "name": "Lean.Syntax.getHeadInfo?.loop.match_1",
  "constType":
  "(motive : Option Lean.SourceInfo â†’ Sort u_1) â†’\n  (x : Option Lean.SourceInfo) â†’ ((info : Lean.SourceInfo) â†’ motive (some info)) â†’ (Unit â†’ motive none) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.instMembershipSet"],
  "name": "Finset.mem_coe",
  "constType": "âˆ€ {Î± : Type u_1} {a : Î±} {s : Finset Î±}, a âˆˆ â†‘s â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Filter.inter_mem",
   "Eq.rec",
   "Set",
   "Filter.generate",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)), (Filter.generate s).sets = s â†’ âˆ€ {x y : Set Î±}, x âˆˆ s â†’ y âˆˆ s â†’ x âˆ© y âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} â†’\n  {M : outParam (Type u_10)} â†’\n    {N : outParam (Type u_11)} â†’\n      [inst : Zero M] â†’ [inst_1 : Zero N] â†’ [self : ZeroHomClass F M N] â†’ FunLike F M fun x â†¦ N",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Data.AC.Context",
  "constType": "Sort u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Continuous_of._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Continuous_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["HImp", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHImp",
  "constType": "{Î± : Type u} â†’ [self : BooleanAlgebra Î±] â†’ HImp Î±",
  "constCategory": "Definition"},
 {"references": ["Trunc.eq", "Subsingleton.intro", "Subsingleton", "Trunc"],
  "name": "Trunc.instSubsingletonTrunc.proof_1",
  "constType": "âˆ€ {Î± : Sort u_1}, Subsingleton (Trunc Î±)",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare", "Ordering", "Eq.refl", "instOrdNat", "Nat", "Eq"],
  "name": "Nat.linearOrder.proof_3",
  "constType": "âˆ€ (a b : â„•), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.erase.match_2",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ Î± â†’ Sort u_2) â†’\n    (x : List Î±) â†’\n      (x_1 : Î±) â†’ ((x : Î±) â†’ motive [] x) â†’ ((a : Î±) â†’ (as : List Î±) â†’ (b : Î±) â†’ motive (a :: as) b) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.inv",
  "constType":
  "{E : Sort u_1} â†’ {Î± : outParam (Sort u_2)} â†’ {Î² : outParam (Sort u_3)} â†’ [self : EquivLike E Î± Î²] â†’ E â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Name.mkStr2",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Symmetric",
  "constType": "{Î² : Sort v} â†’ (Î² â†’ Î² â†’ Prop) â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Ici",
  "constType": "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "Setoid.r",
   "List.Subperm.refl",
   "List",
   "Quot.ind",
   "List.isSetoid",
   "Multiset",
   "LE.le"],
  "name": "Multiset.instPartialOrderMultiset.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} (a : Multiset Î±), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.succ_le_succ",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_succ_of_le",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ n < Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_6"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termÏ€__1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.28",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) = (a âˆ§ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Topology.lower",
   "Topology.IsLower",
   "Topology.IsLower.noConfusionType",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.casesOn",
   "Eq"],
  "name": "Topology.IsLower.noConfusion",
  "constType":
  "{Î± : Type u_1} â†’\n  {t : TopologicalSpace Î±} â†’\n    {inst : Preorder Î±} â†’\n      {P : Sort u} â†’ {v1 v2 : Topology.IsLower Î±} â†’ v1 = v2 â†’ Topology.IsLower.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["BEq"],
  "name": "LawfulBEq",
  "constType": "(Î± : Type u) â†’ [inst : BEq Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{Î± : Type u_2} â†’ [self : LinearOrderedCommSemiring Î±] â†’ Min Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.TFAE._hyg.492",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.mem_iUnion.match_2",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î¹ : Sort u_1} {x : Î±} {s : Î¹ â†’ Set Î±} (motive : (âˆƒ i, x âˆˆ s i) â†’ Prop) (x_1 : âˆƒ i, x âˆˆ s i),\n  (âˆ€ (a : Î¹) (h : x âˆˆ s a), motive (_ : âˆƒ i, x âˆˆ s i)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Continuous_of._closed_6", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Bool.true",
   "Eq.refl",
   "Eq.casesOn",
   "Bool",
   "Eq.symm",
   "Eq"],
  "name": "List.mem_filter.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {p : Î± â†’ Bool} (motive : (a : Î±) â†’ x = a â†’ p a = true â†’ Prop) (a : Î±) (x_1 : x = a)\n  (h : p a = true), (âˆ€ (h : p x = true), motive x (_ : x = x) h) â†’ motive a x_1 h",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "HasSubset.Subset",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "Preorder.toLE",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "top_le_iff",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "BiheytingAlgebra.toCoheytingAlgebra"],
  "name": "Set.univ_subset_iff",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.univ âŠ† s â†” s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "HNot.hnot",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra.sdiff_eq",
   "isCompl_compl",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "HNot.mk",
   "Lattice.toInf",
   "top_inf_eq",
   "Eq.mpr",
   "HImp.himp",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "BoundedOrder.toOrderBot",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "id",
   "BooleanAlgebra.le_top",
   "Bot.bot",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "himp_eq",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "LE.le",
   "GeneralizedHeytingAlgebra.toTop",
   "DistribLattice.toLattice",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "bot_sup_eq",
   "propext",
   "HeytingAlgebra.mk",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.bot_le",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BooleanAlgebra Î±] (a : Î±), âŠ¤ \\ a = ï¿¢a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Singleton.singleton",
   "Set.range_subset_iff",
   "rfl",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Set.range_const_subset",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {c : Î±}, (Set.range fun x â†¦ c) âŠ† {c}",
  "constCategory": "Theorem"},
 {"references":
  ["iInf_subtype",
   "Classical.choose_spec",
   "iInf_range",
   "CompleteSemilatticeInf.toPartialOrder",
   "Classical.choose",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "le_iInf",
   "Subtype.val",
   "Set",
   "CompletelyDistribLattice",
   "Eq.refl",
   "le_iSup",
   "Exists.intro",
   "iSup",
   "rfl",
   "True",
   "Preorder.toLE",
   "Eq",
   "Iff.of_eq",
   "Subtype.property",
   "Set.range",
   "Eq.mpr",
   "iSup_congr_Prop",
   "Set.Elem",
   "iSup_subtype",
   "le_trans",
   "Eq.symm",
   "iInf_le",
   "Eq.trans",
   "CompletelyDistribLattice.iInf_iSup_eq",
   "CompleteLattice.toSupSet",
   "Subtype",
   "id",
   "iInf_congr_Prop",
   "eq_self",
   "Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "funext",
   "iSup_range",
   "iSup_le",
   "LE.le",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_refl",
   "instTransEq",
   "le_iInf_iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "congrArg",
   "Subtype.mk"],
  "name": "iInf_iSup_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} {Îº : Î¹ â†’ Sort w'} [inst : CompletelyDistribLattice Î±] {f : (a : Î¹) â†’ Îº a â†’ Î±},\n  â¨… a, â¨† b, f a b = â¨† g, â¨… a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termð“._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype.complete",
   "Fintype",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Finset.mem_univ",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] (x : Î±), x âˆˆ Finset.univ",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT", "Unit", "Lean.Syntax"],
  "name": "Lean.PrettyPrinter.UnexpandM",
  "constType": "Type â†’ Type",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "LE.le",
   "Preorder.toLE",
   "le_isGLB_iff",
   "Set.instMembershipSet",
   "Set.range",
   "Iff",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "lowerBounds",
   "Iff.trans",
   "Set.forall_range_iff",
   "CompleteLattice.toCompleteSemilatticeInf",
   "isGLB_iInf"],
  "name": "le_iInf_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {a : Î±}, a â‰¤ iInf f â†” âˆ€ (i : Î¹), a â‰¤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet", "Eq"],
  "name": "Set.insert",
  "constType": "{Î± : Type u_1} â†’ Î± â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_9",
  "constType": "âˆ€ {Î± : Type u_1} (x y : Set Î±), x \\ y = x âŠ“ yá¶œ",
  "constCategory": "Theorem"},
 {"references": ["And", "and_congr_left_iff", "Iff", "propext", "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.9",
  "constType": "âˆ€ {a c b : Prop}, (a âˆ§ c â†” b âˆ§ c) = (c â†’ (a â†” b))",
  "constCategory": "Theorem"},
 {"references":
  ["sup_compl_eq_top",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Top.top",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Eq.refl",
   "inf_sup_left",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra.sdiff_eq",
   "Preorder.toLE",
   "BooleanAlgebra",
   "inf_top_eq",
   "Eq",
   "OrderTop.toTop",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "BooleanAlgebra.toSDiff",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toTop",
   "id"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BooleanAlgebra Î±] (a b : Î±), a âŠ“ b âŠ” a \\ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "GaloisInsertion.choice",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisInsertion.choice_eq",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±}\n  (self : GaloisInsertion l u) (a : Î±) (h : u (l a) â‰¤ a), GaloisInsertion.choice self a h = l a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "And",
   "setOf",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Set",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "definition._@.Mathlib.Topology.Basic._hyg.10536",
  "constType": "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ Î± â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Macro.Context", "_private.Init.Prelude.0.Lean.Macro.MethodsRef"],
  "name": "Lean.Macro.Context.methods",
  "constType": "Lean.Macro.Context â†’ Lean.Macro.MethodsRef",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "eq_true",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.57",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (a : Î±), List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist (a :: lâ‚) (a :: lâ‚‚) = True",
  "constCategory": "Theorem"},
 {"references":
  ["InfTopHomClass",
   "Top",
   "outParam",
   "Top.top",
   "Inf",
   "InfHomClass.toFunLike",
   "FunLike.coe",
   "Eq",
   "InfHomClass"],
  "name": "InfTopHomClass.mk",
  "constType":
  "{F : Type u_7} â†’\n  {Î± : outParam (Type u_8)} â†’\n    {Î² : outParam (Type u_9)} â†’\n      [inst : Inf Î±] â†’\n        [inst_1 : Inf Î²] â†’\n          [inst_2 : Top Î±] â†’\n            [inst_3 : Top Î²] â†’ [toInfHomClass : InfHomClass F Î± Î²] â†’ (âˆ€ (f : F), â†‘f âŠ¤ = âŠ¤) â†’ InfTopHomClass F Î± Î²",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "compl_compl",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Set.compl_sUnion",
   "Set.sUnion",
   "Set.image",
   "Set.sInter",
   "Eq.symm",
   "id"],
  "name": "Set.sUnion_eq_compl_sInter_compl",
  "constType": "âˆ€ {Î± : Type u_1} (S : Set (Set Î±)), â‹ƒâ‚€ S = (â‹‚â‚€ (compl '' S))á¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.ext",
   "upperBounds_mono_mem",
   "And.right",
   "upperBounds",
   "Set",
   "lowerBounds",
   "Set.Ici",
   "Preorder",
   "And.left",
   "IsLUB",
   "Eq",
   "Set.instMembershipSet"],
  "name": "IsLUB.upperBounds_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, IsLUB s a â†’ upperBounds s = Set.Ici a",
  "constCategory": "Theorem"},
 {"references": ["and_or_left", "And", "Or", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.25",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ (b âˆ¨ c)) = (a âˆ§ b âˆ¨ a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Lean.Name",
  "constCategory": "Other"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Mathlib.Topology.Bases._auxLemma.2",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b âˆ§ c) = (b âˆ§ a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "Continuous",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "inf_inf_distrib_left",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Eq.refl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "inf_bot_eq",
   "BooleanAlgebra.sdiff_eq",
   "Preorder.toLE",
   "BooleanAlgebra",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "Eq.ndrec",
   "OrderBot.toBot",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.toSDiff",
   "Eq.symm",
   "BooleanAlgebra.toDistribLattice",
   "inf_compl_eq_bot'",
   "BoundedOrder.toOrderBot",
   "id"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : BooleanAlgebra Î±] (a b : Î±), a âŠ“ b âŠ“ a \\ b = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedHeytingAlgebra.le_himp_iff",
  "constType":
  "âˆ€ {Î± : Type u_4} [self : GeneralizedHeytingAlgebra Î±] (a b c : Î±), a â‰¤ b â‡¨ c â†” a âŠ“ b â‰¤ c",
  "constCategory": "Definition"},
 {"references": ["Preorder"],
  "name": "GaloisCoinsertion",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ (Î± â†’ Î²) â†’ (Î² â†’ Î±) â†’ Type (max u v)",
  "constCategory": "Other"},
 {"references": ["UInt32.mk", "UInt32", "UInt32.size", "Fin"],
  "name": "UInt32.rec",
  "constType":
  "{motive : UInt32 â†’ Sort u} â†’ ((val : Fin UInt32.size) â†’ motive { val := val }) â†’ (t : UInt32) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Membership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} â†’ {B : Type u_2} â†’ [i : SetLike A B] â†’ Membership B A",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {motive : Exists p â†’ Prop} (t : Exists p),\n  (âˆ€ (w : Î±) (h : p w), motive (_ : Exists p)) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.mk",
  "constType": "{Î± : Type u_3} â†’ (Î± â†’ Î±) â†’ HasCompl Î±",
  "constCategory": "Other"},
 {"references":
  ["And.rec",
   "Iff.intro",
   "And",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "And.imp",
   "And.intro",
   "Or.imp_right",
   "Or.rec"],
  "name": "or_and_left",
  "constType": "âˆ€ {a b c : Prop}, a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "or_self.match_1",
  "constType":
  "âˆ€ (p : Prop) (motive : p âˆ¨ p â†’ Prop) (x : p âˆ¨ p),\n  (âˆ€ (h : p), motive (_ : p âˆ¨ p)) â†’ (âˆ€ (h : p), motive (_ : p âˆ¨ p)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAppend",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompletelyDistribLattice",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["LE.mk", "And", "Prod.snd", "LE", "Prod", "Prod.fst", "LE.le"],
  "name": "Prod.instLEProd",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : LE Î±] â†’ [inst : LE Î²] â†’ LE (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Min",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Decidable.casesOn",
   "Decidable.isFalse",
   "List.instMembershipList",
   "List",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "List.decidableBAll.match_3",
  "constType":
  "{Î± : Type u_1} â†’\n  (p : Î± â†’ Prop) â†’\n    (xs : List Î±) â†’\n      (motive : Decidable (âˆ€ x âˆˆ xs, p x) â†’ Sort u_2) â†’\n        (x : Decidable (âˆ€ x âˆˆ xs, p x)) â†’\n          ((hâ‚‚ : âˆ€ x âˆˆ xs, p x) â†’ motive (isTrue hâ‚‚)) â†’ ((hâ‚‚ : Â¬âˆ€ x âˆˆ xs, p x) â†’ motive (isFalse hâ‚‚)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["outParam", "FunLike", "ContinuousMapClass", "TopologicalSpace"],
  "name": "ContinuousMapClass.toFunLike",
  "constType":
  "{F : Type u_1} â†’\n  {Î± : outParam (Type u_2)} â†’\n    {Î² : outParam (Type u_3)} â†’\n      [inst : TopologicalSpace Î±] â†’\n        [inst_1 : TopologicalSpace Î²] â†’ [self : ContinuousMapClass F Î± Î²] â†’ FunLike F Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references": ["Iff", "False", "iff_true_intro", "Not", "not_false", "True"],
  "name": "not_false_iff",
  "constType": "Â¬False â†” True",
  "constCategory": "Theorem"},
 {"references": ["le_rfl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.lift.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î²] (f : Î± â†’ Î²) (x : Î±), f x â‰¤ f x",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Char",
   "List",
   "Unit",
   "Unit.unit",
   "List.casesOn",
   "List.nil"],
  "name": "String.utf8ByteSize.go.match_1",
  "constType":
  "(motive : List Char â†’ Sort u_1) â†’\n  (x : List Char) â†’ (Unit â†’ motive []) â†’ ((c : Char) â†’ (cs : List Char) â†’ motive (c :: cs)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "OrderDual.lattice.proof_6",
   "OrderDual.lattice.proof_5",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "OrderDual.lattice.proof_1",
   "SemilatticeSup",
   "OrderDual.lattice.proof_2",
   "OrderDual.semilatticeInf",
   "OrderDual.lattice.proof_4",
   "SemilatticeSup.toSup",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice.proof_3",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "OrderDual.lattice",
  "constType": "(Î± : Type u_1) â†’ [inst : Lattice Î±] â†’ Lattice Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.Context", "Nat"],
  "name": "Lean.Macro.Context.currRecDepth",
  "constType": "Lean.Macro.Context â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{Î± : Type u} â†’ [self : NonUnitalNonAssocSemiring Î±] â†’ AddCommMonoid Î±",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.gt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left.match_1",
  "constType":
  "âˆ€ {a b c : â„•} (motive : (âˆƒ k, a + b + k = a + c) â†’ Prop) (x : âˆƒ k, a + b + k = a + c),\n  (âˆ€ (d : â„•) (hd : a + b + d = a + c), motive (_ : âˆƒ k, a + b + k = a + c)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsClosed_of._closed_4"],
  "name": "Topology.IsClosed_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset.trans",
   "HasSubset.Subset",
   "Exists.intro",
   "Set.Subset.rfl",
   "Eq",
   "Iff.intro",
   "Filter.comap_principal.match_1",
   "Filter.principal",
   "And",
   "Set.instHasSubsetSet",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Filter.ext",
   "Set.preimage_mono",
   "instMembershipSetFilter"],
  "name": "Filter.comap_principal",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {m : Î± â†’ Î²} {t : Set Î²}, Filter.comap m (Filter.principal t) = Filter.principal (m â»Â¹' t)",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "GaloisInsertion", "Preorder.toLE"],
  "name": "GaloisInsertion.choice",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’ {l : Î± â†’ Î²} â†’ {u : Î² â†’ Î±} â†’ GaloisInsertion l u â†’ (x : Î±) â†’ u (l x) â‰¤ x â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instLENat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "LE.le",
   "True",
   "Eq"],
  "name": "Init.Data.Nat.Basic._auxLemma.1",
  "constType": "âˆ€ (n : â„•), (0 â‰¤ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM",
   "EStateM.modifyGet.match_1",
   "Prod",
   "EStateM.Result"],
  "name": "EStateM.modifyGet",
  "constType": "{Îµ Ïƒ Î± : Type u} â†’ (Ïƒ â†’ Î± Ã— Ïƒ) â†’ EStateM Îµ Ïƒ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.mem_filter",
   "List.filter",
   "List.instMembershipList",
   "propext",
   "List",
   "Bool.true",
   "Bool",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {x : Î±} {p : Î± â†’ Bool} {as : List Î±}, (x âˆˆ List.filter p as) = (x âˆˆ as âˆ§ p x = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "absurd",
   "instLTNat"],
  "name": "Nat.ge_of_not_lt",
  "constType": "âˆ€ {n m : â„•}, Â¬n < m â†’ n â‰¥ m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.removeNeutrals",
   "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.loop.match_1.splitter",
   "Lean.IsNeutral.right_neutral",
   "instDecidableEqList",
   "List.casesOn",
   "Eq.refl",
   "Lean.Data.AC.Context.unwrap_isNeutral",
   "True",
   "instDecidableEqNat",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.List.two_step_induction",
   "Lean.IsNeutral.left_neutral",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Lean.Data.AC.ContextInformation.isNeutral",
   "Lean.Data.AC.EvalInformation.evalOp",
   "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.splitter",
   "id",
   "eq_self",
   "funext",
   "List.cons",
   "False",
   "Unit",
   "Lean.Data.AC.removeNeutrals.loop.match_1",
   "Lean.Data.AC.removeNeutrals.match_1",
   "eq_false_of_decide",
   "_private.Init.Data.AC.0.Lean.Data.AC.evalList._eq_3",
   "instDecidableFalse",
   "Bool.casesOn",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "False.elim",
   "Lean.Data.AC.removeNeutrals.loop",
   "of_eq_true",
   "Bool.false",
   "List",
   "instDecidableForAll",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Eq.mp",
   "congr",
   "Bool",
   "List.noConfusion",
   "congrArg",
   "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.eq_2",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_removeNeutrals",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±) (e : List â„•),\n  Lean.Data.AC.evalList Î± ctx (Lean.Data.AC.removeNeutrals ctx e) = Lean.Data.AC.evalList Î± ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop", "Top.top", "le_top", "OrderTop", "LE", "IsTop"],
  "name": "isTop_top",
  "constType": "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderTop Î±], IsTop âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termI^_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {l : List Î±}, (a âˆˆ b :: l) = (a = b âˆ¨ a âˆˆ l)",
  "constCategory": "Theorem"},
 {"references": ["List", "List.range.loop", "List.nil", "Nat"],
  "name": "List.range",
  "constType": "â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "Inter.inter",
   "Exists.intro",
   "rfl",
   "Preorder.toLE",
   "Set.Subset.rfl",
   "True",
   "Mathlib.Data.Set.Basic._auxLemma.26",
   "Eq",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Eq.mpr",
   "Filter",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "HasSubset.Subset",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "And",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "congr",
   "And.intro",
   "Mathlib.Data.Set.Basic._auxLemma.27",
   "congrArg",
   "le_antisymm",
   "and_self",
   "Mathlib.Order.Filter.Basic._auxLemma.42",
   "Set.instInterSet"],
  "name": "Filter.inf_principal",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, Filter.principal s âŠ“ Filter.principal t = Filter.principal (s âˆ© t)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_5",
  "constType": "65535 < UInt32.size",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} â†’ [self : AddMonoid M] â†’ AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Top.top",
   "Inf.inf",
   "inf_of_le_right",
   "le_top",
   "SemilatticeInf.toPartialOrder",
   "OrderTop",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "top_inf_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] [inst_1 : OrderTop Î±] {a : Î±}, âŠ¤ âŠ“ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set.ball_empty_iff",
   "Set",
   "Set.instEmptyCollectionSet",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.18",
  "constType": "âˆ€ {Î± : Type u} {p : Î± â†’ Prop}, (âˆ€ x âˆˆ âˆ…, p x) = True",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.decidableBEx.match_5",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ Sort u_2) â†’\n    (x : List Î±) â†’ (Unit â†’ motive []) â†’ ((x : Î±) â†’ (xs : List Î±) â†’ motive (x :: xs)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Acc.rec", "Acc.intro", "Acc"],
  "name": "Acc.recOn",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : (a : Î±) â†’ Acc r a â†’ Sort u_1} â†’\n      {a : Î±} â†’\n        (t : Acc r a) â†’\n          ((x : Î±) â†’\n              (h : âˆ€ (y : Î±), r y x â†’ Acc r y) â†’\n                ((y : Î±) â†’ (a : r y x) â†’ motive y (_ : Acc r y)) â†’ motive x (_ : Acc r x)) â†’\n            motive a t",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "UpperSet.coe_iInf",
   "UpperSet.instInfSetUpperSet",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.Ici",
   "Mathlib.Order.UpperLower.Basic._auxLemma.94",
   "UpperSet",
   "SetLike.instMembership",
   "Preorder.toLE",
   "True",
   "Eq",
   "iff_self",
   "Iff.of_eq",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "upperClosure",
   "Set.iUnion_congr_Prop",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "UpperSet.Ici",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "iInf",
   "UpperSet.ext",
   "congr",
   "congrArg",
   "SetLike.coe",
   "exists_prop_congr'"],
  "name": "UpperSet.iInf_Ici",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (s : Set Î±), â¨… a âˆˆ s, UpperSet.Ici a = upperClosure s",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.mp_mem.match_1",
   "Membership.mem",
   "setOf",
   "Filter.inter_mem",
   "Set",
   "Filter.mem_of_superset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mp_mem",
  "constType":
  "âˆ€ {Î± : Type u} {f : Filter Î±} {s t : Set Î±}, s âˆˆ f â†’ {x | x âˆˆ s â†’ x âˆˆ t} âˆˆ f â†’ t âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["add_right_cancel",
   "Function.Injective",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add"],
  "name": "add_left_injective",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G), Function.Injective fun x â†¦ x + a",
  "constCategory": "Theorem"},
 {"references":
  ["Char.val",
   "UInt32",
   "Char",
   "Char.val_eq_of_eq",
   "False",
   "Not",
   "absurd",
   "Eq"],
  "name": "Char.ne_of_val_ne",
  "constType": "âˆ€ {c d : Char}, Â¬c.val = d.val â†’ Â¬c = d",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.succ_le_of_lt",
   "instAddNat",
   "instSubNat",
   "Nat.succ_sub",
   "Nat.sub_le_sub_right",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "instLTNat",
   "Eq",
   "Nat.add_sub_cancel_left",
   "instLENat",
   "Eq.ndrec",
   "LT.lt",
   "Eq.mp",
   "Nat",
   "Nat.succ"],
  "name": "Nat.sub_lt_left_of_lt_add",
  "constType": "âˆ€ {n k m : â„•}, n â‰¤ k â†’ k < n + m â†’ k - n < m",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "Set.univ", "rfl", "Eq"],
  "name": "Set.preimage_univ",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²}, f â»Â¹' Set.univ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "HasSubset.Subset", "HasSubset", "Eq", "subset_of_eq"],
  "name": "Eq.subset'",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsRefl Î± fun x x_1 â†¦ x âŠ† x_1], a = b â†’ a âŠ† b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "induced_id",
   "Inducing.mk",
   "Topology.lowerSet",
   "Eq.refl",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Eq.mpr",
   "Topology.WithLowerSet",
   "Eq.ndrec",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Topology.WithLowerSet.ofLowerSet",
   "TopologicalSpace.induced",
   "Topology.IsLowerSet.topology_eq",
   "id"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±],\n  Inducing â†‘Topology.WithLowerSet.ofLowerSet",
  "constCategory": "Theorem"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.mk",
  "constType":
  "âˆ€ {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {r : N â†’ N â†’ Prop}, Contravariant M N Î¼ r â†’ ContravariantClass M N Î¼ r",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "_auto._@.Mathlib.Topology.Homeomorph._hyg.17",
   "Equiv.invFun",
   "Continuous",
   "Homeomorph",
   "_auto._@.Mathlib.Topology.Homeomorph._hyg.46",
   "TopologicalSpace",
   "autoParam"],
  "name": "Homeomorph.mk",
  "constType":
  "{X : Type u_4} â†’\n  {Y : Type u_5} â†’\n    [inst : TopologicalSpace X] â†’\n      [inst_1 : TopologicalSpace Y] â†’\n        (toEquiv : X â‰ƒ Y) â†’\n          autoParam (Continuous toEquiv.toFun) _autoâœ â†’ autoParam (Continuous toEquiv.invFun) _autoâœÂ¹ â†’ X â‰ƒâ‚œ Y",
  "constCategory": "Other"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "Membership.mem",
   "Exists",
   "List.instMembershipList",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.12",
   "Std.Logic._auxLemma.23",
   "implies_congr",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.57",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "List",
   "forall_congr",
   "List.map",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.forall_mem_map_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {l : List Î±} {P : Î² â†’ Prop}, (âˆ€ i âˆˆ List.map f l, P i) â†” âˆ€ j âˆˆ l, P (f j)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_3",
   "Lean.Name.str._override"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.Variable"],
  "name": "Lean.Data.AC.Variable.value",
  "constType": "{Î± : Sort u} â†’ {op : Î± â†’ Î± â†’ Î±} â†’ Lean.Data.AC.Variable op â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Iff",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpper.toUpper_inj",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±}, â†‘Topology.WithUpper.toUpper a = â†‘Topology.WithUpper.toUpper b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.booleanAlgebra.proof_3",
   "HeytingAlgebra",
   "Pi.booleanAlgebra.proof_1",
   "Pi.booleanAlgebra.proof_7",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "SDiff.sdiff",
   "Pi.booleanAlgebra.proof_2",
   "BooleanAlgebra",
   "Pi.heytingAlgebra",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.distribLattice",
   "BooleanAlgebra.mk",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Pi.booleanAlgebra.proof_6",
   "DistribLattice",
   "Pi.booleanAlgebra.proof_5",
   "SDiff.mk",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.sdiff",
   "BooleanAlgebra.toSDiff",
   "SDiff",
   "BooleanAlgebra.toDistribLattice",
   "HeytingAlgebra.toHasCompl",
   "Pi.booleanAlgebra.proof_4"],
  "name": "Pi.booleanAlgebra",
  "constType":
  "{Î¹ : Type u} â†’ {Î± : Î¹ â†’ Type v} â†’ [inst : (i : Î¹) â†’ BooleanAlgebra (Î± i)] â†’ BooleanAlgebra ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView", "List", "Lean.Name", "Lean.MacroScope"],
  "name": "Lean.MacroScopesView.mk",
  "constType":
  "Lean.Name â†’ Lean.Name â†’ Lean.Name â†’ List Lean.MacroScope â†’ Lean.MacroScopesView",
  "constCategory": "Other"},
 {"references":
  ["_obj", "_neutral", "Topology.IsLowerSet.WithLowerSetHomeomorph._rarg"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u â†’ Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Set.range", "SupSet", "Eq.refl", "SupSet.sSup", "iSup", "Eq"],
  "name": "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SupSet Î±] {Î¹ : Sort u_9} (s : Î¹ â†’ Î±), iSup s = sSup (Set.range s)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Exists.intro", "Exists.casesOn", "Subtype.mk", "Subtype"],
  "name": "Subtype.exists.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}\n  (motive : (âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }) â†’ Prop)\n  (x : âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }),\n  (âˆ€ (a : Î±) (b : p a) (h : q { val := a, property := b }),\n      motive (_ : âˆƒ a, âˆƒ (b : p a), q { val := a, property := b })) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "And",
   "Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.map",
   "List.get",
   "List.length",
   "Exists.casesOn",
   "instLTFin",
   "Fin",
   "Eq"],
  "name": "List.sublist_eq_map_get.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}\n  (motive : (âˆƒ is, lâ‚ = List.map (List.get lâ‚‚) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is) â†’ Prop)\n  (IH : âˆƒ is, lâ‚ = List.map (List.get lâ‚‚) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is),\n  (âˆ€ (is : List (Fin (List.length lâ‚‚))) (IH : lâ‚ = List.map (List.get lâ‚‚) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is),\n      motive (_ : âˆƒ is, lâ‚ = List.map (List.get lâ‚‚) is âˆ§ List.Pairwise (fun x x_1 â†¦ x < x_1) is)) â†’\n    motive IH",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "And.intro",
   "And.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mp_mem.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {s t : Set Î±} (x : Î±) (motive : x âˆˆ s âˆ© {x | x âˆˆ s â†’ x âˆˆ t} â†’ Prop)\n  (x_1 : x âˆˆ s âˆ© {x | x âˆˆ s â†’ x âˆˆ t}),\n  (âˆ€ (hâ‚ : x âˆˆ s) (hâ‚‚ : x âˆˆ {x | x âˆˆ s â†’ x âˆˆ t}), motive (_ : x âˆˆ s âˆ§ x âˆˆ {x | x âˆˆ s â†’ x âˆˆ t})) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.IsClosed_of._closed_6",
   "Topology.IsClosed_of._closed_2"],
  "name": "Topology.IsClosed_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Equiv.refl",
   "lcProof",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSetOrderIso._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithUpperSet Î± â‰ƒo Î±",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Eq.rec",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "Eq.symm",
   "absurd",
   "instLTNat",
   "Eq"],
  "name": "Nat.ne_of_lt",
  "constType": "âˆ€ {a b : â„•}, a < b â†’ a â‰  b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "instDecidableEqList",
   "Eq.refl",
   "List.casesOn",
   "implies_congr",
   "True",
   "instDecidableEqNat",
   "Eq",
   "Lean.Data.AC.Context.assoc",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "eq_false'",
   "instDecidableNot",
   "Lean.Data.AC.List.two_step_induction",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "id",
   "true_implies",
   "eq_self",
   "Ne",
   "List.append",
   "List.cons",
   "False",
   "eq_false_of_decide",
   "Lean.Data.AC.Context.op",
   "instHAppend",
   "False.elim",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "List.instAppendList",
   "of_eq_true",
   "List",
   "Bool.false",
   "HAppend.hAppend",
   "Eq.mp",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Not",
   "Bool",
   "List.noConfusion",
   "congrArg"],
  "name": "Lean.Data.AC.Context.evalList_append",
  "constType":
  "âˆ€ {Î± : Sort u_1} (ctx : Lean.Data.AC.Context Î±) (l r : List â„•),\n  l â‰  [] â†’\n    r â‰  [] â†’\n      Lean.Data.AC.evalList Î± ctx (List.append l r) =\n        Lean.Data.AC.Context.op ctx (Lean.Data.AC.evalList Î± ctx l) (Lean.Data.AC.evalList Î± ctx r)",
  "constCategory": "Theorem"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "Ne",
   "And",
   "Iff.mp",
   "False",
   "List.Pairwise.map",
   "List.Nodup",
   "List.Pairwise.and_mem",
   "List.instMembershipList",
   "List",
   "List.map",
   "List.Nodup.map_on.match_1",
   "Eq"],
  "name": "List.Nodup.map_on",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {l : List Î±} {f : Î± â†’ Î²},\n  (âˆ€ x âˆˆ l, âˆ€ y âˆˆ l, f x = f y â†’ x = y) â†’ List.Nodup l â†’ List.Nodup (List.map f l)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Sup",
   "Prod.instSupProd",
   "SemilatticeSup.mk",
   "Sup.mk",
   "PartialOrder",
   "Prod.semilatticeSup.proof_3",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "Prod.semilatticeSup.proof_4",
   "Prod",
   "Sup.sup",
   "Prod.semilatticeSup.proof_2",
   "Prod.semilatticeSup.proof_1",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup",
  "constType":
  "(Î± : Type u) â†’ (Î² : Type v) â†’ [inst : SemilatticeSup Î±] â†’ [inst : SemilatticeSup Î²] â†’ SemilatticeSup (Î± Ã— Î²)",
  "constCategory": "Definition"},
 {"references":
  ["List.eraseP_cons_of_pos",
   "Exists",
   "List.below",
   "List.brecOn",
   "List.instMembershipList",
   "Eq.refl",
   "dite",
   "Exists.intro",
   "Iff.mpr",
   "True",
   "List.eraseP_cons_of_neg",
   "Eq",
   "PProd",
   "Bool.of_not_eq_true",
   "Eq.mpr",
   "List.eraseP",
   "List.rec",
   "Bool.true",
   "PUnit",
   "List.nil",
   "List.Sublist.eq_of_length.match_1",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "instDecidableEqBool",
   "Membership.mem",
   "eq_self",
   "List.exists_of_eraseP.match_1",
   "List.cons",
   "False",
   "List.Mem",
   "eq_false_of_decide",
   "List.forall_mem_cons",
   "List.cons_append",
   "List.exists_of_eraseP.match_2",
   "instHAppend",
   "And",
   "PProd.fst",
   "Eq.ndrec",
   "List.instAppendList",
   "of_eq_true",
   "Bool.false",
   "HAppend.hAppend",
   "List",
   "List.forall_mem_nil",
   "congr",
   "Not",
   "Bool",
   "And.intro",
   "List.exists_of_eraseP.match_3",
   "congrArg",
   "and_self",
   "congrFun"],
  "name": "List.exists_of_eraseP",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Bool} {l : List Î±} {a : Î±},\n  a âˆˆ l â†’\n    p a = true â†’ âˆƒ a, âˆƒ lâ‚, âˆƒ lâ‚‚, (âˆ€ b âˆˆ lâ‚, Â¬p b = true) âˆ§ p a = true âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ List.eraseP p l = lâ‚ ++ lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "Finset.toSet",
   "Set",
   "Finset",
   "Set.instCanLiftSetFinsetToSetFinite.proof_1",
   "Set.Finite"],
  "name": "Set.instCanLiftSetFinsetToSetFinite",
  "constType":
  "âˆ€ {Î± : Type u}, CanLift (Set Î±) (Finset Î±) Finset.toSet Set.Finite",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "implies_congr",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "True",
   "iff_self",
   "Mathlib.Topology.Basic._auxLemma.5",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Continuous",
   "TopologicalSpace",
   "Function.Surjective.forall",
   "compl_surjective",
   "Iff.trans",
   "IsClosed",
   "congrArg",
   "Eq.trans",
   "IsOpen",
   "congrFun",
   "continuous_def"],
  "name": "continuous_iff_isClosed",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†” âˆ€ (s : Set Î²), IsClosed s â†’ IsClosed (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_11"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "autoParam",
   "LE.le",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toStrictOrderedSemiring : StrictOrderedSemiring Î±] â†’\n    [toMin : Min Î±] â†’\n      [toMax : Max Î±] â†’\n        [toOrd : Ord Î±] â†’\n          (âˆ€ (a b : Î±), a â‰¤ b âˆ¨ b â‰¤ a) â†’\n            (decidableLE : DecidableRel fun x x_1 â†¦ x â‰¤ x_1) â†’\n              (decidableEq : DecidableEq Î±) â†’\n                (decidableLT : DecidableRel fun x x_1 â†¦ x < x_1) â†’\n                  autoParam (âˆ€ (a b : Î±), min a b = if a â‰¤ b then a else b) _autoâœ â†’\n                    autoParam (âˆ€ (a b : Î±), max a b = if a â‰¤ b then b else a) _autoâœÂ¹ â†’\n                      autoParam (âˆ€ (a b : Î±), compare a b = compareOfLessAndEq a b) _autoâœÂ² â†’ LinearOrderedSemiring Î±",
  "constCategory": "Other"},
 {"references":
  ["_obj", "Topology.Homotopy.Â«termÎ©^Â»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.Â«termÎ©^Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List",
   "List.casesOn",
   "List.nil",
   "List.noConfusion",
   "Nat",
   "Eq"],
  "name":
  "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.splitter",
  "constType":
  "(motive : List â„• â†’ Sort u_1) â†’ (x : List â„•) â†’ motive [] â†’ ((ys : List â„•) â†’ (ys = [] â†’ False) â†’ motive ys) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Char.mk", "UInt32", "Char", "UInt32.isValidChar"],
  "name": "Char.rec",
  "constType":
  "{motive : Char â†’ Sort u} â†’\n  ((val : UInt32) â†’ (valid : UInt32.isValidChar val) â†’ motive { val := val, valid := valid }) â†’ (t : Char) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_1"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u â†’ Type u",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadState", "Prod"],
  "name": "MonadState.modifyGet",
  "constType":
  "{Ïƒ : outParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ [self : MonadState Ïƒ m] â†’ {Î± : Type u} â†’ (Ïƒ â†’ Î± Ã— Ïƒ) â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.zero_add",
  "constType":
  "âˆ€ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Prod.instPreorderProd.match_5",
   "Prod.snd",
   "Prod.instPreorderProd.match_4",
   "Prod.instLEProd",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Prod.mk",
   "Prod.instPreorderProd.match_2",
   "Prod.instPreorderProd.match_3",
   "inferInstanceAs",
   "LE",
   "Prod",
   "le_trans",
   "And.intro"],
  "name": "Prod.instPreorderProd.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Preorder Î±] [inst_1 : Preorder Î²] (x x_1 x_2 : Î± Ã— Î²),\n  x â‰¤ x_1 â†’ x_1 â‰¤ x_2 â†’ x â‰¤ x_2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Char",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["BiheytingAlgebra",
   "BooleanAlgebra.le_top",
   "BooleanAlgebra.toBiheytingAlgebra.proof_2",
   "HasCompl.compl",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.toBiheytingAlgebra.proof_1",
   "GeneralizedCoheytingAlgebra.sdiff_le_iff",
   "BooleanAlgebra",
   "HNot.mk",
   "DistribLattice.toLattice",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "BooleanAlgebra.toHImp",
   "GeneralizedCoheytingAlgebra",
   "BiheytingAlgebra.mk",
   "HeytingAlgebra.mk",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toBiheytingAlgebra.proof_3",
   "BooleanAlgebra.toTop",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra",
  "constType": "{Î± : Type u} â†’ [inst : BooleanAlgebra Î±] â†’ BiheytingAlgebra Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.univ_sets",
   "Set",
   "Filter",
   "Set.univ",
   "instMembershipSetFilter"],
  "name": "Filter.univ_mem",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±}, Set.univ âˆˆ f",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b : Î±}, a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termð“",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Â«termð“[>]_Â»._closed_4",
   "Topology.Â«termð“[_]_Â»._closed_9"],
  "name": "Topology.Â«termð“[>]_Â»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Fin.val",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Nat",
   "Fin",
   "Eq"],
  "name": "instDecidableEqFin.match_1",
  "constType":
  "(n : â„•) â†’\n  (i j : Fin n) â†’\n    (motive : Decidable (â†‘i = â†‘j) â†’ Sort u_1) â†’\n      (x : Decidable (â†‘i = â†‘j)) â†’ ((h : â†‘i = â†‘j) â†’ motive (isTrue h)) â†’ ((h : Â¬â†‘i = â†‘j) â†’ motive (isFalse h)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.mk",
   "Prod.fst",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "And",
   "CompleteLattice",
   "Prod.supSet",
   "le_sSup",
   "Prod",
   "And.intro",
   "Set.image",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet",
   "Set.mem_image_of_mem"],
  "name": "Prod.completeLattice.proof_4",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : CompleteLattice Î±] [inst_1 : CompleteLattice Î²] (x : Set (Î± Ã— Î²)),\n  âˆ€ x_1 âˆˆ x, x_1.1 â‰¤ (sSup x).1 âˆ§ x_1.2 â‰¤ (sSup x).2",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Ne",
   "List.erase_cons",
   "List.cons",
   "instBEq",
   "List.erase",
   "True",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Decidable",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "congrFun"],
  "name": "List.erase_cons_tail",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a b : Î±} (l : List Î±), b â‰  a â†’ List.erase (b :: l) a = b :: List.erase l a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddRightCancelMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Array",
   "GetElem.mk",
   "LT.lt",
   "Array.get",
   "Nat",
   "Array.size",
   "instLTNat",
   "Fin.mk",
   "GetElem"],
  "name": "instGetElemArrayNatLtInstLTNatSize",
  "constType":
  "{Î± : Type u_1} â†’ GetElem (Array Î±) â„• Î± fun xs i â†¦ i < Array.size xs",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Prod.instPreorderProd.match_1",
   "Prod.snd",
   "Prod.mk",
   "le_refl",
   "Prod.instLEProd",
   "LE",
   "inferInstanceAs",
   "Prod",
   "Prod.fst",
   "And.intro",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Prod.instPreorderProd.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Preorder Î±] [inst_1 : Preorder Î²] (x : Î± Ã— Î²), x â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_inf_iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.13",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] {a b c : Î±}, (a â‰¤ b âŠ“ c) = (a â‰¤ b âˆ§ a â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Context", "Lean.Name"],
  "name": "Lean.Macro.Context.mainModule",
  "constType": "Lean.Macro.Context â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.forall_mem_nil.match_1",
   "List.instMembershipList",
   "List",
   "List.nil"],
  "name": "List.forall_mem_nil",
  "constType": "âˆ€ {Î± : Type u_1} (p : Î± â†’ Prop), âˆ€ x âˆˆ [], p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Quot.liftOn",
   "Setoid.r",
   "List.instMembershipList",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Mem.proof_1"],
  "name": "Multiset.Mem",
  "constType": "{Î± : Type u_1} â†’ Î± â†’ Multiset Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add.match_1",
  "constType":
  "(motive : â„• â†’ â„• â†’ Sort u_1) â†’\n  (x x_1 : â„•) â†’ ((a : â„•) â†’ motive a Nat.zero) â†’ ((a : â„•) â†’ (b : â„•) â†’ motive a (Nat.succ b)) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset",
   "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
   "LE.le",
   "Multiset.instAddMultiset",
   "ContravariantClass",
   "Preorder.toLE",
   "ContravariantClass.mk",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1}, ContravariantClass (Multiset Î±) (Multiset Î±) (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsOpen_of._closed_8",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name": "Topology.IsOpen_of._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Bool.casesOn",
   "Lean.SourceInfo.casesOn",
   "Bool.false",
   "Bool.true",
   "Lean.SourceInfo.original",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "optParam",
   "Substring",
   "String.Pos"],
  "name": "Lean.SourceInfo.getPos?.match_1",
  "constType":
  "(motive : Lean.SourceInfo â†’ optParam Bool false â†’ Sort u_1) â†’\n  (info : Lean.SourceInfo) â†’\n    (canonicalOnly : optParam Bool false) â†’\n      ((leading : Substring) â†’\n          (pos : String.Pos) â†’\n            (trailing : Substring) â†’\n              (endPos : String.Pos) â†’\n                (x : optParam Bool false) â†’ motive (Lean.SourceInfo.original leading pos trailing endPos) x) â†’\n        ((pos endPos : String.Pos) â†’ (x : optParam Bool false) â†’ motive (Lean.SourceInfo.synthetic pos endPos true) x) â†’\n          ((pos endPos : String.Pos) â†’ (canonical : Bool) â†’ motive (Lean.SourceInfo.synthetic pos endPos canonical)) â†’\n            ((x : Lean.SourceInfo) â†’ (x_1 : optParam Bool false) â†’ motive x x_1) â†’ motive info canonicalOnly",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.forall_mem_cons.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} {a : Î±} {l : List Î±} (motive : (p a âˆ§ âˆ€ x âˆˆ l, p x) â†’ Prop) (x : p a âˆ§ âˆ€ x âˆˆ l, p x),\n  (âˆ€ (Hâ‚ : p a) (Hâ‚‚ : âˆ€ x âˆˆ l, p x), motive (_ : p a âˆ§ âˆ€ x âˆˆ l, p x)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp",
   "nhds",
   "Filter.comap",
   "TopologicalSpace",
   "Filter",
   "Inducing",
   "inducing_iff_nhds",
   "Eq"],
  "name": "Inducing.nhds_eq_comap",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Inducing f â†’ âˆ€ (a : Î±), nhds a = Filter.comap f (nhds (f a))",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{Î± : Type u} â†’ [self : SemilatticeInf Î±] â†’ PartialOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Preorder.mk",
   "Prod.instPreorderProd",
   "Preorder.toLT",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "And.casesOn",
   "Preorder.lt_iff_le_not_le"],
  "name": "Prod.instPartialOrder.match_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (x x_1 : Î± Ã— Î²),\n  let src := inferInstanceAs (Preorder (Î± Ã— Î²));\n  âˆ€ (motive : x_1 â‰¤ x â†’ Prop) (x_2 : x_1 â‰¤ x),\n    (âˆ€ (hca : x_1.1 â‰¤ x.1) (hdb : x_1.2 â‰¤ x.2), motive (_ : x_1.1 â‰¤ x.1 âˆ§ x_1.2 â‰¤ x.2)) â†’ motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.filter_length_eq_length",
   "List.filter",
   "Iff.rfl",
   "List.instMembershipList",
   "Eq.refl",
   "List.length",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "List",
   "propext",
   "Bool.true",
   "Bool",
   "Nat",
   "List.countP",
   "id",
   "List.countP_eq_length_filter"],
  "name": "List.countP_eq_length",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {l : List Î±}, List.countP p l = List.length l â†” âˆ€ a âˆˆ l, p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "List.Pairwise.below",
   "List.Pairwise.brecOn",
   "List",
   "Function.comp",
   "Unit",
   "List.Pairwise.imp.match_1._@.Std.Data.List.Lemmas._hyg.29208",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.imp",
  "constType":
  "âˆ€ {Î± : Type u_1} {R S : Î± â†’ Î± â†’ Prop},\n  (âˆ€ {a b : Î±}, R a b â†’ S a b) â†’ âˆ€ {l : List Î±}, List.Pairwise R l â†’ List.Pairwise S l",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.reverseAux.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : List Î± â†’ List Î± â†’ Sort u_2) â†’\n    (x x_1 : List Î±) â†’ ((r : List Î±) â†’ motive [] r) â†’ ((a : Î±) â†’ (l r : List Î±) â†’ motive (a :: l) r) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "Eq"],
  "name": "GeneralizedBooleanAlgebra.sup_inf_sdiff",
  "constType":
  "âˆ€ {Î± : Type u} [self : GeneralizedBooleanAlgebra Î±] (a b : Î±), a âŠ“ b âŠ” a \\ b = a",
  "constCategory": "Definition"},
 {"references": ["CoheytingAlgebra", "HNot"],
  "name": "CoheytingAlgebra.toHNot",
  "constType": "{Î± : Type u_4} â†’ [self : CoheytingAlgebra Î±] â†’ HNot Î±",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup", "Finset.univ", "Fintype", "Finset.val", "Multiset.Nodup"],
  "name": "Fintype.truncEquivFin.proof_2",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Fintype Î±], Multiset.Nodup Finset.univ.val",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "true_and",
   "List.instMembershipList",
   "implies_true",
   "Eq.refl",
   "implies_congr_ctx",
   "True",
   "iff_self",
   "List.Pairwise",
   "And",
   "eq_true",
   "Iff",
   "of_eq_true",
   "List",
   "List.Pairwise.iff_of_mem",
   "forall_congr",
   "congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.Pairwise.and_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {l : List Î±}, List.Pairwise R l â†” List.Pairwise (fun x y â†¦ x âˆˆ l âˆ§ y âˆˆ l âˆ§ R x y) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.mp",
   "Iff",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Set",
   "Function.comp",
   "Set.Ici",
   "Set.ext_iff",
   "eq_of_forall_ge_iff",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "PartialOrder"],
  "name": "Set.Ici_injective",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±], Function.Injective Set.Ici",
  "constCategory": "Theorem"},
 {"references": ["MonadExceptOf.throw", "MonadExceptOf"],
  "name": "throwThe",
  "constType":
  "(Îµ : Type u) â†’ {m : Type v â†’ Type w} â†’ [inst : MonadExceptOf Îµ m] â†’ {Î± : Type v} â†’ Îµ â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Sublist.casesOn",
   "HEq",
   "eq_of_heq",
   "List.Sublist",
   "List.Sublist.cons",
   "Eq.refl",
   "List.length",
   "List.Sublist.slnil",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.consâ‚‚",
   "List.nil",
   "Nat",
   "Eq.symm"],
  "name": "List.Sublist.eq_of_length.match_2",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (lâ‚‚ lâ‚ : List Î±) â†’ List.Sublist lâ‚ lâ‚‚ â†’ List.length lâ‚ = List.length lâ‚‚ â†’ Prop)\n  (lâ‚‚ lâ‚ : List Î±) (x : List.Sublist lâ‚ lâ‚‚) (x_1 : List.length lâ‚ = List.length lâ‚‚),\n  (âˆ€ (x : List.length [] = List.length []), motive [] [] (_ : List.Sublist [] []) x) â†’\n    (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (s : List.Sublist lâ‚ lâ‚‚) (h : List.length lâ‚ = List.length (a :: lâ‚‚)),\n        motive (a :: lâ‚‚) lâ‚ (_ : List.Sublist lâ‚ (a :: lâ‚‚)) h) â†’\n      (âˆ€ (lâ‚ lâ‚‚ : List Î±) (a : Î±) (s : List.Sublist lâ‚ lâ‚‚) (h : List.length (a :: lâ‚) = List.length (a :: lâ‚‚)),\n          motive (a :: lâ‚‚) (a :: lâ‚) (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)) h) â†’\n        motive lâ‚‚ lâ‚ x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "Preorder.toLE",
   "OrderDual.boundedOrder"],
  "name": "OrderDual.completeLattice.proof_4",
  "constType": "âˆ€ (Î± : Type u_1) [inst : CompleteLattice Î±] (a : Î±áµ’áµˆ), a â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references":
  ["And", "Iff", "Prod.mk.injEq", "Prod.mk", "Prod", "Eq", "Iff.of_eq"],
  "name": "Prod.mk.inj_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {aâ‚ aâ‚‚ : Î±} {bâ‚ bâ‚‚ : Î²}, (aâ‚, bâ‚) = (aâ‚‚, bâ‚‚) â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "propext",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.union_subset_iff",
   "Set.instUnionSet",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.57",
  "constType": "âˆ€ {Î± : Type u} {s t u : Set Î±}, (s âˆª t âŠ† u) = (s âŠ† u âˆ§ t âŠ† u)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "rfl",
   "Topology.IsLowerSet.mk"],
  "name": "Topology.instIsLowerSetLowerSet.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsLowerSet Î±",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder", "Preorder.toLE", "BoundedOrder", "PartialOrder"],
  "name": "IsCompl",
  "constType":
  "{Î± : Type u_1} â†’ [inst : PartialOrder Î±] â†’ [inst : BoundedOrder Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": ["OrderDual", "TopologicalSpace"],
  "name": "instTopologicalSpaceOrderDual",
  "constType":
  "{Î± : Type u} â†’ [inst : TopologicalSpace Î±] â†’ TopologicalSpace Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.instUnionList",
   "List.insert",
   "Mathlib.Data.List.Perm._auxLemma.31",
   "Union.union",
   "True",
   "List.nil_union",
   "List.cons_union",
   "eq_true",
   "List.Perm",
   "DecidableEq",
   "List.rec",
   "of_eq_true",
   "List",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans"],
  "name": "List.Perm.union_left",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] (l : List Î±) {tâ‚ tâ‚‚ : List Î±}, tâ‚ ~ tâ‚‚ â†’ l âˆª tâ‚ ~ l âˆª tâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.append",
   "List.brecOn",
   "List.below",
   "Iff.rfl",
   "List.Subperm",
   "Unit",
   "List.subperm_cons",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "Iff",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "List.Perm.refl.match_1",
   "Iff.trans",
   "List.nil"],
  "name": "List.subperm_append_left",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±} (l : List Î±), l ++ lâ‚ <+~ l ++ lâ‚‚ â†” lâ‚ <+~ lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{Î± : Type u} â†’ [self : StrictOrderedSemiring Î±] â†’ OrderedCancelAddCommMonoid Î±",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse"],
  "name": "Function.RightInverse",
  "constType": "{Î± : Sort uâ‚} â†’ {Î² : Sort uâ‚‚} â†’ (Î² â†’ Î±) â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "And.intro",
   "List.noConfusion",
   "Eq.symm",
   "And.casesOn",
   "Eq.propIntro",
   "Eq"],
  "name": "List.cons.injEq",
  "constType":
  "âˆ€ {Î± : Type u} (head : Î±) (tail : List Î±) (head_1 : Î±) (tail_1 : List Î±),\n  (head :: tail = head_1 :: tail_1) = (head = head_1 âˆ§ tail = tail_1)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "Preorder.toLE",
   "ContravariantClass",
   "Multiset.instPartialOrderMultiset",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1"],
  "name":
  "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
  "constType":
  "âˆ€ {Î± : Type u_1}, ContravariantClass (Multiset Î±) (Multiset Î±) (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Unit",
   "Nat.ble_self_eq_true",
   "Nat.ble_eq_true_of_le.match_1",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.ble_succ_eq_true",
   "Bool.true",
   "PUnit",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ Nat.ble n m = true",
  "constCategory": "Theorem"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Injective",
   "EmbeddingLike.injective",
   "EquivLike.toEmbeddingLike",
   "FunLike.coe"],
  "name": "EquivLike.injective",
  "constType":
  "âˆ€ {E : Sort u_1} {Î± : Sort u_3} {Î² : Sort u_4} [iE : EquivLike E Î± Î²] (e : E), Function.Injective â†‘e",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "decide_eq_true.match_1",
  "constType":
  "âˆ€ {p : Prop} (motive : Decidable p â†’ p â†’ Prop) (x : Decidable p) (x_1 : p),\n  (âˆ€ (h x : p), motive (isTrue h) x) â†’ (âˆ€ (hâ‚ : Â¬p) (hâ‚‚ : p), motive (isFalse hâ‚) hâ‚‚) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "Set",
   "True",
   "Set.instMembershipSet",
   "iff_self",
   "Eq",
   "Set.ext",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set.iInter",
   "congr",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "congrArg",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "Eq.trans"],
  "name": "Set.preimage_iInter",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {f : Î± â†’ Î²} {s : Î¹ â†’ Set Î²}, f â»Â¹' â‹‚ i, s i = â‹‚ i, f â»Â¹' s i",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet", "Preorder"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_right",
   "Prod",
   "Lattice",
   "Prod.semilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Prod.lattice.proof_5",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : Lattice Î±] [inst_1 : Lattice Î²] (a b : Î± Ã— Î²), a âŠ“ b â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Membership.mem",
   "Equiv",
   "AddHomClass.toFunLike",
   "List.isSetoid",
   "Multiset.Nodup",
   "AddCommMonoid.toAddMonoid",
   "Trunc.instSubsingletonTrunc",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "instSubsingletonForAll",
   "Multiset.instMembershipMultiset",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Setoid.r",
   "Nat.addMonoid",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "List",
   "Subsingleton",
   "Multiset",
   "Trunc",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "Fin",
   "AddMonoidHom",
   "Quot.mk"],
  "name": "Fintype.truncEquivFin.proof_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (a : List Î±),\n  Subsingleton\n    ((âˆ€ (x : Î±), x âˆˆ Quot.mk Setoid.r a) â†’\n      Multiset.Nodup (Quot.mk Setoid.r a) â†’ Trunc (Î± â‰ƒ Fin (â†‘Multiset.card (Quot.mk Setoid.r a))))",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.lattice.proof_3",
   "Pi.lattice.proof_1",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Pi.lattice.proof_2",
   "Pi.semilatticeInf",
   "SemilatticeSup",
   "Pi.lattice.proof_6",
   "SemilatticeSup.toSup",
   "Pi.lattice.proof_5",
   "Pi.semilatticeSup",
   "inferInstanceAs",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "Pi.lattice.proof_4"],
  "name": "Pi.lattice",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î±' : Î¹ â†’ Type u_2} â†’ [inst : (i : Î¹) â†’ Lattice (Î±' i)] â†’ Lattice ((i : Î¹) â†’ Î±' i)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{Î± Î² : Sort u} â†’ Î± = Î² â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.EvalInformation", "Nat"],
  "name": "Lean.Data.AC.EvalInformation.evalVar",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ [self : Lean.Data.AC.EvalInformation Î± Î²] â†’ Î± â†’ â„• â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "instOfNatNat", "Nat", "optParam", "Nat.succ", "Nat.casesOn"],
  "name": "List.range'.match_1",
  "constType":
  "(motive : â„• â†’ â„• â†’ optParam â„• 1 â†’ Sort u_1) â†’\n  (x x_1 : â„•) â†’\n    (x_2 : optParam â„• 1) â†’\n      ((x : â„•) â†’ (x_3 : optParam â„• 1) â†’ motive x 0 x_3) â†’\n        ((s n : â„•) â†’ (step : optParam â„• 1) â†’ motive s (Nat.succ n) step) â†’ motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{Î± : Type u} â†’ [self : LinearOrder Î±] â†’ Max Î±",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{Î± Î² : Sort u} â†’ Î± = Î² â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_13",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Iff",
   "Iff.rfl",
   "Set",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_inter_iff",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), x âˆˆ a âˆ© b â†” x âˆˆ a âˆ§ x âˆˆ b",
  "constCategory": "Theorem"},
 {"references": ["And", "propext", "forall_and", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.19",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (x : Î±), p x âˆ§ q x) = ((âˆ€ (x : Î±), p x) âˆ§ âˆ€ (x : Î±), q x)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.rec._rarg._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{Î± : Type u_1} â†’ EmptyCollection (Set Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_9 â†’ Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{Î± : Type u} â†’ [self : Lattice Î±] â†’ SemilatticeInf Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.eraseP_cons_of_pos",
   "List.erase_cons_tail",
   "List.below",
   "List.brecOn",
   "Eq.refl",
   "dite",
   "rfl",
   "List.erase",
   "True",
   "List.eraseP_cons_of_neg",
   "Eq",
   "Subsingleton.elim",
   "Decidable.decide",
   "PProd",
   "List.eraseP",
   "List.rec",
   "List.erase_cons_head",
   "Eq.rec",
   "Bool.true",
   "PUnit",
   "Decidable",
   "List.nil",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "eq_self",
   "List.mem_map.match_1",
   "List.cons",
   "funext",
   "False",
   "Unit",
   "instBEq",
   "Ne.symm",
   "eq_false_of_decide",
   "instDecidableTrue",
   "instDecidableFalse",
   "PProd.fst",
   "eq_false",
   "Eq.ndrec",
   "of_eq_true",
   "DecidableEq",
   "Bool.false",
   "List",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "instSubsingletonDecidable",
   "congrFun"],
  "name": "List.erase_eq_eraseP",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (a : Î±) (l : List Î±), List.erase l a = List.eraseP (fun b â†¦ decide (a = b)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Order.Basic._auxLemma.1",
   "of_eq_true",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Set",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Eq.trans",
   "True",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.left_mem_Ici",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a : Î±}, a âˆˆ Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Pure.pure",
   "Applicative.toPure"],
  "name": "ReaderT.pure",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ {Î± : Type u} â†’ Î± â†’ ReaderT Ï m Î±",
  "constCategory": "Definition"},
 {"references": ["Multiset", "Finset", "Multiset.Nodup", "Finset.mk"],
  "name": "Finset.rec",
  "constType":
  "{Î± : Type u_4} â†’\n  {motive : Finset Î± â†’ Sort u} â†’\n    ((val : Multiset Î±) â†’ (nodup : Multiset.Nodup val) â†’ motive { val := val, nodup := nodup }) â†’\n      (t : Finset Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termð“[â‰ ]_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_top",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Top.top",
   "Function.comp",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "CompleteLattice.toTop",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_6",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î±] [inst_1 : CompleteLattice Î²]\n  (gi : GaloisCoinsertion l u) (x : Î±áµ’áµˆáµ’áµˆ), x â‰¤ âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toSupSet",
  "constType":
  "{Î± : Type u_5} â†’ [self : ConditionallyCompleteLattice Î±] â†’ SupSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "propext",
   "Set",
   "Preorder",
   "LE.le",
   "mem_upperBounds",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.12",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, (a âˆˆ upperBounds s) = âˆ€ x âˆˆ s, x â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "eq_true", "List.Perm", "List", "List.Perm.cons", "True", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.13",
  "constType":
  "âˆ€ {Î± : Type uu} (x : Î±) {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (x :: lâ‚ ~ x :: lâ‚‚) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.nodup",
   "Multiset.ndunion",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.Nodup.ndunion"],
  "name": "Finset.instUnionFinset.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (s t : Finset Î±), Multiset.Nodup (Multiset.ndunion s.val t.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.toFun",
   "Equiv.invFun",
   "Function.comp",
   "Function.LeftInverse.comp",
   "Equiv.left_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans.proof_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_3} {Î³ : Sort u_2} (eâ‚ : Î± â‰ƒ Î²) (eâ‚‚ : Î² â‰ƒ Î³),\n  Function.LeftInverse (â†‘eâ‚.symm âˆ˜ eâ‚‚.invFun) (eâ‚‚.toFun âˆ˜ â†‘eâ‚)",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.toUpperSet",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithUpperSet Î±",
  "constCategory": "Definition"},
 {"references": ["IsTrans"],
  "name": "IsTrans.trans",
  "constType":
  "âˆ€ {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} [self : IsTrans Î± r] (a b c : Î±), r a b â†’ r b c â†’ r a c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "and_assoc",
   "Iff.rfl",
   "Eq.refl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "SemilatticeSup",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Iff",
   "propext",
   "congr",
   "Sup.sup",
   "Mathlib.Order.Lattice._auxLemma.3",
   "eq_of_forall_ge_iff",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congrFun",
   "id"],
  "name": "sup_assoc",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, a âŠ” b âŠ” c = a âŠ” (b âŠ” c)",
  "constCategory": "Theorem"},
 {"references":
  ["RelHomClass.map_rel",
   "Monotone",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "OrderHomClass",
   "RelHomClass.toFunLike"],
  "name": "OrderHomClass.monotone",
  "constType":
  "âˆ€ {F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : OrderHomClass F Î± Î²]\n  (f : F), Monotone â†‘f",
  "constCategory": "Theorem"},
 {"references": ["WellFounded.intro", "WellFounded", "Acc"],
  "name": "WellFounded.rec",
  "constType":
  "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : WellFounded r â†’ Sort u_1} â†’\n      ((h : âˆ€ (a : Î±), Acc r a) â†’ motive (_ : WellFounded r)) â†’ (t : WellFounded r) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "Set", "LE", "LE.le", "Set.instMembershipSet"],
  "name": "IsLowerSet",
  "constType": "{Î± : Type u_1} â†’ [inst : LE Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.mem_cons",
   "Or",
   "propext",
   "Finset",
   "Finset.cons",
   "Finset.instMembershipFinset",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.39",
  "constType":
  "âˆ€ {Î± : Type u_1} {s : Finset Î±} {a b : Î±} {h : Â¬a âˆˆ s}, (b âˆˆ Finset.cons a s h) = (b = a âˆ¨ b âˆˆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn"],
  "name": "Filter.HasBasis.to_hasBasis'.match_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î¹' : Sort u_1} {p' : Î¹' â†’ Prop} {s' : Î¹' â†’ Set Î±} (t : Set Î±) (motive : (âˆƒ i, p' i âˆ§ s' i âŠ† t) â†’ Prop)\n  (x : âˆƒ i, p' i âˆ§ s' i âŠ† t), (âˆ€ (i' : Î¹') (hi' : p' i') (ht : s' i' âŠ† t), motive (_ : âˆƒ i, p' i âˆ§ s' i âŠ† t)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[_]_Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "outParam",
   "OfNat.ofNat",
   "FunLike",
   "ZeroHomClass",
   "FunLike.coe",
   "Eq"],
  "name": "ZeroHomClass.mk",
  "constType":
  "{F : Type u_9} â†’\n  {M : outParam (Type u_10)} â†’\n    {N : outParam (Type u_11)} â†’\n      [inst : Zero M] â†’\n        [inst_1 : Zero N] â†’ [toFunLike : FunLike F M fun x â†¦ N] â†’ (âˆ€ (f : F), â†‘f 0 = 0) â†’ ZeroHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "Inducing.continuous_iff",
   "Iff.mp",
   "Function.comp",
   "Continuous",
   "TopologicalSpace",
   "Inducing"],
  "name": "Inducing.continuous",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Inducing f â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.termÏ€_._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.eq_of_mem_singleton.match_1",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "Unit",
   "List.nil",
   "rfl",
   "Eq"],
  "name": "List.eq_of_mem_singleton",
  "constType": "âˆ€ {Î± : Type u_1} {a b : Î±}, a âˆˆ [b] â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet._rarg._cstage2",
  "constType": "_obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLower", "Topology.lower", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsLower.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±] [inst : Preorder Î±], t = Topology.lower Î± â†’ Topology.IsLower Î±",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Continuous_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u â†’ Type v â†’ outParam (Type w) â†’ Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["inf_le_left",
   "inf_le_right",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Disjoint",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "Iff.intro",
   "Iff",
   "le_inf",
   "OrderBot.toBot",
   "SemilatticeInf"],
  "name": "disjoint_iff_inf_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±] [inst_1 : OrderBot Î±] {a b : Î±}, Disjoint a b â†” a âŠ“ b â‰¤ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["WellFoundedRelation.rel",
   "invImage.proof_1",
   "WellFoundedRelation",
   "InvImage",
   "WellFoundedRelation.mk"],
  "name": "invImage",
  "constType":
  "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (Î± â†’ Î²) â†’ WellFoundedRelation Î² â†’ WellFoundedRelation Î±",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "PSigma",
   "PSigma.casesOn",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instSizeOfNat",
   "dite",
   "instDecidableAnd",
   "Nat.modCore._unary.proof_1",
   "WellFounded.fix",
   "instLTNat",
   "LE.le",
   "instWellFoundedRelation",
   "And",
   "instLENat",
   "invImage",
   "Nat.div_rec_lemma",
   "LT.lt",
   "SizeOf.sizeOf",
   "PSigma.mk",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.decLe"],
  "name": "Nat.modCore._unary",
  "constType": "(_ : â„•) Ã—' â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "Eq"],
  "name": "Set.singleton",
  "constType": "{Î± : Type u_1} â†’ Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Â«termI^_Â»._closed_7",
   "_obj",
   "Topology.Â«termI^_Â»._closed_10",
   "Topology.Â«termI^_Â»._closed_5"],
  "name": "Topology.Â«termI^_Â»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Set.univ",
   "Set.instMembershipSet"],
  "name": "Filter.univ_sets",
  "constType": "âˆ€ {Î± : Type u_1} (self : Filter Î±), Set.univ âˆˆ self.sets",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "ConditionallyCompleteLattice",
   "LE.le",
   "BddAbove",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "upperBounds",
   "BddBelow",
   "lowerBounds",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "ConditionallyCompleteLattice.mk",
  "constType":
  "{Î± : Type u_5} â†’\n  [toLattice : Lattice Î±] â†’\n    [toSupSet : SupSet Î±] â†’\n      [toInfSet : InfSet Î±] â†’\n        (âˆ€ (s : Set Î±) (a : Î±), BddAbove s â†’ a âˆˆ s â†’ a â‰¤ sSup s) â†’\n          (âˆ€ (s : Set Î±) (a : Î±), Set.Nonempty s â†’ a âˆˆ upperBounds s â†’ sSup s â‰¤ a) â†’\n            (âˆ€ (s : Set Î±) (a : Î±), BddBelow s â†’ a âˆˆ s â†’ sInf s â‰¤ a) â†’\n              (âˆ€ (s : Set Î±) (a : Î±), Set.Nonempty s â†’ a âˆˆ lowerBounds s â†’ a â‰¤ sInf s) â†’ ConditionallyCompleteLattice Î±",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Filter.GenerateSets", "Set", "Set.univ"],
  "name": "Filter.GenerateSets.univ",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)}, Filter.GenerateSets g Set.univ",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "âˆ€ {Î± : Type u} [self : Lattice Î±] (a b c : Î±), a â‰¤ b â†’ a â‰¤ c â†’ a â‰¤ b âŠ“ c",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Filter.HasBasis.to_hasBasis'.match_1",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Iff.mp",
   "Set",
   "Filter.HasBasis.mem_of_mem",
   "HasSubset.Subset",
   "Filter",
   "Filter.HasBasis.mem_iff",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.forall_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’\n    âˆ€ {P : Set Î± â†’ Prop}, (âˆ€ â¦ƒs t : Set Î±â¦„, s âŠ† t â†’ P s â†’ P t) â†’ ((âˆ€ s âˆˆ l, P s) â†” âˆ€ (i : Î¹), p i â†’ P (s i))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (a : Î±) (l : List Î±), (âˆ€ a_1 âˆˆ a :: l, p a_1) â†’ âˆ€ x âˆˆ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Or.casesOn",
   "Eq"],
  "name": "le_of_not_lt.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±} (motive : a < b âˆ¨ a = b âˆ¨ b < a â†’ Prop) (x : a < b âˆ¨ a = b âˆ¨ b < a),\n  (âˆ€ (hlt : a < b), motive (_ : a < b âˆ¨ a = b âˆ¨ b < a)) â†’\n    (âˆ€ (HEq : a = b), motive (_ : a < b âˆ¨ a = b âˆ¨ b < a)) â†’\n      (âˆ€ (hgt : b < a), motive (_ : a < b âˆ¨ a = b âˆ¨ b < a)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "propext",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsOpen",
   "Eq",
   "continuous_def"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {x : TopologicalSpace Î±} {x_1 : TopologicalSpace Î²} {f : Î± â†’ Î²},\n  Continuous f = âˆ€ (s : Set Î²), IsOpen s â†’ IsOpen (f â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "Or.comm"],
  "name": "or_comm",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†” b âˆ¨ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.Pairwise",
   "List.pairwise_map",
   "Iff.mp",
   "List.Pairwise.imp",
   "List",
   "List.map"],
  "name": "List.Pairwise.of_map",
  "constType":
  "âˆ€ {Î² : Type u_1} {Î± : Type u_2} {R : Î± â†’ Î± â†’ Prop} {l : List Î±} {S : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²),\n  (âˆ€ (a b : Î±), S (f a) (f b) â†’ R a b) â†’ List.Pairwise S (List.map f l) â†’ List.Pairwise R l",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "Preorder", "LE.le", "Preorder.toLE", "instIsReflLeToLE.proof_1"],
  "name": "instIsReflLeToLE",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±], IsRefl Î± fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.IsUpperSet.mk",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "rfl"],
  "name": "Topology.instIsUpperSetUpperSet.proof_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsUpperSet Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike.bijective",
   "Function.Bijective",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.bijective",
  "constType": "âˆ€ {Î± : Sort u} {Î² : Sort v} (e : Î± â‰ƒ Î²), Function.Bijective â†‘e",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_sup_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.semilatticeSup.proof_2",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ SemilatticeSup (Î±' i)] (x x_1 : (i : Î¹) â†’ Î±' i) (x_2 : Î¹),\n  x_1 x_2 â‰¤ x x_2 âŠ” x_1 x_2",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[<]_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "instDecidableNot",
   "Bool.false",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_false",
  "constType": "âˆ€ (b : Bool), (Â¬b = false) = (b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "List.filter",
   "OfNat.ofNat",
   "List.instMembershipList",
   "Std.Data.List.Count._auxLemma.2",
   "List.length",
   "instLTNat",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "List",
   "LT.lt",
   "Bool.true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "congrArg",
   "Eq.trans",
   "Std.Data.List.Count._auxLemma.1",
   "List.countP_eq_length_filter",
   "congrFun"],
  "name": "List.countP_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} (p : Î± â†’ Bool) {l : List Î±}, 0 < List.countP p l â†” âˆƒ a âˆˆ l, p a = true",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_comm.match_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} (motive : (âˆƒ a, âˆƒ b, p a b) â†’ Prop) (x : âˆƒ a, âˆƒ b, p a b),\n  (âˆ€ (a : Î±) (b : Î²) (h : p a b), motive (_ : âˆƒ a, âˆƒ b, p a b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons"],
  "name": "List.sublist_cons",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±) (l : List Î±), List.Sublist l (a :: l)",
  "constCategory": "Theorem"},
 {"references": ["Preorder"],
  "name": "GaloisInsertion",
  "constType":
  "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ (Î± â†’ Î²) â†’ (Î² â†’ Î±) â†’ Type (max u_2 u_3)",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Prop) â†’ LT Î±",
  "constCategory": "Other"},
 {"references":
  ["List.Sublist.refl",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "List.cons",
   "List.sublist_append_left.match_1",
   "List.instAppendList",
   "List.rec",
   "List.below",
   "List.brecOn",
   "HAppend.hAppend",
   "List",
   "PUnit",
   "List.Sublist",
   "List.Sublist.cons",
   "List.nil"],
  "name": "List.sublist_append_right",
  "constType": "âˆ€ {Î± : Type u_1} (lâ‚ lâ‚‚ : List Î±), List.Sublist lâ‚‚ (lâ‚ ++ lâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.pairwise_cons",
   "List.instMembershipList",
   "List"],
  "name": "List.Pairwise.of_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {l : List Î±} {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R (a :: l) â†’ List.Pairwise R l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadStateOf.get", "MonadStateOf"],
  "name": "getThe",
  "constType":
  "(Ïƒ : Type u) â†’ {m : Type u â†’ Type v} â†’ [inst : MonadStateOf Ïƒ m] â†’ m Ïƒ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Bot.bot",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.NeBot.ne'",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±} [self : Filter.NeBot f], f â‰  âŠ¥",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Bot.bot",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_15",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î± â†’ Prop), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Â«termð“Ë¢Â»._closed_2",
   "Topology.Â«termð“Ë¢Â»._closed_1"],
  "name": "Topology.Â«termð“Ë¢Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Quotient.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.inductionOnâ‚ƒ",
  "constType":
  "âˆ€ {Î± : Sort uA} {Î² : Sort uB} {Ï† : Sort uC} {sâ‚ : Setoid Î±} {sâ‚‚ : Setoid Î²} {sâ‚ƒ : Setoid Ï†}\n  {motive : Quotient sâ‚ â†’ Quotient sâ‚‚ â†’ Quotient sâ‚ƒ â†’ Prop} (qâ‚ : Quotient sâ‚) (qâ‚‚ : Quotient sâ‚‚) (qâ‚ƒ : Quotient sâ‚ƒ),\n  (âˆ€ (a : Î±) (b : Î²) (c : Ï†), motive (Quotient.mk sâ‚ a) (Quotient.mk sâ‚‚ b) (Quotient.mk sâ‚ƒ c)) â†’ motive qâ‚ qâ‚‚ qâ‚ƒ",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.instEquivLikeEquiv.proof_1",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "EquivLike.mk"],
  "name": "Equiv.instEquivLikeEquiv",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ EquivLike (Î± â‰ƒ Î²) Î± Î²",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false_iff_not",
   "Bool.false",
   "propext",
   "Decidable",
   "Not",
   "Bool",
   "Eq"],
  "name": "Std.Logic._auxLemma.58",
  "constType": "âˆ€ (p : Prop) [inst : Decidable p], (decide p = false) = Â¬p",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "le_sup_left"],
  "name": "Pi.semilatticeSup.proof_1",
  "constType":
  "âˆ€ {Î¹ : Type u_2} {Î±' : Î¹ â†’ Type u_1} [inst : (i : Î¹) â†’ SemilatticeSup (Î±' i)] (x x_1 : (i : Î¹) â†’ Î±' i) (x_2 : Î¹),\n  x x_2 â‰¤ x x_2 âŠ” x_1 x_2",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Inhabited", "Nat", "Inhabited.mk"],
  "name": "instInhabitedNat",
  "constType": "Inhabited â„•",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Function.Surjective.exists.match_1",
  "constType":
  "âˆ€ {Î² : Sort u_1} {p : Î² â†’ Prop} (motive : (âˆƒ y, p y) â†’ Prop) (x : âˆƒ y, p y),\n  (âˆ€ (y : Î²) (hy : p y), motive (_ : âˆƒ y, p y)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "nhds",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Specializes",
  "constType": "{X : Type u_1} â†’ [inst : TopologicalSpace X] â†’ X â†’ X â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "Set",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image2_of_mem",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f : Î± â†’ Î² â†’ Î³} {s : Set Î±} {t : Set Î²} {a : Î±} {b : Î²},\n  a âˆˆ s â†’ b âˆˆ t â†’ f a b âˆˆ Set.image2 f s t",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{Î± : Sort uâ‚} â†’ {Î² : Sort uâ‚‚} â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{Î± : Type u} â†’ [self : Add Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termÏ€_._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Finset.casesOn",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Finset.mk",
   "Eq"],
  "name": "Finset.eq_of_veq.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x x_1 : Finset Î±) â†’ x.val = x_1.val â†’ Prop) (x x_1 : Finset Î±) (x_2 : x.val = x_1.val),\n  (âˆ€ (s : Multiset Î±) (nodup : Multiset.Nodup s) (t : Multiset Î±) (nodup_1 : Multiset.Nodup t)\n      (h : { val := s, nodup := nodup }.val = { val := t, nodup := nodup_1 }.val),\n      motive { val := s, nodup := nodup } { val := t, nodup := nodup_1 } h) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ord",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Order.Filter.Basic._auxLemma.13",
   "PartialOrder.toPreorder",
   "Set",
   "GE.ge",
   "Mathlib.Order.Filter.Basic._auxLemma.47",
   "Directed",
   "True",
   "Preorder.toLE",
   "Nonempty",
   "iff_self",
   "Set.instMembershipSet",
   "Set.iUnion",
   "Iff",
   "Filter.iInf_sets_eq",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "congr",
   "Filter",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.mem_iInf_of_directed",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ Filter Î±},\n  Directed (fun x x_1 â†¦ x â‰¥ x_1) f â†’ âˆ€ [inst : Nonempty Î¹] (s : Set Î±), s âˆˆ iInf f â†” âˆƒ i, s âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpper", "Inhabited"],
  "name": "Topology.WithUpper.instInhabitedWithUpper._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Inhabited Î±] â†’ Inhabited (Topology.WithUpper Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Lean.Syntax.missing",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "Lean.SourceInfo",
   "Nat",
   "Lean.Syntax",
   "Array.getD"],
  "name": "Lean.Syntax.getArg",
  "constType": "Lean.Syntax â†’ â„• â†’ Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "List.Perm.subperm_left.match_1",
   "List.Sublist.length_le",
   "List.Perm",
   "instLENat",
   "List",
   "Eq.rec",
   "List.Subperm",
   "List.Sublist",
   "List.length",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "List.Subperm.length_le",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <+~ lâ‚‚ â†’ List.length lâ‚ â‰¤ List.length lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Fin.veq_of_eq", "False", "Fin.val", "Nat", "absurd", "Fin", "Eq"],
  "name": "Fin.ne_of_vne",
  "constType": "âˆ€ {n : â„•} {i j : Fin n}, â†‘i â‰  â†‘j â†’ i â‰  j",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsLower.WithLowerHomeomorph._rarg", "_obj", "_neutral"],
  "name": "Topology.IsLower.WithLowerHomeomorph._cstage2",
  "constType": "_neutral â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_14"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "eq_true",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "le_sup_right",
   "Sup.sup",
   "LE.le",
   "True",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (b â‰¤ a âŠ” b) = True",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Lean.Name"],
  "name": "Lean.Name.num",
  "constType": "Lean.Name â†’ â„• â†’ Lean.Name",
  "constCategory": "Other"},
 {"references": ["Topology.WithUpperSet", "Preorder"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "IsGreatest", "Preorder"],
  "name": "IsGLB",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["MonadExceptOf.tryCatch", "MonadExceptOf"],
  "name": "tryCatchThe",
  "constType":
  "(Îµ : Type u) â†’ {m : Type v â†’ Type w} â†’ [inst : MonadExceptOf Îµ m] â†’ {Î± : Type v} â†’ m Î± â†’ (Îµ â†’ m Î±) â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "induced_id",
   "Inducing.mk",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Eq.refl",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLower.topology_eq",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Topology.IsLower",
   "Topology.lower",
   "TopologicalSpace",
   "Topology.WithLower.ofLower",
   "TopologicalSpace.induced",
   "id"],
  "name": "Topology.IsLower.WithLowerHomeomorph.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±],\n  Inducing â†‘Topology.WithLower.ofLower",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¥]__1Â»._cstage2",
  "constType": "_obj â†’ _obj â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Array",
   "Array.mkEmpty",
   "Array.extract.loop",
   "Nat.sub",
   "Nat",
   "Array.size",
   "instMinNat"],
  "name": "Array.extract",
  "constType": "{Î± : Type u_1} â†’ Array Î± â†’ â„• â†’ â„• â†’ Array Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Sublist.below.consâ‚‚",
   "List.Sublist.below.cons",
   "List",
   "List.Sublist",
   "List.Sublist.consâ‚‚",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.below.rec",
   "List.Sublist.slnil",
   "List.Sublist.below.slnil",
   "List.Sublist.below"],
  "name": "List.Sublist.below.casesOn",
  "constType":
  "âˆ€ {Î± : Type u_1} {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop}\n  {motive_1 : {a a_1 : List Î±} â†’ (x : List.Sublist a a_1) â†’ List.Sublist.below x â†’ Prop} {a a_1 : List Î±}\n  {x : List.Sublist a a_1} (t : List.Sublist.below x),\n  motive_1 (_ : List.Sublist [] []) (_ : List.Sublist.below (_ : List.Sublist [] [])) â†’\n    (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) {a_2 : List.Sublist lâ‚ lâ‚‚} (a_3 : List.Sublist.below a_2) (a_4 : motive lâ‚ lâ‚‚ a_2),\n        motive_1 (_ : List.Sublist lâ‚ (a :: lâ‚‚)) (_ : List.Sublist.below (_ : List.Sublist lâ‚ (a :: lâ‚‚)))) â†’\n      (âˆ€ {lâ‚ lâ‚‚ : List Î±} (a : Î±) {a_2 : List.Sublist lâ‚ lâ‚‚} (a_3 : List.Sublist.below a_2) (a_4 : motive lâ‚ lâ‚‚ a_2),\n          motive_1 (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: lâ‚) (a :: lâ‚‚)))) â†’\n        motive_1 x t",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ SupSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Filter.principal",
   "Filter.HasBasis",
   "Iff",
   "Filter.HasBasis.inf_principal",
   "Filter.HasBasis.neBot_iff",
   "Inf.inf",
   "Set",
   "Set.Nonempty",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "Filter.NeBot",
   "Set.instInterSet"],
  "name": "Filter.HasBasis.inf_principal_neBot_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ âˆ€ {t : Set Î±}, Filter.NeBot (l âŠ“ Filter.principal t) â†” âˆ€ â¦ƒi : Î¹â¦„, p i â†’ Set.Nonempty (s i âˆ© t)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "UInt64.size",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "Nat",
   "instLTNat"],
  "name": "Lean.Name.hash.proof_1",
  "constType": "1723 < UInt64.size",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.preimage",
   "Set.ball_image_iff",
   "Set",
   "HasSubset.Subset",
   "Set.image",
   "Set.instMembershipSet"],
  "name": "Set.image_subset_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²}, f '' s âŠ† t â†” s âŠ† f â»Â¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["IsAntisymm", "HasSubset.Subset", "HasSubset", "subset_antisymm", "Eq"],
  "name": "HasSubset.Subset.antisymm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] {a b : Î±} [inst_1 : IsAntisymm Î± fun x x_1 â†¦ x âŠ† x_1], a âŠ† b â†’ b âŠ† a â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.cons",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.cons",
  "constType": "{Î± : Type u_1} â†’ Î± â†’ Multiset Î± â†’ Multiset Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.insert",
   "DecidableEq",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_insert_iff",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.53",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a b : Î±} {l : List Î±}, (a âˆˆ List.insert b l) = (a = b âˆ¨ a âˆˆ l)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_trans.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_trans.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_trans",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b c : Î±}, a < b â†’ b < c â†’ a < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subsingleton",
  "constType": "Sort u â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["OrderHom.comp",
   "ContinuousMap.comp",
   "Topology.WithUpperSet",
   "OrderHom",
   "Topology.WithUpperSet.map",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "Eq",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map_comp",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : Preorder Î³]\n  (g : Î² â†’o Î³) (f : Î± â†’o Î²),\n  Topology.WithUpperSet.map (OrderHom.comp g f) =\n    ContinuousMap.comp (Topology.WithUpperSet.map g) (Topology.WithUpperSet.map f)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{Î± : Sort u} â†’ [i : Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["HNot"],
  "name": "HNot.mk",
  "constType": "{Î± : Type u_4} â†’ (Î± â†’ Î±) â†’ HNot Î±",
  "constCategory": "Other"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "ite",
  "constType": "{Î± : Sort u} â†’ (c : Prop) â†’ [h : Decidable c] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ULift",
  "constType": "Type s â†’ Type (max s r)",
  "constCategory": "Other"},
 {"references": ["BEq.beq", "BEq", "List", "List.findIdx", "Nat"],
  "name": "List.indexOf",
  "constType": "{Î± : Type u_1} â†’ [inst : BEq Î±] â†’ Î± â†’ List Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†’ Â¬b â†’ a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1"],
  "name": "List.foldr",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î² â†’ Î²) â†’ Î² â†’ List Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references": [],
  "name": "String",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Filter.GenerateSets.inter",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.GenerateSets.rec",
  "constType":
  "âˆ€ {Î± : Type u} {g : Set (Set Î±)} {motive : (a : Set Î±) â†’ Filter.GenerateSets g a â†’ Prop},\n  (âˆ€ {s : Set Î±} (a : s âˆˆ g), motive s (_ : Filter.GenerateSets g s)) â†’\n    motive Set.univ (_ : Filter.GenerateSets g Set.univ) â†’\n      (âˆ€ {s t : Set Î±} (a : Filter.GenerateSets g s) (a_1 : s âŠ† t),\n          motive s a â†’ motive t (_ : Filter.GenerateSets g t)) â†’\n        (âˆ€ {s t : Set Î±} (a : Filter.GenerateSets g s) (a_1 : Filter.GenerateSets g t),\n            motive s a â†’ motive t a_1 â†’ motive (s âˆ© t) (_ : Filter.GenerateSets g (s âˆ© t))) â†’\n          âˆ€ {a : Set Î±} (t : Filter.GenerateSets g a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Exists",
   "propext",
   "Set",
   "Set.mem_range",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.20",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {x : Î±}, (x âˆˆ Set.range f) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "BooleanAlgebra.himp_eq",
  "constType":
  "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x y : Î±), x â‡¨ y = y âŠ” xá¶œ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CoheytingAlgebra",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references":
  ["_obj", "Topology.Â«termð“[_]_Â»._closed_6", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[_]_Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "Iff.rfl", "LT.lt", "Not", "LT.mk"],
  "name": "Prop.partialOrder.proof_1",
  "constType": "âˆ€ (a b : Prop), a < b â†” a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup.sSup_le",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "sSup_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeSup Î±] {s : Set Î±} {a : Î±}, (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set",
   "Std.Logic._auxLemma.24",
   "Eq.refl",
   "Mathlib.Data.Set.Lattice._auxLemma.2",
   "BooleanAlgebra.toHasCompl",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "Set.ext",
   "Iff",
   "forall_congr",
   "Set.image",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "Eq.trans",
   "Membership.mem",
   "Set.sInter_image",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Mathlib.Data.Set.Basic._auxLemma.78",
   "And",
   "Set.instBooleanAlgebraSet",
   "Std.Logic._auxLemma.31",
   "of_eq_true",
   "congr",
   "Set.iInter",
   "Not",
   "Set.sUnion",
   "Set.sInter",
   "congrArg"],
  "name": "Set.compl_sUnion",
  "constType": "âˆ€ {Î± : Type u_1} (S : Set (Set Î±)), (â‹ƒâ‚€ S)á¶œ = â‹‚â‚€ (compl '' S)",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.5",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen sá¶œ = IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "funext",
   "Set.iUnion",
   "Set.preimage",
   "of_eq_true",
   "Set",
   "congrArg",
   "Set.preimage_iUnion",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "Set.preimage_iUnionâ‚‚",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {Îº : Î¹ â†’ Sort u_7} {f : Î± â†’ Î²} {s : (i : Î¹) â†’ Îº i â†’ Set Î²},\n  f â»Â¹' â‹ƒ i, â‹ƒ j, s i j = â‹ƒ i, â‹ƒ j, f â»Â¹' s i j",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds",
   "PartialOrder.toPreorder",
   "IsLeast.unique",
   "Set",
   "IsLUB",
   "Eq",
   "PartialOrder"],
  "name": "IsLUB.unique",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] {s : Set Î±} {a b : Î±}, IsLUB s a â†’ IsLUB s b â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.IsOpen_of._closed_12", "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.eq_empty_iff_forall_not_mem",
   "Membership.mem",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.11",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (s = âˆ…) = âˆ€ (x : Î±), Â¬x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff"],
  "name": "iff_of_true",
  "constType": "âˆ€ {a b : Prop}, a â†’ b â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references":
  ["Functor.map",
   "Monad",
   "Monad.toApplicative",
   "ReaderT",
   "Applicative.toFunctor",
   "Functor",
   "Functor.mapConst",
   "Functor.mk"],
  "name": "ReaderT.instFunctorReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ Functor (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.const",
  "constType": "{Î± : Sort u} â†’ (Î² : Sort v) â†’ Î± â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["IsGLB.insert",
   "IsGLB",
   "Set.instSingletonSet",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "Singleton.singleton",
   "Insert.insert",
   "SemilatticeInf",
   "Set.instInsertSet",
   "isGLB_singleton"],
  "name": "isGLB_pair",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] {a b : Î³}, IsGLB {a, b} (a âŠ“ b)",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_add.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ Prop) (x : â„•), (Unit â†’ motive 0) â†’ (âˆ€ (n : â„•), motive (Nat.succ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["PSigma", "PSigma.rec", "PSigma.mk"],
  "name": "PSigma.casesOn",
  "constType":
  "{Î± : Sort u} â†’\n  {Î² : Î± â†’ Sort v} â†’\n    {motive : PSigma Î² â†’ Sort u_1} â†’\n      (t : PSigma Î²) â†’ ((fst : Î±) â†’ (snd : Î² fst) â†’ motive { fst := fst, snd := snd }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "CompleteLattice.toTop",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "CompleteLattice.le_top",
  "constType": "âˆ€ {Î± : Type u_9} [self : CompleteLattice Î±] (x : Î±), x â‰¤ âŠ¤",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Mathlib.Data.List.Chain._auxLemma.7",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b : Î±} {l : List Î±}, (a âˆˆ b :: l) = (a = b âˆ¨ a âˆˆ l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.2",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±} {l : List Î±},\n  List.Pairwise R (a :: l) = ((âˆ€ a' âˆˆ l, R a a') âˆ§ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "List.Sublist",
   "instBEq",
   "List.Sublist.count_le",
   "LE.le",
   "List.filter_eq",
   "Iff.mpr",
   "List.count_replicate_self",
   "Eq",
   "Iff.intro",
   "Decidable.decide",
   "List.replicate_sublist_replicate",
   "Iff",
   "instLENat",
   "DecidableEq",
   "List",
   "List.Sublist.trans",
   "List.filter_sublist",
   "Eq.rec",
   "Eq.mp",
   "List.replicate",
   "Nat",
   "congrArg",
   "List.count",
   "congrFun"],
  "name": "List.le_count_iff_replicate_sublist",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {n : â„•} {a : Î±} {l : List Î±},\n  n â‰¤ List.count a l â†” List.Sublist (List.replicate n a) l",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "eq_false", "False", "Eq"],
  "name": "and_false",
  "constType": "âˆ€ (p : Prop), (p âˆ§ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp",
   "PartialOrder.toPreorder",
   "Disjoint",
   "disjoint_comm",
   "OrderBot",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Disjoint.symm",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : OrderBot Î±] â¦ƒa b : Î±â¦„, Disjoint a b â†’ Disjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Set",
   "True",
   "Mathlib.Order.Filter.Basic._auxLemma.3",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Mathlib.Order.Filter.Basic._auxLemma.2",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "congr",
   "Filter",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "congrFun",
   "Mathlib.Order.Filter.Basic._auxLemma.4"],
  "name": "Filter.ext_iff",
  "constType":
  "âˆ€ {Î± : Type u} {f g : Filter Î±}, f = g â†” âˆ€ (s : Set Î±), s âˆˆ f â†” s âˆˆ g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.not_nonempty_empty.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : Set.Nonempty âˆ… â†’ Prop) (x : Set.Nonempty âˆ…),\n  (âˆ€ (w : Î±) (hx : w âˆˆ âˆ…), motive (_ : âˆƒ x, x âˆˆ âˆ…)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.get._sunfold.proof_1",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "rfl",
   "instLTNat",
   "Eq",
   "List.get?_eq_get.match_1",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "Option.some",
   "instOfNatNat",
   "Nat",
   "List.get?",
   "List.get",
   "Fin.mk",
   "Option"],
  "name": "List.get?_eq_get",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} {n : â„•} (h : n < List.length l), List.get? l n = some (List.get l { val := n, isLt := h })",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.lift.proof_2",
   "LE.mk",
   "Preorder.toLT",
   "LT.lt",
   "LT.mk",
   "Preorder",
   "Preorder.lift.proof_3",
   "LE.le",
   "Preorder.lift.proof_1",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Preorder.lift",
  "constType":
  "{Î± : Type u_3} â†’ {Î² : Type u_4} â†’ [inst : Preorder Î²] â†’ (Î± â†’ Î²) â†’ Preorder Î±",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "MonadStateOf",
  "constType":
  "semiOutParam (Type u) â†’ (Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references": ["semiOutParam"],
  "name": "MonadExceptOf",
  "constType":
  "semiOutParam (Type u) â†’ (Type v â†’ Type w) â†’ Type (max (max u (v + 1)) w)",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "Iff",
   "Topology.isUpperSet_orderDual",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.isLowerSet_orderDual",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±], Topology.IsLowerSet Î±áµ’áµˆ â†” Topology.IsUpperSet Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "CompleteLattice.sInf_le",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_9",
  "constType": "âˆ€ {Î± : Type u_1} (s : Set (Filter Î±)áµ’áµˆáµ’áµˆ), âˆ€ a âˆˆ s, sInf s â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Eq.to_iff", "Iff", "Eq"],
  "name": "iff_of_eq",
  "constType": "âˆ€ {a b : Prop}, a = b â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HAppend"],
  "name": "HAppend.hAppend",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HAppend Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "IsCancelAdd",
   "AddMonoid.toAddZeroClass",
   "AddCancelMonoid.toIsCancelAdd.proof_1"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "âˆ€ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "And", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.inter",
  "constType": "{Î± : Type u_1} â†’ Set Î± â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.5",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b âˆ§ c) = (b âˆ§ a âˆ§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set",
   "GE.ge",
   "Eq.refl",
   "IsOpen.inter",
   "Inter.inter",
   "Exists.intro",
   "isOpen_univ",
   "Eq",
   "Filter.principal",
   "Filter.HasBasis",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Filter",
   "Set.inter_subset_right",
   "IsOpen",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "nhds",
   "nhds_basis_opens.match_1",
   "Set.univ",
   "Set.instLESet",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "nhds_def",
   "Order.Preimage",
   "And",
   "Eq.ndrec",
   "iInf",
   "Filter.hasBasis_biInf_principal",
   "And.intro",
   "Set.inter_subset_left",
   "Set.mem_univ",
   "Set.instInterSet"],
  "name": "nhds_basis_opens",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (a : Î±), Filter.HasBasis (nhds a) (fun s â†¦ a âˆˆ s âˆ§ IsOpen s) fun s â†¦ s",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Pi.orderBot",
   "OrderBot.toBot",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.bot_le",
   "Pi.hasLe",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE"],
  "name": "Pi.heytingAlgebra.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ HeytingAlgebra (Î± i)] (a : (i : Î¹) â†’ Î± i), âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Decidable", "Eq"],
  "name": "decEq",
  "constType":
  "{Î± : Sort u} â†’ [inst : DecidableEq Î±] â†’ (a b : Î±) â†’ Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} â†’ [self : AddCommMonoidWithOne R] â†’ AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "PUnit"],
  "name": "EStateM.dummySave",
  "constType": "{Ïƒ : Type u} â†’ Ïƒ â†’ PUnit.{u_1}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "upperBounds",
   "Set",
   "Preorder",
   "Set.instMembershipSet"],
  "name": "IsGreatest",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_refl",
  "constType": "âˆ€ {Î± : Type u} [self : Preorder Î±] (a : Î±), a â‰¤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Mathlib.Logic.Basic._auxLemma.41",
   "Set",
   "Eq.refl",
   "IsGreatest",
   "Preorder",
   "Set.univ",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "And",
   "upperBounds",
   "Iff",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Mathlib.Order.Bounds.Basic._auxLemma.12",
   "of_eq_true",
   "forall_congr",
   "congr",
   "IsTop",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "isGreatest_univ_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, IsGreatest Set.univ a â†” IsTop a",
  "constCategory": "Theorem"},
 {"references": ["BEq", "BEq.mk", "Lean.Name.beq", "Lean.Name"],
  "name": "Lean.Name.instBEqName",
  "constType": "BEq Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Set",
   "LowerSet.instSetLikeLowerSet",
   "SetLike.ext'",
   "LE",
   "SetLike.coe",
   "Eq"],
  "name": "LowerSet.ext",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] {s t : LowerSet Î±}, â†‘s = â†‘t â†’ s = t",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CompleteBooleanAlgebra",
   "funext",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "CompleteBooleanAlgebra.toSupSet",
   "compl_compl",
   "HasCompl.compl",
   "compl_injective",
   "BooleanAlgebra.toHasCompl",
   "iSup",
   "True",
   "CompleteBooleanAlgebra.toInfSet",
   "Eq",
   "iInf",
   "of_eq_true",
   "compl_iInf",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "compl_iSup",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} [inst : CompleteBooleanAlgebra Î±] {f : Î¹ â†’ Î±}, (iSup f)á¶œ = â¨… i, (f i)á¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "Function.LeftInverse",
   "EquivLike",
   "outParam",
   "EquivLike.inv"],
  "name": "EquivLike.left_inv",
  "constType":
  "âˆ€ {E : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EquivLike E Î± Î²] (e : E),\n  Function.LeftInverse (EquivLike.inv e) (EquivLike.coe e)",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.range_loop_range'.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ â„• â†’ Prop) (x x_1 : â„•), (âˆ€ (n : â„•), motive 0 n) â†’ (âˆ€ (s n : â„•), motive (Nat.succ s) n) â†’ motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "le_iSupâ‚‚",
   "iSup_subtype.match_1",
   "iSup",
   "le_iSup",
   "iSup_le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "iSupâ‚‚_le",
   "Subtype",
   "CompleteLattice.toSupSet",
   "Subtype.mk"],
  "name": "iSup_subtype",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {p : Î¹ â†’ Prop} {f : Subtype p â†’ Î±},\n  iSup f = â¨† i, â¨† (h : p i), f { val := i, property := h }",
  "constCategory": "Theorem"},
 {"references": ["Ordering"],
  "name": "Ordering.lt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.12",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ§ b) âˆ§ c) = (a âˆ§ b âˆ§ c)",
  "constCategory": "Theorem"},
 {"references": ["LowerSet", "IsLowerSet", "Set", "LowerSet.mk", "LE"],
  "name": "LowerSet.rec",
  "constType":
  "{Î± : Type u_6} â†’\n  [inst : LE Î±] â†’\n    {motive : LowerSet Î± â†’ Sort u} â†’\n      ((carrier : Set Î±) â†’ (lower' : IsLowerSet carrier) â†’ motive { carrier := carrier, lower' := lower' }) â†’\n        (t : LowerSet Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EmbeddingLike.injective'",
   "Function.Injective",
   "EmbeddingLike",
   "FunLike.coe"],
  "name": "EmbeddingLike.injective",
  "constType":
  "âˆ€ {F : Sort u_1} {Î± : Sort u_2} {Î² : Sort u_3} [i : EmbeddingLike F Î± Î²] (f : F), Function.Injective â†‘f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 â†’ Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Set", "LE", "UpperSet.mk", "IsUpperSet", "UpperSet.rec", "UpperSet"],
  "name": "UpperSet.casesOn",
  "constType":
  "{Î± : Type u_6} â†’\n  [inst : LE Î±] â†’\n    {motive : UpperSet Î± â†’ Sort u} â†’\n      (t : UpperSet Î±) â†’\n        ((carrier : Set Î±) â†’ (upper' : IsUpperSet carrier) â†’ motive { carrier := carrier, upper' := upper' }) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.le",
   "instLENat",
   "Nat.pred",
   "Nat.pred_le_pred.match_1",
   "Nat.le_succ",
   "Nat.le_trans",
   "instOfNatNat",
   "Nat.le.refl",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.pred_le_pred",
  "constType": "âˆ€ {n m : â„•}, n â‰¤ m â†’ Nat.pred n â‰¤ Nat.pred m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Ne",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.Nodup.map_on.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {l : List Î±} (a b : Î±) (motive : a âˆˆ l âˆ§ b âˆˆ l âˆ§ a â‰  b â†’ Prop) (x : a âˆˆ l âˆ§ b âˆˆ l âˆ§ a â‰  b),\n  (âˆ€ (ma : a âˆˆ l) (mb : b âˆˆ l) (n : a â‰  b), motive (_ : a âˆˆ l âˆ§ b âˆˆ l âˆ§ a â‰  b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u â†’ Lean.Syntax â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.nodup_cons",
   "List.Nodup",
   "List.instMembershipList",
   "List",
   "Not",
   "And.intro",
   "Iff.mpr"],
  "name": "List.Nodup.cons",
  "constType":
  "âˆ€ {Î± : Type u} {l : List Î±} {a : Î±}, Â¬a âˆˆ l â†’ List.Nodup l â†’ List.Nodup (a :: l)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Â«termð“[_]_Â»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Finite",
   "Set.Finite",
   "Set.toFinite",
   "Finite.Set.finite_range"],
  "name": "Set.finite_range",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort w} (f : Î¹ â†’ Î±) [inst : Finite Î¹], Set.Finite (Set.range f)",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.toLower._cstage1",
  "constType": "{Î± : Type u_1} â†’ Î± â‰ƒ Topology.WithLower Î±",
  "constCategory": "Definition"},
 {"references": ["GeneralizedBooleanAlgebra", "SDiff"],
  "name": "GeneralizedBooleanAlgebra.toSDiff",
  "constType": "{Î± : Type u} â†’ [self : GeneralizedBooleanAlgebra Î±] â†’ SDiff Î±",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "instDiscreteTopologyProdInstTopologicalSpaceProd.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (motive : Î± Ã— Î² â†’ Prop) (x : Î± Ã— Î²), (âˆ€ (a : Î±) (b : Î²), motive (a, b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero",
   "instLENat",
   "Nat.pred",
   "Unit",
   "Nat.pred_le.match_1",
   "Nat.le_succ",
   "Nat.le.refl",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.pred_le",
  "constType": "âˆ€ (n : â„•), Nat.pred n â‰¤ n",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.le.step",
  "constType": "âˆ€ {n m : â„•}, Nat.le n m â†’ Nat.le n (Nat.succ m)",
  "constCategory": "Other"},
 {"references":
  ["IsGLB",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Set.insert_eq",
   "Set",
   "Inf.inf",
   "Union.union",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "Insert.insert",
   "isGLB_singleton",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "IsGLB.union",
   "Singleton.singleton",
   "SemilatticeInf",
   "Set.instUnionSet",
   "Set.instInsertSet",
   "id"],
  "name": "IsGLB.insert",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : SemilatticeInf Î³] (a : Î³) {b : Î³} {s : Set Î³}, IsGLB s b â†’ IsGLB (insert a s) (a âŠ“ b)",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "Eq.symm",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.8",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsClosed s = IsOpen sá¶œ",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equivalence"],
  "name": "Equivalence.refl",
  "constType":
  "âˆ€ {Î± : Sort u} {r : Î± â†’ Î± â†’ Prop}, Equivalence r â†’ âˆ€ (x : Î±), r x x",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_2",
  "constType": "âˆ€ {Î± : Type u_1} (a b c : Î± â†’ Prop), a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.head",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} (as : List Î±), List.Mem a (a :: as)",
  "constCategory": "Other"},
 {"references": ["BEq", "Bool"],
  "name": "BEq.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Bool) â†’ BEq Î±",
  "constCategory": "Other"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{Î± : Type u_9} â†’ [self : CompleteLattice Î±] â†’ Top Î±",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "String.csize",
   "PProd",
   "Char",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "String.utf8ByteSize.go.match_1"],
  "name": "String.utf8ByteSize.go",
  "constType": "List Char â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.SourceInfo.rec",
   "Lean.SourceInfo.original",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "Substring",
   "String.Pos"],
  "name": "Lean.SourceInfo.casesOn",
  "constType":
  "{motive : Lean.SourceInfo â†’ Sort u} â†’\n  (t : Lean.SourceInfo) â†’\n    ((leading : Substring) â†’\n        (pos : String.Pos) â†’\n          (trailing : Substring) â†’\n            (endPos : String.Pos) â†’ motive (Lean.SourceInfo.original leading pos trailing endPos)) â†’\n      ((pos endPos : String.Pos) â†’ (canonical : Bool) â†’ motive (Lean.SourceInfo.synthetic pos endPos canonical)) â†’\n        motive Lean.SourceInfo.none â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Finset.instMembershipFinset",
   "Mathlib.Data.Finset.Basic._auxLemma.17",
   "True",
   "Multiset.instMembershipMultiset",
   "of_eq_true",
   "Finset",
   "Multiset",
   "Finset.val",
   "Not",
   "Mathlib.Data.Finset.Basic._auxLemma.15",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.16"],
  "name": "Finset.not_mem_empty",
  "constType": "âˆ€ {Î± : Type u_1} (a : Î±), Â¬a âˆˆ âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "Iff.intro",
   "Iff",
   "of_decide_eq_false",
   "Bool.false",
   "decide_eq_false",
   "Decidable",
   "Not",
   "Bool",
   "Eq"],
  "name": "decide_eq_false_iff_not",
  "constType": "âˆ€ (p : Prop) [inst : Decidable p], decide p = false â†” Â¬p",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "congr_arg", "Function.Injective", "Eq"],
  "name": "Function.Injective.eq_iff",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²}, Function.Injective f â†’ âˆ€ {a b : Î±}, f a = f b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instMonadState",
   "MonadStateOf.set",
   "MonadStateOf.get",
   "liftM",
   "MonadLift",
   "MonadState.modifyGet",
   "PUnit",
   "instMonadLiftT",
   "Prod",
   "MonadLiftT.monadLift",
   "MonadStateOf.mk",
   "MonadStateOf",
   "instMonadLiftT_1"],
  "name": "instMonadStateOf",
  "constType":
  "{Ïƒ : Type u} â†’\n  {m : Type u â†’ Type v} â†’ {n : Type u â†’ Type w} â†’ [inst : MonadLift m n] â†’ [inst : MonadStateOf Ïƒ m] â†’ MonadStateOf Ïƒ n",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Set.preimage",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Iff.rfl",
   "Set",
   "Topology.upper",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpper.toUpper",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.isOpen_def",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set (Topology.WithUpper Î±)},\n  IsOpen s â†” TopologicalSpace.IsOpen (â†‘Topology.WithUpper.toUpper â»Â¹' s)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.termð“._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Eq", "congrFun"],
  "name": "congr_fun",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x}, f = g â†’ âˆ€ (a : Î±), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "False",
   "instLENat",
   "Nat.not_le_of_gt",
   "flip",
   "LT.lt",
   "Not",
   "Nat.ge_of_not_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.not_lt",
  "constType": "âˆ€ {a b : â„•}, Â¬a < b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Iff",
   "forall_eq",
   "Set",
   "HasSubset.Subset",
   "Singleton.singleton",
   "Set.instMembershipSet"],
  "name": "Set.singleton_subset_iff",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {s : Set Î±}, {a} âŠ† s â†” a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.mp",
   "List.mem_range",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "List.range"],
  "name": "List.finRange.proof_1",
  "constType": "âˆ€ (n x : â„•), x âˆˆ List.range n â†’ x < n",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Nonempty", "instNonempty.proof_1"],
  "name": "instNonempty",
  "constType": "âˆ€ {Î± : Sort u} [inst : Inhabited Î±], Nonempty Î±",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Std.Logic._auxLemma.52",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) = (a âˆ§ b)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat", "List", "instOfNatNat", "Bool", "Nat", "List.countP.go"],
  "name": "List.countP",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Bool) â†’ List Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_right",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, b â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "Continuous",
   "ContinuousAt",
   "TopologicalSpace",
   "continuous_iff_continuousAt",
   "Eq"],
  "name": "Mathlib.Topology.Maps._auxLemma.1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Continuous f = âˆ€ (x : Î±), ContinuousAt f x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmbeddingLike.toFunLike",
   "Exists",
   "Iff.rfl",
   "Finset.instMembershipFinset",
   "FunLike.coe",
   "Multiset.instMembershipMultiset",
   "Eq",
   "Finset.map",
   "Multiset.map",
   "And",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Multiset",
   "Finset.val",
   "Multiset.mem_map",
   "Function.Embedding",
   "Iff.trans",
   "id"],
  "name": "Finset.mem_map",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†ª Î²} {s : Finset Î±} {b : Î²}, b âˆˆ Finset.map f s â†” âˆƒ a âˆˆ s, â†‘f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Pi.preorder",
   "LT.lt",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_3",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ PartialOrder (Ï€ i)] (a b : (i : Î¹) â†’ Ï€ i), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff.intro",
   "Nonempty.intro",
   "Exists",
   "Iff",
   "Finite.intro",
   "Finite",
   "Exists.intro",
   "finite_iff_exists_equiv_fin.match_1",
   "Nat",
   "finite_iff_exists_equiv_fin.match_2",
   "Fin",
   "Nonempty"],
  "name": "finite_iff_exists_equiv_fin",
  "constType": "âˆ€ {Î± : Sort u_3}, Finite Î± â†” âˆƒ n, Nonempty (Î± â‰ƒ Fin n)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "iInf_mono",
   "iInf_const_mono",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "biInf_mono",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} [inst : CompleteLattice Î±] {f : Î¹ â†’ Î±} {p q : Î¹ â†’ Prop},\n  (âˆ€ (i : Î¹), p i â†’ q i) â†’ â¨… i, â¨… (_ : q i), f i â‰¤ â¨… i, â¨… (_ : p i), f i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_5"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lowerSet.proof_3",
   "TopologicalSpace.mk",
   "Topology.lowerSet.proof_1",
   "IsLowerSet",
   "TopologicalSpace",
   "Preorder",
   "Topology.lowerSet.proof_2",
   "Preorder.toLE"],
  "name": "Topology.lowerSet",
  "constType": "(Î± : Type u_4) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "IsRefl",
   "Set",
   "Set.instIsReflSetSubsetInstHasSubsetSet.proof_1",
   "HasSubset.Subset"],
  "name": "Set.instIsReflSetSubsetInstHasSubsetSet",
  "constType": "âˆ€ {Î± : Type u}, IsRefl (Set Î±) fun x x_1 â†¦ x âŠ† x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "List",
   "LT.lt",
   "List.length",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "List.get._sunfold.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (head : Î±) (as : List Î±) (i : â„•), Nat.succ i < List.length (head :: as) â†’ Nat.succ i â‰¤ List.length as",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name._impl",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Specializes",
   "propext",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Singleton.singleton",
   "specializes_iff_closure_subset",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.3",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x â¤³ y = (closure {y} âŠ† closure {x})",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Eq.rec",
   "Set",
   "TopologicalSpace.GenerateOpen.sUnion",
   "Set.sUnion",
   "TopologicalSpace.GenerateOpen",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)),\n  {u | TopologicalSpace.GenerateOpen s u} = s â†’\n    âˆ€ (s_1 : Set (Set Î±)), (âˆ€ t âˆˆ s_1, (fun u â†¦ u âˆˆ s) t) â†’ (fun u â†¦ u âˆˆ s) (â‹ƒâ‚€ s_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "imp_congr_right",
   "nhds",
   "Set",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Filter.principal",
   "Iff",
   "Filter.le_principal_iff",
   "isOpen_iff_nhds",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "IsOpen",
   "instMembershipSetFilter",
   "forall_congr'"],
  "name": "isOpen_iff_mem_nhds",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, IsOpen s â†” âˆ€ a âˆˆ s, s âˆˆ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.rec._cstage1",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Topology.WithLower Î± â†’ Sort u_1} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithLower.toLower a)) â†’ (a : Topology.WithLower Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3995",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLowerSet",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Preorder"],
  "name": "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Iff",
   "Decidable",
   "Not",
   "Iff.trans",
   "or_comm",
   "Decidable.imp_iff_not_or"],
  "name": "Decidable.imp_iff_or_not",
  "constType": "âˆ€ {b a : Prop} [inst : Decidable b], b â†’ a â†” a âˆ¨ Â¬b",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "HeytingAlgebra",
   "Bot.bot",
   "inf_compl_self",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "Eq"],
  "name": "inf_compl_eq_bot",
  "constType": "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a : Î±}, a âŠ“ aá¶œ = âŠ¥",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Prod.instPreorderProd.match_1",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) (motive : Î± Ã— Î² â†’ Prop) (x : Î± Ã— Î²), (âˆ€ (a : Î±) (b : Î²), motive (a, b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithLower.instTopologicalSpaceWithLower._cstage2",
  "constType": "_neutral â†’ _obj â†’ _obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_and_left", "Eq"],
  "name": "Std.Logic._auxLemma.40",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, b âˆ§ p x) = (b âˆ§ âˆƒ x, p x)",
  "constCategory": "Theorem"},
 {"references": ["upperBounds", "Set", "IsLeast", "Preorder"],
  "name": "IsLUB",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Set Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Order.Filter.Basic._auxLemma.25",
   "Set",
   "Union.union",
   "HasSubset.Subset",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "CompleteLattice.toLattice",
   "Mathlib.Order.Filter.Basic._auxLemma.57",
   "Filter.principal",
   "And",
   "Set.instHasSubsetSet",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Filter",
   "Filter.ext",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "Set.instUnionSet",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.sup_principal",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, Filter.principal s âŠ” Filter.principal t = Filter.principal (s âˆª t)",
  "constCategory": "Theorem"},
 {"references":
  ["Inducing.mk",
   "Inducing.rec",
   "TopologicalSpace",
   "Inducing",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "Inducing.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [tÎ± : TopologicalSpace Î±] â†’\n      [tÎ² : TopologicalSpace Î²] â†’\n        {f : Î± â†’ Î²} â†’\n          {motive : Inducing f â†’ Sort u} â†’\n            (t : Inducing f) â†’ ((induced : tÎ± = TopologicalSpace.induced f tÎ²) â†’ motive (_ : Inducing f)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Or.resolve_left",
   "Ne",
   "OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.pos_of_ne_zero",
  "constType": "âˆ€ {n : â„•}, n â‰  0 â†’ 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : â„• â†’ Sort u} â†’ (t : â„•) â†’ ((t : â„•) â†’ Nat.below t â†’ motive t) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{Î± : Type u_1} â†’ [inst : Sub Î±] â†’ HSub Î± Î± Î±",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_6",
   "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_4",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "âˆ€ {Î± : Type u} [self : Semiring Î±], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_termð“Ë¢_1Â»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Filter Î± â†’ Filter Î² â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Setoid.r",
   "List.nodup_cons",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons",
   "Not",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.nodup_cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {a : Î±} {s : Multiset Î±}, Multiset.Nodup (a ::â‚˜ s) â†” Â¬a âˆˆ s âˆ§ Multiset.Nodup s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Expr.op", "Lean.Data.AC.Expr", "Nat", "Lean.Data.AC.Expr.var"],
  "name": "Lean.Data.AC.Expr.rec",
  "constType":
  "{motive : Lean.Data.AC.Expr â†’ Sort u} â†’\n  ((x : â„•) â†’ motive (Lean.Data.AC.Expr.var x)) â†’\n    ((lhs rhs : Lean.Data.AC.Expr) â†’ motive lhs â†’ motive rhs â†’ motive (Lean.Data.AC.Expr.op lhs rhs)) â†’\n      (t : Lean.Data.AC.Expr) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Decidable.rec"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} â†’\n  {motive : Decidable p â†’ Sort u} â†’\n    (t : Decidable p) â†’ ((h : Â¬p) â†’ motive (isFalse h)) â†’ ((h : p) â†’ motive (isTrue h)) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_sup_inf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DistribLattice Î±] {x y z : Î±}, (x âŠ” y) âŠ“ (x âŠ” z) â‰¤ x âŠ” y âŠ“ z",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context.mk",
   "Lean.Macro.Context",
   "instMonadReaderOfReaderT",
   "Lean.Macro.Context.currMacroScope",
   "ReaderT.instMonadReaderT",
   "Lean.MacroM",
   "Lean.MonadRef",
   "Lean.Macro.Context.ref",
   "Pure.pure",
   "ReaderT.instApplicativeReaderT",
   "Monad.toBind",
   "Lean.Syntax",
   "MonadReader.read",
   "Lean.Macro.Context.methods",
   "EStateM.instMonadEStateM",
   "instMonadWithReaderOfReaderT",
   "instMonadWithReader",
   "instMonadReader",
   "Lean.Macro.State",
   "Lean.Macro.Context.mainModule",
   "Lean.MonadRef.mk",
   "Lean.Macro.Exception",
   "Lean.Macro.Context.maxRecDepth",
   "Lean.Macro.Context.currRecDepth",
   "Bind.bind",
   "MonadWithReader.withReader",
   "Applicative.toPure"],
  "name": "Lean.Macro.instMonadRefMacroM",
  "constType": "Lean.MonadRef Lean.MacroM",
  "constCategory": "Definition"},
 {"references": ["GaloisCoinsertion", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisCoinsertion.u_l_le",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±},\n  GaloisCoinsertion l u â†’ âˆ€ (x : Î±), u (l x) â‰¤ x",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.Â«termð“[_]_Â»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[_]_Â»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context",
   "Option.none",
   "Unit",
   "Unit.unit",
   "Lean.Data.AC.Variable.value",
   "Option.some",
   "Option.casesOn",
   "Lean.IsNeutral",
   "Nat",
   "Lean.Data.AC.Context.var",
   "Option"],
  "name": "Lean.Data.AC.Context.unwrap_isNeutral.match_1",
  "constType":
  "{Î± : Sort u_1} â†’\n  {ctx : Lean.Data.AC.Context Î±} â†’\n    {x : â„•} â†’\n      (motive : Option (Lean.IsNeutral ctx.op (Lean.Data.AC.Context.var ctx x).value) â†’ Sort u_2) â†’\n        (x_1 : Option (Lean.IsNeutral ctx.op (Lean.Data.AC.Context.var ctx x).value)) â†’\n          ((hn : Lean.IsNeutral ctx.op (Lean.Data.AC.Context.var ctx x).value) â†’ motive (some hn)) â†’\n            (Unit â†’ motive none) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "List.cons",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "List.Pairwise.below",
   "List",
   "List.Pairwise.below.nil",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.below.rec",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop}\n  {motive_1 : {a : List Î±} â†’ (x : List.Pairwise R a) â†’ List.Pairwise.below x â†’ Prop},\n  motive_1 (_ : List.Pairwise R []) (_ : List.Pairwise.below (_ : List.Pairwise R [])) â†’\n    (âˆ€ {a : Î±} {l : List Î±} (a_1 : âˆ€ a' âˆˆ l, R a a') {a_2 : List.Pairwise R l} (a_3 : List.Pairwise.below a_2)\n        (a_4 : motive l a_2),\n        motive_1 a_2 a_3 â†’\n          motive_1 (_ : List.Pairwise R (a :: l)) (_ : List.Pairwise.below (_ : List.Pairwise R (a :: l)))) â†’\n      âˆ€ {a : List Î±} {x : List.Pairwise R a} (t : List.Pairwise.below x), motive_1 x t",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "Iff",
   "not_lt_of_ge",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_of_not_gt",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_lt",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b : Î±}, Â¬a < b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Order.Frame",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Set",
   "iSup",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Order.Frame.mk",
  "constType":
  "{Î± : Type u_1} â†’\n  [toCompleteLattice : CompleteLattice Î±] â†’ (âˆ€ (a : Î±) (s : Set Î±), a âŠ“ sSup s â‰¤ â¨† b âˆˆ s, a âŠ“ b) â†’ Order.Frame Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "propext",
   "Filter.empty_mem_iff_bot",
   "Set",
   "Set.instEmptyCollectionSet",
   "Filter",
   "CompleteLattice.toBot",
   "Eq.symm",
   "Filter.instCompleteLatticeFilter",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.20",
  "constType": "âˆ€ {Î± : Type u} {f : Filter Î±}, (f = âŠ¥) = (âˆ… âˆˆ f)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Filter.Eventually.mp",
   "Not",
   "Filter",
   "And.intro",
   "Filter.Eventually",
   "mt",
   "Filter.Eventually.mono",
   "Filter.Frequently"],
  "name": "Filter.Frequently.and_eventually",
  "constType":
  "âˆ€ {Î± : Type u} {p q : Î± â†’ Prop} {f : Filter Î±},\n  (âˆƒá¶  (x : Î±) in f, p x) â†’ (âˆ€á¶  (x : Î±) in f, q x) â†’ âˆƒá¶  (x : Î±) in f, p x âˆ§ q x",
  "constCategory": "Theorem"},
 {"references": ["Or", "propext", "or_assoc", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.10",
  "constType": "âˆ€ {a b c : Prop}, ((a âˆ¨ b) âˆ¨ c) = (a âˆ¨ b âˆ¨ c)",
  "constCategory": "Theorem"},
 {"references": ["List", "List.Sublist"],
  "name": "List.Sublist.below",
  "constType":
  "{Î± : Type u_1} â†’ {motive : (a a_1 : List Î±) â†’ List.Sublist a a_1 â†’ Prop} â†’ {a a_1 : List Î±} â†’ List.Sublist a a_1 â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro", "Or", "Iff.mp", "Iff", "Or.inr", "or_iff_left_of_imp"],
  "name": "or_iff_left_iff_imp",
  "constType": "âˆ€ {a b : Prop}, (a âˆ¨ b â†” a) â†” b â†’ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.TFAE._hyg.531",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "true_and",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "PLift",
   "True",
   "Eq",
   "iff_self",
   "Set.range",
   "Fintype",
   "Iff",
   "PLift.up",
   "forall_congr",
   "Finset.image",
   "Finset",
   "Mathlib.Data.ULift._auxLemma.3",
   "Mathlib.Data.Finset.Image._auxLemma.24",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "Function.comp",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.univ",
   "And",
   "of_eq_true",
   "DecidableEq",
   "PLift.down",
   "congr",
   "congrArg",
   "congrFun"],
  "name": "Set.fintypeRange.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_2} [inst : DecidableEq Î±] (f : Î¹ â†’ Î±) [inst_1 : Fintype (PLift Î¹)] (a : Î±),\n  a âˆˆ Finset.image (f âˆ˜ PLift.down) Finset.univ â†” a âˆˆ Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "Eq.refl",
   "Lean.Data.AC.mergeIdem.loop",
   "instDecidableTrue",
   "instDecidableEqNat",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "of_eq_true",
   "List",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Lean.Data.AC.Context.mergeIdem_head",
  "constType":
  "âˆ€ {x : â„•} {xs : List â„•}, Lean.Data.AC.mergeIdem (x :: x :: xs) = Lean.Data.AC.mergeIdem (x :: xs)",
  "constCategory": "Theorem"},
 {"references": ["true_and", "And", "Iff", "iff_of_eq", "True"],
  "name": "true_and_iff",
  "constType": "âˆ€ (p : Prop), True âˆ§ p â†” p",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Quot",
   "List.Perm.union",
   "HasEquiv.Equiv",
   "List.union",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.ndunion.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] (x x_1 x_2 x_3 : List Î±),\n  x â‰ˆ x_2 â†’ x_1 â‰ˆ x_3 â†’ Quot.mk Setoid.r (List.union x x_1) = Quot.mk Setoid.r (List.union x_2 x_3)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_iff",
   "Set",
   "Set.image",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Set.ball_image_of_ball",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {s : Set Î±} {p : Î² â†’ Prop}, (âˆ€ x âˆˆ s, p (f x)) â†’ âˆ€ y âˆˆ f '' s, p y",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Add"],
  "name": "AddHomClass",
  "constType":
  "Type u_9 â†’\n  (M : outParam (Type u_10)) â†’\n    (N : outParam (Type u_11)) â†’ [inst : Add M] â†’ [inst : Add N] â†’ Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (s : Set (Set Î±)), âˆ€ t âˆˆ s, âˆ€ a âˆˆ t, âˆƒ t âˆˆ s, a âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Filter.eq_sInf_of_mem_iff_exists_mem.match_1",
   "InfSet.sInf",
   "le_sInf",
   "Exists.intro",
   "Iff.mpr",
   "Eq",
   "Set.instMembershipSet",
   "sInf_le",
   "And",
   "Iff.mp",
   "Iff",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "Filter",
   "And.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.eq_sInf_of_mem_iff_exists_mem",
  "constType":
  "âˆ€ {Î± : Type u} {S : Set (Filter Î±)} {l : Filter Î±}, (âˆ€ {s : Set Î±}, s âˆˆ l â†” âˆƒ f âˆˆ S, s âˆˆ f) â†’ l = sInf S",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.cons",
   "List.Pairwise.below",
   "List.instMembershipList",
   "List",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.below.cons",
  "constType":
  "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {motive : (a : List Î±) â†’ List.Pairwise R a â†’ Prop} {a : Î±} {l : List Î±}\n  (a_1 : âˆ€ a' âˆˆ l, R a a') {a_2 : List.Pairwise R l},\n  List.Pairwise.below a_2 â†’ motive l a_2 â†’ List.Pairwise.below (_ : List.Pairwise R (a :: l))",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteSemilatticeInf.sInf_le",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "sInf_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeInf Î±] {s : Set Î±} {a : Î±}, a âˆˆ s â†’ sInf s â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "Topology.WithUpperSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsUpperSet.WithUpperSetHomeomorph._spec_1",
  "constType":
  "(Î± : Type u_1) â†’\n  (inst : Preorder Î±) â†’\n    (inst_1 : TopologicalSpace Î±) â†’\n      let _x_1 :=\n        { IsOpen := IsUpperSet, isOpen_univ := (_ : âˆ€ â¦ƒa b : Î±â¦„, a â‰¤ b â†’ a âˆˆ Set.univ â†’ b âˆˆ Set.univ),\n          isOpen_inter := (_ : âˆ€ (x x_1 : Set Î±), IsUpperSet x â†’ IsUpperSet x_1 â†’ IsUpperSet (Inter.interâœ x x_1)),\n          isOpen_sUnion := (_ : âˆ€ (x : Set (Set Î±)), (âˆ€ s âˆˆ x, IsUpperSet s) â†’ IsUpperSet (â‹ƒâ‚€ x)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithUpperSet Î± â‰ƒ Î±) â†’ Inducing â†‘f â†’ Topology.WithUpperSet Î± â‰ƒâ‚œ Î±",
  "constCategory": "Axiom"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u â†’ Type v â†’ Type (max u v)",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{Î± : Type u} â†’ [self : StrictOrderedSemiring Î±] â†’ Semiring Î±",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "PartialOrder.le_antisymm",
   "sup_le",
   "Sup.sup",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "GaloisConnection.l_le",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup.proof_3",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} {l : Î± â†’ Î²} {u : Î² â†’ Î±} [inst : PartialOrder Î²] [inst_1 : SemilatticeSup Î±],\n  GaloisInsertion l u â†’ âˆ€ (a b c : Î²), a â‰¤ c â†’ b â‰¤ c â†’ l (u a âŠ” u b) â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "Iff.intro",
   "And",
   "Set.Elem",
   "And.intro",
   "Set.image",
   "And.casesOn",
   "Subtype.mk",
   "Subtype.casesOn"],
  "name": "Set.image_eq_range",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (s : Set Î±), f '' s = Set.range fun x â†¦ f â†‘x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Unit",
   "Nat.not_succ_le_self.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_self_eq_true",
  "constType": "âˆ€ (n : â„•), Nat.ble n n = true",
  "constCategory": "Theorem"},
 {"references":
  ["List.Chain.rec", "List", "List.Chain.nil", "List.Chain", "List.Chain.cons"],
  "name": "List.Chain.imp'",
  "constType":
  "âˆ€ {Î± : Type u_1} {R S : Î± â†’ Î± â†’ Prop},\n  (âˆ€ â¦ƒa b : Î±â¦„, R a b â†’ S a b) â†’\n    âˆ€ {a b : Î±}, (âˆ€ â¦ƒc : Î±â¦„, R a c â†’ S b c) â†’ âˆ€ {l : List Î±}, List.Chain R a l â†’ List.Chain S b l",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Topology.WithUpperSet Î± â†’ Sort u_4} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithUpperSet.toUpperSet a)) â†’ (a : Topology.WithUpperSet Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "Nat.succ_le_succ",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.succ_le_succ_iff",
  "constType": "âˆ€ {a b : â„•}, Nat.succ a â‰¤ Nat.succ b â†” a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.instMembershipList",
   "dite",
   "Iff.mpr",
   "True",
   "Eq",
   "Mathlib.Data.List.Perm._auxLemma.30",
   "instOfNatNat",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "List.count_eq_one_of_mem",
   "List.count_eq_zero_of_not_mem",
   "Membership.mem",
   "eq_self",
   "List.perm_iff_count",
   "False",
   "List.dedup",
   "instBEq",
   "mt",
   "List.Perm.subset",
   "eq_true",
   "eq_false",
   "List.Perm",
   "List.Nodup",
   "of_eq_true",
   "DecidableEq",
   "List",
   "List.Perm.mem_iff",
   "List.instDecidableMemListInstMembershipList",
   "congr",
   "Mathlib.Data.List.Dedup._auxLemma.3",
   "Not",
   "List.count",
   "congrArg"],
  "name": "List.Perm.dedup",
  "constType":
  "âˆ€ {Î± : Type uu} [inst : DecidableEq Î±] {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ List.dedup lâ‚ ~ List.dedup lâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLower", "Preorder"],
  "name": "Topology.WithLower.instPreorderWithLower",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Preorder (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.elems",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Fintype.complete",
  "constType": "âˆ€ {Î± : Type u_4} [self : Fintype Î±] (x : Î±), x âˆˆ Fintype.elems",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.rfl",
   "Top.top",
   "Set",
   "Eq.refl",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Filter.instTopFilter",
   "propext",
   "Filter",
   "Filter.mem_top_iff_forall",
   "instMembershipSetFilter",
   "id"],
  "name": "Filter.mem_top",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s âˆˆ âŠ¤ â†” s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet.proof_1",
   "Topology.IsLowerSet",
   "Preorder"],
  "name":
  "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsLowerSet (Topology.WithLowerSet Î±)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Bind",
  "constType": "(Type u â†’ Type v) â†’ Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["IsCompl.disjoint",
   "PartialOrder.toPreorder",
   "Disjoint.symm",
   "IsCompl.mk",
   "IsCompl",
   "IsCompl.codisjoint",
   "BoundedOrder.toOrderTop",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "Codisjoint.symm",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.symm",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, IsCompl x y â†’ IsCompl y x",
  "constCategory": "Theorem"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Option.casesOn",
   "Option"],
  "name": "Option.toBool.match_1",
  "constType":
  "{Î± : Type u_1} â†’\n  (motive : Option Î± â†’ Sort u_2) â†’ (x : Option Î±) â†’ ((val : Î±) â†’ motive (some val)) â†’ (Unit â†’ motive none) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn"],
  "name": "Directed.mono.match_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {r : Î± â†’ Î± â†’ Prop} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±} (a b : Î¹)\n  (motive : (âˆƒ z, r (f a) (f z) âˆ§ r (f b) (f z)) â†’ Prop) (x : âˆƒ z, r (f a) (f z) âˆ§ r (f b) (f z)),\n  (âˆ€ (c : Î¹) (hâ‚ : r (f a) (f c)) (hâ‚‚ : r (f b) (f c)), motive (_ : âˆƒ z, r (f a) (f z) âˆ§ r (f b) (f z))) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.27",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.WF.0.InvImage.accAux.proof_1", "InvImage", "Acc", "Eq"],
  "name": "_private.Init.WF.0.InvImage.accAux",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {r : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²) {b : Î²}, Acc r b â†’ âˆ€ (x : Î±), f x = b â†’ Acc (InvImage r f) x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq"],
  "name": "induced_compose.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [tÎ³ : TopologicalSpace Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} (x : Set Î±)\n  (motive : IsOpen x â†’ Prop) (x_1 : IsOpen x),\n  (âˆ€ (w : Set Î²) (s : Set Î³) (hs : IsOpen s) (hâ‚‚ : g â»Â¹' s = w) (hâ‚ : f â»Â¹' w = x),\n      motive (_ : âˆƒ s', IsOpen s' âˆ§ f â»Â¹' s' = x)) â†’\n    motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "LowerSet.casesOn",
   "Eq.ndrec",
   "IsLowerSet",
   "Eq.rec",
   "Set",
   "Eq.refl",
   "LowerSet.mk",
   "LE",
   "Eq.symm",
   "LowerSet.carrier",
   "Eq"],
  "name": "LowerSet.instSetLikeLowerSet.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LE Î±] (s t : LowerSet Î±), s.carrier = t.carrier â†’ s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.Homotopy.Â«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termÎ©^_1Â»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LawfulBEq", "Nat.instLawfulBEqNatInstBEqNat.proof_1", "instBEqNat", "Nat"],
  "name": "Nat.instLawfulBEqNatInstBEqNat",
  "constType": "LawfulBEq â„•",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "And",
   "Nat.sub_lt",
   "Nat.div_rec_lemma.match_1",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "Nat.lt_of_lt_of_le",
   "LT.lt",
   "HSub.hSub",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div_rec_lemma",
  "constType": "âˆ€ {x y : â„•}, 0 < y âˆ§ y â‰¤ x â†’ x - y < x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "setOf",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.mkOfClosure.proof_2",
   "TopologicalSpace.GenerateOpen",
   "TopologicalSpace.mkOfClosure.proof_1",
   "TopologicalSpace.mkOfClosure.proof_3",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure",
  "constType":
  "{Î± : Type u} â†’ (s : Set (Set Î±)) â†’ {u | TopologicalSpace.GenerateOpen s u} = s â†’ TopologicalSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen"],
  "name": "IsClosed.isOpen_compl",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Iff",
   "setOf",
   "Set",
   "Filter",
   "Filter.Eventually",
   "Filter.HasBasis.mem_iff",
   "Set.instMembershipSet"],
  "name": "Filter.HasBasis.eventually_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±},\n  Filter.HasBasis l p s â†’ âˆ€ {q : Î± â†’ Prop}, (âˆ€á¶  (x : Î±) in l, q x) â†” âˆƒ i, p i âˆ§ âˆ€ â¦ƒx : Î±â¦„, x âˆˆ s i â†’ q x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Â«termI^_Â»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Inf.inf",
   "Set",
   "CompleteLattice.toBoundedOrder",
   "Eq.refl",
   "Inter.inter",
   "IsCompl",
   "CompleteLattice.toBot",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Eq.mpr",
   "IsCompl.of_eq",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.inf_principal",
   "BoundedOrder.toOrderBot",
   "Filter.instCompleteLatticeFilter",
   "id",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "Filter.sup_principal",
   "Top.top",
   "Set.union_compl_self",
   "Union.union",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instEmptyCollectionSet",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Filter.principal_univ",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Set.inter_compl_self",
   "Filter.instPartialOrderFilter",
   "OrderBot.toBot",
   "Filter.instInfFilter",
   "Sup.sup",
   "Filter.principal_empty",
   "Set.instUnionSet",
   "Set.instInterSet"],
  "name": "Filter.isCompl_principal",
  "constType":
  "âˆ€ {Î± : Type u} (s : Set Î±), IsCompl (Filter.principal s) (Filter.principal sá¶œ)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.Syntax.node4",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "by_contradiction"],
  "name": "by_contra",
  "constType": "âˆ€ {p : Prop}, (Â¬p â†’ False) â†’ p",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "Iff",
   "PartialOrder.toPreorder",
   "GeneralizedCoheytingAlgebra",
   "Sup.sup",
   "SDiff.sdiff",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.mk",
  "constType":
  "{Î± : Type u_4} â†’\n  [toLattice : Lattice Î±] â†’\n    [toBot : Bot Î±] â†’\n      [toSDiff : SDiff Î±] â†’ (âˆ€ (a : Î±), âŠ¥ â‰¤ a) â†’ (âˆ€ (a b c : Î±), a \\ b â‰¤ c â†” a â‰¤ b âŠ” c) â†’ GeneralizedCoheytingAlgebra Î±",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithLower.instTopologicalSpaceWithLower._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithLower Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.rec",
  "constType":
  "{Î± : Type u_2} â†’\n  {Î² : Topology.WithLower Î± â†’ Sort u_1} â†’\n    ((a : Î±) â†’ Î² (â†‘Topology.WithLower.toLower a)) â†’ (a : Topology.WithLower Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["PProd", "Lean.Name.rec", "String", "PUnit", "Nat", "Lean.Name"],
  "name": "Lean.Name.below",
  "constType": "{motive : Lean.Name â†’ Sort u} â†’ Lean.Name â†’ Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["isLowerSet_compl",
   "IsLowerSet",
   "Iff.mp",
   "IsClosed.isOpen_compl",
   "Topology.IsLower",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Topology.IsLower.isLowerSet_of_isOpen",
   "IsUpperSet",
   "IsClosed",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE"],
  "name": "Topology.IsLower.isUpperSet_of_isClosed",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLower Î±] {s : Set Î±},\n  IsClosed s â†’ IsUpperSet s",
  "constCategory": "Theorem"},
 {"references": ["List.nil", "List.Chain"],
  "name": "List.Chain.nil",
  "constType": "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} {a : Î±}, List.Chain R a []",
  "constCategory": "Other"},
 {"references": ["BEq", "List", "BEq.mk", "List.beq"],
  "name": "List.instBEqList",
  "constType": "{Î± : Type u} â†’ [inst : BEq Î±] â†’ BEq (List Î±)",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn", "Eq", "Option"],
  "name": "Option.noConfusionType",
  "constType": "{Î± : Type u} â†’ Sort u_1 â†’ Option Î± â†’ Option Î± â†’ Sort u_1",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "Setoid.r",
   "instHasEquiv",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "List.isSetoid",
   "Quot",
   "HasEquiv.Equiv",
   "List.Perm.append",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.add.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (x x_1 x_2 x_3 : List Î±),\n  x â‰ˆ x_2 â†’ x_1 â‰ˆ x_3 â†’ Quot.mk Setoid.r (x ++ x_1) = Quot.mk Setoid.r (x_2 ++ x_3)",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Equivalence"],
  "name": "Setoid.iseqv",
  "constType": "âˆ€ {Î± : Sort u} [self : Setoid Î±], Equivalence Setoid.r",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.add_zero",
  "constType":
  "âˆ€ {M : Type u} [self : AddRightCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot", "OrderBot.toBot", "OrderBot.bot_le", "LE", "OrderBot", "LE.le"],
  "name": "bot_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderBot Î±] {a : Î±}, âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Applicative",
   "Applicative.toSeqRight",
   "Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Unit",
   "SeqLeft.seqLeft",
   "ReaderT.instFunctorReaderT",
   "Applicative.toSeqLeft",
   "Applicative.mk",
   "Seq.seq",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "Applicative.toSeq",
   "SeqRight.mk",
   "ReaderT.pure",
   "SeqLeft.mk",
   "SeqRight.seqRight"],
  "name": "ReaderT.instApplicativeReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ [inst : Monad m] â†’ Applicative (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{Î± : Type u_1} â†’ Membership Î± (Finset Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "HasSubset.Subset",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "Filter",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "instMembershipSetFilter"],
  "name": "Filter.principal_mono",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, Filter.principal s â‰¤ Filter.principal t â†” s âŠ† t",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.not_succ_le_self.match_1",
  "constType":
  "âˆ€ (motive : â„• â†’ Prop) (x : â„•), (Unit â†’ motive 0) â†’ (âˆ€ (n : â„•), motive (Nat.succ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "StrictOrderedCommSemiring",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.termÎ©._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.instPreorderProd",
   "LT.lt",
   "inferInstanceAs",
   "Not",
   "Prod",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "PartialOrder"],
  "name": "Prod.instPartialOrder.proof_3",
  "constType":
  "âˆ€ (Î± : Type u_1) (Î² : Type u_2) [inst : PartialOrder Î±] [inst_1 : PartialOrder Î²] (a b : Î± Ã— Î²), a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pow.match_1",
   "Unit",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.pow",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Std.Logic._auxLemma.29",
   "Exists",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "Eq.refl",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Std.Logic._auxLemma.55",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.forall_range_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} {f : Î¹ â†’ Î±} {p : Î± â†’ Prop}, (âˆ€ a âˆˆ Set.range f, p a) â†” âˆ€ (i : Î¹), p (f i)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Filter",
  "constType": "Type u_1 â†’ Type u_1",
  "constCategory": "Other"},
 {"references":
  ["IsLowerSet",
   "isUpperSet_compl",
   "Iff.rfl",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "Preorder",
   "Topology.IsLowerSet",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Eq",
   "Iff.symm",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Topology.IsLowerSet.isOpen_iff_isLowerSet",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen",
   "id"],
  "name": "Topology.IsLowerSet.isClosed_iff_isUpper",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsLowerSet Î±] {s : Set Î±},\n  IsClosed s â†” IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Mem.tail",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.rec"],
  "name": "List.Mem.casesOn",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {motive : (a_1 : List Î±) â†’ List.Mem a a_1 â†’ Prop} {a_1 : List Î±} (t : List.Mem a a_1),\n  (âˆ€ (as : List Î±), motive (a :: as) (_ : List.Mem a (a :: as))) â†’\n    (âˆ€ (b : Î±) {as : List Î±} (a_2 : List.Mem a as), motive (b :: as) (_ : List.Mem a (b :: as))) â†’ motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "lowerBounds",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "And.intro",
   "sSup_le",
   "IsLUB",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembershipSet"],
  "name": "isLUB_sSup",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CompleteSemilatticeSup Î±] (s : Set Î±), IsLUB s (sSup s)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "OfNat.ofNat",
   "List.cons",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "Nat.zero_sub",
   "List.drop",
   "List.length",
   "True",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "Nat.zero",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "congr",
   "instOfNatNat",
   "List.drop_nil",
   "List.nil",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Nat.succ_sub_succ_eq_sub",
   "Nat.succ",
   "Eq.trans",
   "Nat.casesOn",
   "congrFun"],
  "name": "List.drop_append_eq_append_drop",
  "constType":
  "âˆ€ {Î± : Type u_1} {n : â„•} {lâ‚ lâ‚‚ : List Î±}, List.drop n (lâ‚ ++ lâ‚‚) = List.drop n lâ‚ ++ List.drop (n - List.length lâ‚) lâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "TopologicalSpace.IsTopologicalBasis",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.IsTopologicalBasis.mk",
  "constType":
  "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)},\n  (âˆ€ tâ‚ âˆˆ s, âˆ€ tâ‚‚ âˆˆ s, âˆ€ x âˆˆ tâ‚ âˆ© tâ‚‚, âˆƒ tâ‚ƒ âˆˆ s, x âˆˆ tâ‚ƒ âˆ§ tâ‚ƒ âŠ† tâ‚ âˆ© tâ‚‚) â†’\n    â‹ƒâ‚€ s = Set.univ â†’ t = TopologicalSpace.generateFrom s â†’ TopologicalSpace.IsTopologicalBasis s",
  "constCategory": "Other"},
 {"references":
  ["closure",
   "Membership.mem",
   "propext",
   "Set",
   "mem_closure_iff_nhdsWithin_neBot",
   "TopologicalSpace",
   "nhdsWithin",
   "Filter.NeBot",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Constructions._auxLemma.27",
  "constType":
  "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {x : Î±}, (x âˆˆ closure s) = Filter.NeBot (nhdsWithin x s)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Unit",
   "Nat.zero_add.match_1",
   "instOfNatNat",
   "Nat",
   "rfl",
   "instLTNat",
   "Nat.succ_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.eq_zero_or_pos",
  "constType": "âˆ€ (n : â„•), n = 0 âˆ¨ n > 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Exists",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Fin",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "finite_iff_exists_equiv_fin.match_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} (motive : (âˆƒ n, Nonempty (Î± â‰ƒ Fin n)) â†’ Prop) (x : âˆƒ n, Nonempty (Î± â‰ƒ Fin n)),\n  (âˆ€ (w : â„•) (e : Î± â‰ƒ Fin w), motive (_ : âˆƒ n, Nonempty (Î± â‰ƒ Fin n))) â†’ motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddLeftCancelMonoid",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "optParam",
  "constType": "(Î± : Sort u) â†’ Î± â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons",
   "And.left"],
  "name": "List.pmap._sunfold.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop} (a : Î±) (l : List Î±), (âˆ€ a_1 âˆˆ a :: l, p a_1) â†’ p a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Trans.trans",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Eq.refl",
   "sup_comm",
   "inf_assoc",
   "True",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "sup_inf_self",
   "sup_inf_right",
   "Eq.mpr",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "inf_sup_self",
   "of_eq_true",
   "congr",
   "instTransEq",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "sup_inf_left",
   "id"],
  "name": "inf_sup_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DistribLattice Î±] {x y z : Î±}, x âŠ“ (y âŠ” z) = x âŠ“ y âŠ” x âŠ“ z",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr",
   "Lean.MacroScopesView",
   "List",
   "Unit",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.review.match_1",
   "Nat",
   "Lean.MacroScopesView.mainModule",
   "Lean.MacroScopesView.imported",
   "Lean.Name.appendCore",
   "Lean.Name",
   "Lean.MacroScopesView.name",
   "List.foldl",
   "Lean.MacroScope",
   "Lean.MacroScopesView.scopes"],
  "name": "Lean.MacroScopesView.review",
  "constType": "Lean.MacroScopesView â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "Lean.Data.AC.insert",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "Nat",
   "Lean.Data.AC.sort.loop.match_1"],
  "name": "Lean.Data.AC.sort.loop",
  "constType": "List â„• â†’ List â„• â†’ List â„•",
  "constCategory": "Definition"},
 {"references":
  ["Classical.propDecidable", "Not", "dite", "Classical.choice", "Nonempty"],
  "name": "Function.sometimes",
  "constType":
  "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ [inst : Nonempty Î²] â†’ (Î± â†’ Î²) â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "UpperSet.instInfSetUpperSet",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.iUnion_exists",
   "UpperSet",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "Set.iUnion",
   "iInf",
   "of_eq_true",
   "Set.iUnion_iUnion_eq'",
   "LE",
   "Set.iUnion_congr_Prop",
   "congrArg",
   "Eq.trans",
   "SetLike.coe",
   "congrFun"],
  "name": "UpperSet.coe_iInf",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : LE Î±] (f : Î¹ â†’ UpperSet Î±), â†‘(â¨… i, f i) = â‹ƒ i, â†‘(f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "OrderDual.toDual",
   "continuous_coinduced_rng",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.coinduced",
   "OrderDual.ofDual",
   "Topology.WithLowerSet",
   "Continuous",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.toDualHomeomorph.proof_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±],\n  Continuous\n    { toFun := â†‘OrderDual.toDual, invFun := â†‘OrderDual.ofDual,\n        left_inv := (_ : âˆ€ (a : Î±áµ’áµˆ), â†‘OrderDual.toDual (â†‘OrderDual.ofDual a) = a),\n        right_inv := (_ : âˆ€ (a : Topology.WithLowerSet Î±áµ’áµˆ), â†‘OrderDual.ofDual (â†‘OrderDual.toDual a) = a) }.toFun",
  "constCategory": "Theorem"},
 {"references": ["Sup", "TopologicalSpace"],
  "name": "ContinuousSup",
  "constType":
  "(L : Type u_1) â†’ [inst : TopologicalSpace L] â†’ [inst : Sup L] â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Union", "Set.union", "Union.mk", "Set"],
  "name": "Set.instUnionSet",
  "constType": "{Î± : Type u_1} â†’ Union (Set Î±)",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "forall_and", "Eq"],
  "name": "Std.Logic._auxLemma.44",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p q : Î± â†’ Prop}, (âˆ€ (x : Î±), p x âˆ§ q x) = ((âˆ€ (x : Î±), p x) âˆ§ âˆ€ (x : Î±), q x)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_termð“_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_4",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[>]__1Â»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "inferInstance",
   "instIsTransLeToLE",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "IsTrans",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.instIsTransSetSubsetInstHasSubsetSet.proof_1",
  "constType": "âˆ€ {Î± : Type u_1}, IsTrans (Set Î±) fun x x_1 â†¦ x â‰¤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithUpperSet.of_WithUpperSet_symm_eq",
  "constType":
  "âˆ€ {Î± : Type u_1}, Topology.WithUpperSet.ofUpperSet.symm = Topology.WithUpperSet.toUpperSet",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Filter.giGenerate.proof_1",
   "Filter.giGenerate.proof_3",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter.mkOfClosure",
   "Filter.le_generate_iff",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "GaloisInsertion.mk",
   "Filter",
   "Filter.giGenerate.proof_2",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "Filter.giGenerate",
  "constType": "(Î± : Type u_2) â†’ GaloisInsertion Filter.generate Filter.sets",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.dummyRestore",
   "PUnit",
   "EStateM.Backtrackable",
   "EStateM.dummySave",
   "EStateM.Backtrackable.mk"],
  "name": "EStateM.nonBacktrackable",
  "constType": "{Ïƒ : Type u} â†’ EStateM.Backtrackable PUnit.{u + 1} Ïƒ",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.pow.match_1",
  "constType":
  "(motive : â„• â†’ Sort u_1) â†’ (x : â„•) â†’ (Unit â†’ motive 0) â†’ ((n : â„•) â†’ motive (Nat.succ n)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Iff", "forall_const"],
  "name": "forall_prop_of_true",
  "constType": "âˆ€ {p : Prop} {q : p â†’ Prop} (h : p), (âˆ€ (h' : p), q h') â†” q h",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "List.cons",
   "Nat.le",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get?_eq_get.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} (motive : (x : List Î±) â†’ (x_1 : â„•) â†’ x_1 < List.length x â†’ Prop) (x : List Î±) (x_1 : â„•)\n  (x_2 : x_1 < List.length x),\n  (âˆ€ (head : Î±) (tail : List Î±) (x : 0 < List.length (head :: tail)), motive (head :: tail) 0 x) â†’\n    (âˆ€ (head : Î±) (l : List Î±) (n : â„•) (x : n + 1 < List.length (head :: l)), motive (head :: l) (Nat.succ n) x) â†’\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Iff",
   "Equiv.refl",
   "Topology.WithLowerSet",
   "lcProof",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSetOrderIso._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithLowerSet Î± â‰ƒo Î±",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder",
   "OrderDual.instIsLowerSet.proof_1"],
  "name": "OrderDual.instIsLowerSet",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpperSet Î±],\n  Topology.IsLowerSet Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} â†’ {Î± : outParam (Sort u_2)} â†’ {Î² : outParam (Î± â†’ Sort u_3)} â†’ [self : FunLike F Î± Î²] â†’ F â†’ (a : Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["Trans", "le_trans", "Preorder", "LE.le", "Trans.mk", "Preorder.toLE"],
  "name": "instTransLeToLE",
  "constType": "{Î± : Type u} â†’ [inst : Preorder Î±] â†’ Trans LE.le LE.le LE.le",
  "constCategory": "Definition"},
 {"references": ["Bool.false", "Bool.true", "Bool"],
  "name": "Bool.rec",
  "constType":
  "{motive : Bool â†’ Sort u} â†’ motive false â†’ motive true â†’ (t : Bool) â†’ motive t",
  "constCategory": "Other"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LE.le.trans",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "UInt32",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.mk",
   "Equiv",
   "Exists",
   "Set",
   "Topology.WithLower",
   "Set.Iic",
   "Set.Ici",
   "Eq",
   "lcProof",
   "Continuous",
   "Homeomorph",
   "TopologicalSpace",
   "Membership.mem",
   "Equiv.toFun",
   "Topology.WithUpper",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "setOf",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "Preorder",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "TopologicalSpace.coinduced",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Equiv.invFun",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "Set.sUnion",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.WithLower.toDualHomeomorph._cstage1",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithLower Î± â‰ƒâ‚œ Topology.WithUpper Î±áµ’áµˆ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "Continuous.tendsto.match_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : TopologicalSpace Î²] {f : Î± â†’ Î²} (x : Î±) (t : Set Î²)\n  (motive : f x âˆˆ t âˆ§ IsOpen t â†’ Prop) (x_1 : f x âˆˆ t âˆ§ IsOpen t),\n  (âˆ€ (hxt : f x âˆˆ t) (ht : IsOpen t), motive (_ : f x âˆˆ t âˆ§ IsOpen t)) â†’ motive x_1",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Iff", "List.instMembershipList", "List"],
  "name": "List.TFAE",
  "constType": "List Prop â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Topology.instIsLowerSetLowerSet.proof_1",
   "Topology.lowerSet",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.instIsLowerSetLowerSet",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±], Topology.IsLowerSet Î±",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[_]_Â»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Nat.zero",
   "List",
   "Eq.refl",
   "List.nil",
   "List.drop",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "List.drop_nil",
  "constType": "âˆ€ {Î± : Type u} {i : â„•}, List.drop i [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Function.comp",
   "Set",
   "Eq.refl",
   "Set.image_eq_range",
   "iSup",
   "SupSet.sSup",
   "Eq",
   "Set.instMembershipSet",
   "SupSet",
   "Set.range",
   "Eq.mpr",
   "Eq.ndrec",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "Set.Elem",
   "Set.image",
   "Eq.symm",
   "Set.range_comp",
   "id"],
  "name": "iSup_range'",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_5} [inst : SupSet Î±] (g : Î² â†’ Î±) (f : Î¹ â†’ Î²), â¨† b, g â†‘b = â¨† i, g (f i)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰ ]__1Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.termÎ©._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Eq.ndrec",
   "ZeroHom.casesOn",
   "ZeroHom.toFun",
   "ZeroHom.mk",
   "Eq.rec",
   "Eq.refl",
   "ZeroHom",
   "Eq.symm",
   "Eq"],
  "name": "ZeroHom.zeroHomClass.proof_1",
  "constType":
  "âˆ€ {M : Type u_2} {N : Type u_1} [inst : Zero M] [inst_1 : Zero N] (f g : ZeroHom M N), f.toFun = g.toFun â†’ f = g",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "UpperSet",
  "constType": "(Î± : Type u_6) â†’ [inst : LE Î±] â†’ Type u_6",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{Î± : Type u} â†’\n  [toAddCommMonoid : AddCommMonoid Î±] â†’\n    [toMul : Mul Î±] â†’\n      (âˆ€ (a b c : Î±), a * (b + c) = a * b + a * c) â†’\n        (âˆ€ (a b c : Î±), (a + b) * c = a * c + b * c) â†’\n          (âˆ€ (a : Î±), 0 * a = 0) â†’ (âˆ€ (a : Î±), a * 0 = 0) â†’ NonUnitalNonAssocSemiring Î±",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.attach.proof_1",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "List.attach",
   "Eq",
   "List.map_pmap",
   "List.pmap_eq_map",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.map",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "List.attach_map_coe'",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (l : List Î±) (f : Î± â†’ Î²), List.map (fun i â†¦ f â†‘i) (List.attach l) = List.map f l",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Exists", "Iff", "Exists.intro", "forall_exists_index.match_1"],
  "name": "forall_exists_index",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) â†” âˆ€ (x : Î±) (h : p x), q (_ : âˆƒ x, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["IsAssociative.mk",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "IsAssociative",
   "inf_assoc",
   "SemilatticeInf"],
  "name": "instIsAssociativeInfToInf.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SemilatticeInf Î±], IsAssociative Î± fun x x_1 â†¦ x âŠ“ x_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Acc",
  "constType": "{Î± : Sort u} â†’ (Î± â†’ Î± â†’ Prop) â†’ Î± â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Eq", "IsCommutative"],
  "name": "IsCommutative.comm",
  "constType":
  "âˆ€ {Î± : Type u} {op : Î± â†’ Î± â†’ Î±} [self : IsCommutative Î± op] (a b : Î±), op a b = op b a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_top",
   "OrderTop.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "CompleteLattice",
   "CompleteLattice.bot_le",
   "CompleteLattice.toTop",
   "CompleteLattice.toBot",
   "OrderBot.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "CompleteLattice.toBoundedOrder",
  "constType": "{Î± : Type u_1} â†’ [h : CompleteLattice Î±] â†’ BoundedOrder Î±",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "âˆ€ {Î± : Type u} [self : LinearOrder Î±] (a b : Î±), max a b = if a â‰¤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "subset_trans",
  "constType":
  "âˆ€ {Î± : Type u} [inst : HasSubset Î±] [inst_1 : IsTrans Î± fun x x_1 â†¦ x âŠ† x_1] {a b c : Î±}, a âŠ† b â†’ b âŠ† c â†’ a âŠ† c",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "OrderDual.instPreorder",
   "Set",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "Singleton.singleton",
   "Set.Iic",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "Topology.IsLower.closure_singleton",
   "Eq"],
  "name": "Topology.IsUpper.closure_singleton",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±] (a : Î±),\n  closure {a} = Set.Iic a",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "exists_prop.match_2",
  "constType":
  "âˆ€ {b a : Prop} (motive : a âˆ§ b â†’ Prop) (x : a âˆ§ b), (âˆ€ (hp : a) (hq : b), motive (_ : a âˆ§ b)) â†’ motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u â†’ Type u",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_6",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Â«_aux_Mathlib_Topology_Basic___macroRules_Topology_termð“[â‰¤]__1Â»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["induced_iff_nhds_eq",
   "inducing_iff",
   "Iff",
   "nhds",
   "Filter.comap",
   "TopologicalSpace",
   "Filter",
   "Inducing",
   "Iff.trans",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "inducing_iff_nhds",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {f : Î± â†’ Î²},\n  Inducing f â†” âˆ€ (a : Î±), nhds a = Filter.comap f (nhds (f a))",
  "constCategory": "Theorem"},
 {"references": ["sInfHom", "Set", "InfSet.sInf", "InfSet", "Set.image", "Eq"],
  "name": "sInfHom.mk",
  "constType":
  "{Î± : Type u_8} â†’\n  {Î² : Type u_9} â†’\n    [inst : InfSet Î±] â†’\n      [inst_1 : InfSet Î²] â†’ (toFun : Î± â†’ Î²) â†’ (âˆ€ (s : Set Î±), toFun (sInf s) = sInf (toFun '' s)) â†’ sInfHom Î± Î²",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [inst : Preorder Î±] â†’ [inst : Preorder Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Â«termð“[>]_Â»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Â«termð“[_]_Â»._closed_5",
   "_obj",
   "Topology.Â«termð“[_]_Â»._closed_7",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.Â«termð“[_]_Â»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "IsCompl.disjoint",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "OrderDual",
   "FunLike.coe",
   "IsCompl.mk",
   "IsCompl",
   "IsCompl.codisjoint",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "OrderDual.boundedOrder",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.dual",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] [inst_1 : BoundedOrder Î±] {x y : Î±},\n  IsCompl x y â†’ IsCompl (â†‘OrderDual.toDual x) (â†‘OrderDual.toDual y)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPreorder",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "OrderDual.instIsUpperSet",
   "Topology.IsUpperSet.toAlexandrovDiscrete",
   "Topology.IsLowerSet",
   "Preorder",
   "AlexandrovDiscrete"],
  "name": "Topology.IsLowerSet.toAlexandrovDiscrete.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst : Topology.IsLowerSet Î±],\n  AlexandrovDiscrete Î±áµ’áµˆ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} â†’\n  {Î± : outParam (Type u_6)} â†’\n    {Î² : outParam (Type u_7)} â†’\n      {r : outParam (Î± â†’ Î± â†’ Prop)} â†’ {s : outParam (Î² â†’ Î² â†’ Prop)} â†’ [self : RelHomClass F r s] â†’ FunLike F Î± fun x â†¦ Î²",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} â†’ [self : NatCast R] â†’ â„• â†’ R",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "instAddNat",
   "Fin.val",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instLTNat",
   "Eq",
   "Eq.ndrec",
   "of_eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Fin.succ",
   "Nat.succ",
   "Fin",
   "Fin.mk",
   "Fin.casesOn"],
  "name": "Fin.val_succ",
  "constType": "âˆ€ {n : â„•} (j : Fin n), â†‘(Fin.succ j) = â†‘j + 1",
  "constCategory": "Theorem"},
 {"references": ["Array.mkEmpty", "_obj", "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadRef", "Lean.MonadQuotation"],
  "name": "Lean.MonadQuotation.toMonadRef",
  "constType":
  "{m : Type â†’ Type} â†’ [self : Lean.MonadQuotation m] â†’ Lean.MonadRef m",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Alternative"],
  "name": "Alternative.toApplicative",
  "constType": "{f : Type u â†’ Type v} â†’ [self : Alternative f] â†’ Applicative f",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "propext",
   "Set",
   "Filter.comap",
   "Filter",
   "Filter.mem_comap'",
   "Set.instMembershipSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.59",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {l : Filter Î²} {s : Set Î±},\n  (s âˆˆ Filter.comap f l) = ({y | âˆ€ â¦ƒx : Î±â¦„, f x = y â†’ x âˆˆ s} âˆˆ l)",
  "constCategory": "Theorem"},
 {"references": ["UInt32", "UInt32.size", "UInt32.casesOn", "Fin", "Eq"],
  "name": "UInt32.noConfusionType",
  "constType": "Sort u â†’ UInt32 â†’ UInt32 â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "LE.le",
   "PProd",
   "Nat.le_succ_of_le",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.le_add_right",
  "constType": "âˆ€ (n k : â„•), n â‰¤ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["Continuous", "TopologicalSpace", "ContinuousMap", "ContinuousMap.mk"],
  "name": "ContinuousMap.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : TopologicalSpace Î±] â†’\n      [inst_1 : TopologicalSpace Î²] â†’\n        {motive : C(Î±, Î²) â†’ Sort u} â†’\n          ((toFun : Î± â†’ Î²) â†’ (continuous_toFun : Continuous toFun) â†’ motive (ContinuousMap.mk toFun)) â†’\n            (t : C(Î±, Î²)) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["propext", "List", "List.Sublist", "List.nil", "List.sublist_nil", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.37",
  "constType": "âˆ€ {Î± : Type u_1} {l : List Î±}, List.Sublist l [] = (l = [])",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder"],
  "name": "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
  "constType":
  "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ TopologicalSpace (Topology.WithUpperSet Î±)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_antisymm.match_1",
  "constType":
  "âˆ€ {n : â„•} (motive : (m : â„•) â†’ n â‰¤ m â†’ m â‰¤ n â†’ Prop) (m : â„•) (hâ‚ : n â‰¤ m) (hâ‚‚ : m â‰¤ n),\n  (âˆ€ (hâ‚‚ : n â‰¤ n), motive n (_ : Nat.le n n) hâ‚‚) â†’\n    (âˆ€ (m : â„•) (h : Nat.le n m) (hâ‚‚ : Nat.succ m â‰¤ n), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m)) hâ‚‚) â†’\n      motive m hâ‚ hâ‚‚",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "ClosedIciTopology",
  "constType":
  "(Î± : Type u_1) â†’ [inst : TopologicalSpace Î±] â†’ [inst : Preorder Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.trans",
  "constType": "âˆ€ {a b c : Prop}, (a â†” b) â†’ (b â†” c) â†’ (a â†” c)",
  "constCategory": "Theorem"},
 {"references": ["ReaderT", "MonadLift", "MonadLift.mk"],
  "name": "ReaderT.instMonadLiftReaderT",
  "constType":
  "{Ï : Type u} â†’ {m : Type u â†’ Type v} â†’ MonadLift m (ReaderT Ï m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 â†’ Sort u_2 â†’ Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "trivial",
   "Bot.bot",
   "Set",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_bot",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s âˆˆ âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "Unit",
   "Unit.unit",
   "List.casesOn",
   "List.nil",
   "Lean.MacroScope"],
  "name": "Lean.MacroScopesView.review.match_1",
  "constType":
  "(motive : List Lean.MacroScope â†’ Sort u_1) â†’\n  (x : List Lean.MacroScope) â†’\n    (Unit â†’ motive []) â†’ ((head : Lean.MacroScope) â†’ (tail : List Lean.MacroScope) â†’ motive (head :: tail)) â†’ motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_succ",
  "constType":
  "âˆ€ {M : Type u} [self : AddLeftCancelMonoid M] (n : â„•) (x : M),\n  AddLeftCancelMonoid.nsmul (n + 1) x = x + AddLeftCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.monotone",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.mono",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Preorder Î±] [inst_1 : Preorder Î²] (f : Î± â†’o Î²), Monotone â†‘f",
  "constCategory": "Theorem"},
 {"references": ["PSigma"],
  "name": "PSigma.fst",
  "constType": "{Î± : Sort u} â†’ {Î² : Î± â†’ Sort v} â†’ PSigma Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["SDiff"],
  "name": "SDiff.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Î±) â†’ SDiff Î±",
  "constCategory": "Other"},
 {"references": ["Inhabited", "String", "Inhabited.default"],
  "name": "panicCore",
  "constType": "{Î± : Type u} â†’ [inst : Inhabited Î±] â†’ String â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "IsCompl",
   "disjoint_compl_left",
   "IsCompl.codisjoint",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "IsCompl.disjoint",
   "LE.le.antisymm'",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "Disjoint.le_compl_left",
   "Disjoint.le_of_codisjoint",
   "HeytingAlgebra.toHasCompl"],
  "name": "IsCompl.compl_eq",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : HeytingAlgebra Î±] {a b : Î±}, IsCompl a b â†’ aá¶œ = b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "LT.lt",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Fin.casesOn",
   "Eq"],
  "name": "Fin.veq_of_eq.match_1",
  "constType":
  "âˆ€ {n : â„•} (motive : (x x_1 : Fin n) â†’ x = x_1 â†’ Prop) (x x_1 : Fin n) (x_2 : x = x_1),\n  (âˆ€ (val : â„•) (isLt : val < n),\n      motive { val := val, isLt := isLt } { val := val, isLt := isLt }\n        (_ : { val := val, isLt := (_ : val < n) } = { val := val, isLt := (_ : val < n) })) â†’\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) â†’ [h : Decidable p] â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadReader"],
  "name": "MonadReader.mk",
  "constType":
  "{Ï : outParam (Type u)} â†’ {m : Type u â†’ Type v} â†’ m Ï â†’ MonadReader Ï m",
  "constCategory": "Other"},
 {"references":
  ["Set.eq_univ_of_forall",
   "Set",
   "Set.Ici",
   "Preorder",
   "Set.univ",
   "Preorder.toLE",
   "IsBot",
   "Eq"],
  "name": "IsBot.Ici_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a : Î±}, IsBot a â†’ Set.Ici a = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "inf_le_inf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_inf_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeInf Î±] (a : Î±) {b c : Î±}, b â‰¤ c â†’ a âŠ“ b â‰¤ a âŠ“ c",
  "constCategory": "Theorem"},
 {"references": ["List", "List.casesOn", "Eq"],
  "name": "List.noConfusionType",
  "constType": "{Î± : Type u} â†’ Sort u_1 â†’ List Î± â†’ List Î± â†’ Sort u_1",
  "constCategory": "Definition"},
 {"references":
  ["and_comm",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "and_assoc",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "Eq.symm",
   "Eq",
   "id"],
  "name": "and_left_comm",
  "constType": "âˆ€ {a b c : Prop}, a âˆ§ b âˆ§ c â†” b âˆ§ a âˆ§ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "instBEq",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "And",
   "instHAppend",
   "BEq.beq",
   "List.eraseP",
   "List.instAppendList",
   "DecidableEq",
   "List",
   "HAppend.hAppend",
   "Bool.true",
   "Not",
   "And.intro",
   "Bool",
   "And.casesOn"],
  "name": "List.exists_erase_eq.match_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {a : Î±} {l : List Î±}\n  (motive :\n    (âˆƒ a_1,\n        âˆƒ lâ‚,\n          âˆƒ lâ‚‚,\n            (âˆ€ b âˆˆ lâ‚, Â¬(a == b) = true) âˆ§\n              (a == a_1) = true âˆ§ l = lâ‚ ++ a_1 :: lâ‚‚ âˆ§ List.eraseP (BEq.beq a) l = lâ‚ ++ lâ‚‚) â†’\n      Prop)\n  (x :\n    âˆƒ a_1,\n      âˆƒ lâ‚,\n        âˆƒ lâ‚‚,\n          (âˆ€ b âˆˆ lâ‚, Â¬(a == b) = true) âˆ§\n            (a == a_1) = true âˆ§ l = lâ‚ ++ a_1 :: lâ‚‚ âˆ§ List.eraseP (BEq.beq a) l = lâ‚ ++ lâ‚‚),\n  (âˆ€ (w : Î±) (lâ‚ lâ‚‚ : List Î±) (hâ‚ : âˆ€ b âˆˆ lâ‚, Â¬(a == b) = true) (e : (a == w) = true) (hâ‚‚ : l = lâ‚ ++ w :: lâ‚‚)\n      (hâ‚ƒ : List.eraseP (BEq.beq a) l = lâ‚ ++ lâ‚‚),\n      motive\n        (_ :\n          âˆƒ a_1,\n            âˆƒ lâ‚,\n              âˆƒ lâ‚‚,\n                (âˆ€ b âˆˆ lâ‚, Â¬(a == b) = true) âˆ§\n                  (a == a_1) = true âˆ§ l = lâ‚ ++ a_1 :: lâ‚‚ âˆ§ List.eraseP (BEq.beq a) l = lâ‚ ++ lâ‚‚)) â†’\n    motive x",
  "constCategory": "Definition"},
 {"references": ["ULift"],
  "name": "ULift.down",
  "constType": "{Î± : Type s} â†’ ULift.{r, s} Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr3",
  "constType": "String â†’ String â†’ String â†’ Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.mk",
   "Eq.ndrec",
   "Eq.rec",
   "Eq.refl",
   "Monotone",
   "OrderHom",
   "OrderHom.casesOn",
   "OrderHom.toFun",
   "Preorder",
   "Eq.symm",
   "Eq"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
  "constType":
  "âˆ€ {Î± : Type u_2} {Î² : Type u_1} [inst : Preorder Î±] [inst_1 : Preorder Î²] (f g : Î± â†’o Î²), f.toFun = g.toFun â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Filter.HasBasis.tendsto_right_iff",
   "Filter.Eventually",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis.eventually_iff",
   "Filter.HasBasis",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "propext",
   "Filter",
   "Filter.Tendsto",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Filter.HasBasis.tendsto_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Sort u_4} {Î¹' : Sort u_5} {la : Filter Î±} {pa : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±}\n  {lb : Filter Î²} {pb : Î¹' â†’ Prop} {sb : Î¹' â†’ Set Î²} {f : Î± â†’ Î²},\n  Filter.HasBasis la pa sa â†’\n    Filter.HasBasis lb pb sb â†’ (Filter.Tendsto f la lb â†” âˆ€ (ib : Î¹'), pb ib â†’ âˆƒ ia, pa ia âˆ§ âˆ€ x âˆˆ sa ia, f x âˆˆ sb ib)",
  "constCategory": "Theorem"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Î± â†’ Ordering) â†’ Ord Î±",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.subperm_left.match_1",
   "Exists",
   "List.Perm",
   "List.Sublist.trans",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "List.Subperm.trans.match_1",
   "Iff.mpr",
   "List.Perm.subperm_left"],
  "name": "List.Subperm.trans",
  "constType":
  "âˆ€ {Î± : Type uu} {lâ‚ lâ‚‚ lâ‚ƒ : List Î±}, lâ‚ <+~ lâ‚‚ â†’ lâ‚‚ <+~ lâ‚ƒ â†’ lâ‚ <+~ lâ‚ƒ",
  "constCategory": "Theorem"}]